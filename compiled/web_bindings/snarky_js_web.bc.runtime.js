// Generated by js_of_ocaml 4.0.0
(function(Object)
   {typeof globalThis
    !==
    "object"
    &&
    (this
      ?get()
      :(Object.defineProperty
         (Object.prototype,"_T_",{configurable:true,get:get}),
        _T_));
    function get()
     {var global=this || self;
      global.globalThis = global;
      delete Object.prototype._T_}}
  (Object));
(function(globalThis)
   {var joo_global_object=globalThis;
    (function()
       {var
         DefaultLocale=
          {days:
           ["Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"],
           shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],
           months:
           ["January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"],
           shortMonths:
           ["Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"],
           AM:"AM",
           PM:"PM",
           am:"am",
           pm:"pm",
           formats:
           {D:"%m/%d/%y",
            F:"%Y-%m-%d",
            R:"%H:%M",
            T:"%H:%M:%S",
            X:"%T",
            c:"%a %b %d %X %Y",
            r:"%I:%M:%S %p",
            v:"%e-%b-%Y",
            x:"%D"}},
         defaultStrftime=new Strftime(DefaultLocale,0,false),
         isCommonJS=typeof module !== "undefined",
         namespace;
        if(isCommonJS)
         {namespace = module.exports = adaptedStrftime;
          namespace.strftime = deprecatedStrftime;
          if(joo_global_object)joo_global_object.strftime = adaptedStrftime}
        else
         {namespace
          =
          joo_global_object
          ||
          function(){return this || (1,eval)("this")}();
          namespace.strftime = adaptedStrftime}
        var
         _require=isCommonJS?"require('strftime')":"strftime",
         _deprecationWarnings={};
        function deprecationWarning(name,instead)
         {if(! _deprecationWarnings[name])
           {if
             (typeof console
              !==
              "undefined"
              &&
              typeof console.warn
              ==
              "function")
             console.warn
              ("[WARNING] "
               +
               name
               +
               " is deprecated and will be removed in version 1.0. Instead, use `"
               +
               instead
               +
               "`.");
            _deprecationWarnings[name] = true}}
        namespace.strftimeTZ = deprecatedStrftimeTZ;
        namespace.strftimeUTC = deprecatedStrftimeUTC;
        namespace.localizedStrftime = deprecatedStrftimeLocalized;
        function adaptForwards(fn)
         {fn.localize = defaultStrftime.localize.bind(defaultStrftime);
          fn.timezone = defaultStrftime.timezone.bind(defaultStrftime);
          fn.utc = defaultStrftime.utc.bind(defaultStrftime)}
        adaptForwards(adaptedStrftime);
        function adaptedStrftime(fmt,d,locale)
         {if(d && d.days){locale = d;d = undefined}
          if(locale)
           deprecationWarning
            ("`" + _require + "(format, [date], [locale])`",
             "var s = " + _require + ".localize(locale); s(format, [date])");
          var
           strftime=
            locale?defaultStrftime.localize(locale):defaultStrftime;
          return strftime(fmt,d)}
        adaptForwards(deprecatedStrftime);
        function deprecatedStrftime(fmt,d,locale)
         {if(locale)
           deprecationWarning
            ("`" + _require + ".strftime(format, [date], [locale])`",
             "var s = " + _require + ".localize(locale); s(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftime(format, [date])`",
             _require + "(format, [date])");
          var
           strftime=
            locale?defaultStrftime.localize(locale):defaultStrftime;
          return strftime(fmt,d)}
        function deprecatedStrftimeTZ(fmt,d,locale,timezone)
         {if
           ((typeof locale == "number" || typeof locale == "string")
            &&
            timezone
            ==
            null)
           {timezone = locale;locale = undefined}
          if(locale)
           deprecationWarning
            ("`" + _require + ".strftimeTZ(format, date, locale, tz)`",
             "var s = "
             +
             _require
             +
             ".localize(locale).timezone(tz); s(format, [date])` or `var s = "
             +
             _require
             +
             ".localize(locale); s.timezone(tz)(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftimeTZ(format, date, tz)`",
             "var s = "
             +
             _require
             +
             ".timezone(tz); s(format, [date])` or `"
             +
             _require
             +
             ".timezone(tz)(format, [date])");
          var
           strftime=
            (locale?defaultStrftime.localize(locale):defaultStrftime).timezone
             (timezone);
          return strftime(fmt,d)}
        var utcStrftime=defaultStrftime.utc();
        function deprecatedStrftimeUTC(fmt,d,locale)
         {if(locale)
           deprecationWarning
            ("`" + _require + ".strftimeUTC(format, date, locale)`",
             "var s = "
             +
             _require
             +
             ".localize(locale).utc(); s(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftimeUTC(format, [date])`",
             "var s = " + _require + ".utc(); s(format, [date])");
          var strftime=locale?utcStrftime.localize(locale):utcStrftime;
          return strftime(fmt,d)}
        function deprecatedStrftimeLocalized(locale)
         {deprecationWarning
           ("`" + _require + ".localizedStrftime(locale)`",
            _require + ".localize(locale)");
          return defaultStrftime.localize(locale)}
        if(typeof Date.now !== "function")
         Date.now = function(){return + new Date()};
        function Strftime(locale,customTimezoneOffset,useUtcTimezone)
         {var
           _locale=locale || DefaultLocale,
           _customTimezoneOffset=customTimezoneOffset || 0,
           _useUtcBasedDate=useUtcTimezone || false,
           _cachedDateTimestamp=0,
           _cachedDate;
          function _strftime(format,date)
           {var timestamp;
            if(! date)
             {var currentTimestamp=Date.now();
              if(currentTimestamp > _cachedDateTimestamp)
               {_cachedDateTimestamp = currentTimestamp;
                _cachedDate = new Date(_cachedDateTimestamp);
                timestamp = _cachedDateTimestamp;
                if(_useUtcBasedDate)
                 _cachedDate
                 =
                 new
                  Date
                  (_cachedDateTimestamp
                   +
                   getTimestampToUtcOffsetFor(_cachedDate)
                   +
                   _customTimezoneOffset)}
              date = _cachedDate}
            else
             {timestamp = date.getTime();
              if(_useUtcBasedDate)
               date
               =
               new
                Date
                (date.getTime()
                 +
                 getTimestampToUtcOffsetFor(date)
                 +
                 _customTimezoneOffset)}
            return _processFormat(format,date,_locale,timestamp)}
          function _processFormat(format,date,locale,timestamp)
           {var
             resultString="",
             padding=null,
             isInScope=false,
             length=format.length,
             extendedTZ=false;
            for(var i=0;i < length;i++)
             {var currentCharCode=format.charCodeAt(i);
              if(isInScope === true)
               {if(currentCharCode === 45)
                 {padding = "";continue}
                else
                 if(currentCharCode === 95)
                  {padding = " ";continue}
                 else
                  if(currentCharCode === 48)
                   {padding = "0";continue}
                  else
                   if(currentCharCode === 58)
                    {if(extendedTZ)
                      if
                       (typeof console
                        !==
                        "undefined"
                        &&
                        typeof console.warn
                        ==
                        "function")
                       console.warn
                        ("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime");
                     extendedTZ = true;
                     continue}
                switch(currentCharCode)
                 {case 65:resultString += locale.days[date.getDay()];break;
                  case 66:
                   resultString += locale.months[date.getMonth()];break;
                  case 67:
                   resultString
                   +=
                   padTill2(Math.floor(date.getFullYear() / 100),padding);
                   break;
                  case 68:
                   resultString
                   +=
                   _processFormat(locale.formats.D,date,locale,timestamp);
                   break;
                  case 70:
                   resultString
                   +=
                   _processFormat(locale.formats.F,date,locale,timestamp);
                   break;
                  case 72:
                   resultString += padTill2(date.getHours(),padding);break;
                  case 73:
                   resultString += padTill2(hours12(date.getHours()),padding);
                   break;
                  case 76:
                   resultString += padTill3(Math.floor(timestamp % 1000));
                   break;
                  case 77:
                   resultString += padTill2(date.getMinutes(),padding);break;
                  case 80:
                   resultString += date.getHours() < 12?locale.am:locale.pm;
                   break;
                  case 82:
                   resultString
                   +=
                   _processFormat(locale.formats.R,date,locale,timestamp);
                   break;
                  case 83:
                   resultString += padTill2(date.getSeconds(),padding);break;
                  case 84:
                   resultString
                   +=
                   _processFormat(locale.formats.T,date,locale,timestamp);
                   break;
                  case 85:
                   resultString += padTill2(weekNumber(date,"sunday"),padding);
                   break;
                  case 87:
                   resultString += padTill2(weekNumber(date,"monday"),padding);
                   break;
                  case 88:
                   resultString
                   +=
                   _processFormat(locale.formats.X,date,locale,timestamp);
                   break;
                  case 89:resultString += date.getFullYear();break;
                  case 90:
                   if(_useUtcBasedDate && _customTimezoneOffset === 0)
                    resultString += "GMT";
                   else
                    {var tzString=date.toString().match(/\(([\w\s]+)\)/);
                     resultString += tzString && tzString[1] || ""}
                   break;
                  case 97:
                   resultString += locale.shortDays[date.getDay()];break;
                  case 98:
                   resultString += locale.shortMonths[date.getMonth()];break;
                  case 99:
                   resultString
                   +=
                   _processFormat(locale.formats.c,date,locale,timestamp);
                   break;
                  case 100:
                   resultString += padTill2(date.getDate(),padding);break;
                  case 101:
                   resultString
                   +=
                   padTill2(date.getDate(),padding == null?" ":padding);
                   break;
                  case 104:
                   resultString += locale.shortMonths[date.getMonth()];break;
                  case 106:
                   var
                    y=new Date(date.getFullYear(),0,1),
                    day=
                     Math.ceil
                      ((date.getTime() - y.getTime()) / (1000 * 60 * 60 * 24));
                   resultString += padTill3(day);
                   break;
                  case 107:
                   resultString
                   +=
                   padTill2(date.getHours(),padding == null?" ":padding);
                   break;
                  case 108:
                   resultString
                   +=
                   padTill2
                    (hours12(date.getHours()),padding == null?" ":padding);
                   break;
                  case 109:
                   resultString += padTill2(date.getMonth() + 1,padding);break;
                  case 110:resultString += "\n";break;
                  case 111:
                   resultString
                   +=
                   String(date.getDate())
                   +
                   ordinal(date.getDate());
                   break;
                  case 112:
                   resultString += date.getHours() < 12?locale.AM:locale.PM;
                   break;
                  case 114:
                   resultString
                   +=
                   _processFormat(locale.formats.r,date,locale,timestamp);
                   break;
                  case 115:resultString += Math.floor(timestamp / 1000);break;
                  case 116:resultString += "\t";break;
                  case 117:
                   var day=date.getDay();resultString += day === 0?7:day;break;
                  case 118:
                   resultString
                   +=
                   _processFormat(locale.formats.v,date,locale,timestamp);
                   break;
                  case 119:resultString += date.getDay();break;
                  case 120:
                   resultString
                   +=
                   _processFormat(locale.formats.x,date,locale,timestamp);
                   break;
                  case 121:
                   resultString += ("" + date.getFullYear()).slice(2);break;
                  case 122:
                   if(_useUtcBasedDate && _customTimezoneOffset === 0)
                    resultString += extendedTZ?"+00:00":"+0000";
                   else
                    {var off;
                     if(_customTimezoneOffset !== 0)
                      off = _customTimezoneOffset / (60 * 1000);
                     else
                      off = - date.getTimezoneOffset();
                     var
                      sign=off < 0?"-":"+",
                      sep=extendedTZ?":":"",
                      hours=Math.floor(Math.abs(off / 60)),
                      mins=Math.abs(off % 60);
                     resultString
                     +=
                     sign
                     +
                     padTill2(hours)
                     +
                     sep
                     +
                     padTill2(mins)}
                   break;
                  default:resultString += format[i];break}
                padding = null;
                isInScope = false;
                continue}
              if(currentCharCode === 37){isInScope = true;continue}
              resultString += format[i]}
            return resultString}
          var strftime=_strftime;
          strftime.localize
          =
          function(locale)
           {return new
                    Strftime
                    (locale || _locale,_customTimezoneOffset,_useUtcBasedDate)};
          strftime.timezone
          =
          function(timezone)
           {var
             customTimezoneOffset=_customTimezoneOffset,
             useUtcBasedDate=_useUtcBasedDate,
             timezoneType=typeof timezone;
            if(timezoneType === "number" || timezoneType === "string")
             {useUtcBasedDate = true;
              if(timezoneType === "string")
               {var
                 sign=timezone[0] === "-"?- 1:1,
                 hours=parseInt(timezone.slice(1,3),10),
                 minutes=parseInt(timezone.slice(3,5),10);
                customTimezoneOffset
                =
                sign
                *
                (60 * hours + minutes)
                *
                60
                *
                1000}
              else
               if(timezoneType === "number")
                customTimezoneOffset = timezone * 60 * 1000}
            return new Strftime(_locale,customTimezoneOffset,useUtcBasedDate)};
          strftime.utc
          =
          function(){return new Strftime(_locale,_customTimezoneOffset,true)};
          return strftime}
        function padTill2(numberToPad,paddingChar)
         {if(paddingChar === "" || numberToPad > 9)return numberToPad;
          if(paddingChar == null)paddingChar = "0";
          return paddingChar + numberToPad}
        function padTill3(numberToPad)
         {if(numberToPad > 99)return numberToPad;
          if(numberToPad > 9)return "0" + numberToPad;
          return "00" + numberToPad}
        function hours12(hour)
         {if(hour === 0)return 12;else if(hour > 12)return hour - 12;
          return hour}
        function weekNumber(date,firstWeekday)
         {firstWeekday = firstWeekday || "sunday";
          var weekday=date.getDay();
          if(firstWeekday === "monday")
           if(weekday === 0)weekday = 6;else weekday--;
          var
           firstDayOfYearUtc=Date.UTC(date.getFullYear(),0,1),
           dateUtc=Date.UTC(date.getFullYear(),date.getMonth(),date.getDate()),
           yday=Math.floor((dateUtc - firstDayOfYearUtc) / 86400000),
           weekNum=(yday + 7 - weekday) / 7;
          return Math.floor(weekNum)}
        function ordinal(number)
         {var i=number % 10,ii=number % 100;
          if(ii >= 11 && ii <= 13 || i === 0 || i >= 4)return "th";
          switch(i){case 1:return "st";case 2:return "nd";case 3:return "rd"}}
        function getTimestampToUtcOffsetFor(date)
         {return (date.getTimezoneOffset() || 0) * 60000}}
      ())}
  (globalThis));
(function(globalThis)
   {"use strict";
    var joo_global_object=globalThis,plonk_wasm=joo_global_object.plonk_wasm;
    function rust_affine_to_caml_affine(pt)
     {var infinity=pt.infinity;
      if(infinity)
       {pt.free();return 0}
      else
       {var x=pt.x,y=pt.y;pt.free();return [0,[0,x,y]]}}
    function js_class_vector_of_rust_vector(v,klass)
     {var len=v.length,res=new Array(len);
      for(var i=0,pos=0;i < len;i++)res[i] = klass.__wrap(v[i]);
      return res}
    function caml_array_of_rust_vector(v,klass,convert,should_free)
     {v = js_class_vector_of_rust_vector(v,klass);
      var len=v.length,res=new Array(len + 1);
      res[0] = 0;
      for(var i=0;i < len;i++)
       {var rust_val=v[i];
        res[i + 1] = convert(rust_val);
        if(should_free)rust_val.free()}
      return res}
    function caml_poly_comm_of_rust_poly_comm(poly_comm,klass,should_free)
     {var
       rust_shifted=poly_comm.shifted,
       rust_unshifted=poly_comm.unshifted,
       caml_shifted;
      if(rust_shifted === undefined)
       caml_shifted = 0;
      else
       caml_shifted = [0,rust_affine_to_caml_affine(rust_shifted)];
      var
       caml_unshifted=
        caml_array_of_rust_vector
         (rust_unshifted,klass,rust_affine_to_caml_affine,should_free);
      return [0,caml_unshifted,caml_shifted]}
    function caml_vesta_poly_comm_of_rust(x)
     {return caml_poly_comm_of_rust_poly_comm(x,plonk_wasm.WasmGVesta,false)}
    function caml_expm1_float(x){return Math.expm1(x)}
    function caml_pallas_poly_comm_of_rust(x)
     {return caml_poly_comm_of_rust_poly_comm(x,plonk_wasm.WasmGPallas,false)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    function fs_node_supported()
     {return typeof globalThis.process
             !==
             "undefined"
             &&
             typeof globalThis.process.versions
             !==
             "undefined"
             &&
             typeof globalThis.process.versions.node
             !==
             "undefined"}
    function make_path_is_absolute()
     {function posix(path)
       {if(path.charAt(0) === "/")return ["",path.substring(1)];return}
      function win32(path)
       {var
         splitDeviceRe=
          /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
         result=splitDeviceRe.exec(path),
         device=result[1] || "",
         isUnc=Boolean(device && device.charAt(1) !== ":");
        if(Boolean(result[2] || isUnc))
         {var root=result[1] || "",sep=result[2] || "";
          return [root,path.substring(root.length + sep.length)]}
        return}
      return fs_node_supported()
              &&
              globalThis.process
              &&
              globalThis.process.platform
              ?globalThis.process.platform === "win32"?win32:posix
              :posix}
    var path_is_absolute=make_path_is_absolute();
    function caml_trailing_slash(name)
     {return name.slice(- 1) !== "/"?name + "/":name}
    if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
     var caml_current_dir=globalThis.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    caml_current_dir = caml_trailing_slash(caml_current_dir);
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(! path_is_absolute(name))name = caml_current_dir + name;
      var comp0=path_is_absolute(name),comp=comp0[1].split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         default:ncomp.push(comp[i]);break}
      ncomp.unshift(comp0[0]);
      ncomp.orig = name;
      return ncomp}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    var
     unix_error=
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
    function make_unix_err_args(code,syscall,path,errno)
     {var variant=unix_error.indexOf(code);
      if(variant < 0){if(errno == null)errno = - 9999;variant = [0,errno]}
      var
       args=
        [variant,
         caml_string_of_jsstring(syscall || ""),
         caml_string_of_jsstring(path || "")];
      return args}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_raise_with_args(tag,args){throw [0,tag].concat(args)}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg){throw globalThis.Error(msg.c)}
    var caml_global_data=[0];
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {caml_raise_sys_error(name + ": No such file or directory")}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(globalThis.Uint8Array)
       var a=new (globalThis.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.create_dir_if_needed
    =
    function(name)
     {var comp=name.split("/"),res="";
      for(var i=0;i < comp.length - 1;i++)
       {res += comp[i] + "/";
        if(this.content[res])continue;
        this.content[res] = Symbol("directory")}};
    MlFakeDevice.prototype.slash
    =
    function(name){return /\/$/.test(name)?name:name + "/"};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         {this.create_dir_if_needed(name);
          this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=this.slash(name);
      if(this.content[name_slash])return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {var unix_error=raise_unix && caml_named_value("Unix.Unix_error");
      if(this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("EEXIST","mkdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": File exists");
      var parent=/^(.*)\/[^/]+/.exec(name);
      parent = parent && parent[1] || "";
      if(! this.exists(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": No such file or directory");
      if(! this.is_dir(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": Not a directory");
      this.create_dir_if_needed(this.slash(name))};
    MlFakeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {var
       unix_error=raise_unix && caml_named_value("Unix.Unix_error"),
       name_slash=name == ""?"":this.slash(name),
       r=new RegExp("^" + name_slash + "([^/]+)");
      if(! this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": Not a directory");
      for(var n in this.content)
       if(n.match(r))
        if(unix_error)
         caml_raise_with_args
          (unix_error,make_unix_err_args("ENOTEMPTY","rmdir",this.nm(name)));
        else
         caml_raise_sys_error(this.nm(name) + ": Directory not empty");
      delete this.content[name_slash]};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var name_slash=name == ""?"":this.slash(name);
      if(! this.exists(name))
       caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))caml_raise_sys_error(name + ": Not a directory");
      var r=new RegExp("^" + name_slash + "([^/]+)"),seen={},a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {if(name == "")return true;
      var name_slash=this.slash(name);
      return this.content[name_slash]?1:0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.create_dir_if_needed(name);
         this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {var file;
      if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))file = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       file = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        file = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         file = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           file = new MlFakeFile(bytes)}
      if(file)
       {this.create_dir_if_needed(name);this.content[name] = file}
      else
       caml_raise_sys_error
        (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof globalThis.Uint8Array))
       a = new (globalThis.Uint8Array)(a);
      var buffer=globalThis.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof globalThis.Uint8Array))
       a = new (globalThis.Uint8Array)(a);
      var buffer=globalThis.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var a=new (globalThis.Uint8Array)(1),buffer=globalThis.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try {return this.fs.existsSync(this.nm(name))?1:0}catch(err){return 0}};
    MlNodeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {try
       {this.fs.mkdirSync(this.nm(name),{mode:mode});return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {try
       {this.fs.rmdirSync(this.nm(name));return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readdir
    =
    function(name,raise_unix)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name,raise_unix)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name));
        return b}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.open
    =
    function(name,f,raise_unix)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rename
    =
    function(o,n,raise_unix)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.stat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.statSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.lstat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.lstatSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.symlink
    =
    function(to_dir,target,path,raise_unix)
     {try
       {this.fs.symlinkSync(this.nm(target),this.nm(path),to_dir?"dir":"file");
        return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readlink
    =
    function(name,raise_unix)
     {try
       {var link=this.fs.readlinkSync(this.nm(name),"utf8");
        return caml_string_of_jsstring(link)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.raise_nodejs_error
    =
    function(err,raise_unix)
     {var unix_error=caml_named_value("Unix.Unix_error");
      if(raise_unix && unix_error)
       {var args=make_unix_err_args(err.code,err.syscall,err.path,err.errno);
        caml_raise_with_args(unix_error,args)}
      else
       caml_raise_sys_error(err.toString())};
    MlNodeDevice.prototype.stats_from_js
    =
    function(js_stats)
     {var file_kind;
      if(js_stats.isFile())
       file_kind = 0;
      else
       if(js_stats.isDirectory())
        file_kind = 1;
       else
        if(js_stats.isCharacterDevice())
         file_kind = 2;
        else
         if(js_stats.isBlockDevice())
          file_kind = 3;
         else
          if(js_stats.isSymbolicLink())
           file_kind = 4;
          else
           if(js_stats.isFIFO())
            file_kind = 5;
           else
            if(js_stats.isSocket())file_kind = 6;
      return [0,
              js_stats.dev,
              js_stats.ino,
              file_kind,
              js_stats.mode,
              js_stats.nlink,
              js_stats.uid,
              js_stats.gid,
              js_stats.rdev,
              js_stats.size,
              js_stats.atimeMs,
              js_stats.mtimeMs,
              js_stats.ctimeMs]};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    function caml_get_root(path)
     {var x=path_is_absolute(path);if(! x)return;return x[0] + "/"}
    function caml_failwith(msg)
     {if(! caml_global_data.Failure)
       caml_global_data.Failure = [248,caml_string_of_jsbytes("Failure"),- 3];
      caml_raise_with_string(caml_global_data.Failure,msg)}
    var
     caml_root=
      caml_get_root(caml_current_dir)
      ||
      caml_failwith("unable to compute caml_root"),
     jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:"/static/",device:new MlFakeDevice("/static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=caml_trailing_slash(name),
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      if(! res && fs_node_supported())
       {var root=caml_get_root(name);
        if(root && root.match(/^[a-zA-Z]:\/$/))
         {var m={path:root,device:new MlNodeDevice(root)};
          jsoo_mount_point.push(m);
          res
          =
          {path:m.path,
           device:m.device,
           rest:name.substring(m.path.length,name.length)}}}
      if(res)return res;
      caml_raise_sys_error("no device found for " + name_slash)}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    var
     free_finalization_registry=
      new
       (joo_global_object.FinalizationRegistry)
       (function(instance_representative){instance_representative.free()});
    function free_on_finalize(x)
     {var instance_representative=x.constructor.__wrap(x.ptr);
      free_finalization_registry.register(x,instance_representative,x);
      return x}
    function caml_plonk_domain_to_rust(x,klass){return new klass(x[1],x[2])}
    function rust_affine_of_caml_affine(pt,klass)
     {var res=new klass();
      if(pt === 0)res.infinity = true;else{res.x = pt[1][1];res.y = pt[1][2]}
      return res}
    function js_class_vector_to_rust_vector(v)
     {var len=v.length,res=new (joo_global_object.Uint32Array)(len);
      for(var i=0;i < len;i++)res[i] = v[i].ptr;
      return res}
    function caml_array_to_rust_vector(v,convert,mk_new)
     {v = v.slice(1);
      for(var i=0,l=v.length;i < l;i++)
       {var class_val=convert(v[i],mk_new);
        v[i] = class_val;
        free_finalization_registry.unregister(class_val)}
      return js_class_vector_to_rust_vector(v)}
    function caml_poly_comm_to_rust_poly_comm
     (poly_comm,poly_comm_class,mk_affine)
     {var
       caml_unshifted=poly_comm[1],
       caml_shifted=poly_comm[2],
       rust_shifted=undefined;
      if(caml_shifted !== 0)
       rust_shifted = rust_affine_of_caml_affine(caml_shifted[1],mk_affine);
      var
       rust_unshifted=
        caml_array_to_rust_vector
         (caml_unshifted,rust_affine_of_caml_affine,mk_affine);
      return new poly_comm_class(rust_unshifted,rust_shifted)}
    function caml_plonk_verification_evals_to_rust
     (x,klass,poly_comm_class,mk_affine)
     {function convert(poly_comm)
       {return caml_poly_comm_to_rust_poly_comm
                (poly_comm,poly_comm_class,mk_affine)}
      function convertArray(comms)
       {var n=comms.length,res=new Array(n - 1);
        for(var i=1;i < n;i++)res[i - 1] = convert(comms[i]);
        return js_class_vector_to_rust_vector(res)}
      var
       sigma_comm=convertArray(x[1]),
       coefficients_comm=convertArray(x[2]),
       generic_comm=convert(x[3]),
       psm_comm=convert(x[4]),
       complete_add_comm=convert(x[5]),
       mul_comm=convert(x[6]),
       emul_comm=convert(x[7]),
       endomul_scalar_comm=convert(x[8]);
      return new
              klass
              (sigma_comm,
               coefficients_comm,
               generic_comm,
               psm_comm,
               complete_add_comm,
               mul_comm,
               emul_comm,
               endomul_scalar_comm)}
    function caml_plonk_verification_shifts_to_rust(x,klass)
     {return new klass(x[1],x[2],x[3],x[4],x[5],x[6],x[7])}
    function caml_plonk_verifier_index_to_rust
     (x,
      klass,
      domain_class,
      verification_evals_class,
      poly_comm_class,
      mk_affine,
      verification_shifts_class)
     {var
       domain=caml_plonk_domain_to_rust(x[1],domain_class),
       max_poly_size=x[2],
       public_=x[3],
       prev_challenges=x[4],
       srs=x[5],
       evals=
        caml_plonk_verification_evals_to_rust
         (x[6],verification_evals_class,poly_comm_class,mk_affine),
       shifts=
        caml_plonk_verification_shifts_to_rust(x[7],verification_shifts_class);
      return new
              klass
              (domain,max_poly_size,public_,prev_challenges,srs,evals,shifts)}
    function caml_raise_constant(tag){throw tag}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=globalThis,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if(globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
       return caml_string_of_jsstring(globalThis.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var MlObjectTable;
    if(typeof globalThis.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function(){this.objs = [];this.lookup = new (globalThis.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_int64_neg(x){return x.neg()}
    function integers_uint_of_string(s,max_val)
     {var i=0,len=caml_ml_string_length(s),negative=false;
      if(i >= len)caml_failwith("int_of_string");
      var c=caml_string_unsafe_get(s,i);
      if(c === 45){i++;negative = true}else if(c === 43)i++;
      var no_digits=true;
      max_val.hi = max_val.hi >>> 0;
      var
       ten=caml_int64_of_int32(10),
       max_base_10=max_val.udivmod(ten).quotient,
       res=caml_int64_of_int32(0);
      for(;i < len;i++)
       {var c=caml_string_unsafe_get(s,i),d=caml_parse_digit(c);
        if(d < 0 || d >= 10)break;
        no_digits = false;
        if(caml_int64_ult(max_base_10,res))return max_val;
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(ten,res),d);
        if(caml_int64_ult(res,d))return max_val}
      if(no_digits)caml_failwith("int_of_string");
      if(negative)res = caml_int64_neg(res);
      res.hi = res.hi >>> 0;
      return res}
    function caml_int64_to_int32(x){return x.toInt()}
    var
     UInt32=
      function()
        {function UInt32(x){this.value = x >>> 0}
         UInt32.prototype.caml_custom = "integers:uint32";
         return UInt32}
       ();
    function integers_uint32_of_int64(i)
     {return new UInt32(caml_int64_to_int32(i))}
    function integers_uint32_of_string(s)
     {var max_val=caml_int64_create_lo_mi_hi(0xffffff,0xffffff,0xffff);
      return integers_uint32_of_int64(integers_uint_of_string(s,max_val))}
    function caml_log10_float(x){return Math.log10(x)}
    function caml_pasta_fq_copy(x,y)
     {for(var i=0,l=x.length;i < l;i++)x[i] = y[i]}
    var caml_pasta_fq_sub=plonk_wasm.caml_pasta_fq_sub;
    function caml_pasta_fq_mut_sub(x,y)
     {caml_pasta_fq_copy(x,caml_pasta_fq_sub(x,y))}
    function unix_unlink(name)
     {var root=resolve_fs_device(name);
      if(! root.device.unlink)caml_failwith("unix_unlink: not implemented");
      return root.device.unlink(root.rest,true)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function unix_rmdir(name)
     {var root=resolve_fs_device(name);
      if(! root.device.rmdir)caml_failwith("unix_rmdir: not implemented");
      return root.device.rmdir(root.rest,true)}
    function column_of_rust(col)
     {var tag=col.tag,gate_type=col.gate_type,i=col.i;
      col.free();
      return {0:[tag,i],2:[tag,i],5:[tag,i],6:[tag,gate_type],7:[tag,i]}[tag]
             ||
             tag}
    function variable_of_rust(variable)
     {var col=variable.col,row=variable.row;
      variable.free();
      return [0,column_of_rust(col),row]}
    function polish_token_of_rust(token)
     {var
       tag=token.tag,
       i0=token.i0,
       i1=token.i1,
       f=token.f,
       v=variable_of_rust(token.v);
      token.free();
      return {5:[5,i0,i1],6:[6,f],7:[7,v],9:[9,i0],14:[14,i0],16:[16,i0]}[tag]
             ||
             tag}
    function wrap(ptr,klass)
     {var obj=Object.create(klass.prototype);obj.ptr = ptr;return obj}
    function index_term_of_rust(term,token_class)
     {var
       column=column_of_rust(term.column),
       coefficient=
        js_class_vector_of_rust_vector(term.coefficient,token_class);
      coefficient = coefficient.map(polish_token_of_rust);
      coefficient = [0].concat(coefficient);
      term.free();
      return [0,column,coefficient]}
    function linearization_of_rust(linearization,affine_class)
     {var
       F=affine_class === plonk_wasm.WasmGVesta?"Fq":"Fp",
       WasmPolishToken=plonk_wasm["Wasm" + F + "PolishToken"],
       WasmIndexTerm=plonk_wasm["Wasm" + F + "IndexTerm"],
       constant_term=
        js_class_vector_of_rust_vector
         (linearization.constant_term,WasmPolishToken);
      constant_term = constant_term.map(polish_token_of_rust);
      constant_term = [0].concat(constant_term);
      var
       index_terms=
        Array.from(linearization.index_terms).map
         (function(ptr)
           {var wasmIndexTerm=wrap(ptr,WasmIndexTerm);
            return index_term_of_rust(wasmIndexTerm,WasmPolishToken)});
      index_terms = [0].concat(index_terms);
      linearization.free();
      return [0,constant_term,index_terms]}
    function caml_plonk_domain_of_rust(x)
     {var log_size_of_group=x.log_size_of_group,group_gen=x.group_gen;
      x.free();
      return [0,log_size_of_group,group_gen]}
    function caml_plonk_verification_evals_of_rust(x,affine_klass)
     {function convert(poly_comm)
       {return caml_poly_comm_of_rust_poly_comm(poly_comm,affine_klass,false)}
      function convertArray(comms)
       {comms
        =
        js_class_vector_of_rust_vector(comms,plonk_wasm.WasmFqPolyComm);
        return [0].concat(comms.map(convert))}
      var
       sigma_comm=convertArray(x.sigma_comm),
       coefficients_comm=convertArray(x.coefficients_comm),
       generic_comm=convert(x.generic_comm),
       psm_comm=convert(x.psm_comm),
       complete_add_comm=convert(x.complete_add_comm),
       mul_comm=convert(x.mul_comm),
       emul_comm=convert(x.emul_comm),
       endomul_scalar_comm=convert(x.endomul_scalar_comm);
      x.free();
      return [0,
              sigma_comm,
              coefficients_comm,
              generic_comm,
              psm_comm,
              complete_add_comm,
              mul_comm,
              emul_comm,
              endomul_scalar_comm,
              0]}
    function caml_plonk_verification_shifts_of_rust(x)
     {var res=[0,x.s0,x.s1,x.s2,x.s3,x.s4,x.s5,x.s6];x.free();return res}
    var None=0;
    function caml_plonk_verifier_index_of_rust(x,affine_class)
     {var
       domain=caml_plonk_domain_of_rust(x.domain),
       max_poly_size=x.max_poly_size,
       public_=x.public_,
       prev_challenges=x.prev_challenges,
       srs=free_on_finalize(x.srs),
       evals=caml_plonk_verification_evals_of_rust(x.evals,affine_class),
       shifts=caml_plonk_verification_shifts_of_rust(x.shifts),
       lookup_index=None;
      x.free();
      return [0,
              domain,
              max_poly_size,
              public_,
              prev_challenges,
              srs,
              evals,
              shifts,
              None]}
    function caml_pasta_fq_plonk_verifier_index_of_rust(x)
     {return caml_plonk_verifier_index_of_rust(x,plonk_wasm.WasmGPallas)}
    function caml_pasta_fq_plonk_verifier_index_to_rust(x)
     {return caml_plonk_verifier_index_to_rust
              (x,
               plonk_wasm.WasmFqPlonkVerifierIndex,
               plonk_wasm.WasmFqDomain,
               plonk_wasm.WasmFqPlonkVerificationEvals,
               plonk_wasm.WasmFqPolyComm,
               plonk_wasm.caml_pallas_affine_one,
               plonk_wasm.WasmFqShifts)}
    function caml_pasta_fq_plonk_verifier_index_deep_copy(x)
     {return caml_pasta_fq_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_deep_copy
                (caml_pasta_fq_plonk_verifier_index_to_rust(x)))}
    var caml_pasta_fq_print=plonk_wasm.caml_pasta_fq_print;
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function integers_ulonglong_size(unit){return 8}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function bigstring_blit_bigstring_bytes_stub(src,src_pos,dst,dst_pos,len)
     {return caml_bigstring_blit_ba_to_bytes(src,src_pos,dst,dst_pos,len)}
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function caml_pasta_fp_plonk_index_create
     (gates,public_inputs,prev_challenges,urs)
     {var
       t=
        plonk_wasm.caml_pasta_fp_plonk_index_create
         (gates,public_inputs,prev_challenges,urs);
      return free_on_finalize(t)}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    var caml_vesta_endo_base=plonk_wasm.caml_vesta_endo_base;
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_jsbytes_of_string(s)
     {s.t & 6 && caml_convert_string_to_bytes(s);return s.c}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    function caml_pasta_fp_plonk_gate_vector_create()
     {return free_on_finalize
              (plonk_wasm.caml_pasta_fp_plonk_gate_vector_create())}
    function unix_has_symlink(unit){return fs_node_supported()?1:0}
    function caml_pasta_fq_plonk_verifier_index_create(x)
     {return caml_pasta_fq_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_create(x))}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (globalThis.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (globalThis.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=globalThis,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (globalThis.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (globalThis.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_pasta_fq_domain_generator=
      plonk_wasm.caml_pasta_fq_domain_generator;
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_pallas_negate(x)
     {var res=plonk_wasm.caml_pallas_negate(x);
      free_on_finalize(res);
      return res}
    function caml_fq_srs_h(t)
     {return rust_affine_to_caml_affine(plonk_wasm.caml_fq_srs_h(t))}
    function caml_sys_exit(code)
     {var g=globalThis;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    var caml_ml_channels=new Array();
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_plonk_wire_of_rust(wire)
     {var res=[0,wire.row,wire.col];wire.free();return res}
    function caml_plonk_wires_of_rust(wires)
     {var
       res=
        [0,
         caml_plonk_wire_of_rust(wires[0]),
         caml_plonk_wire_of_rust(wires[1]),
         caml_plonk_wire_of_rust(wires[2]),
         caml_plonk_wire_of_rust(wires[3]),
         caml_plonk_wire_of_rust(wires[4]),
         caml_plonk_wire_of_rust(wires[5]),
         caml_plonk_wire_of_rust(wires[6])];
      wires.free();
      return res}
    function caml_u8array_vector_of_rust_flat_vector(v,inner_len)
     {var
       len=v.length,
       output_len=len / inner_len,
       res=new Array(output_len + 1);
      res[0] = 0;
      for(var i=1,pos=0;i <= output_len;i++)
       {var inner_res=new (joo_global_object.Uint8Array)(inner_len);
        for(var j=0;j < inner_len;j++,pos++)inner_res[j] = v[pos];
        res[i] = inner_res}
      return res}
    function caml_plonk_gate_of_rust(gate)
     {var
       res=
        [0,
         gate.typ,
         caml_plonk_wires_of_rust(gate.wires),
         caml_u8array_vector_of_rust_flat_vector(gate.c,32)];
      gate.free();
      return res}
    function caml_pasta_fq_plonk_gate_vector_get(v,i)
     {return caml_plonk_gate_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_gate_vector_get(v,i))}
    function caml_u8array_vector_to_rust_flat_vector(v)
     {var i=1,len=v.length - i;
      if(len === 0)return new (joo_global_object.Uint8Array)(0);
      var
       inner_len=v[i].length,
       res=new (joo_global_object.Uint8Array)(len * inner_len);
      for(var pos=0;i <= len;i++)
       for(var j=0;j < inner_len;j++,pos++)res[pos] = v[i][j];
      return res}
    function caml_option_to_maybe_undefined(x){return x === 0?undefined:x[1]}
    function caml_random_oracles_to_rust(x,roKlass)
     {var
       joint_combiner_ocaml=caml_option_to_maybe_undefined(x[1]),
       joint_combiner_chal=undefined,
       joint_combiner=undefined;
      if(joint_combiner_ocaml !== undefined)
       {joint_combiner_chal = joint_combiner_ocaml[1][1];
        joint_combiner = joint_combiner_ocaml[2]}
      return new
              roKlass
              (joint_combiner_chal,
               joint_combiner,
               x[2],
               x[3],
               x[4][1],
               x[5],
               x[6],
               x[7],
               x[8],
               x[9][1],
               x[10][1],
               x[11][1])}
    var
     UInt64=
      function()
        {function UInt64(x){this.value = x}
         UInt64.prototype.caml_custom = "integers:uint64";
         return UInt64}
       ();
    function integers_uint64_of_string(s)
     {var max_val=caml_int64_create_lo_mi_hi(0xffffff,0xffffff,0xffff);
      return new UInt64(integers_uint_of_string(s,max_val))}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_fp_srs_h(t)
     {return rust_affine_to_caml_affine(plonk_wasm.caml_fp_srs_h(t))}
    function caml_pasta_fp_plonk_verifier_index_of_rust(x)
     {return caml_plonk_verifier_index_of_rust(x,plonk_wasm.WasmGVesta)}
    function caml_pasta_fp_plonk_verifier_index_create(x)
     {var
       vk=plonk_wasm.caml_pasta_fp_plonk_verifier_index_create(x),
       vk_caml=caml_pasta_fp_plonk_verifier_index_of_rust(vk);
      return vk_caml}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    var caml_pasta_fq_deep_copy=plonk_wasm.caml_pasta_fq_deep_copy;
    function bigstring_is_mmapped_stub(x){return 0}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_check_bound_bigstring(bigstring,i)
     {if(i >>> 0 >= bigstring.data.length)caml_array_bound_error()}
    function bin_prot_blit_buf_float_array_stub(src_pos,src,dst_pos,dst,len)
     {if(len == 0)return 0;
      caml_check_bound(dst,dst_pos);
      caml_check_bound(dst,dst_pos + len - 1);
      caml_check_bound_bigstring(src,src_pos);
      caml_check_bound_bigstring(src,src_pos + len * 8 - 1);
      var
       view=new (joo_global_object.Float64Array)(len),
       buffer=new (joo_global_object.Uint8Array)(view.buffer);
      buffer.set(src.data.subarray(src_pos,src_pos + len * 8));
      for(var i=0;i < len;i++)dst[dst_pos + i + 1] = view[i];
      return 0}
    function caml_pallas_random()
     {var res=plonk_wasm.caml_pallas_random();
      free_on_finalize(res);
      return res}
    function caml_pasta_fq_plonk_verifier_index_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_pasta_fq_plonk_verifier_index_write
              (append,
               caml_pasta_fq_plonk_verifier_index_to_rust(t),
               caml_jsstring_of_string(path))}
    var caml_pasta_fp_to_bigint=plonk_wasm.caml_pasta_fp_to_bigint;
    function caml_vesta_poly_comm_to_rust(x)
     {return caml_poly_comm_to_rust_poly_comm
              (x,plonk_wasm.WasmFpPolyComm,plonk_wasm.caml_vesta_affine_one)}
    function caml_pasta_fp_commitments_to_rust(x)
     {function convertArray(v)
       {var n=v.length - 1,res=new Array(n);
        for(var i=0;i < n;++i)res[i] = caml_vesta_poly_comm_to_rust(v[i + 1]);
        return js_class_vector_to_rust_vector(res)}
      var
       w_comm=convertArray(x[1]),
       z_comm=caml_vesta_poly_comm_to_rust(x[2]),
       t_comm=caml_vesta_poly_comm_to_rust(x[3]);
      return new (plonk_wasm.WasmFpProverCommitments)(w_comm,z_comm,t_comm)}
    function caml_pasta_fp_opening_proof_to_rust(x)
     {function convert_affines(affines)
       {return caml_array_to_rust_vector
                (affines,
                 rust_affine_of_caml_affine,
                 plonk_wasm.caml_vesta_affine_one)}
      var
       lr=x[1],
       delta=rust_affine_of_caml_affine(x[2],plonk_wasm.caml_vesta_affine_one),
       z1=x[3],
       z2=x[4],
       sg=rust_affine_of_caml_affine(x[5],plonk_wasm.caml_vesta_affine_one),
       len=lr.length,
       l_ocaml=new Array(len),
       r_ocaml=new Array(len);
      for(var i=1;i < len;i++){l_ocaml[i] = lr[i][1];r_ocaml[i] = lr[i][2]}
      var l=convert_affines(l_ocaml),r=convert_affines(r_ocaml);
      return new (plonk_wasm.WasmFpOpeningProof)(l,r,delta,z1,z2,sg)}
    function caml_fp_vector_to_rust(v)
     {return caml_u8array_vector_to_rust_flat_vector(v)}
    var PERMUTS_MINUS_1=6,COLUMNS=15;
    function caml_pasta_fp_proof_evaluations_to_rust(x){return x}
    function caml_pasta_fp_proof_to_rust(x)
     {var
       commitments=caml_pasta_fp_commitments_to_rust(x[1]),
       proof=caml_pasta_fp_opening_proof_to_rust(x[2]),
       evals=caml_pasta_fp_proof_evaluations_to_rust(x[3]),
       ft_eval1=x[4],
       public_=caml_fp_vector_to_rust(x[5]),
       prev_challenges=x[6],
       chals_len=prev_challenges.length,
       prev_challenges_scalars=new (plonk_wasm.WasmVecVecFp)(chals_len - 1),
       prev_challenges_comms=new Array(chals_len - 1);
      for(var i=1;i < chals_len;i++)
       {prev_challenges_scalars.push
         (caml_fp_vector_to_rust(prev_challenges[i][1]));
        prev_challenges_comms[i - 1]
        =
        caml_vesta_poly_comm_to_rust(prev_challenges[i][2])}
      prev_challenges_comms
      =
      js_class_vector_to_rust_vector(prev_challenges_comms);
      return new
              (plonk_wasm.WasmFpProverProof)
              (commitments,
               proof,
               evals,
               ft_eval1,
               public_,
               prev_challenges_scalars,
               prev_challenges_comms)}
    function caml_pasta_fp_commitments_of_rust(x)
     {function convertArray(v)
       {var
         a=js_class_vector_of_rust_vector(v,plonk_wasm.WasmFpPolyComm),
         res=[0];
        for(var i=0;i < a.length;++i)
         res.push(caml_vesta_poly_comm_of_rust(a[i]));
        return res}
      var
       w_comm=convertArray(x.w_comm),
       z_comm=caml_vesta_poly_comm_of_rust(x.z_comm),
       t_comm=caml_vesta_poly_comm_of_rust(x.t_comm);
      x.free();
      return [0,w_comm,z_comm,t_comm]}
    function caml_pasta_fp_opening_proof_of_rust(x)
     {function convert_affines(affines)
       {return caml_array_of_rust_vector
                (affines,
                 plonk_wasm.WasmGVesta,
                 rust_affine_to_caml_affine,
                 false)}
      var
       l=convert_affines(x.lr_0),
       r=convert_affines(x.lr_1),
       delta=rust_affine_to_caml_affine(x.delta),
       z1=x.z1,
       z2=x.z2,
       sg=rust_affine_to_caml_affine(x.sg);
      x.free();
      var len=l.length;
      if(len !== r.length)throw new Error("l and r lengths don't match");
      var lr=new Array(len);
      lr[0] = 0;
      for(var i=1;i < len;i++)
       {var tuple=new Array(3);
        tuple[0] = 0;
        tuple[1] = l[i];
        tuple[2] = r[i];
        lr[i] = tuple}
      return [0,lr,delta,z1,z2,sg]}
    function caml_fp_vector_of_rust(v)
     {return caml_u8array_vector_of_rust_flat_vector(v,32)}
    function caml_pasta_fp_proof_evaluations_of_rust(x){return x}
    function caml_pasta_fp_proof_of_rust(x)
     {var
       messages=caml_pasta_fp_commitments_of_rust(x.commitments),
       proof=caml_pasta_fp_opening_proof_of_rust(x.proof),
       evals=caml_pasta_fp_proof_evaluations_of_rust(x.evals),
       ft_eval1=x.ft_eval1,
       public_=caml_fp_vector_of_rust(x.public_),
       prev_challenges_scalars=x.prev_challenges_scalars,
       prev_challenges_comms=
        js_class_vector_of_rust_vector
         (x.prev_challenges_comms,plonk_wasm.WasmFpPolyComm),
       chals_len=prev_challenges_comms.length,
       prev_challenges=new Array(chals_len);
      prev_challenges[0] = 0;
      for(var i=1;i < chals_len;i++)
       {var res=new Array(3);
        res[0] = 0;
        res[1] = caml_fp_vector_of_rust(prev_challenges_scalars.get(i - 1));
        res[2] = caml_vesta_poly_comm_of_rust(prev_challenges_comms[i]);
        prev_challenges[i] = res}
      return [0,messages,proof,evals,ft_eval1,public_,prev_challenges]}
    function caml_pasta_fp_plonk_proof_deep_copy(proof)
     {return caml_pasta_fp_proof_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_proof_deep_copy
                (caml_pasta_fp_proof_to_rust(proof)))}
    var caml_oo_last_id=0;
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_pasta_fq_plonk_verifier_index_dummy()
     {return caml_pasta_fq_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_dummy())}
    function caml_erf_float(x)
     {var
       a1=0.254829592,
       a2=- 0.284496736,
       a3=1.421413741,
       a4=- 1.453152027,
       a5=1.061405429,
       p=0.3275911,
       sign=1;
      if(x < 0)sign = - 1;
      x = Math.abs(x);
      var
       t=1.0 / (1.0 + p * x),
       y=
        1.0
        -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1)
        *
        t
        *
        Math.exp(- (x * x));
      return sign * y}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    var
     bigInt=
      function(undefined)
        {"use strict";
         var
          BASE=1e7,
          LOG_BASE=7,
          MAX_INT=9007199254740992,
          MAX_INT_ARR=smallToArray(MAX_INT),
          DEFAULT_ALPHABET="0123456789abcdefghijklmnopqrstuvwxyz",
          BigInt=joo_global_object.BigInt,
          supportsNativeBigInt=typeof BigInt === "function";
         function Integer(v,radix,alphabet,caseSensitive)
          {if(typeof v === "undefined")return Integer[0];
           if(typeof radix !== "undefined")
            return + radix === 10 && ! alphabet
                    ?parseValue(v)
                    :parseBase(v,radix,alphabet,caseSensitive);
           return parseValue(v)}
         function BigInteger(value,sign)
          {this.value = value;
           this.sign = sign;
           this.isSmall = false;
           this.caml_custom = "_z"}
         BigInteger.prototype = Object.create(Integer.prototype);
         function SmallInteger(value)
          {this.value = value;
           this.sign = value < 0;
           this.isSmall = true;
           this.caml_custom = "_z"}
         SmallInteger.prototype = Object.create(Integer.prototype);
         function NativeBigInt(value)
          {this.value = value;this.caml_custom = "_z"}
         NativeBigInt.prototype = Object.create(Integer.prototype);
         function isPrecise(n){return - MAX_INT < n && n < MAX_INT}
         function smallToArray(n)
          {if(n < 1e7)return [n];
           if(n < 1e14)return [n % 1e7,Math.floor(n / 1e7)];
           return [n % 1e7,Math.floor(n / 1e7) % 1e7,Math.floor(n / 1e14)]}
         function arrayToSmall(arr)
          {trim(arr);
           var length=arr.length;
           if(length < 4 && compareAbs(arr,MAX_INT_ARR) < 0)
            switch(length)
             {case 0:return 0;
              case 1:return arr[0];
              case 2:return arr[0] + arr[1] * BASE;
              default:return arr[0] + (arr[1] + arr[2] * BASE) * BASE}
           return arr}
         function trim(v){var i=v.length;while(v[--i] === 0);v.length = i + 1}
         function createArray(length)
          {var x=new Array(length),i=- 1;while(++i < length)x[i] = 0;return x}
         function truncate(n)
          {if(n > 0)return Math.floor(n);return Math.ceil(n)}
         function add(a,b)
          {var
            l_a=a.length,
            l_b=b.length,
            r=new Array(l_a),
            carry=0,
            base=BASE,
            sum,
            i;
           for(i = 0;i < l_b;i++)
            {sum = a[i] + b[i] + carry;
             carry = sum >= base?1:0;
             r[i] = sum - carry * base}
           while(i < l_a)
            {sum = a[i] + carry;
             carry = sum === base?1:0;
             r[i++] = sum - carry * base}
           if(carry > 0)r.push(carry);
           return r}
         function addAny(a,b)
          {if(a.length >= b.length)return add(a,b);return add(b,a)}
         function addSmall(a,carry)
          {var l=a.length,r=new Array(l),base=BASE,sum,i;
           for(i = 0;i < l;i++)
            {sum = a[i] - base + carry;
             carry = Math.floor(sum / base);
             r[i] = sum - carry * base;
             carry += 1}
           while(carry > 0)
            {r[i++] = carry % base;carry = Math.floor(carry / base)}
           return r}
         BigInteger.prototype.add
         =
         function(v)
          {var n=parseValue(v);
           if(this.sign !== n.sign)return this.subtract(n.negate());
           var a=this.value,b=n.value;
           if(n.isSmall)
            return new BigInteger(addSmall(a,Math.abs(b)),this.sign);
           return new BigInteger(addAny(a,b),this.sign)};
         BigInteger.prototype.plus = BigInteger.prototype.add;
         SmallInteger.prototype.add
         =
         function(v)
          {var n=parseValue(v),a=this.value;
           if(a < 0 !== n.sign)return this.subtract(n.negate());
           var b=n.value;
           if(n.isSmall)
            {if(isPrecise(a + b))return new SmallInteger(a + b);
             b = smallToArray(Math.abs(b))}
           return new BigInteger(addSmall(b,Math.abs(a)),a < 0)};
         SmallInteger.prototype.plus = SmallInteger.prototype.add;
         NativeBigInt.prototype.add
         =
         function(v)
          {return new NativeBigInt(this.value + parseValue(v).value)};
         NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
         function subtract(a,b)
          {var
            a_l=a.length,
            b_l=b.length,
            r=new Array(a_l),
            borrow=0,
            base=BASE,
            i,
            difference;
           for(i = 0;i < b_l;i++)
            {difference = a[i] - borrow - b[i];
             if(difference < 0){difference += base;borrow = 1}else borrow = 0;
             r[i] = difference}
           for(i = b_l;i < a_l;i++)
            {difference = a[i] - borrow;
             if(difference < 0)
              difference += base;
             else
              {r[i++] = difference;break}
             r[i] = difference}
           for(;i < a_l;i++)r[i] = a[i];
           trim(r);
           return r}
         function subtractAny(a,b,sign)
          {var value;
           if(compareAbs(a,b) >= 0)
            value = subtract(a,b);
           else
            {value = subtract(b,a);sign = ! sign}
           value = arrayToSmall(value);
           if(typeof value === "number")
            {if(sign)value = - value;return new SmallInteger(value)}
           return new BigInteger(value,sign)}
         function subtractSmall(a,b,sign)
          {var l=a.length,r=new Array(l),carry=- b,base=BASE,i,difference;
           for(i = 0;i < l;i++)
            {difference = a[i] + carry;
             carry = Math.floor(difference / base);
             difference %= base;
             r[i] = difference < 0?difference + base:difference}
           r = arrayToSmall(r);
           if(typeof r === "number")
            {if(sign)r = - r;return new SmallInteger(r)}
           return new BigInteger(r,sign)}
         BigInteger.prototype.subtract
         =
         function(v)
          {var n=parseValue(v);
           if(this.sign !== n.sign)return this.add(n.negate());
           var a=this.value,b=n.value;
           if(n.isSmall)return subtractSmall(a,Math.abs(b),this.sign);
           return subtractAny(a,b,this.sign)};
         BigInteger.prototype.minus = BigInteger.prototype.subtract;
         SmallInteger.prototype.subtract
         =
         function(v)
          {var n=parseValue(v),a=this.value;
           if(a < 0 !== n.sign)return this.add(n.negate());
           var b=n.value;
           if(n.isSmall)return new SmallInteger(a - b);
           return subtractSmall(b,Math.abs(a),a >= 0)};
         SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
         NativeBigInt.prototype.subtract
         =
         function(v)
          {return new NativeBigInt(this.value - parseValue(v).value)};
         NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
         BigInteger.prototype.negate
         =
         function(){return new BigInteger(this.value,! this.sign)};
         SmallInteger.prototype.negate
         =
         function()
          {var sign=this.sign,small=new SmallInteger(- this.value);
           small.sign = ! sign;
           return small};
         NativeBigInt.prototype.negate
         =
         function(){return new NativeBigInt(- this.value)};
         BigInteger.prototype.abs
         =
         function(){return new BigInteger(this.value,false)};
         SmallInteger.prototype.abs
         =
         function(){return new SmallInteger(Math.abs(this.value))};
         NativeBigInt.prototype.abs
         =
         function()
          {return new NativeBigInt(this.value >= 0?this.value:- this.value)};
         function multiplyLong(a,b)
          {var
            a_l=a.length,
            b_l=b.length,
            l=a_l + b_l,
            r=createArray(l),
            base=BASE,
            product,
            carry,
            i,
            a_i,
            b_j;
           for(i = 0;i < a_l;++i)
            {a_i = a[i];
             for(var j=0;j < b_l;++j)
              {b_j = b[j];
               product = a_i * b_j + r[i + j];
               carry = Math.floor(product / base);
               r[i + j] = product - carry * base;
               r[i + j + 1] += carry}}
           trim(r);
           return r}
         function multiplySmall(a,b)
          {var l=a.length,r=new Array(l),base=BASE,carry=0,product,i;
           for(i = 0;i < l;i++)
            {product = a[i] * b + carry;
             carry = Math.floor(product / base);
             r[i] = product - carry * base}
           while(carry > 0)
            {r[i++] = carry % base;carry = Math.floor(carry / base)}
           return r}
         function shiftLeft(x,n)
          {var r=[];while(n-- > 0)r.push(0);return r.concat(x)}
         function multiplyKaratsuba(x,y)
          {var n=Math.max(x.length,y.length);
           if(n <= 30)return multiplyLong(x,y);
           n = Math.ceil(n / 2);
           var
            b=x.slice(n),
            a=x.slice(0,n),
            d=y.slice(n),
            c=y.slice(0,n),
            ac=multiplyKaratsuba(a,c),
            bd=multiplyKaratsuba(b,d),
            abcd=multiplyKaratsuba(addAny(a,b),addAny(c,d)),
            product=
             addAny
              (addAny(ac,shiftLeft(subtract(subtract(abcd,ac),bd),n)),
               shiftLeft(bd,2 * n));
           trim(product);
           return product}
         function useKaratsuba(l1,l2)
          {return - (0.012 * l1) - 0.012 * l2 + 0.000015 * l1 * l2 > 0}
         BigInteger.prototype.multiply
         =
         function(v)
          {var
            n=parseValue(v),
            a=this.value,
            b=n.value,
            sign=this.sign !== n.sign,
            abs;
           if(n.isSmall)
            {if(b === 0)return Integer[0];
             if(b === 1)return this;
             if(b === - 1)return this.negate();
             abs = Math.abs(b);
             if(abs < BASE)return new BigInteger(multiplySmall(a,abs),sign);
             b = smallToArray(abs)}
           if(useKaratsuba(a.length,b.length))
            return new BigInteger(multiplyKaratsuba(a,b),sign);
           return new BigInteger(multiplyLong(a,b),sign)};
         BigInteger.prototype.times = BigInteger.prototype.multiply;
         function multiplySmallAndArray(a,b,sign)
          {if(a < BASE)return new BigInteger(multiplySmall(b,a),sign);
           return new BigInteger(multiplyLong(b,smallToArray(a)),sign)}
         SmallInteger.prototype._multiplyBySmall
         =
         function(a)
          {if(isPrecise(a.value * this.value))
            return new SmallInteger(a.value * this.value);
           return multiplySmallAndArray
                   (Math.abs(a.value),
                    smallToArray(Math.abs(this.value)),
                    this.sign !== a.sign)};
         BigInteger.prototype._multiplyBySmall
         =
         function(a)
          {if(a.value === 0)return Integer[0];
           if(a.value === 1)return this;
           if(a.value === - 1)return this.negate();
           return multiplySmallAndArray
                   (Math.abs(a.value),this.value,this.sign !== a.sign)};
         SmallInteger.prototype.multiply
         =
         function(v){return parseValue(v)._multiplyBySmall(this)};
         SmallInteger.prototype.times = SmallInteger.prototype.multiply;
         NativeBigInt.prototype.multiply
         =
         function(v)
          {return new NativeBigInt(this.value * parseValue(v).value)};
         NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
         function square(a)
          {var
            l=a.length,
            r=createArray(l + l),
            base=BASE,
            product,
            carry,
            i,
            a_i,
            a_j;
           for(i = 0;i < l;i++)
            {a_i = a[i];
             carry = 0 - a_i * a_i;
             for(var j=i;j < l;j++)
              {a_j = a[j];
               product = 2 * (a_i * a_j) + r[i + j] + carry;
               carry = Math.floor(product / base);
               r[i + j] = product - carry * base}
             r[i + l] = carry}
           trim(r);
           return r}
         BigInteger.prototype.square
         =
         function(){return new BigInteger(square(this.value),false)};
         SmallInteger.prototype.square
         =
         function()
          {var value=this.value * this.value;
           if(isPrecise(value))return new SmallInteger(value);
           return new
                   BigInteger
                   (square(smallToArray(Math.abs(this.value))),false)};
         NativeBigInt.prototype.square
         =
         function(v){return new NativeBigInt(this.value * this.value)};
         function divMod1(a,b)
          {var
            a_l=a.length,
            b_l=b.length,
            base=BASE,
            result=createArray(b.length),
            divisorMostSignificantDigit=b[b_l - 1],
            lambda=Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder=multiplySmall(a,lambda),
            divisor=multiplySmall(b,lambda),
            quotientDigit,
            shift,
            carry,
            borrow,
            i,
            l,
            q;
           if(remainder.length <= a_l)remainder.push(0);
           divisor.push(0);
           divisorMostSignificantDigit = divisor[b_l - 1];
           for(shift = a_l - b_l;shift >= 0;shift--)
            {quotientDigit = base - 1;
             if(remainder[shift + b_l] !== divisorMostSignificantDigit)
              quotientDigit
              =
              Math.floor
               ((remainder[shift + b_l] * base + remainder[shift + b_l - 1])
                /
                divisorMostSignificantDigit);
             carry = 0;
             borrow = 0;
             l = divisor.length;
             for(i = 0;i < l;i++)
              {carry += quotientDigit * divisor[i];
               q = Math.floor(carry / base);
               borrow += remainder[shift + i] - (carry - q * base);
               carry = q;
               if(borrow < 0)
                {remainder[shift + i] = borrow + base;borrow = - 1}
               else
                {remainder[shift + i] = borrow;borrow = 0}}
             while(borrow !== 0)
              {quotientDigit -= 1;
               carry = 0;
               for(i = 0;i < l;i++)
                {carry += remainder[shift + i] - base + divisor[i];
                 if(carry < 0)
                  {remainder[shift + i] = carry + base;carry = 0}
                 else
                  {remainder[shift + i] = carry;carry = 1}}
               borrow += carry}
             result[shift] = quotientDigit}
           remainder = divModSmall(remainder,lambda)[0];
           return [arrayToSmall(result),arrayToSmall(remainder)]}
         function divMod2(a,b)
          {var
            a_l=a.length,
            b_l=b.length,
            result=[],
            part=[],
            base=BASE,
            guess,
            xlen,
            highx,
            highy,
            check;
           while(a_l)
            {part.unshift(a[--a_l]);
             trim(part);
             if(compareAbs(part,b) < 0){result.push(0);continue}
             xlen = part.length;
             highx = part[xlen - 1] * base + part[xlen - 2];
             highy = b[b_l - 1] * base + b[b_l - 2];
             if(xlen > b_l)highx = (highx + 1) * base;
             guess = Math.ceil(highx / highy);
             do
              {check = multiplySmall(b,guess);
               if(compareAbs(check,part) <= 0)break;
               guess--}
             while
              (guess);
             result.push(guess);
             part = subtract(part,check)}
           result.reverse();
           return [arrayToSmall(result),arrayToSmall(part)]}
         function divModSmall(value,lambda)
          {var
            length=value.length,
            quotient=createArray(length),
            base=BASE,
            i,
            q,
            remainder,
            divisor;
           remainder = 0;
           for(i = length - 1;i >= 0;--i)
            {divisor = remainder * base + value[i];
             q = truncate(divisor / lambda);
             remainder = divisor - q * lambda;
             quotient[i] = q | 0}
           return [quotient,remainder | 0]}
         function divModAny(self,v)
          {var value,n=parseValue(v);
           if(supportsNativeBigInt)
            return [new NativeBigInt(self.value / n.value),
                    new NativeBigInt(self.value % n.value)];
           var a=self.value,b=n.value,quotient;
           if(b === 0)throw new Error("Cannot divide by zero");
           if(self.isSmall)
            {if(n.isSmall)
              return [new SmallInteger(truncate(a / b)),
                      new SmallInteger(a % b)];
             return [Integer[0],self]}
           if(n.isSmall)
            {if(b === 1)return [self,Integer[0]];
             if(b == - 1)return [self.negate(),Integer[0]];
             var abs=Math.abs(b);
             if(abs < BASE)
              {value = divModSmall(a,abs);
               quotient = arrayToSmall(value[0]);
               var remainder=value[1];
               if(self.sign)remainder = - remainder;
               if(typeof quotient === "number")
                {if(self.sign !== n.sign)quotient = - quotient;
                 return [new SmallInteger(quotient),
                         new SmallInteger(remainder)]}
               return [new BigInteger(quotient,self.sign !== n.sign),
                       new SmallInteger(remainder)]}
             b = smallToArray(abs)}
           var comparison=compareAbs(a,b);
           if(comparison === - 1)return [Integer[0],self];
           if(comparison === 0)
            return [Integer[self.sign === n.sign?1:- 1],Integer[0]];
           if(a.length + b.length <= 200)
            value = divMod1(a,b);
           else
            value = divMod2(a,b);
           quotient = value[0];
           var qSign=self.sign !== n.sign,mod=value[1],mSign=self.sign;
           if(typeof quotient === "number")
            {if(qSign)quotient = - quotient;
             quotient = new SmallInteger(quotient)}
           else
            quotient = new BigInteger(quotient,qSign);
           if(typeof mod === "number")
            {if(mSign)mod = - mod;mod = new SmallInteger(mod)}
           else
            mod = new BigInteger(mod,mSign);
           return [quotient,mod]}
         BigInteger.prototype.divmod
         =
         function(v)
          {var result=divModAny(this,v);
           return {quotient:result[0],remainder:result[1]}};
         NativeBigInt.prototype.divmod
         =
         SmallInteger.prototype.divmod
         =
         BigInteger.prototype.divmod;
         BigInteger.prototype.divide
         =
         function(v){return divModAny(this,v)[0]};
         NativeBigInt.prototype.over
         =
         NativeBigInt.prototype.divide
         =
         function(v)
          {return new NativeBigInt(this.value / parseValue(v).value)};
         SmallInteger.prototype.over
         =
         SmallInteger.prototype.divide
         =
         BigInteger.prototype.over
         =
         BigInteger.prototype.divide;
         BigInteger.prototype.mod = function(v){return divModAny(this,v)[1]};
         NativeBigInt.prototype.mod
         =
         NativeBigInt.prototype.remainder
         =
         function(v)
          {return new NativeBigInt(this.value % parseValue(v).value)};
         SmallInteger.prototype.remainder
         =
         SmallInteger.prototype.mod
         =
         BigInteger.prototype.remainder
         =
         BigInteger.prototype.mod;
         BigInteger.prototype.pow
         =
         function(v)
          {var n=parseValue(v),a=this.value,b=n.value,value,x,y;
           if(b === 0)return Integer[1];
           if(a === 0)return Integer[0];
           if(a === 1)return Integer[1];
           if(a === - 1)return n.isEven()?Integer[1]:Integer[- 1];
           if(n.sign)return Integer[0];
           if(! n.isSmall)
            throw new Error("The exponent " + n.toString() + " is too large.");
           if(this.isSmall)
            if(isPrecise(value = Math.pow(a,b)))
             return new SmallInteger(truncate(value));
           x = this;
           y = Integer[1];
           while(true)
            {if(b & 1 === 1){y = y.times(x);--b}
             if(b === 0)break;
             b /= 2;
             x = x.square()}
           return y};
         SmallInteger.prototype.pow = BigInteger.prototype.pow;
         NativeBigInt.prototype.pow
         =
         function(v)
          {var
            n=parseValue(v),
            a=this.value,
            b=n.value,
            _0=BigInt(0),
            _1=BigInt(1),
            _2=BigInt(2);
           if(b === _0)return Integer[1];
           if(a === _0)return Integer[0];
           if(a === _1)return Integer[1];
           if(a === BigInt(- 1))return n.isEven()?Integer[1]:Integer[- 1];
           if(n.isNegative())return new NativeBigInt(_0);
           var x=this,y=Integer[1];
           while(true)
            {if((b & _1) === _1){y = y.times(x);--b}
             if(b === _0)break;
             b /= _2;
             x = x.square()}
           return y};
         BigInteger.prototype.modPow
         =
         function(exp,mod)
          {exp = parseValue(exp);
           mod = parseValue(mod);
           if(mod.isZero())
            throw new Error("Cannot take modPow with modulus 0");
           var r=Integer[1],base=this.mod(mod);
           if(exp.isNegative())
            {exp = exp.multiply(Integer[- 1]);base = base.modInv(mod)}
           while(exp.isPositive())
            {if(base.isZero())return Integer[0];
             if(exp.isOdd())r = r.multiply(base).mod(mod);
             exp = exp.divide(2);
             base = base.square().mod(mod)}
           return r};
         NativeBigInt.prototype.modPow
         =
         SmallInteger.prototype.modPow
         =
         BigInteger.prototype.modPow;
         function compareAbs(a,b)
          {if(a.length !== b.length)return a.length > b.length?1:- 1;
           for(var i=a.length - 1;i >= 0;i--)
            if(a[i] !== b[i])return a[i] > b[i]?1:- 1;
           return 0}
         BigInteger.prototype.compareAbs
         =
         function(v)
          {var n=parseValue(v),a=this.value,b=n.value;
           if(n.isSmall)return 1;
           return compareAbs(a,b)};
         SmallInteger.prototype.compareAbs
         =
         function(v)
          {var n=parseValue(v),a=Math.abs(this.value),b=n.value;
           if(n.isSmall){b = Math.abs(b);return a === b?0:a > b?1:- 1}
           return - 1};
         NativeBigInt.prototype.compareAbs
         =
         function(v)
          {var a=this.value,b=parseValue(v).value;
           a = a >= 0?a:- a;
           b = b >= 0?b:- b;
           return a === b?0:a > b?1:- 1};
         BigInteger.prototype.compare
         =
         function(v)
          {if(v === Infinity)return - 1;
           if(v === - Infinity)return 1;
           var n=parseValue(v),a=this.value,b=n.value;
           if(this.sign !== n.sign)return n.sign?1:- 1;
           if(n.isSmall)return this.sign?- 1:1;
           return compareAbs(a,b) * (this.sign?- 1:1)};
         BigInteger.prototype.compareTo = BigInteger.prototype.compare;
         SmallInteger.prototype.compare
         =
         function(v)
          {if(v === Infinity)return - 1;
           if(v === - Infinity)return 1;
           var n=parseValue(v),a=this.value,b=n.value;
           if(n.isSmall)return a == b?0:a > b?1:- 1;
           if(a < 0 !== n.sign)return a < 0?- 1:1;
           return a < 0?1:- 1};
         SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
         NativeBigInt.prototype.compare
         =
         function(v)
          {if(v === Infinity)return - 1;
           if(v === - Infinity)return 1;
           var a=this.value,b=parseValue(v).value;
           return a === b?0:a > b?1:- 1};
         NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
         BigInteger.prototype.equals
         =
         function(v){return this.compare(v) === 0};
         NativeBigInt.prototype.eq
         =
         NativeBigInt.prototype.equals
         =
         SmallInteger.prototype.eq
         =
         SmallInteger.prototype.equals
         =
         BigInteger.prototype.eq
         =
         BigInteger.prototype.equals;
         BigInteger.prototype.notEquals
         =
         function(v){return this.compare(v) !== 0};
         NativeBigInt.prototype.neq
         =
         NativeBigInt.prototype.notEquals
         =
         SmallInteger.prototype.neq
         =
         SmallInteger.prototype.notEquals
         =
         BigInteger.prototype.neq
         =
         BigInteger.prototype.notEquals;
         BigInteger.prototype.greater
         =
         function(v){return this.compare(v) > 0};
         NativeBigInt.prototype.gt
         =
         NativeBigInt.prototype.greater
         =
         SmallInteger.prototype.gt
         =
         SmallInteger.prototype.greater
         =
         BigInteger.prototype.gt
         =
         BigInteger.prototype.greater;
         BigInteger.prototype.lesser
         =
         function(v){return this.compare(v) < 0};
         NativeBigInt.prototype.lt
         =
         NativeBigInt.prototype.lesser
         =
         SmallInteger.prototype.lt
         =
         SmallInteger.prototype.lesser
         =
         BigInteger.prototype.lt
         =
         BigInteger.prototype.lesser;
         BigInteger.prototype.greaterOrEquals
         =
         function(v){return this.compare(v) >= 0};
         NativeBigInt.prototype.geq
         =
         NativeBigInt.prototype.greaterOrEquals
         =
         SmallInteger.prototype.geq
         =
         SmallInteger.prototype.greaterOrEquals
         =
         BigInteger.prototype.geq
         =
         BigInteger.prototype.greaterOrEquals;
         BigInteger.prototype.lesserOrEquals
         =
         function(v){return this.compare(v) <= 0};
         NativeBigInt.prototype.leq
         =
         NativeBigInt.prototype.lesserOrEquals
         =
         SmallInteger.prototype.leq
         =
         SmallInteger.prototype.lesserOrEquals
         =
         BigInteger.prototype.leq
         =
         BigInteger.prototype.lesserOrEquals;
         BigInteger.prototype.isEven
         =
         function(){return (this.value[0] & 1) === 0};
         SmallInteger.prototype.isEven
         =
         function(){return (this.value & 1) === 0};
         NativeBigInt.prototype.isEven
         =
         function(){return (this.value & BigInt(1)) === BigInt(0)};
         BigInteger.prototype.isOdd
         =
         function(){return (this.value[0] & 1) === 1};
         SmallInteger.prototype.isOdd
         =
         function(){return (this.value & 1) === 1};
         NativeBigInt.prototype.isOdd
         =
         function(){return (this.value & BigInt(1)) === BigInt(1)};
         BigInteger.prototype.isPositive = function(){return ! this.sign};
         SmallInteger.prototype.isPositive
         =
         function(){return this.value > 0};
         NativeBigInt.prototype.isPositive
         =
         SmallInteger.prototype.isPositive;
         BigInteger.prototype.isNegative = function(){return this.sign};
         SmallInteger.prototype.isNegative
         =
         function(){return this.value < 0};
         NativeBigInt.prototype.isNegative
         =
         SmallInteger.prototype.isNegative;
         BigInteger.prototype.isUnit = function(){return false};
         SmallInteger.prototype.isUnit
         =
         function(){return Math.abs(this.value) === 1};
         NativeBigInt.prototype.isUnit
         =
         function(){return this.abs().value === BigInt(1)};
         BigInteger.prototype.isZero = function(){return false};
         SmallInteger.prototype.isZero = function(){return this.value === 0};
         NativeBigInt.prototype.isZero
         =
         function(){return this.value === BigInt(0)};
         BigInteger.prototype.isDivisibleBy
         =
         function(v)
          {var n=parseValue(v);
           if(n.isZero())return false;
           if(n.isUnit())return true;
           if(n.compareAbs(2) === 0)return this.isEven();
           return this.mod(n).isZero()};
         NativeBigInt.prototype.isDivisibleBy
         =
         SmallInteger.prototype.isDivisibleBy
         =
         BigInteger.prototype.isDivisibleBy;
         function isBasicPrime(v)
          {var n=v.abs();
           if(n.isUnit())return false;
           if(n.equals(2) || n.equals(3) || n.equals(5))return true;
           if(n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5))
            return false;
           if(n.lesser(49))return true}
         function millerRabinTest(n,a)
          {var nPrev=n.prev(),b=nPrev,r=0,d,t,i,x;
           while(b.isEven())b = b.divide(2),r++;
           next:
           for(i = 0;i < a.length;i++)
            {if(n.lesser(a[i]))continue;
             x = bigInt(a[i]).modPow(b,n);
             if(x.isUnit() || x.equals(nPrev))continue;
             for(d = r - 1;d != 0;d--)
              {x = x.square().mod(n);
               if(x.isUnit())return false;
               if(x.equals(nPrev))continue next}
             return false}
           return true}
         BigInteger.prototype.isPrime
         =
         function(strict)
          {var isPrime=isBasicPrime(this);
           if(isPrime !== undefined)return isPrime;
           var n=this.abs(),bits=n.bitLength();
           if(bits <= 64)
            return millerRabinTest(n,[2,3,5,7,11,13,17,19,23,29,31,37]);
           var
            logN=Math.log(2) * bits.toJSNumber(),
            t=Math.ceil(strict === true?2 * Math.pow(logN,2):logN);
           for(var a=[],i=0;i < t;i++)a.push(bigInt(i + 2));
           return millerRabinTest(n,a)};
         NativeBigInt.prototype.isPrime
         =
         SmallInteger.prototype.isPrime
         =
         BigInteger.prototype.isPrime;
         BigInteger.prototype.isProbablePrime
         =
         function(iterations)
          {var isPrime=isBasicPrime(this);
           if(isPrime !== undefined)return isPrime;
           var n=this.abs(),t=iterations === undefined?5:iterations;
           for(var a=[],i=0;i < t;i++)
            a.push(bigInt.randBetween(2,n.minus(2)));
           return millerRabinTest(n,a)};
         NativeBigInt.prototype.isProbablePrime
         =
         SmallInteger.prototype.isProbablePrime
         =
         BigInteger.prototype.isProbablePrime;
         BigInteger.prototype.modInv
         =
         function(n)
          {var
            t=bigInt.zero,
            newT=bigInt.one,
            r=parseValue(n),
            newR=this.abs(),
            q,
            lastT,
            lastR;
           while(! newR.isZero())
            {q = r.divide(newR);
             lastT = t;
             lastR = r;
             t = newT;
             r = newR;
             newT = lastT.subtract(q.multiply(newT));
             newR = lastR.subtract(q.multiply(newR))}
           if(! r.isUnit())
            throw new
                   Error
                   (this.toString()
                    +
                    " and "
                    +
                    n.toString()
                    +
                    " are not co-prime");
           if(t.compare(0) === - 1)t = t.add(n);
           if(this.isNegative())return t.negate();
           return t};
         NativeBigInt.prototype.modInv
         =
         SmallInteger.prototype.modInv
         =
         BigInteger.prototype.modInv;
         BigInteger.prototype.next
         =
         function()
          {var value=this.value;
           if(this.sign)return subtractSmall(value,1,this.sign);
           return new BigInteger(addSmall(value,1),this.sign)};
         SmallInteger.prototype.next
         =
         function()
          {var value=this.value;
           if(value + 1 < MAX_INT)return new SmallInteger(value + 1);
           return new BigInteger(MAX_INT_ARR,false)};
         NativeBigInt.prototype.next
         =
         function(){return new NativeBigInt(this.value + BigInt(1))};
         BigInteger.prototype.prev
         =
         function()
          {var value=this.value;
           if(this.sign)return new BigInteger(addSmall(value,1),true);
           return subtractSmall(value,1,this.sign)};
         SmallInteger.prototype.prev
         =
         function()
          {var value=this.value;
           if(value - 1 > - MAX_INT)return new SmallInteger(value - 1);
           return new BigInteger(MAX_INT_ARR,true)};
         NativeBigInt.prototype.prev
         =
         function(){return new NativeBigInt(this.value - BigInt(1))};
         var powersOfTwo=[1];
         while(2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)
          powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
         var
          powers2Length=powersOfTwo.length,
          highestPower2=powersOfTwo[powers2Length - 1];
         function shift_isSmall(n){return Math.abs(n) <= BASE}
         BigInteger.prototype.shiftLeft
         =
         function(v)
          {var n=parseValue(v).toJSNumber();
           if(! shift_isSmall(n))
            throw new Error(String(n) + " is too large for shifting.");
           if(n < 0)return this.shiftRight(- n);
           var result=this;
           if(result.isZero())return result;
           while(n >= powers2Length)
            {result = result.multiply(highestPower2);n -= powers2Length - 1}
           return result.multiply(powersOfTwo[n])};
         NativeBigInt.prototype.shiftLeft
         =
         SmallInteger.prototype.shiftLeft
         =
         BigInteger.prototype.shiftLeft;
         BigInteger.prototype.shiftRight
         =
         function(v)
          {var remQuo,n=parseValue(v).toJSNumber();
           if(! shift_isSmall(n))
            throw new Error(String(n) + " is too large for shifting.");
           if(n < 0)return this.shiftLeft(- n);
           var result=this;
           while(n >= powers2Length)
            {if(result.isZero() || result.isNegative() && result.isUnit())
              return result;
             remQuo = divModAny(result,highestPower2);
             result = remQuo[1].isNegative()?remQuo[0].prev():remQuo[0];
             n -= powers2Length - 1}
           remQuo = divModAny(result,powersOfTwo[n]);
           return remQuo[1].isNegative()?remQuo[0].prev():remQuo[0]};
         NativeBigInt.prototype.shiftRight
         =
         SmallInteger.prototype.shiftRight
         =
         BigInteger.prototype.shiftRight;
         function bitwise(x,y,fn)
          {y = parseValue(y);
           var
            xSign=x.isNegative(),
            ySign=y.isNegative(),
            xRem=xSign?x.not():x,
            yRem=ySign?y.not():y,
            xDigit=0,
            yDigit=0,
            xDivMod=null,
            yDivMod=null,
            result=[];
           while(! xRem.isZero() || ! yRem.isZero())
            {xDivMod = divModAny(xRem,highestPower2);
             xDigit = xDivMod[1].toJSNumber();
             if(xSign)xDigit = highestPower2 - 1 - xDigit;
             yDivMod = divModAny(yRem,highestPower2);
             yDigit = yDivMod[1].toJSNumber();
             if(ySign)yDigit = highestPower2 - 1 - yDigit;
             xRem = xDivMod[0];
             yRem = yDivMod[0];
             result.push(fn(xDigit,yDigit))}
           var sum=fn(xSign?1:0,ySign?1:0) !== 0?bigInt(- 1):bigInt(0);
           for(var i=result.length - 1;i >= 0;i -= 1)
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
           return sum}
         BigInteger.prototype.not = function(){return this.negate().prev()};
         NativeBigInt.prototype.not
         =
         SmallInteger.prototype.not
         =
         BigInteger.prototype.not;
         BigInteger.prototype.and
         =
         function(n){return bitwise(this,n,function(a,b){return a & b})};
         NativeBigInt.prototype.and
         =
         SmallInteger.prototype.and
         =
         BigInteger.prototype.and;
         BigInteger.prototype.or
         =
         function(n){return bitwise(this,n,function(a,b){return a | b})};
         NativeBigInt.prototype.or
         =
         SmallInteger.prototype.or
         =
         BigInteger.prototype.or;
         BigInteger.prototype.xor
         =
         function(n){return bitwise(this,n,function(a,b){return a ^ b})};
         NativeBigInt.prototype.xor
         =
         SmallInteger.prototype.xor
         =
         BigInteger.prototype.xor;
         var
          LOBMASK_I=1 << 30,
          LOBMASK_BI=(BASE & - BASE) * (BASE & - BASE) | LOBMASK_I;
         function roughLOB(n)
          {var
            v=n.value,
            x=
             typeof v === "number"
              ?v | LOBMASK_I
              :typeof v === "bigint"
                ?v | BigInt(LOBMASK_I)
                :v[0] + v[1] * BASE | LOBMASK_BI;
           return x & - x}
         function integerLogarithm(value,base)
          {if(base.compareTo(value) <= 0)
            {var
              tmp=integerLogarithm(value,base.square(base)),
              p=tmp.p,
              e=tmp.e,
              t=p.multiply(base);
             return t.compareTo(value) <= 0?{p:t,e:e * 2 + 1}:{p:p,e:e * 2}}
           return {p:bigInt(1),e:0}}
         BigInteger.prototype.bitLength
         =
         function()
          {var n=this;
           if(n.compareTo(bigInt(0)) < 0)n = n.negate().subtract(bigInt(1));
           if(n.compareTo(bigInt(0)) === 0)return bigInt(0);
           return bigInt(integerLogarithm(n,bigInt(2)).e).add(bigInt(1))};
         NativeBigInt.prototype.bitLength
         =
         SmallInteger.prototype.bitLength
         =
         BigInteger.prototype.bitLength;
         function max(a,b)
          {a = parseValue(a);b = parseValue(b);return a.greater(b)?a:b}
         function min(a,b)
          {a = parseValue(a);b = parseValue(b);return a.lesser(b)?a:b}
         function gcd(a,b)
          {a = parseValue(a).abs();
           b = parseValue(b).abs();
           if(a.equals(b))return a;
           if(a.isZero())return b;
           if(b.isZero())return a;
           var c=Integer[1],d,t;
           while(a.isEven() && b.isEven())
            {d = min(roughLOB(a),roughLOB(b));
             a = a.divide(d);
             b = b.divide(d);
             c = c.multiply(d)}
           while(a.isEven())a = a.divide(roughLOB(a));
           do
            {while(b.isEven())b = b.divide(roughLOB(b));
             if(a.greater(b)){t = b;b = a;a = t}
             b = b.subtract(a)}
           while
            (! b.isZero());
           return c.isUnit()?a:a.multiply(c)}
         function lcm(a,b)
          {a = parseValue(a).abs();
           b = parseValue(b).abs();
           return a.divide(gcd(a,b)).multiply(b)}
         function randBetween(a,b)
          {a = parseValue(a);
           b = parseValue(b);
           var low=min(a,b),high=max(a,b),range=high.subtract(low).add(1);
           if(range.isSmall)return low.add(Math.floor(Math.random() * range));
           var digits=toBase(range,BASE).value,result=[],restricted=true;
           for(var i=0;i < digits.length;i++)
            {var
              top=restricted?digits[i]:BASE,
              digit=truncate(Math.random() * top);
             result.push(digit);
             if(digit < top)restricted = false}
           return low.add(Integer.fromArray(result,BASE,false))}
         function parseBase(text,base,alphabet,caseSensitive)
          {alphabet = alphabet || DEFAULT_ALPHABET;
           text = String(text);
           if(! caseSensitive)
            {text = text.toLowerCase();alphabet = alphabet.toLowerCase()}
           var length=text.length,i,absBase=Math.abs(base),alphabetValues={};
           for(i = 0;i < alphabet.length;i++)alphabetValues[alphabet[i]] = i;
           for(i = 0;i < length;i++)
            {var c=text[i];
             if(c === "-")continue;
             if(c in alphabetValues)
              if(alphabetValues[c] >= absBase)
               {if(c === "1" && absBase === 1)continue;
                throw new
                       Error
                       (c + " is not a valid digit in base " + base + ".")}}
           base = parseValue(base);
           var digits=[],isNegative=text[0] === "-";
           for(i = isNegative?1:0;i < text.length;i++)
            {var c=text[i];
             if(c in alphabetValues)
              digits.push(parseValue(alphabetValues[c]));
             else
              if(c === "<")
               {var start=i;
                do i++;while(text[i] !== ">" && i < text.length);
                digits.push(parseValue(text.slice(start + 1,i)))}
              else
               throw new Error(c + " is not a valid character")}
           return parseBaseFromArray(digits,base,isNegative)}
         function parseBaseFromArray(digits,base,isNegative)
          {var val=Integer[0],pow=Integer[1],i;
           for(i = digits.length - 1;i >= 0;i--)
            {val = val.add(digits[i].times(pow));pow = pow.times(base)}
           return isNegative?val.negate():val}
         function stringify(digit,alphabet)
          {alphabet = alphabet || DEFAULT_ALPHABET;
           if(digit < alphabet.length)return alphabet[digit];
           return "<" + digit + ">"}
         function toBase(n,base)
          {base = bigInt(base);
           if(base.isZero())
            {if(n.isZero())return {value:[0],isNegative:false};
             throw new Error("Cannot convert nonzero numbers to base 0.")}
           if(base.equals(- 1))
            {if(n.isZero())return {value:[0],isNegative:false};
             if(n.isNegative())
              return {value:
                      [].concat.apply
                       ([],
                        Array.apply(null,Array(- n.toJSNumber())).map
                         (Array.prototype.valueOf,[1,0])),
                      isNegative:false};
             var
              arr=
               Array.apply(null,Array(n.toJSNumber() - 1)).map
                (Array.prototype.valueOf,[0,1]);
             arr.unshift([1]);
             return {value:[].concat.apply([],arr),isNegative:false}}
           var neg=false;
           if(n.isNegative() && base.isPositive()){neg = true;n = n.abs()}
           if(base.isUnit())
            {if(n.isZero())return {value:[0],isNegative:false};
             return {value:
                     Array.apply(null,Array(n.toJSNumber())).map
                      (Number.prototype.valueOf,1),
                     isNegative:neg}}
           var out=[],left=n,divmod;
           while(left.isNegative() || left.compareAbs(base) >= 0)
            {divmod = left.divmod(base);
             left = divmod.quotient;
             var digit=divmod.remainder;
             if(digit.isNegative())
              {digit = base.minus(digit).abs();left = left.next()}
             out.push(digit.toJSNumber())}
           out.push(left.toJSNumber());
           return {value:out.reverse(),isNegative:neg}}
         function toBaseString(n,base,alphabet)
          {var arr=toBase(n,base);
           return (arr.isNegative?"-":"")
                  +
                  arr.value.map(function(x){return stringify(x,alphabet)}).join
                   ("")}
         BigInteger.prototype.toArray
         =
         function(radix){return toBase(this,radix)};
         SmallInteger.prototype.toArray
         =
         function(radix){return toBase(this,radix)};
         NativeBigInt.prototype.toArray
         =
         function(radix){return toBase(this,radix)};
         BigInteger.prototype.toString
         =
         function(radix,alphabet)
          {if(radix === undefined)radix = 10;
           if(radix !== 10)return toBaseString(this,radix,alphabet);
           var
            v=this.value,
            l=v.length,
            str=String(v[--l]),
            zeros="0000000",
            digit;
           while(--l >= 0)
            {digit = String(v[l]);str += zeros.slice(digit.length) + digit}
           var sign=this.sign?"-":"";
           return sign + str};
         SmallInteger.prototype.toString
         =
         function(radix,alphabet)
          {if(radix === undefined)radix = 10;
           if(radix != 10)return toBaseString(this,radix,alphabet);
           return String(this.value)};
         NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
         NativeBigInt.prototype.toJSON
         =
         BigInteger.prototype.toJSON
         =
         SmallInteger.prototype.toJSON
         =
         function(){return this.toString()};
         BigInteger.prototype.valueOf
         =
         function(){return parseInt(this.toString(),10)};
         BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
         SmallInteger.prototype.valueOf = function(){return this.value};
         SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
         NativeBigInt.prototype.valueOf
         =
         NativeBigInt.prototype.toJSNumber
         =
         function(){return parseInt(this.toString(),10)};
         function parseStringValue(v)
          {if(isPrecise(+ v))
            {var x=+ v;
             if(x === truncate(x))
              return supportsNativeBigInt
                      ?new NativeBigInt(BigInt(x))
                      :new SmallInteger(x);
             throw new Error("Invalid integer: " + v)}
           var sign=v[0] === "-";
           if(sign)v = v.slice(1);
           var split=v.split(/e/i);
           if(split.length > 2)
            throw new Error("Invalid integer: " + split.join("e"));
           if(split.length === 2)
            {var exp=split[1];
             if(exp[0] === "+")exp = exp.slice(1);
             exp = + exp;
             if(exp !== truncate(exp) || ! isPrecise(exp))
              throw new
                     Error
                     ("Invalid integer: " + exp + " is not a valid exponent.");
             var text=split[0],decimalPlace=text.indexOf(".");
             if(decimalPlace >= 0)
              {exp -= text.length - decimalPlace - 1;
               text
               =
               text.slice(0,decimalPlace)
               +
               text.slice(decimalPlace + 1)}
             if(exp < 0)
              throw new
                     Error
                     ("Cannot include negative exponent part for integers");
             text += new Array(exp + 1).join("0");
             v = text}
           var isValid=/^([0-9][0-9]*)$/.test(v);
           if(! isValid)throw new Error("Invalid integer: " + v);
           if(supportsNativeBigInt)
            return new NativeBigInt(BigInt(sign?"-" + v:v));
           var r=[],max=v.length,l=LOG_BASE,min=max - l;
           while(max > 0)
            {r.push(+ v.slice(min,max));min -= l;if(min < 0)min = 0;max -= l}
           trim(r);
           return new BigInteger(r,sign)}
         function parseNumberValue(v)
          {if(supportsNativeBigInt)return new NativeBigInt(BigInt(v));
           if(isPrecise(v))
            {if(v !== truncate(v))throw new Error(v + " is not an integer.");
             return new SmallInteger(v)}
           return parseStringValue(v.toString())}
         function parseValue(v)
          {if(typeof v === "number")return parseNumberValue(v);
           if(typeof v === "string")return parseStringValue(v);
           if(typeof v === "bigint")return new NativeBigInt(v);
           return v}
         for(var i=0;i < 1000;i++)
          {Integer[i] = parseValue(i);if(i > 0)Integer[- i] = parseValue(- i)}
         Integer.one = Integer[1];
         Integer.zero = Integer[0];
         Integer.minusOne = Integer[- 1];
         Integer.max = max;
         Integer.min = min;
         Integer.gcd = gcd;
         Integer.lcm = lcm;
         Integer.isInstance
         =
         function(x)
          {return x instanceof BigInteger
                  ||
                  x instanceof SmallInteger
                  ||
                  x instanceof NativeBigInt};
         Integer.randBetween = randBetween;
         Integer.fromArray
         =
         function(digits,base,isNegative)
          {return parseBaseFromArray
                   (digits.map(parseValue),parseValue(base || 10),isNegative)};
         return Integer}
       ();
    function ml_z_normalize(x)
     {var y=x.toJSNumber() | 0;if(x.equals(bigInt(y)))return y;return x}
    function ml_z_shift_right(z1,amt)
     {return ml_z_normalize(bigInt(z1).shiftRight(amt))}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function integers_uint32_compare(x,y)
     {if(x.value > y.value)return 1;if(x.value < y.value)return - 1;return 0}
    function caml_pasta_fp_copy(x,y)
     {for(var i=0,l=x.length;i < l;i++)x[i] = y[i]}
    var caml_pasta_fp_square=plonk_wasm.caml_pasta_fp_square;
    function caml_pasta_fp_mut_square(x)
     {caml_pasta_fp_copy(x,caml_pasta_fp_square(x))}
    function caml_sys_const_naked_pointers_checked(_unit){return 0}
    function caml_obj_add_offset(v,offset)
     {caml_failwith("Obj.add_offset is not supported")}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_pasta_fq_plonk_verifier_index_read(offset,urs,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      return caml_pasta_fq_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_read
                (offset,urs,caml_jsstring_of_string(path)))}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_pasta_fp_plonk_verifier_index_to_rust(x)
     {return caml_plonk_verifier_index_to_rust
              (x,
               plonk_wasm.WasmFpPlonkVerifierIndex,
               plonk_wasm.WasmFpDomain,
               plonk_wasm.WasmFpPlonkVerificationEvals,
               plonk_wasm.WasmFpPolyComm,
               plonk_wasm.caml_vesta_affine_one,
               plonk_wasm.WasmFpShifts)}
    function caml_pasta_fp_plonk_proof_verify(index,proof)
     {index = caml_pasta_fp_plonk_verifier_index_to_rust(index);
      proof = caml_pasta_fp_proof_to_rust(proof);
      return plonk_wasm.caml_pasta_fp_plonk_proof_verify(index,proof)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function ml_z_shift_left(z1,amt)
     {return ml_z_normalize(bigInt(z1).shiftLeft(amt))}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function unix_getuid(unit)
     {if(globalThis.process && globalThis.process.getuid)
       return globalThis.process.getuid();
      caml_raise_not_found()}
    function caml_js_to_bool(x){return + x}
    function caml_pasta_fq_is_square(x)
     {return caml_js_to_bool(plonk_wasm.caml_pasta_fq_is_square(x))}
    function caml_ml_debug_info_status(){return 0}
    function caml_option_of_maybe_undefined(x){return x === undefined?0:[0,x]}
    function caml_random_oracles_of_rust(x)
     {var
       joint_combiner_chal=x.joint_combiner_chal,
       joint_combiner=x.joint_combiner,
       joint_combiner_ocaml=undefined;
      if(joint_combiner_chal !== undefined && joint_combiner !== undefined)
       joint_combiner_ocaml = [0,[0,joint_combiner_chal],joint_combiner];
      return [0,
              caml_option_of_maybe_undefined(joint_combiner_ocaml),
              x.beta,
              x.gamma,
              [0,x.alpha_chal],
              x.alpha,
              x.zeta,
              x.v,
              x.u,
              [0,x.zeta_chal],
              [0,x.v_chal],
              [0,x.u_chal]]}
    function caml_oracles_of_rust(x)
     {return [0,
              caml_random_oracles_of_rust(x.o),
              [0,x.p_eval0,x.p_eval1],
              caml_u8array_vector_of_rust_flat_vector
               (x.opening_prechallenges,32),
              x.digest_before_evaluations]}
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_plonk_wire_to_rust(wire)
     {return plonk_wasm.Wire.create(wire[1],wire[2])}
    function caml_plonk_wires_to_rust(wires)
     {return new
              (plonk_wasm.WasmGateWires)
              (caml_plonk_wire_to_rust(wires[1]),
               caml_plonk_wire_to_rust(wires[2]),
               caml_plonk_wire_to_rust(wires[3]),
               caml_plonk_wire_to_rust(wires[4]),
               caml_plonk_wire_to_rust(wires[5]),
               caml_plonk_wire_to_rust(wires[6]),
               caml_plonk_wire_to_rust(wires[7]))}
    function caml_fp_plonk_gate_to_rust(gate)
     {return new
              (plonk_wasm.WasmFpGate)
              (gate[1],
               caml_plonk_wires_to_rust(gate[2]),
               caml_u8array_vector_to_rust_flat_vector(gate[3]))}
    function caml_pasta_fp_plonk_gate_vector_add(v,x)
     {return plonk_wasm.caml_pasta_fp_plonk_gate_vector_add
              (v,caml_fp_plonk_gate_to_rust(x))}
    function core_kernel_gc_minor_words(){return 0}
    var
     caml_argv=
      function()
        {var g=globalThis,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_fp_vector_get(v,i)
     {var value=v[i + 1];
      if(value === undefined)
       throw Error
              ("caml_fp_vector_get: Index out of bounds, got "
               +
               i
               +
               "/"
               +
               (v.length - 1));
      return new (joo_global_object.Uint8Array)(value)}
    function integers_uint32_to_int(i){return i.value | 0}
    function caml_ml_set_buffered(c,v){return 0}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_ml_bytes_content(s)
     {switch(s.t & 6)
       {default:caml_convert_string_to_bytes(s);case 0:return s.c;
        case 4:return s.c
        }}
    function caml_hash_mix_bytes(h,v)
     {var content=caml_ml_bytes_content(v);
      return typeof content === "string"
              ?caml_hash_mix_jsbytes(h,content)
              :caml_hash_mix_bytes_arr(h,content)}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function Base_hash_string(s){return caml_hash(1,1,0,s)}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=globalThis;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=globalThis;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var refill=null;
      if(fd == 0 && fs_node_supported())
       {var fs=require("fs");
        refill
        =
        function(){return caml_string_of_jsstring(fs.readFileSync(0,"utf8"))}}
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:refill};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_string_of_bytes(s){return s}
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[],content=caml_ml_bytes_content(s);
           if(typeof content === "string")
            {var b=content;
             for(var i=0;i < len;i += 4)
              {var j=i + ofs;
               buf[i >> 2]
               =
               b.charCodeAt(j)
               |
               b.charCodeAt(j + 1)
               <<
               8
               |
               b.charCodeAt(j + 2)
               <<
               16
               |
               b.charCodeAt(j + 3)
               <<
               24}
             for(;i < len;i++)
              buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3)}
           else
            {var a=content;
             for(var i=0;i < len;i += 4)
              {var j=i + ofs;
               buf[i >> 2]
               =
               a[j]
               |
               a[j + 1]
               <<
               8
               |
               a[j + 2]
               <<
               16
               |
               a[j + 3]
               <<
               24}
             for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)}
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function core_md5_fd(fd)
     {var ic=caml_ml_open_descriptor_in(fd);
      try {return caml_md5_chan(ic,- 1)}finally {caml_ml_close_channel(ic)}}
    var caml_ephe_key_offset=3;
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function jsoo_z_of_js_string_base(base,s)
     {if(base == 0)
       {base = 10;
        var p=0,sign=1;
        if(s[p] == "-"){sign = - 1;p++}else if(s[p] == "+")p++;
        if(s[p] == "0")
         {p++;
          if(s.length == p)
           return 0;
          else
           {var bc=s[p];
            if(bc == "o" || bc == "O")
             base = 8;
            else
             if(bc == "x" || bc == "X")
              base = 16;
             else
              if(bc == "b" || bc == "B")base = 2;
            if(base != 10){s = s.substring(p + 1);if(sign == - 1)s = "-" + s}}}}
      if(s[0] == "+")s = s.substring(1);
      s = s.replace(/^0+/,"");
      if(s == "-" || s == "")s = "0";
      function digit(code)
       {if(code >= 48 && code <= 57)return code - 48;
        if(code >= 97 && code <= 102)return code - 97 + 10;
        if(code >= 65 && code <= 70)return code - 65 + 10}
      var i=0;
      if(s[i] == "-")i++;
      for(;i < s.length;i++)
       {var c=digit(s.charCodeAt(i));
        if(c == undefined || c >= base)
         caml_invalid_argument("Z.of_substring_base: invalid digit")}
      return ml_z_normalize(bigInt(s,base))}
    function ml_z_of_substring_base(base,s,pos,len)
     {s = caml_jsbytes_of_string(s);
      if(pos != 0 || len != s.length)
       {if(s.length - pos < len)
         caml_invalid_argument
          ("Z.of_substring_base: invalid offset or length");
        s = s.slice(pos,pos + len)}
      return jsoo_z_of_js_string_base(base,s)}
    function caml_bytes_to_uint8array(ocaml_bytes)
     {var
       length=caml_ml_bytes_length(ocaml_bytes),
       bytes=new (joo_global_object.Uint8Array)(length);
      for(var i=0;i < length;i++)
       bytes[i] = caml_bytes_unsafe_get(ocaml_bytes,i);
      return bytes}
    function caml_pasta_fq_of_bytes(ocaml_bytes)
     {return plonk_wasm.caml_pasta_fq_of_bytes
              (caml_bytes_to_uint8array(ocaml_bytes))}
    var
     caml_pasta_fp_plonk_index_domain_d8_size=
      plonk_wasm.caml_pasta_fp_plonk_index_domain_d8_size;
    function win_cleanup(){}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (globalThis.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function unix_inet_addr_of_string(){return 0}
    var
     caml_pasta_fq_plonk_index_domain_d1_size=
      plonk_wasm.caml_pasta_fq_plonk_index_domain_d1_size;
    function ml_z_gcdext_intern(z1,z2)
     {z1 = bigInt(z1);
      z2 = bigInt(z2);
      var
       gcd=bigInt.gcd(z1,z2),
       a=z1,
       b=z2,
       x=bigInt(0),
       lastx=bigInt(1),
       y=bigInt(1),
       lasty=bigInt(1),
       q,
       t,
       r;
      if(z1.equals(bigInt(0)))caml_raise_zero_divide();
      while(! b.equals(bigInt(0)))
       {q = a.divide(b);
        r = a.subtract(q.multiply(b));
        t = x;
        x = lastx.subtract(q.multiply(x));
        lastx = t;
        t = y;
        y = lasty.subtract(q.multiply(y));
        lasty = t;
        a = b;
        b = r}
      return a.lt(bigInt(0))
              ?[0,ml_z_normalize(a.negate()),ml_z_normalize(lastx.negate()),1]
              :[0,ml_z_normalize(a),ml_z_normalize(lastx),1]}
    function integers_uint8_deserialize(reader,size)
     {size[0] = 1;return reader.read8u()}
    function caml_gc_huge_fallback_count(unit){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function integers_uint32_max(unit){return new UInt32(0xFFFFFFFF)}
    function ml_z_abs(z1){return ml_z_normalize(bigInt(z1).abs())}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    var
     Base_internalhash_fold_float=caml_hash_mix_float,
     os_type=
      globalThis.process
       &&
       globalThis.process.platform
       &&
       globalThis.process.platform
       ==
       "win32"
       ?"Cygwin"
       :"Unix";
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_int64_or(x,y){return x.or(y)}
    function integers_uint64_logor(x,y)
     {return new UInt64(caml_int64_or(x.value,y.value))}
    function bigstring_destroy_stub(v_bstr)
     {if(v_bstr.hasOwnProperty("__is_deallocated"))
       caml_invalid_argument
        ("bigstring_destroy: bigstring is already deallocated");
      v_bstr.__is_deallocated = true;
      v_bstr.data = new (v_bstr.data.__proto__.constructor)(0);
      v_bstr.dims = [0];
      return 0}
    function bigstring_realloc(bigstring,size)
     {if(bigstring.hasOwnProperty("__is_deallocated"))
       caml_invalid_argument
        ("bigstring_realloc: bigstring is already deallocated");
      var new_data=new (bigstring.data.__proto__.constructor)(size);
      new_data.set(bigstring.data.slice(0,size));
      var
       new_bigstring=
        caml_ba_create_unsafe(bigstring.kind,bigstring.layout,[size],new_data);
      bigstring_destroy_stub(bigstring);
      return new_bigstring}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function integers_uint32_of_int32(i){return new UInt32(i)}
    function caml_fp_srs_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_fp_srs_write
              (append,t,caml_jsstring_of_string(path))}
    function ml_z_rem(z1,z2)
     {z2 = bigInt(z2);
      if(z2.equals(bigInt(0)))caml_raise_zero_divide();
      return ml_z_normalize(bigInt(z1).mod(z2))}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function deferred_is_determined(deferred){return deferred.isDetermined}
    function caml_vesta_of_affine(pt)
     {var
       res=
        plonk_wasm.caml_vesta_of_affine
         (rust_affine_of_caml_affine(pt,plonk_wasm.caml_vesta_affine_one));
      free_on_finalize(res);
      return res}
    function integers_uint64_div(x,y)
     {if(y.value.isZero())caml_raise_zero_divide();
      x.value.hi = x.value.hi >>> 0;
      y.value.hi = y.value.hi >>> 0;
      return new UInt64(x.value.udivmod(y.value).quotient)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_pallas_poly_comm_to_rust(x)
     {return caml_poly_comm_to_rust_poly_comm
              (x,plonk_wasm.WasmFqPolyComm,plonk_wasm.caml_pallas_affine_one)}
    function caml_pasta_fq_commitments_to_rust(x)
     {function convertArray(v)
       {var n=v.length - 1,res=new Array(n);
        for(var i=0;i < n;++i)
         res[i] = caml_pallas_poly_comm_to_rust(v[i + 1]);
        return js_class_vector_to_rust_vector(res)}
      var
       w_comm=convertArray(x[1]),
       z_comm=caml_pallas_poly_comm_to_rust(x[2]),
       t_comm=caml_pallas_poly_comm_to_rust(x[3]);
      return new (plonk_wasm.WasmFqProverCommitments)(w_comm,z_comm,t_comm)}
    function caml_pasta_fq_opening_proof_to_rust(x)
     {function convert_affines(affines)
       {return caml_array_to_rust_vector
                (affines,
                 rust_affine_of_caml_affine,
                 plonk_wasm.caml_pallas_affine_one)}
      var
       lr=x[1],
       delta=
        rust_affine_of_caml_affine(x[2],plonk_wasm.caml_pallas_affine_one),
       z1=x[3],
       z2=x[4],
       sg=rust_affine_of_caml_affine(x[5],plonk_wasm.caml_pallas_affine_one),
       len=lr.length,
       l_ocaml=new Array(len),
       r_ocaml=new Array(len);
      for(var i=1;i < len;i++){l_ocaml[i] = lr[i][1];r_ocaml[i] = lr[i][2]}
      var l=convert_affines(l_ocaml),r=convert_affines(r_ocaml);
      return new (plonk_wasm.WasmFqOpeningProof)(l,r,delta,z1,z2,sg)}
    function caml_fq_vector_to_rust(v)
     {return caml_u8array_vector_to_rust_flat_vector(v)}
    function caml_pasta_fq_proof_evaluations_to_rust(x){return x}
    function caml_pasta_fq_proof_to_rust(x)
     {var
       messages=caml_pasta_fq_commitments_to_rust(x[1]),
       proof=caml_pasta_fq_opening_proof_to_rust(x[2]),
       evals=caml_pasta_fq_proof_evaluations_to_rust(x[3]),
       ft_eval1=x[4],
       public_=caml_fq_vector_to_rust(x[5]),
       prev_challenges=x[6],
       chals_len=prev_challenges.length,
       prev_challenges_scalars=new (plonk_wasm.WasmVecVecFq)(chals_len - 1),
       prev_challenges_comms=new Array(chals_len - 1);
      for(var i=1;i < chals_len;i++)
       {prev_challenges_scalars.push
         (caml_fq_vector_to_rust(prev_challenges[i][1]));
        prev_challenges_comms[i - 1]
        =
        caml_pallas_poly_comm_to_rust(prev_challenges[i][2])}
      prev_challenges_comms
      =
      js_class_vector_to_rust_vector(prev_challenges_comms);
      return new
              (plonk_wasm.WasmFqProverProof)
              (messages,
               proof,
               evals,
               ft_eval1,
               public_,
               prev_challenges_scalars,
               prev_challenges_comms)}
    function caml_pasta_fq_plonk_proof_verify(index,proof)
     {index = caml_pasta_fq_plonk_verifier_index_to_rust(index);
      proof = caml_pasta_fq_proof_to_rust(proof);
      return plonk_wasm.caml_pasta_fq_plonk_proof_verify(index,proof)}
    function integers_uint32_logxor(x,y){return new UInt32(x.value ^ y.value)}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function deferred_create(promise_creator)
     {var
       deferred=
        {promise:
         new Promise(function(resolve){promise_creator(resolve)}).then
           (function(value)
             {deferred.value = value;deferred.isDetermined = true}).catch
          (function(err)
            {deferred.error = err;
             deferred.isError = true;
             deferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return deferred}
    function ml_z_mul_overflows(x,y){var z=x * y;return z != (z | 0)}
    function Base_am_testing(x){return 0}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    var
     caml_pasta_fp_plonk_index_public_inputs=
      plonk_wasm.caml_pasta_fp_plonk_index_public_inputs;
    function caml_obj_reachable_words(o){return 0}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_pallas_affine_deep_copy(pt)
     {return rust_affine_to_caml_affine
              (plonk_wasm.caml_pallas_affine_deep_copy
                (rust_affine_of_caml_affine
                  (pt,plonk_wasm.caml_pallas_affine_one)))}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_bigint_256_to_string(x)
     {return caml_string_of_jsstring(plonk_wasm.caml_bigint_256_to_string(x))}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            globalThis.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {caml_raise_sys_error(name + ": Not a directory")}
    function caml_pasta_fp_plonk_proof_example_with_range_check0()
     {throw new
             Error
             ("Unimplemented caml_pasta_fp_plonk_proof_example_with_range_check0")}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)?1:0}
      else
       return 0}
    function MlNat(x)
     {this.data = new (globalThis.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_vesta_to_affine(pt)
     {var res=plonk_wasm.caml_vesta_to_affine(pt);
      return rust_affine_to_caml_affine(res)}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function bigstring_memcmp_stub(v_s1,v_s1_pos,v_s2,v_s2_pos,v_len)
     {for(var i=0;i < v_len;i++)
       {var
         a=caml_ba_get_1(v_s1,v_s1_pos + i),
         b=caml_ba_get_1(v_s2,v_s2_pos + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function integers_uint32_add(x,y){return new UInt32(x.value + y.value)}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_pallas_double(x)
     {var res=plonk_wasm.caml_pallas_double(x);
      free_on_finalize(res);
      return res}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_bigint_256_test_bit(x,i)
     {return caml_js_to_bool(plonk_wasm.caml_bigint_256_test_bit(x,i))}
    function caml_vesta_add(x,y)
     {var res=plonk_wasm.caml_vesta_add(x,y);free_on_finalize(res);return res}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    var caml_pasta_fq_compare=plonk_wasm.caml_pasta_fq_compare;
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function integers_uint32_to_int64(i)
     {return caml_int64_create_lo_mi_hi
              (i.value & 0xffffff,i.value >>> 24 & 0xffffff,0)}
    function integers_uint32_mul(x,y)
     {var x_64=integers_uint32_to_int64(x),y_64=integers_uint32_to_int64(y);
      return new UInt32(caml_int64_to_int32(caml_int64_mul(x_64,y_64)))}
    function caml_pasta_fq_commitments_of_rust(x)
     {function convertArray(v)
       {var
         a=js_class_vector_of_rust_vector(v,plonk_wasm.WasmFqPolyComm),
         res=[0];
        for(var i=0;i < a.length;++i)
         res.push(caml_pallas_poly_comm_of_rust(a[i]));
        return res}
      var
       w_comm=convertArray(x.w_comm),
       z_comm=caml_pallas_poly_comm_of_rust(x.z_comm),
       t_comm=caml_pallas_poly_comm_of_rust(x.t_comm);
      x.free();
      return [0,w_comm,z_comm,t_comm]}
    function caml_pasta_fq_opening_proof_of_rust(x)
     {function convert_affines(affines)
       {return caml_array_of_rust_vector
                (affines,
                 plonk_wasm.WasmGPallas,
                 rust_affine_to_caml_affine,
                 false)}
      var
       l=convert_affines(x.lr_0),
       r=convert_affines(x.lr_1),
       delta=rust_affine_to_caml_affine(x.delta),
       z1=x.z1,
       z2=x.z2,
       sg=rust_affine_to_caml_affine(x.sg);
      x.free();
      var len=l.length;
      if(len !== r.length)throw new Error("l and r lengths don't match");
      var lr=new Array(len);
      lr[0] = 0;
      for(var i=1;i < len;i++)
       {var tuple=new Array(3);
        tuple[0] = 0;
        tuple[1] = l[i];
        tuple[2] = r[i];
        lr[i] = tuple}
      return [0,lr,delta,z1,z2,sg]}
    function caml_fq_vector_of_rust(v)
     {return caml_u8array_vector_of_rust_flat_vector(v,32)}
    function caml_pasta_fq_proof_evaluations_of_rust(x){return x}
    function caml_pasta_fq_proof_of_rust(x)
     {var
       messages=caml_pasta_fq_commitments_of_rust(x.commitments),
       proof=caml_pasta_fq_opening_proof_of_rust(x.proof),
       evals=caml_pasta_fq_proof_evaluations_of_rust(x.evals),
       evals1=caml_pasta_fq_proof_evaluations_of_rust(x.evals1),
       ft_eval1=x.ft_eval1,
       public_=caml_fq_vector_of_rust(x.public_),
       prev_challenges_scalars=x.prev_challenges_scalars,
       prev_challenges_comms=
        js_class_vector_of_rust_vector
         (x.prev_challenges_comms,plonk_wasm.WasmFqPolyComm),
       chals_len=prev_challenges_comms.length,
       prev_challenges=new Array(chals_len);
      prev_challenges[0] = 0;
      for(var i=1;i < chals_len;i++)
       {var res=new Array(3);
        res[0] = 0;
        res[1] = caml_fq_vector_of_rust(prev_challenges_scalars.get(i - 1));
        res[2] = caml_pallas_poly_comm_of_rust(prev_challenges_comms[i]);
        prev_challenges[i] = res}
      return [0,messages,proof,evals,ft_eval1,public_,prev_challenges]}
    function caml_pasta_fq_plonk_proof_create
     (index,witness_cols,prev_challenges,prev_sgs)
     {var w=new (plonk_wasm.WasmVecVecFq)(witness_cols.length - 1);
      for(var i=1;i < witness_cols.length;i++)
       w.push(caml_fq_vector_to_rust(witness_cols[i]));
      witness_cols = w;
      prev_challenges = caml_fq_vector_to_rust(prev_challenges);
      prev_sgs
      =
      caml_array_to_rust_vector
       (prev_sgs,rust_affine_of_caml_affine,plonk_wasm.caml_pallas_affine_one);
      var
       res=
        plonk_wasm.caml_pasta_fq_plonk_proof_create
         (index,witness_cols,prev_challenges,prev_sgs),
       proof=caml_pasta_fq_proof_of_rust(res);
      return proof}
    function caml_int64_is_zero(x){return + x.isZero()}
    function Base_int_math_int64_pow_stub(base,exponent)
     {var one=caml_int64_create_lo_hi(1,0),mul=[one,base,one,one],res=one;
      while(! caml_int64_is_zero(exponent))
       {mul[1] = caml_int64_mul(mul[1],mul[3]);
        mul[2] = caml_int64_mul(mul[1],mul[1]);
        mul[3] = caml_int64_mul(mul[2],mul[1]);
        res = caml_int64_mul(res,mul[caml_int64_lo32(exponent) & 3]);
        exponent = caml_int64_shift_right_unsigned(exponent,2)}
      return res}
    function caml_sys_const_word_size(){return 32}
    function integers_uint64_to_int64(i)
     {i = i.value;return caml_int64_create_lo_mi_hi(i.lo,i.mi,i.hi | 0)}
    function ml_z_mul(z1,z2)
     {return ml_z_normalize(bigInt(z1).multiply(bigInt(z2)))}
    function ml_z_popcount(z)
     {z = bigInt(z);
      var zero=bigInt(0),one=bigInt(1);
      if(z.lt(zero))caml_raise_constant(caml_named_value("ml_z_overflow"));
      var i;
      for(i = 0;! z.equals(zero);i++)z = z.and(z.prev());
      if(i != (i | 0))caml_raise_constant(caml_named_value("ml_z_overflow"));
      return i | 0}
    function ml_z_hamdist(z1,z2)
     {if(bigInt(z1).isNegative() != bigInt(z2).isNegative())
       caml_raise_constant(caml_named_value("ml_z_overflow"));
      if
       ((z1 != (z1 | 0) || z2 != (z2 | 0))
        &&
        (bigInt(z1).isNegative() || bigInt(z2).isNegative()))
       caml_invalid_argument("Z.hamdist: negative arguments");
      return ml_z_popcount(bigInt(z1).xor(bigInt(z2)))}
    function ml_z_pow(z1,i1)
     {i1 = bigInt(i1);
      if(i1.lt(bigInt(0)))
       caml_invalid_argument("Z.pow: exponent must be nonnegative");
      return ml_z_normalize(bigInt(z1).pow(i1))}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function bigstring_alloc(_,size){return caml_ba_create(12,0,[0,size])}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function deferred_peek(deferred)
     {if(! deferred.isDetermined || deferred.isError)return 0;
      return [0,deferred.value]}
    function ml_z_logand(z1,z2)
     {return ml_z_normalize(bigInt(z1).and(bigInt(z2)))}
    function caml_vesta_of_affine_coordinates(x,y)
     {var res=plonk_wasm.caml_vesta_of_affine_coordinates(x,y);
      free_on_finalize(res);
      return res}
    function custom_reraise_exn(exn,fallbackMessage)
     {var err=exn[2];
      if(err instanceof globalThis.Error)
       throw err;
      else
       throw Error(fallbackMessage)}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_ba_kind_of_typed_array(ta)
     {var g=globalThis,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function deferred_to_promise(deferred){return deferred.promise}
    function Base_int_math_int32_ctz(x)
     {if(x === 0)return 32;
      var n=1;
      if((x & 0x0000FFFF) === 0){n = n + 16;x = x >> 16}
      if((x & 0x000000FF) === 0){n = n + 8;x = x >> 8}
      if((x & 0x0000000F) === 0){n = n + 4;x = x >> 4}
      if((x & 0x00000003) === 0){n = n + 2;x = x >> 2}
      return n - (x & 1)}
    function Base_int_math_nativeint_ctz(x){return Base_int_math_int32_ctz(x)}
    var expect_test_collector_saved_stderr,expect_test_collector_saved_stdout;
    function expect_test_collector_after_test(vstdout,vstderr)
     {caml_ml_channels[vstdout] = expect_test_collector_saved_stdout;
      caml_ml_channels[vstderr] = expect_test_collector_saved_stderr;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function ml_z_fits_int(z1){return z1 == (z1 | 0)?1:0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    var Base_internalhash_fold_int=caml_hash_mix_int;
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_bigint_256_of_decimal_string(s)
     {return plonk_wasm.caml_bigint_256_of_decimal_string
              (caml_jsstring_of_string(s))}
    function Base_int_math_int32_clz(x)
     {var n=32,y;
      y = x >> 16;
      if(y != 0){n = n - 16;x = y}
      y = x >> 8;
      if(y != 0){n = n - 8;x = y}
      y = x >> 4;
      if(y != 0){n = n - 4;x = y}
      y = x >> 2;
      if(y != 0){n = n - 2;x = y}
      y = x >> 1;
      if(y != 0)return n - 2;
      return n - x}
    function Base_int_math_nativeint_clz(x){return Base_int_math_int32_clz(x)}
    var caml_pasta_fp_add=plonk_wasm.caml_pasta_fp_add;
    function core_kernel_time_ns_format(time,format)
     {var
       d=new Date(time * 1000),
       formatjs=caml_jsbytes_of_string(format),
       jstring=joo_global_object.strftime(formatjs,d);
      return caml_string_of_jsbytes(jstring)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_atanh_float(x){return Math.atanh(x)}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_pasta_fp_plonk_verifier_index_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_pasta_fp_plonk_verifier_index_write
              (append,
               caml_pasta_fp_plonk_verifier_index_to_rust(t),
               caml_jsstring_of_string(path))}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function integers_uint16_deserialize(reader,size)
     {size[0] = 2;return reader.read16u()}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    var internalhash_fold_bigstring=caml_hash_mix_bigstring;
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function ml_z_sign(z1){return bigInt(z1).compare(bigInt.zero)}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_fp_srs_b_poly_commitment(srs,chals)
     {var
       res=
        plonk_wasm.caml_fp_srs_b_poly_commitment
         (srs,caml_u8array_vector_to_rust_flat_vector(chals));
      return caml_vesta_poly_comm_of_rust(res)}
    function ml_z_nextprime(z1)
     {z1 = bigInt(z1);
      var one=bigInt(1),two=bigInt(2);
      if(z1.lt(one) || z1.equals(one))return 2;
      if(z1.and(one).equals(one))z1 = z1.add(two);else z1 = z1.add(one);
      while(true)
       if(z1.isProbablePrime(25))
        return ml_z_normalize(z1);
       else
        z1 = z1.add(two)}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    var caml_pasta_fq_equal=plonk_wasm.caml_pasta_fq_equal;
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function fq_oracles_create(lgr_comm,verifier_index,proof)
     {return caml_oracles_of_rust
              (plonk_wasm.fq_oracles_create
                (caml_array_to_rust_vector
                  (lgr_comm,caml_pallas_poly_comm_to_rust),
                 caml_pasta_fq_plonk_verifier_index_to_rust(verifier_index),
                 caml_pasta_fq_proof_to_rust(proof)))}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_eventlog_resume(unit){return 0}
    var
     caml_pasta_fp_plonk_index_domain_d1_size=
      plonk_wasm.caml_pasta_fp_plonk_index_domain_d1_size;
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           var content=caml_ml_bytes_content(obj);
           if(typeof content === "string")
            for(var b=content,l=b.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            for(var a=content,l=a.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + a[i] | 0}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_vesta_negate(x)
     {var res=plonk_wasm.caml_vesta_negate(x);
      free_on_finalize(res);
      return res}
    function ml_z_div(z1,z2)
     {z2 = bigInt(z2);
      if(z2.equals(bigInt(0)))caml_raise_zero_divide();
      return ml_z_normalize(bigInt(z1).divide(bigInt(z2)))}
    function ml_z_divexact(z1,z2){return ml_z_div(z1,z2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function caml_vesta_rng(i)
     {var res=plonk_wasm.caml_vesta_rng(i);free_on_finalize(res);return res}
    function caml_pasta_fp_plonk_verifier_index_read(offset,urs,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      return caml_pasta_fp_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_verifier_index_read
                (offset,urs,caml_jsstring_of_string(path)))}
    function jsoo_create_file_extern(name,content)
     {if(globalThis.jsoo_create_file)
       globalThis.jsoo_create_file(name,content);
      else
       {if(! globalThis.caml_fs_tmp)globalThis.caml_fs_tmp = [];
        globalThis.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_pasta_fp_plonk_circuit_serialize
     (public_input_size,gate_vector)
     {return caml_string_of_jsstring
              (plonk_wasm.caml_pasta_fp_plonk_circuit_serialize
                (public_input_size,gate_vector))}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_fq_srs_read(offset,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      var
       res=
        plonk_wasm.caml_fq_srs_read(offset,caml_jsstring_of_string(path));
      return res?[0,res]:0}
    function caml_pasta_fq_plonk_circuit_serialize
     (public_input_size,gate_vector)
     {return caml_string_of_jsstring
              (plonk_wasm.caml_pasta_fq_plonk_circuit_serialize
                (public_input_size,gate_vector))}
    function caml_obj_set_raw_field(o,i,v){return o[i + 1] = v}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_pasta_fp_mut_add(x,y)
     {caml_pasta_fp_copy(x,caml_pasta_fp_add(x,y))}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_zarith_marshal(writer,v,sz)
     {v = bigInt(v);
      var bits=v.toArray(Math.pow(2,32));
      writer.write(8,bits.isNegative?1:0);
      var block=bits.value.length,len=block * 4;
      writer.write(32,len);
      for(var i=block - 1;i >= 0;i--)
       {writer.write(8,bits.value[i] >>> 0 & 0xff);
        writer.write(8,bits.value[i] >>> 8 & 0xff);
        writer.write(8,bits.value[i] >>> 16 & 0xff);
        writer.write(8,bits.value[i] >>> 24 & 0xff)}
      sz[0] = 4 * (1 + ((len + 3) / 4 | 0));
      sz[1] = 8 * (1 + ((len + 7) / 8 | 0))}
    function caml_fp_vector_emplace_back(v,x){v.push(x)}
    var
     Base_internalhash_fold_int64=caml_hash_mix_int64,
     caml_vesta_endo_scalar=plonk_wasm.caml_vesta_endo_scalar;
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var win_filedescr_of_channel=caml_channel_descriptor;
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    function caml_fq_srs_b_poly_commitment(srs,chals)
     {var
       res=
        plonk_wasm.caml_fq_srs_b_poly_commitment
         (srs,caml_u8array_vector_to_rust_flat_vector(chals));
      return caml_pallas_poly_comm_of_rust(res)}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_obj_raw_field(o,i){return o[i + 1]}
    function caml_js_equals(x,y){return + (x == y)}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function bigstring_to_typed_array(bs){return bs.data}
    function integers_uint16_of_string(x)
     {var y=integers_uint32_of_string(x);return y.value & 0xFFFF}
    function ml_z_fits_nativeint(z1){return ml_z_fits_int(z1)}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function integers_uint64_logxor(x,y)
     {return new UInt64(caml_int64_xor(x.value,y.value))}
    function integers_uint32_of_int(i){return new UInt32(i)}
    var caml_pasta_fp_compare=plonk_wasm.caml_pasta_fp_compare;
    function caml_pallas_of_affine(pt)
     {var
       res=
        plonk_wasm.caml_pallas_of_affine
         (rust_affine_of_caml_affine(pt,plonk_wasm.caml_pallas_affine_one));
      free_on_finalize(res);
      return res}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_out_channel_pos_fd(chan)
     {var info=caml_ml_channels[chan];return info.offset}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_gc_major_slice(work){return 0}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function integers_uint64_to_string(i)
     {return caml_int64_format(caml_new_string("%u"),i.value)}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function integers_uint32_serialize(writer,v,size)
     {writer.write(32,v.value);size[0] = 4;size[1] = 4}
    function caml_pasta_fp_poseidon_params_create(){return [0]}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_pasta_fq_sqrt(x)
     {return caml_option_of_maybe_undefined(plonk_wasm.caml_pasta_fq_sqrt(x))}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function caml_create_file(name,content)
     {var root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function jsoo_create_file(name,content)
     {var
       name=caml_string_of_jsbytes(name),
       content=caml_string_of_jsbytes(content);
      return caml_create_file(name,content)}
    function ml_z_hash(z1)
     {var a=bigInt(z1).toArray(Math.pow(2,32)),acc=0;
      for(var i=0;i < a.value.length;i++)
       acc = caml_hash_mix_int(acc,a.value[i]);
      if(a.value.length % 2 != 0)acc = caml_hash_mix_int(acc,0);
      if(a.isNegative)acc = acc + 1;
      return acc | 0}
    function integers_uint64_logand(x,y)
     {return new UInt64(caml_int64_and(x.value,y.value))}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_fq_vector_emplace_back(v,x){v.push(x)}
    function Base_int_math_int_clz(x){return Base_int_math_int32_clz(x)}
    var caml_pasta_fp_of_bigint=plonk_wasm.caml_pasta_fp_of_bigint;
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function ml_z_root(z,i)
     {var zero=bigInt(0),one=bigInt(1);
      z = bigInt(z);
      if(i % 2 === 0 && z.lt(zero))
       caml_invalid_argument("Z.root: even root of a negative number");
      if(z.equals(zero) || z.equals(one))return ml_z_normalize(z);
      var start=zero,end=z,ans=null,two=bigInt(2);
      while(start.leq(end))
       {var mid=start.add(end).divide(two),po=mid.pow(i);
        if(po.equals(z))
         return ml_z_normalize(mid);
        else
         if(po.lt(z)){start = mid.next();ans = mid}else end = mid.prev()}
      return ml_z_normalize(ans)}
    function ml_z_sqrt_rem(z)
     {z = bigInt(z);
      var zero=bigInt(0);
      if(z.lt(zero))
       caml_invalid_argument("Z.sqrt_rem: square root of a negative number");
      var
       root=bigInt(ml_z_root(z,2)),
       mul=root.multiply(root),
       diff=z.subtract(mul);
      return [0,ml_z_normalize(root),ml_z_normalize(diff)]}
    var caml_ephe_data_offset=2;
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    var
     caml_pasta_fp_plonk_index_max_degree=
      plonk_wasm.caml_pasta_fp_plonk_index_max_degree;
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_fp_srs_batch_accumulator_generate(srs,comms,chals)
     {var
       rust_chals=caml_fp_vector_to_rust(chals),
       rust_comms=
        plonk_wasm.caml_fp_srs_batch_accumulator_generate
         (srs,comms,rust_chals);
      return caml_array_of_rust_vector
              (rust_comms,
               plonk_wasm.WasmGVesta,
               rust_affine_to_caml_affine,
               false)}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function integers_uint64_of_uint32(i)
     {return new UInt64(caml_int64_of_int32(i))}
    var caml_pasta_fq_add=plonk_wasm.caml_pasta_fq_add;
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === undefined)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_vesta_affine_deep_copy(pt)
     {return rust_affine_to_caml_affine
              (plonk_wasm.caml_vesta_affine_deep_copy
                (rust_affine_of_caml_affine
                  (pt,plonk_wasm.caml_vesta_affine_one)))}
    function bin_prot_blit_buf_bytes_stub(src_pos,src,dst_pos,dst,len)
     {return caml_bigstring_blit_ba_to_bytes(src,src_pos,dst,dst_pos,len)}
    function caml_js_get_console()
     {var
       c=globalThis.console?globalThis.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (globalThis.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function ml_z_of_bits(z1)
     {var r=bigInt.zero,base1=bigInt(256),base=bigInt.one;
      for(var i=0;i < caml_ml_string_length(z1);i++)
       {var d=caml_string_unsafe_get(z1,i);
        r = bigInt(base).multiply(d).add(r);
        base = bigInt(base).multiply(base1)}
      return ml_z_normalize(r)}
    function unix_stat(name)
     {var root=resolve_fs_device(name);
      if(! root.device.stat)caml_failwith("unix_stat: not implemented");
      return root.device.stat(root.rest,true)}
    var unix_stat_64=unix_stat;
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return Math.sinh(x)}
    function caml_pasta_fq_plonk_index_read(offset,urs,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      return plonk_wasm.caml_pasta_fq_plonk_index_read
              (offset,urs,caml_jsstring_of_string(path))}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_zarith_unmarshal(reader,sz)
     {var negate;
      switch(reader.read8u())
       {case 1:negate = true;break;
        case 0:negate = false;break;
        default:caml_failwith("input_value: z (malformed input)")}
      var len=reader.read32u(),x=bigInt(0);
      for(var i=0;i < len / 4;i++)
       {var y=bigInt(reader.read8u());
        y = y.add(reader.read8u() << 8);
        y = y.add(reader.read8u() << 16);
        y = y.add(reader.read8u() << 24 >>> 0);
        x = y.shiftLeft(i * 32).add(x)}
      if(negate)x = x.negate();
      sz[0] = len + 4;
      return ml_z_normalize(x)}
    function caml_get_current_callstack(){return [0]}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    var caml_pasta_fq_of_int=plonk_wasm.caml_pasta_fq_of_int;
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function integers_uint8_of_string(x)
     {var y=integers_uint32_of_string(x);return x.value & 0xFF}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_get_major_bucket(n){return 0}
    function integers_uint32_sub(x,y){return new UInt32(x.value - y.value)}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function caml_pasta_fq_plonk_gate_vector_create()
     {return free_on_finalize
              (plonk_wasm.caml_pasta_fq_plonk_gate_vector_create())}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function integers_uint32_div(x,y){return new UInt32(x.value / y.value)}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function unix_symlink(to_dir,src,dst)
     {var src_root=resolve_fs_device(src),dst_root=resolve_fs_device(dst);
      if(src_root.device != dst_root.device)
       caml_failwith("unix_symlink: cannot symlink between two filesystems");
      if(! src_root.device.symlink)
       caml_failwith("unix_symlink: not implemented");
      return src_root.device.symlink(to_dir,src_root.rest,dst_root.rest,true)}
    function fp_oracles_create(lgr_comm,verifier_index,proof)
     {return caml_oracles_of_rust
              (plonk_wasm.fp_oracles_create
                (caml_array_to_rust_vector
                  (lgr_comm,caml_vesta_poly_comm_to_rust),
                 caml_pasta_fp_plonk_verifier_index_to_rust(verifier_index),
                 caml_pasta_fp_proof_to_rust(proof)))}
    function caml_pasta_fp_plonk_proof_example_with_xor()
     {throw new
             Error
             ("Unimplemented caml_pasta_fp_plonk_proof_example_with_xor")}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_fq_vector_get(v,i)
     {var value=v[i + 1];
      if(value === undefined)
       throw Error
              ("caml_fq_vector_get: Index out of bounds, got "
               +
               i
               +
               "/"
               +
               (v.length - 1));
      return new (joo_global_object.Uint8Array)(value)}
    function Base_int_math_int_ctz(x){return Base_int_math_int32_ctz(x)}
    function bigstring_blit_string_bigstring_stub(src,src_pos,dst,dst_pos,len)
     {return caml_bigstring_blit_string_to_ba(src,src_pos,dst,dst_pos,len)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_fp_vector_create(){return [0]}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_pallas_to_affine(pt)
     {var res=plonk_wasm.caml_pallas_to_affine(pt);
      return rust_affine_to_caml_affine(res)}
    function caml_fq_srs_create(i)
     {return free_on_finalize(plonk_wasm.caml_fq_srs_create(i))}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    var core_array_unsafe_float_blit=caml_array_blit;
    function caml_spacetime_enabled(_unit){return 0}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function integers_uint64_marshal(writer,v,sizes)
     {caml_int64_marshal(writer,v.value,sizes)}
    function caml_fma_float(x,y,z)
     {var
       SPLIT=Math.pow(2,27) + 1,
       MIN_VALUE=Math.pow(2,- 1022),
       EPSILON=Math.pow(2,- 52),
       C=416,
       A=Math.pow(2,+ C),
       B=Math.pow(2,- C);
      function multiply(a,b)
       {var
         at=SPLIT * a,
         ahi=at - (at - a),
         alo=a - ahi,
         bt=SPLIT * b,
         bhi=bt - (bt - b),
         blo=b - bhi,
         p=a * b,
         e=ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
        return {p:p,e:e}}
      function add(a,b)
       {var s=a + b,v=s - a,e=a - (s - v) + (b - v);return {s:s,e:e}}
      function adjust(x,y)
       {return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
                ?x * (1 + (x < 0?- 1:+ 1) * (y < 0?- 1:+ 1) * EPSILON)
                :x}
      if
       (x
        ===
        0
        ||
        x
        !==
        x
        ||
        x
        ===
        +
        (1 / 0)
        ||
        x
        ===
        -
        (1 / 0)
        ||
        y
        ===
        0
        ||
        y
        !==
        y
        ||
        y
        ===
        +
        (1 / 0)
        ||
        y
        ===
        -
        (1 / 0))
       return x * y + z;
      if(z === 0)return x * y;
      if(z !== z || z === + (1 / 0) || z === - (1 / 0))return z;
      var scale=1;
      while(Math.abs(x) > A){scale *= A;x *= B}
      while(Math.abs(y) > A){scale *= A;y *= B}
      if(scale === 1 / 0)return x * y * scale;
      while(Math.abs(x) < B){scale *= B;x *= A}
      while(Math.abs(y) < B){scale *= B;y *= A}
      if(scale === 0)return z;
      var xs=x,ys=y,zs=z / scale;
      if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON)return z;
      if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
       zs = (z < 0?- 1:+ 1) * MIN_VALUE;
      var
       xy=multiply(xs,ys),
       s=add(xy.p,zs),
       u=add(xy.e,s.e),
       i=add(s.s,u.s),
       f=i.s + adjust(i.e,u.e);
      if(f === 0)return f;
      var fs=f * scale;
      if(Math.abs(fs) > MIN_VALUE)return fs;
      return fs + adjust(f - fs / scale,i.e) * scale}
    function caml_bytes_of_uint8array(uint8array)
     {var length=uint8array.length,ocaml_bytes=caml_create_bytes(length);
      for(var i=0;i < length;i++)
       caml_bytes_unsafe_set(ocaml_bytes,i,uint8array[i]);
      return ocaml_bytes}
    function caml_pasta_fq_plonk_gate_vector_digest
     (public_input_size,gate_vector)
     {var
       uint8array=
        plonk_wasm.caml_pasta_fq_plonk_gate_vector_digest
         (public_input_size,gate_vector);
      return caml_bytes_of_uint8array(uint8array)}
    function core_kernel_gc_compactions(){return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    var
     caml_pasta_fq_plonk_index_domain_d4_size=
      plonk_wasm.caml_pasta_fq_plonk_index_domain_d4_size;
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    var caml_ephe_blit_key=caml_weak_blit;
    function caml_pasta_fp_plonk_gate_vector_digest
     (public_input_size,gate_vector)
     {var
       uint8array=
        plonk_wasm.caml_pasta_fp_plonk_gate_vector_digest
         (public_input_size,gate_vector);
      return caml_bytes_of_uint8array(uint8array)}
    var caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function fp_oracles_dummy()
     {return caml_oracles_of_rust(plonk_wasm.fp_oracles_dummy())}
    function Base_clear_caml_backtrace_pos(x){return 0}
    function caml_pasta_fp_plonk_proof_example_with_range_check()
     {throw new
             Error
             ("Unimplemented caml_pasta_fp_plonk_proof_example_with_range_check")}
    var caml_bigint_256_compare=plonk_wasm.caml_bigint_256_compare;
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function Core_kernel_heap_block_is_heap_block(x)
     {return + (x instanceof Array)}
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function bigstring_blit_bytes_bigstring_stub(src,src_pos,dst,dst_pos,len)
     {return caml_bigstring_blit_bytes_to_ba(src,src_pos,dst,dst_pos,len)}
    function ml_z_pred(z1){return ml_z_normalize(bigInt(z1).prev())}
    function ml_z_extract(z1,pos,len)
     {z1 = bigInt(z1);
      return ml_z_normalize
              (z1.shiftRight(pos).and(bigInt(2).pow(len).subtract(1)))}
    function ml_z_lognot(z1){return ml_z_normalize(bigInt(z1).not())}
    var caml_pasta_fq_rng=plonk_wasm.caml_pasta_fq_rng;
    function caml_pasta_fp_is_square(x)
     {return caml_js_to_bool(plonk_wasm.caml_pasta_fp_is_square(x))}
    function caml_oracles_to_rust(x,klass,roKlass)
     {return new
              klass
              (caml_random_oracles_to_rust(x[1],roKlass),
               x[2][1],
               x[2][2],
               caml_u8array_vector_to_rust_flat_vector(x[3]),
               x[4])}
    function fp_oracles_deep_copy(x)
     {return caml_oracles_of_rust
              (plonk_wasm.fp_oracles_deep_copy
                (caml_oracles_to_rust
                  (x,plonk_wasm.WasmFpOracles,plonk_wasm.WasmFpRandomOracles)))}
    function caml_get_minor_free(unit){return 0}
    function caml_set_static_env(k,v)
     {if(! globalThis.jsoo_static_env)globalThis.jsoo_static_env = {};
      globalThis.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function core_kernel_gc_top_heap_words(){return 0}
    function caml_pasta_fq_poseidon_params_create(){return [0]}
    function unix_mkdir(name,perm)
     {var root=resolve_fs_device(name);
      if(! root.device.mkdir)caml_failwith("unix_mkdir: not implemented");
      return root.device.mkdir(root.rest,perm,true)}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_fq_srs_lagrange_commitment(t,domain_size,i)
     {var res=plonk_wasm.caml_fq_srs_lagrange_commitment(t,domain_size,i);
      return caml_pallas_poly_comm_of_rust(res)}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_gr_open_graph(info)
     {var g=globalThis,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    var caml_pallas_endo_scalar=plonk_wasm.caml_pallas_endo_scalar;
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_bigint_256_of_numeral(s,len,base)
     {return plonk_wasm.caml_bigint_256_of_numeral
              (caml_jsstring_of_string(s),len,base)}
    var caml_bigint_256_print=plonk_wasm.caml_bigint_256_print;
    function caml_memprof_stop(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    var caml_pasta_fq_square=plonk_wasm.caml_pasta_fq_square;
    function caml_pasta_fq_mut_square(x)
     {caml_pasta_fq_copy(x,caml_pasta_fq_square(x))}
    function ml_z_numbits(z1)
     {z1 = bigInt(z1).abs();
      var n=0,upperBound=bigInt.one;
      while(upperBound.leq(z1)){n += 1;upperBound = upperBound.multiply(2)}
      return n}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x){return Math.log1p(x)}
    function caml_pasta_fq_poseidon_block_cipher(_fake_params,fq_vector)
     {var
       wasm_flat_vector=
        plonk_wasm.caml_pasta_fq_poseidon_block_cipher
         (caml_fq_vector_to_rust(fq_vector)),
       new_fq_vector=caml_fq_vector_of_rust(wasm_flat_vector);
      new_fq_vector.forEach(function(a,i){fq_vector[i] = a})}
    function caml_lazy_make_forward(v){return [250,v]}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function integers_uint64_mul(x,y)
     {return new UInt64(caml_int64_mul(x.value,y.value))}
    function ml_z_compare(z1,z2){return bigInt(z1).compare(bigInt(z2))}
    function ml_z_init(unit)
     {caml_custom_ops["_z"]
      =
      {serialize:caml_zarith_marshal,
       deserialize:caml_zarith_unmarshal,
       hash:ml_z_hash,
       compare:ml_z_compare};
      return 0}
    function caml_is_special_exception(exn)
     {switch(exn[2]){case - 8:case - 11:case - 12:return 1;default:return 0}}
    function caml_format_exception(exn)
     {var r="";
      if(exn[0] == 0)
       {r += exn[1][1];
        if
         (exn.length
          ==
          3
          &&
          exn[2][0]
          ==
          0
          &&
          caml_is_special_exception(exn[1]))
         var bucket=exn[2],start=1;
        else
         var start=2,bucket=exn;
        r += "(";
        for(var i=start;i < bucket.length;i++)
         {if(i > start)r += ", ";
          var v=bucket[i];
          if(typeof v == "number")
           r += v.toString();
          else
           if(v instanceof MlBytes)
            r += '"' + v.toString() + '"';
           else
            if(typeof v == "string")
             r += '"' + v.toString() + '"';
            else
             r += "_"}
        r += ")"}
      else
       if(exn[0] == 248)r += exn[1];
      return r}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_pasta_fp_plonk_index_read(offset,urs,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      return plonk_wasm.caml_pasta_fp_plonk_index_read
              (offset,urs,caml_jsstring_of_string(path))}
    var caml_pasta_fp_negate=plonk_wasm.caml_pasta_fp_negate;
    function bin_prot_blit_string_buf_stub(src_pos,src,dst_pos,dst,len)
     {return caml_bigstring_blit_string_to_ba(src,src_pos,dst,dst_pos,len)}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    var caml_pasta_fp_sub=plonk_wasm.caml_pasta_fp_sub;
    function caml_pasta_fp_mut_sub(x,y)
     {caml_pasta_fp_copy(x,caml_pasta_fp_sub(x,y))}
    function caml_return_exn_constant(tag){return tag}
    function integers_uint64_unmarshal(reader,size)
     {return new UInt64(caml_int64_unmarshal(reader,size))}
    function ml_z_fits_int64(z1)
     {z1 = bigInt(z1);
      return z1.compare(bigInt("9223372036854775807"))
              <=
              0
              &&
              z1.compare(bigInt("-9223372036854775808"))
              >=
              0
              ?1
              :0}
    function ml_z_to_int64(z1)
     {z1 = bigInt(z1);
      if(! ml_z_fits_int64(z1))
       caml_raise_constant(caml_named_value("ml_z_overflow"));
      var
       mask=bigInt(0xffffffff),
       lo=z1.and(mask).toJSNumber(),
       hi=z1.shiftRight(32).and(mask).toJSNumber(),
       x=caml_int64_create_lo_hi(lo,hi);
      return x}
    function ml_z_size(z1)
     {return bigInt(z1).toArray(Math.pow(2,32)).value.length}
    function caml_backtrace_status(){return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_fp_srs_commit_evaluations(t,domain_size,fps)
     {var
       res=
        plonk_wasm.caml_fp_srs_commit_evaluations
         (t,domain_size,caml_fp_vector_to_rust(fps));
      return caml_vesta_poly_comm_of_rust(res)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_pasta_fp_plonk_proof_create
     (index,witness_cols,prev_challenges,prev_sgs)
     {var w=new (plonk_wasm.WasmVecVecFp)(witness_cols.length - 1);
      for(var i=1;i < witness_cols.length;i++)
       w.push(caml_fp_vector_to_rust(witness_cols[i]));
      witness_cols = w;
      prev_challenges = caml_fp_vector_to_rust(prev_challenges);
      prev_sgs
      =
      caml_array_to_rust_vector
       (prev_sgs,rust_affine_of_caml_affine,plonk_wasm.caml_vesta_affine_one);
      var
       res=
        plonk_wasm.caml_pasta_fp_plonk_proof_create
         (index,witness_cols,prev_challenges,prev_sgs),
       proof=caml_pasta_fp_proof_of_rust(res);
      return proof}
    function caml_pasta_fp_plonk_proof_example_with_foreign_field_mul()
     {throw new
             Error
             ("Unimplemented caml_pasta_fp_plonk_proof_example_with_foreign_field_mul")}
    function caml_pasta_fq_plonk_gate_vector_len(v)
     {return plonk_wasm.caml_pasta_fq_plonk_gate_vector_len(v)}
    var
     caml_pasta_fq_two_adic_root_of_unity=
      plonk_wasm.caml_pasta_fq_two_adic_root_of_unity;
    function caml_vesta_scale(x,y)
     {var res=plonk_wasm.caml_vesta_scale(x,y);
      free_on_finalize(res);
      return res}
    function ml_z_install_frametable(unit){return 0}
    function caml_sys_mkdir(name,perm)
     {var root=resolve_fs_device(name);
      root.device.mkdir(root.rest,perm);
      return 0}
    function bigstring_blit_stub(s1,i1,s2,i2,len)
     {return caml_bigstring_blit_ba_to_ba(s1,i1,s2,i2,len)}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_pasta_fp_sqrt(x)
     {return caml_option_of_maybe_undefined(plonk_wasm.caml_pasta_fp_sqrt(x))}
    function Base_int_math_int_popcount(v)
     {v = v - (v >>> 1 & 0x55555555);
      v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
      return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(caml_jsbytes_of_string(name))}
    function caml_js_to_float(x){return x}
    var caml_pasta_fp_rng=plonk_wasm.caml_pasta_fp_rng;
    function caml_pasta_fp_to_string(x)
     {return caml_string_of_jsstring(plonk_wasm.caml_pasta_fp_to_string(x))}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    function deferred_of_promise(promise)
     {var
       deferred=
        {promise:
         promise.then
           (function(value)
             {deferred.value = value;
              deferred.isDetermined = true;
              return value}).catch
          (function(err)
            {deferred.error = err;
             deferred.isError = true;
             deferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return deferred}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    var caml_pasta_fp_equal=plonk_wasm.caml_pasta_fp_equal;
    function integers_uint32_deserialize(reader,size)
     {size[0] = 4;return new UInt32(reader.read32u())}
    var caml_bigint_256_div=plonk_wasm.caml_bigint_256_div;
    function integers_uint32_to_string(i)
     {return caml_new_string(i.value.toString())}
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_vesta_sub(x,y)
     {var res=plonk_wasm.caml_vesta_sub(x,y);free_on_finalize(res);return res}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function bigstringaf_memcmp_bigstring(ba1,ba1_off,ba2,ba2_off,len)
     {for(var i=0;i < len;i++)
       {var
         c=
          caml_int_compare
           (caml_ba_get_1(ba1,ba1_off + i),caml_ba_get_1(ba2,ba2_off + i));
        if(c != 0)return c}
      return 0}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (globalThis.RangeError
        &&
        e instanceof globalThis.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (globalThis.InternalError
        &&
        e instanceof globalThis.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof globalThis.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_fs_init()
     {var tmp=globalThis.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        jsoo_create_file(tmp[i].name,tmp[i].content);
      globalThis.jsoo_create_file = jsoo_create_file;
      globalThis.caml_fs_tmp = [];
      return 0}
    var Base_internalhash_fold_string=caml_hash_mix_string;
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = caml_trailing_slash(root.path + root.rest);
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(caml_jsbytes_of_string(dir))}
    function caml_fq_srs_batch_accumulator_check(srs,comms,chals)
     {var
       rust_comms=
        caml_array_to_rust_vector
         (comms,rust_affine_of_caml_affine,plonk_wasm.caml_pallas_affine_one),
       rust_chals=caml_fq_vector_to_rust(chals),
       ok=
        plonk_wasm.caml_fq_srs_batch_accumulator_check
         (srs,rust_comms,rust_chals);
      return ok}
    var caml_pasta_fp_deep_copy=plonk_wasm.caml_pasta_fp_deep_copy;
    function ml_z_add(z1,z2)
     {return ml_z_normalize(bigInt(z1).add(bigInt(z2)))}
    function ml_z_cdiv(z1,z2)
     {var z1_pos=ml_z_sign(z1),z2_pos=ml_z_sign(z2);
      if(z1_pos * z2_pos > 0)
       if(! bigInt(z1).mod(bigInt(z2)).equals(bigInt(0)))
        return ml_z_add(ml_z_div(z1,z2),bigInt(1));
      return ml_z_div(z1,z2)}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function bigstringaf_blit_from_bytes(src,src_off,dst,dst_off,len)
     {for(var i=0;i < len;i++)
       caml_ba_set_1(dst,dst_off + i,caml_string_unsafe_get(src,src_off + i))}
    function caml_fq_srs_commit_evaluations(t,domain_size,fqs)
     {var
       res=
        plonk_wasm.caml_fq_srs_commit_evaluations
         (t,domain_size,caml_fq_vector_to_rust(fqs));
      return caml_pallas_poly_comm_of_rust(res)}
    function caml_pasta_fp_of_bytes(ocaml_bytes)
     {return plonk_wasm.caml_pasta_fp_of_bytes
              (caml_bytes_to_uint8array(ocaml_bytes))}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function integers_uint32_hash(v){return v.value}
    function bigstring_find(bs,chr,pos,len)
     {while(len > 0){if(caml_ba_get_1(bs,pos) == chr)return pos;pos++;len--}
      return - 1}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    var caml_pasta_fq_mul=plonk_wasm.caml_pasta_fq_mul;
    function ml_z_of_int64(i64)
     {var neg=false;
      if(caml_int64_compare(i64,caml_int64_create_lo_hi(0,0)) < 0)
       {neg = true;i64 = caml_int64_neg(i64)}
      var
       lo=caml_int64_lo32(i64) >>> 0,
       hi=caml_int64_hi32(i64) >>> 0,
       x=bigInt(lo).add(bigInt(hi).shiftLeft(32));
      if(neg)x = x.negate();
      return ml_z_normalize(x)}
    function integers_uint64_of_int(i)
     {return new UInt64(caml_int64_of_int32(i))}
    function ml_z_neg(z1){return ml_z_normalize(bigInt(z1).negate())}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    function expect_test_collector_before_test(voutput,vstdout,vstderr)
     {expect_test_collector_saved_stderr = caml_ml_channels[vstderr];
      expect_test_collector_saved_stdout = caml_ml_channels[vstdout];
      var output=caml_ml_channels[voutput];
      caml_ml_channels[vstdout] = output;
      caml_ml_channels[vstderr] = output;
      return 0}
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function ml_z_of_int(i){return i | 0}
    function ml_z_of_int32(i32){return ml_z_of_int(i32)}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_pasta_fq_to_bytes(x)
     {var res=plonk_wasm.caml_pasta_fq_to_bytes(x);
      return caml_bytes_of_uint8array(plonk_wasm.caml_pasta_fq_to_bytes(x))}
    function caml_pallas_sub(x,y)
     {var res=plonk_wasm.caml_pallas_sub(x,y);
      free_on_finalize(res);
      return res}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_raw_backtrace_length(){return 0}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function caml_pasta_fq_mut_add(x,y)
     {caml_pasta_fq_copy(x,caml_pasta_fq_add(x,y))}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function integers_uint64_rem(x,y)
     {if(y.value.isZero())caml_raise_zero_divide();
      x.value.hi = x.value.hi >>> 0;
      y.value.hi = y.value.hi >>> 0;
      return new UInt64(x.value.udivmod(y.value).modulus)}
    function ml_z_logor(z1,z2)
     {return ml_z_normalize(bigInt(z1).or(bigInt(z2)))}
    function ml_z_fits_int32(z1){return ml_z_fits_int(z1)}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    var caml_pasta_fp_size=plonk_wasm.caml_pasta_fp_size;
    function caml_pasta_fq_mut_mul(x,y)
     {caml_pasta_fq_copy(x,caml_pasta_fq_mul(x,y))}
    var caml_bigint_256_num_limbs=plonk_wasm.caml_bigint_256_num_limbs;
    function caml_sys_const_ostype_cygwin(){return os_type == "Cygwin"?1:0}
    function caml_cosh_float(x){return Math.cosh(x)}
    var caml_pasta_fp_of_int=plonk_wasm.caml_pasta_fp_of_int;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function integers_ulong_size(unit){return 4}
    function caml_acosh_float(x){return Math.acosh(x)}
    function caml_pasta_fp_plonk_verifier_index_deep_copy(x)
     {return caml_pasta_fp_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_verifier_index_deep_copy
                (caml_pasta_fp_plonk_verifier_index_to_rust(x)))}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function integers_uint32_shift_left(x,y){return new UInt32(x.value << y)}
    function caml_js_get(o,f){return o[f]}
    function caml_gc_compaction(){return 0}
    function bin_prot_blit_float_array_buf_stub(src_pos,src,dst_pos,dst,len)
     {if(len == 0)return 0;
      caml_check_bound(src,src_pos);
      caml_check_bound(src,src_pos + len - 1);
      caml_check_bound_bigstring(dst,dst_pos);
      caml_check_bound_bigstring(dst,dst_pos + len * 8 - 1);
      src_pos = src_pos + 1;
      var
       float64=
        new (joo_global_object.Float64Array)(src.slice(src_pos,src_pos + len)),
       float64_uint8=new (joo_global_object.Uint8Array)(float64.buffer),
       view=dst.data.subarray(dst_pos,dst_pos + len * 8);
      view.set(float64_uint8);
      return 0}
    function Base_int_math_int_pow_stub(base,exponent)
     {var one=1,mul=[one,base,one,one],res=one;
      while(! exponent == 0)
       {mul[1] = mul[1] * mul[3] | 0;
        mul[2] = mul[1] * mul[1] | 0;
        mul[3] = mul[2] * mul[1] | 0;
        res = res * mul[exponent & 3] | 0;
        exponent = exponent >> 2}
      return res}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_pasta_fp_of_string(x)
     {return plonk_wasm.caml_pasta_fp_of_string(caml_jsstring_of_string(x))}
    function caml_vesta_double(x)
     {var res=plonk_wasm.caml_vesta_double(x);
      free_on_finalize(res);
      return res}
    function caml_pasta_fp_poseidon_block_cipher(_fake_params,fp_vector)
     {var
       wasm_flat_vector=
        plonk_wasm.caml_pasta_fp_poseidon_block_cipher
         (caml_fp_vector_to_rust(fp_vector)),
       new_fp_vector=caml_fp_vector_of_rust(wasm_flat_vector);
      new_fp_vector.forEach(function(a,i){fp_vector[i] = a})}
    function ml_z_testbit(z,pos)
     {z = bigInt(z);return z.shiftRight(pos).and(bigInt(1)).toJSNumber() | 0}
    function core_kernel_gc_major_plus_minor_words(){return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    var prover_to_json=plonk_wasm.prover_to_json;
    function caml_log2_float(x){return Math.log2(x)}
    function caml_pasta_fp_plonk_verifier_index_shifts(log2_size)
     {return caml_plonk_verification_shifts_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_verifier_index_shifts(log2_size))}
    function bin_prot_blit_bytes_buf_stub(src_pos,src,dst_pos,dst,len)
     {return caml_bigstring_blit_string_to_ba(src,src_pos,dst,dst_pos,len)}
    function caml_int64_sub(x,y){return x.sub(y)}
    function bin_prot_blit_buf_stub(src_pos,src,dst_pos,dst,len)
     {if(src.kind != 12)src = bigstring_of_typed_array(src.data);
      if(dst.kind != 12)dst = bigstring_of_typed_array(dst.data);
      return caml_bigstring_blit_ba_to_ba(src,src_pos,dst,dst_pos,len)}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_sys_const_int_size(){return 32}
    function caml_fp_srs_lagrange_commitment(t,domain_size,i)
     {var res=plonk_wasm.caml_fp_srs_lagrange_commitment(t,domain_size,i);
      return caml_vesta_poly_comm_of_rust(res)}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function ml_z_sqrt(z1)
     {var z=bigInt(z1),zero=bigInt(0);
      if(z.lt(zero))
       caml_invalid_argument("Z.sqrt: square root of a negative number");
      return ml_z_root(z,2)}
    function caml_fp_srs_batch_accumulator_check(srs,comms,chals)
     {var
       rust_comms=
        caml_array_to_rust_vector
         (comms,rust_affine_of_caml_affine,plonk_wasm.caml_vesta_affine_one),
       rust_chals=caml_fp_vector_to_rust(chals),
       ok=
        plonk_wasm.caml_fp_srs_batch_accumulator_check
         (srs,rust_comms,rust_chals);
      return ok}
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function deferred_value_exn(deferred)
     {if(! deferred.isDetermined)
       throw Error("Deferred has not returned yet.");
      if(deferred.isError)throw deferred.error;
      return deferred.value}
    function ml_z_probab_prime(z,i){return bigInt(z).isProbablePrime(i)?1:0}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    var caml_bigint_256_deep_copy=plonk_wasm.caml_bigint_256_deep_copy;
    function caml_fq_srs_add_lagrange_basis(srs,log2_size)
     {return plonk_wasm.caml_fq_srs_add_lagrange_basis(srs,log2_size)}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    var caml_pasta_fq_of_bigint=plonk_wasm.caml_pasta_fq_of_bigint;
    function caml_fq_vector_length(v){return v.length - 1}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(caml_jsbytes_of_string(name));
      return 0}
    function caml_hypot_float(x,y){return Math.hypot(x,y)}
    function caml_pasta_fp_plonk_index_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_pasta_fp_plonk_index_write
              (append,t,caml_jsstring_of_string(path))}
    function caml_pasta_fq_inv(x)
     {return caml_option_of_maybe_undefined(plonk_wasm.caml_pasta_fq_inv(x))}
    function caml_fp_vector_length(v){return v.length - 1}
    function ml_z_to_int(z1)
     {if(z1 == (z1 | 0))return z1 | 0;
      caml_raise_constant(caml_named_value("ml_z_overflow"))}
    function bigstringaf_blit_to_bytes(src,src_off,dst,dst_off,len)
     {for(var i=0;i < len;i++)
       caml_string_unsafe_set(dst,dst_off + i,caml_ba_get_1(src,src_off + i))}
    function caml_erfc_float(x){return 1 - caml_erf_float(x)}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_pasta_fp_inv(x)
     {return caml_option_of_maybe_undefined(plonk_wasm.caml_pasta_fp_inv(x))}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[5] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_const_big_endian(){return 0}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function core_kernel_gc_major_words(){return 0}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function integers_uint32_logand(x,y){return new UInt32(x.value & y.value)}
    function ml_z_succ(z1){return ml_z_normalize(bigInt(z1).next())}
    function unix_lstat(name)
     {var root=resolve_fs_device(name);
      if(! root.device.lstat)caml_failwith("unix_lstat: not implemented");
      return root.device.lstat(root.rest,true)}
    var unix_lstat_64=unix_lstat;
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_pasta_fq_plonk_proof_dummy()
     {return caml_pasta_fq_proof_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_proof_dummy())}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function integers_uint64_max(unit)
     {var x=caml_int64_create_lo_mi_hi(0xffffff,0xffffff,0xffff);
      x.hi = x.hi >>> 0;
      return new UInt64(x)}
    function integers_uint64_of_int64(i)
     {return new UInt64(caml_int64_create_lo_mi_hi(i.lo,i.mi,i.hi >>> 0))}
    function ml_z_gcd(z1,z2)
     {return ml_z_normalize(bigInt.gcd(bigInt(z1),bigInt(z2)).abs())}
    function caml_pasta_fp_to_bytes(x)
     {var res=plonk_wasm.caml_pasta_fp_to_bytes(x);
      return caml_bytes_of_uint8array(plonk_wasm.caml_pasta_fp_to_bytes(x))}
    function integers_size_t_size(unit){return 4}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    var
     caml_pasta_fp_plonk_index_domain_d4_size=
      plonk_wasm.caml_pasta_fp_plonk_index_domain_d4_size;
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function ml_z_div_rem(z1,z2){return [0,ml_z_div(z1,z2),ml_z_rem(z1,z2)]}
    function caml_sys_const_ostype_unix(){return os_type == "Unix"?1:0}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_pasta_fp_plonk_proof_example_with_ffadd()
     {throw new
             Error
             ("Unimplemented caml_pasta_fp_plonk_proof_example_with_ffadd")}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    function caml_fatal_uncaught_exception(err)
     {function throw_errors(err)
       {if(err instanceof Error)
         throw err;
        else
         if(Array.isArray(err))err.forEach(throw_errors)}
      throw_errors(err);
      console.dir(err,{depth:20});
      function collect_strings(err,acc)
       {var str=undefined;
        if(typeof err === "string")
         str = err;
        else
         if(err && err.constructor && err.constructor.name === "MlBytes")
          str = err.c;
         else
          if(Array.isArray(err))
           err.forEach(function(e){collect_strings(e,acc)});
        if(! str)return acc.string;
        if(acc.string === undefined)
         acc.string = str;
        else
         acc.string = acc.string + "\n" + str;
        return acc.string}
      var str=collect_strings(err,{});
      if(str !== undefined)throw joo_global_object.Error(str);
      console.dir(err,{depth:10});
      throw joo_global_object.Error("Unknown error thrown from OCaml")}
    function caml_pallas_rng(i)
     {var res=plonk_wasm.caml_pallas_rng(i);free_on_finalize(res);return res}
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_pasta_fq_plonk_index_create
     (gates,public_inputs,prev_challenges,urs)
     {return free_on_finalize
              (plonk_wasm.caml_pasta_fq_plonk_index_create
                (gates,public_inputs,prev_challenges,urs))}
    function caml_ml_set_channel_name(){return 0}
    function caml_exp2_float(x){return Math.pow(2,x)}
    var
     caml_pasta_fp_print=plonk_wasm.caml_pasta_fp_print,
     caml_pasta_fp_mul=plonk_wasm.caml_pasta_fp_mul;
    function caml_pasta_fp_mut_mul(x,y)
     {caml_pasta_fp_copy(x,caml_pasta_fp_mul(x,y))}
    function bigstring_memset_stub(bigstring,v_pos,v_len,v_char)
     {for(var i=0;i < v_len;i++)caml_ba_set_1(bigstring,v_pos + i,v_char)}
    var
     caml_pasta_fq_plonk_index_domain_d8_size=
      plonk_wasm.caml_pasta_fq_plonk_index_domain_d8_size,
     caml_pasta_fp_size_in_bits=plonk_wasm.caml_pasta_fp_size_in_bits;
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {var g=globalThis;
      if(typeof g.XMLHttpRequest !== "undefined")
       try {return new (g.XMLHttpRequest)()}catch(e){}
      if(typeof g.activeXObject !== "undefined")
       {try {return new (g.activeXObject)("Msxml2.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Msxml3.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Microsoft.XMLHTTP")}catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_ml_is_buffered(c){return 1}
    function caml_fq_plonk_gate_to_rust(gate)
     {return new
              (plonk_wasm.WasmFqGate)
              (gate[1],
               caml_plonk_wires_to_rust(gate[2]),
               caml_u8array_vector_to_rust_flat_vector(gate[3]))}
    function caml_pasta_fq_plonk_gate_vector_add(v,x)
     {return plonk_wasm.caml_pasta_fq_plonk_gate_vector_add
              (v,caml_fq_plonk_gate_to_rust(x))}
    function caml_vesta_one()
     {var res=plonk_wasm.caml_vesta_one();free_on_finalize(res);return res}
    function Base_int_math_int64_clz(x)
     {var n=64,y;
      y = caml_int64_shift_right_unsigned(x,32);
      if(! caml_int64_is_zero(y)){n = n - 32;x = y}
      y = caml_int64_shift_right_unsigned(x,16);
      if(! caml_int64_is_zero(y)){n = n - 16;x = y}
      y = caml_int64_shift_right_unsigned(x,8);
      if(! caml_int64_is_zero(y)){n = n - 8;x = y}
      y = caml_int64_shift_right_unsigned(x,4);
      if(! caml_int64_is_zero(y)){n = n - 4;x = y}
      y = caml_int64_shift_right_unsigned(x,2);
      if(! caml_int64_is_zero(y)){n = n - 2;x = y}
      y = caml_int64_shift_right_unsigned(x,1);
      if(! caml_int64_is_zero(y))return n - 2;
      return n - caml_int64_to_int32(x)}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    var
     caml_pallas_endo_base=plonk_wasm.caml_pallas_endo_base,
     caml_pasta_fp_div=plonk_wasm.caml_pasta_fp_div;
    function ml_z_sub(z1,z2)
     {return ml_z_normalize(bigInt(z1).subtract(bigInt(z2)))}
    function ml_z_fdiv(z1,z2)
     {var z1_pos=ml_z_sign(z1),z2_pos=ml_z_sign(z2);
      if(z1_pos * z2_pos < 0)
       if(! bigInt(z1).mod(bigInt(z2)).equals(bigInt(0)))
        return ml_z_sub(ml_z_div(z1,z2),bigInt(1));
      return ml_z_div(z1,z2)}
    function caml_fq_srs_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_fq_srs_write
              (append,t,caml_jsstring_of_string(path))}
    function ml_z_to_bits(z1)
     {z1 = bigInt(z1).abs();
      var res="";
      while(! z1.equals(bigInt(0)))
       {res += String.fromCharCode(z1.mod(bigInt(256)));
        z1 = z1.divide(bigInt(256))}
      while(res.length % 4 != 0)res += String.fromCharCode(0);
      return caml_string_of_jsbytes(res)}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    var
     caml_pasta_fp_domain_generator=
      plonk_wasm.caml_pasta_fp_domain_generator;
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function deferred_upon_exn(deferred,func)
     {deferred.promise.then(function(){func(deferred.value)})}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_sys_const_ostype_win32(){return os_type == "Win32"?1:0}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function integers_uint64_to_int(i){return caml_int64_to_int32(i.value)}
    function caml_pasta_fq_plonk_gate_vector_wrap(v,x,y)
     {return plonk_wasm.caml_pasta_fq_plonk_gate_vector_wrap
              (v,caml_plonk_wire_to_rust(x),caml_plonk_wire_to_rust(y))}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function core_kernel_gc_promoted_words(){return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {if(globalThis.crypto)
       if(typeof globalThis.crypto.getRandomValues === "function")
        {var a=new (globalThis.Uint32Array)(1);
         globalThis.crypto.getRandomValues(a);
         return [0,a[0]]}
       else
        if(globalThis.crypto.randomBytes === "function")
         {var
           buff=globalThis.crypto.randomBytes(4),
           a=new (globalThis.Uint32Array)(buff);
          return [0,a[0]]}
      var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_bigint_256_to_bytes(x)
     {return caml_bytes_of_uint8array(plonk_wasm.caml_bigint_256_to_bytes(x))}
    function core_kernel_gc_heap_chunks(){return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function ml_z_of_nativeint(z){return ml_z_of_int(z)}
    function ml_z_invert(a,n)
     {a = bigInt(a);
      n = bigInt(n);
      var zero=bigInt(0),one=bigInt(1);
      if(n.abs().equals(one))return 0;
      if(n.equals(zero) && a.abs().equals(one))return a;
      if(n.equals(zero) || a.equals(zero))caml_raise_zero_divide();
      var
       x=ml_z_gcdext_intern(a,n),
       r=bigInt(x[2]),
       tmp=bigInt(a).multiply(r).mod(n);
      if(tmp.lt(zero))tmp = tmp.add(n.abs());
      if(r.lt(zero))r = r.add(n.abs());
      if(tmp.equals(one))return ml_z_normalize(r);
      caml_raise_zero_divide()}
    function ml_z_powm(z1,z2,z3)
     {var zero=bigInt(0),one=bigInt(1);
      z1 = bigInt(z1);
      z2 = bigInt(z2);
      z3 = bigInt(z3);
      if(z3.equals(zero))caml_raise_zero_divide();
      if(z3.abs().equals(one))return 0;
      if(z2.equals(zero))return 1;
      if(z2.lt(0))
       {var inv=bigInt(ml_z_invert(z1,z3)),r=inv.modPow(z2.negate(),z3);
        if(r.lt(zero))r = r.add(z3.abs());
        return ml_z_normalize(r)}
      else
       {var r=bigInt(z1).modPow(z2,z3);
        if(r.lt(zero))r = r.add(z3.abs());
        return ml_z_normalize(r)}}
    function ml_z_powm_sec(z1,z2,z3)
     {z3 = bigInt(z3).abs();
      var one=bigInt(1);
      if(bigInt(z2).lt(one))
       caml_invalid_argument("Z.powm_sec: exponent must be positive");
      if(! bigInt(z3).and(one).equals(one))
       caml_invalid_argument("Z.powm_sec: modulus must be odd");
      return ml_z_powm(z1,z2,z3)}
    function caml_js_pure_expr(f){return f()}
    var core_array_unsafe_int_blit=caml_array_blit;
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_fq_srs_batch_accumulator_generate(srs,comms,chals)
     {var
       rust_chals=caml_fq_vector_to_rust(chals),
       rust_comms=
        plonk_wasm.caml_fq_srs_batch_accumulator_generate
         (srs,comms,rust_chals);
      return caml_array_of_rust_vector
              (rust_comms,
               plonk_wasm.WasmGPallas,
               rust_affine_to_caml_affine,
               false)}
    function caml_gr_sigio_handler(){return 0}
    var caml_pasta_fq_to_bigint=plonk_wasm.caml_pasta_fq_to_bigint;
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes(os_type),32,0]}
    function caml_fp_srs_read(offset,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      var
       res=
        plonk_wasm.caml_fp_srs_read(offset,caml_jsstring_of_string(path));
      return res?[0,res]:0}
    function deferred_bind(deferred,func)
     {var
       newDeferred=
        {promise:
         deferred.promise.then(func).then
            (function(anotherDeferred){return anotherDeferred.promise}).then
           (function(value)
             {newDeferred.value = value;
              newDeferred.isDetermined = true;
              return value}).catch
          (function(err)
            {newDeferred.error = err;
             newDeferred.isError = true;
             newDeferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return newDeferred}
    function caml_bigint_256_of_bytes(ocaml_bytes)
     {return plonk_wasm.caml_bigint_256_of_bytes
              (caml_bytes_to_uint8array(ocaml_bytes))}
    function caml_asinh_float(x){return Math.asinh(x)}
    var
     caml_pasta_fq_plonk_index_max_degree=
      plonk_wasm.caml_pasta_fq_plonk_index_max_degree;
    function core_kernel_gc_minor_collections(){return 0}
    function bigstring_of_array_buffer(ab)
     {var ta=new (globalThis.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    var caml_pasta_fq_size_in_bits=plonk_wasm.caml_pasta_fq_size_in_bits;
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_get_exception_backtrace(){return 0}
    function integers_uint64_compare(x,y)
     {x.value.hi = x.value.hi >>> 0;
      y.value.hi = y.value.hi >>> 0;
      return x.value.ucompare(y.value)}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=caml_trailing_slash(path.join("/"));
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function ml_z_equal(z1,z2){return bigInt(z1).equals(bigInt(z2))}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function ml_z_perfect_square(z)
     {z = bigInt(z);
      if(z.lt(bigInt(0)))return 0;
      var root=bigInt(ml_z_root(z,2));
      return root.multiply(root).eq(z)?1:0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function ml_z_to_nativeint(z1){return ml_z_to_int(z1)}
    function bigstringaf_memcmp_string(ba,ba_off,str,str_off,len)
     {for(var i=0;i < len;i++)
       {var
         c=
          caml_int_compare
           (caml_ba_get_1(ba,ba_off + i),
            caml_string_unsafe_get(str,str_off + i));
        if(c != 0)return c}
      return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && globalThis.toplevelReloc)
       n = globalThis.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function core_md5_digest_subbigstring(buf,ofs,len,res)
     {var bytes=caml_create_bytes(len);
      bigstring_blit_bigstring_bytes_stub(buf,ofs,bytes,0,len);
      var res2=caml_md5_string(caml_string_of_bytes(bytes),0,len);
      caml_blit_string(res2,0,res,0,16);
      return 0}
    function caml_fp_srs_create(i)
     {return free_on_finalize(plonk_wasm.caml_fp_srs_create(i))}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_get_major_credit(n){return 0}
    function caml_pallas_of_affine_coordinates(x,y)
     {var res=plonk_wasm.caml_pallas_of_affine_coordinates(x,y);
      free_on_finalize(res);
      return res}
    function caml_pasta_fp_plonk_proof_example_with_lookup()
     {throw new
             Error
             ("Unimplemented caml_pasta_fp_plonk_proof_example_with_lookup")}
    function deferred_map(deferred,func)
     {var
       newDeferred=
        {promise:
         deferred.promise.then(func).then
           (function(value)
             {newDeferred.value = value;
              newDeferred.isDetermined = true;
              return value}).catch
          (function(err)
            {newDeferred.error = err;
             newDeferred.isError = true;
             newDeferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return newDeferred}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function integers_uint64_shift_left(x,y)
     {return new UInt64(caml_int64_shift_left(x.value,y))}
    function caml_vesta_random()
     {var res=plonk_wasm.caml_vesta_random();free_on_finalize(res);return res}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_pasta_fq_div=plonk_wasm.caml_pasta_fq_div;
    function ml_z_logxor(z1,z2)
     {return ml_z_normalize(bigInt(z1).xor(bigInt(z2)))}
    var
     caml_pasta_fq_size=plonk_wasm.caml_pasta_fq_size,
     caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function ml_z_trailing_zeros(z)
     {z = bigInt(z).abs();
      var zero=bigInt(0),one=bigInt(1);
      if(z.equals(zero))return 0x7fffffff;
      var i=0;
      z = z.xor(z.prev()).shiftRight(1);
      for(i = 0;! z.equals(bigInt.zero);i++)z = z.shiftRight(1);
      return i}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_gc_minor_words(unit){return 0}
    function caml_pallas_scale(x,y)
     {var res=plonk_wasm.caml_pallas_scale(x,y);
      free_on_finalize(res);
      return res}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function unix_readlink(name)
     {var root=resolve_fs_device(name);
      if(! root.device.readlink)
       caml_failwith("unix_readlink: not implemented");
      return root.device.readlink(root.rest,true)}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_js_instanceof(o,c){return o instanceof c?1:0}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function integers_uint32_shift_right(x,y)
     {return new UInt32(x.value >>> y)}
    function caml_tanh_float(x){return Math.tanh(x)}
    function integers_uint_size(unit){return 4}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var
       path=caml_make_path(name),
       name=caml_trailing_slash(path.join("/")),
       idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    var caml_pasta_fq_negate=plonk_wasm.caml_pasta_fq_negate;
    function caml_pasta_fq_plonk_proof_deep_copy(proof)
     {return caml_pasta_fq_proof_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_proof_deep_copy
                (caml_pasta_fq_proof_to_rust(proof)))}
    function integers_ushort_size(unit){return 4}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (globalThis.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_sys_rmdir(name)
     {var root=resolve_fs_device(name);root.device.rmdir(root.rest);return 0}
    function Base_int_math_int64_ctz(x)
     {if(caml_int64_is_zero(x))return 64;
      var n=1;
      function is_zero(x){return caml_int64_is_zero(x)}
      function land(x,y){return caml_int64_and(x,y)}
      function small_int64(x){return caml_int64_create_lo_mi_hi(x,0,0)}
      if
       (is_zero(land(x,caml_int64_create_lo_mi_hi(0xFFFFFF,0x0000FF,0x0000))))
       {n = n + 32;x = caml_int64_shift_right_unsigned(x,32)}
      if(is_zero(land(x,small_int64(0x00FFFF))))
       {n = n + 16;x = caml_int64_shift_right_unsigned(x,16)}
      if(is_zero(land(x,small_int64(0x0000FF))))
       {n = n + 8;x = caml_int64_shift_right_unsigned(x,8)}
      if(is_zero(land(x,small_int64(0x00000F))))
       {n = n + 4;x = caml_int64_shift_right_unsigned(x,4)}
      if(is_zero(land(x,small_int64(0x000003))))
       {n = n + 2;x = caml_int64_shift_right_unsigned(x,2)}
      return n - caml_int64_to_int32(caml_int64_and(x,small_int64(0x000001)))}
    function integers_uint32_rem(x,y)
     {if(y.value == 0)caml_raise_zero_divide();
      return new UInt32(x.value % y.value)}
    function caml_bytes_notequal(s1,s2){return 1 - caml_bytes_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_pasta_fq_plonk_verifier_index_shifts(log2_size)
     {return caml_plonk_verification_shifts_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_shifts(log2_size))}
    function integers_uint64_shift_right(x,y)
     {return new UInt64(caml_int64_shift_right_unsigned(x.value,y))}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function caml_pasta_fp_plonk_proof_dummy()
     {return caml_pasta_fp_proof_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_proof_dummy())}
    function Base_internalhash_get_hash_value(seed)
     {var h=caml_hash_mix_final(seed);return h & 0x3FFFFFFF}
    function integers_uint64_sub(x,y)
     {return new UInt64(caml_int64_sub(x.value,y.value))}
    function caml_pasta_fq_plonk_index_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_pasta_fq_plonk_index_write
              (append,t,caml_jsstring_of_string(path))}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    var caml_pasta_fp_random=plonk_wasm.caml_pasta_fp_random;
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_pasta_fp_plonk_gate_vector_wrap(v,x,y)
     {return plonk_wasm.caml_pasta_fp_plonk_gate_vector_wrap
              (v,caml_plonk_wire_to_rust(x),caml_plonk_wire_to_rust(y))}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    function caml_fq_vector_create(){return [0]}
    var caml_pasta_fq_random=plonk_wasm.caml_pasta_fq_random;
    function ml_z_to_int32(z1){return ml_z_to_int(z1)}
    function caml_pasta_fp_plonk_verifier_index_dummy()
     {var res=plonk_wasm.caml_pasta_fp_plonk_verifier_index_dummy();
      return caml_pasta_fp_plonk_verifier_index_of_rust(res)}
    function deferred_upon(deferred,func)
     {deferred.promise.then(function(){func(deferred.value)}).catch
       (function(){})}
    function deferred_run(func)
     {var
       deferred=
        {promise:
         Promise.resolve().then(func).then
           (function(value)
             {deferred.value = value;
              deferred.isDetermined = true;
              return value}).catch
          (function(err)
            {deferred.error = err;
             deferred.isError = true;
             deferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return deferred}
    function unix_getpwuid(unit){caml_raise_not_found()}
    function caml_pasta_fp_plonk_proof_example_with_rot()
     {throw new
             Error
             ("Unimplemented caml_pasta_fp_plonk_proof_example_with_rot")}
    function caml_pasta_fp_plonk_proof_batch_verify(indexes,proofs)
     {indexes
      =
      caml_array_to_rust_vector
       (indexes,caml_pasta_fp_plonk_verifier_index_to_rust);
      proofs = caml_array_to_rust_vector(proofs,caml_pasta_fp_proof_to_rust);
      return plonk_wasm.caml_pasta_fp_plonk_proof_batch_verify(indexes,proofs)}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function core_kernel_gc_major_collections(){return 0}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_js_error_option_of_exception(exn)
     {if(exn.js_error)return [0,exn.js_error];return 0}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function ml_z_of_float(f1)
     {if(f1 == Infinity || f1 == - Infinity || f1 != f1)
       caml_raise_constant(caml_named_value("ml_z_overflow"));
      return ml_z_normalize(bigInt(f1 < 0?Math.ceil(f1):Math.floor(f1)))}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_pasta_fp_plonk_gate_vector_len(v)
     {return plonk_wasm.caml_pasta_fp_plonk_gate_vector_len(v)}
    function caml_floatarray_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function fq_oracles_dummy()
     {return caml_oracles_of_rust(plonk_wasm.fq_oracles_dummy())}
    function deferred_return(value)
     {return {promise:Promise.resolve(value),
              value:value,
              isError:false,
              isDetermined:true}}
    function Base_hash_double(d){return caml_hash(1,1,0,d)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    var
     caml_pasta_fp_two_adic_root_of_unity=
      plonk_wasm.caml_pasta_fp_two_adic_root_of_unity;
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function caml_pasta_fq_of_string(x)
     {return plonk_wasm.caml_pasta_fq_of_string(caml_jsstring_of_string(x))}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function integers_uint64_hash(v){return caml_int64_hash(v.value)}
    function caml_cbrt_float(x){return Math.cbrt(x)}
    function caml_eventlog_pause(unit){return 0}
    function core_kernel_gc_heap_words(){return 0}
    function bigstringaf_blit_to_bigstring(src,src_off,dst,dst_off,len)
     {for(var i=0;i < len;i++)
       caml_ba_set_1(dst,dst_off + i,caml_ba_get_1(src,src_off + i))}
    function caml_pallas_one()
     {var res=plonk_wasm.caml_pallas_one();free_on_finalize(res);return res}
    var ms_to_nano=caml_int64_of_int32(1000 * 1000);
    function time_now_nanoseconds_since_unix_epoch_or_zero()
     {var ms=Date.now(),ms_i63=caml_int64_of_float(ms * 2);
      return caml_int64_mul(ms_i63,ms_to_nano)}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    var
     caml_bigint_256_bytes_per_limb=
      plonk_wasm.caml_bigint_256_bytes_per_limb;
    function caml_js_on_ie()
     {var ua=globalThis.navigator?globalThis.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_ba_layout(ba){return ba.layout}
    function integers_int32_of_uint32(i){return i.value | 0}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function ml_z_perfect_power(z)
     {z = bigInt(z);
      var zero=bigInt(0),one=bigInt(1);
      if(z.equals(zero) || z.equals(one) || z.equals(one.negate()))return 1;
      var log2z=ml_z_numbits(z.abs());
      for(var b=2;b <= log2z;b++)
       {if(z.lt(zero) && b % 2 == 0)continue;
        var zp=z.abs(),p=bigInt(ml_z_root(zp,b));
        if(z.lt(zero))p = p.negate();
        var r=bigInt(ml_z_pow(p,b));
        if(z.equals(r))return 1}
      return 0}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_pasta_fp_plonk_gate_vector_get(v,i)
     {return caml_plonk_gate_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_gate_vector_get(v,i))}
    function integers_uint32_logor(x,y){return new UInt32(x.value | y.value)}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    var
     caml_pasta_fq_plonk_index_public_inputs=
      plonk_wasm.caml_pasta_fq_plonk_index_public_inputs;
    function caml_pasta_fq_to_string(x)
     {return caml_string_of_jsstring(plonk_wasm.caml_pasta_fq_to_string(x))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function ml_z_format(fmt,z1)
     {z1 = bigInt(z1);
      var
       fmt=caml_jsbytes_of_string(fmt),
       base=10,
       cas=0,
       width=0,
       alt=0,
       dir=0,
       sign="",
       pad=" ",
       idx=0,
       prefix="";
      while(fmt[idx] == "%")idx++;
      for(;;idx++)
       if(fmt[idx] == "#")
        alt = 1;
       else
        if(fmt[idx] == "0")
         pad = "0";
        else
         if(fmt[idx] == "-")
          dir = 1;
         else
          if(fmt[idx] == " " || fmt[idx] == "+")sign = fmt[idx];else break;
      if(z1.lt(bigInt(0))){sign = "-";z1 = z1.negate()}
      for(;fmt[idx] >= "0" && fmt[idx] <= "9";idx++)
       width = 10 * width + + fmt[idx];
      switch(fmt[idx])
       {case "i":
        case "d":
        case "u":break;
        case "b":base = 2;if(alt)prefix = "0b";break;
        case "o":base = 8;if(alt)prefix = "0o";break;
        case "x":base = 16;if(alt)prefix = "0x";break;
        case "X":base = 16;if(alt)prefix = "0X";cas = 1;break;
        default:caml_failwith("Unsupported format '" + fmt + "'")}
      if(dir)pad = " ";
      var res=z1.toString(base);
      if(cas === 1)res = res.toUpperCase();
      var size=res.length;
      if(pad == " ")
       if(dir)
        {res = sign + prefix + res;for(;res.length < width;)res = res + pad}
       else
        {res = sign + prefix + res;for(;res.length < width;)res = pad + res}
      else
       {var pre=sign + prefix;
        for(;res.length + pre.length < width;)res = pad + res;
        res = pre + res}
      return caml_string_of_jsbytes(res)}
    function fq_oracles_deep_copy(x)
     {return caml_oracles_of_rust
              (plonk_wasm.fq_oracles_deep_copy
                (caml_oracles_to_rust
                  (x,plonk_wasm.WasmFqOracles,plonk_wasm.WasmFqRandomOracles)))}
    function caml_sys_argv(a){return caml_argv}
    function caml_install_signal_handler(){return 0}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function ml_z_shift_right_trunc(z1,z2)
     {return ml_z_div(bigInt(z1),bigInt(2).pow(z2))}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function integers_unsigned_init(unit)
     {caml_custom_ops["integers:uint8"]
      =
      {deserialize:integers_uint8_deserialize,fixed_length:1};
      caml_custom_ops["integers:uint16"]
      =
      {deserialize:integers_uint16_deserialize,fixed_length:2};
      caml_custom_ops["integers:uint32"]
      =
      {serialize:integers_uint32_serialize,
       deserialize:integers_uint32_deserialize,
       fixed_length:4,
       hash:integers_uint32_hash,
       compare:integers_uint32_compare};
      caml_custom_ops["integers:uint64"]
      =
      {serialize:integers_uint64_marshal,
       deserialize:integers_uint64_unmarshal,
       hash:integers_uint64_hash,
       compare:integers_uint64_compare};
      return unit}
    function integers_uint64_add(x,y)
     {return new UInt64(caml_int64_add(x.value,y.value))}
    function caml_pallas_add(x,y)
     {var res=plonk_wasm.caml_pallas_add(x,y);
      free_on_finalize(res);
      return res}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_pasta_fq_plonk_proof_batch_verify(indexes,proofs)
     {indexes
      =
      caml_array_to_rust_vector
       (indexes,caml_pasta_fq_plonk_verifier_index_to_rust);
      proofs = caml_array_to_rust_vector(proofs,caml_pasta_fq_proof_to_rust);
      return plonk_wasm.caml_pasta_fq_plonk_proof_batch_verify(indexes,proofs)}
    function caml_setup_uncaught_exception_handler()
     {var g=globalThis;
      if(g.process && g.process.on)
       g.process.on
        ("uncaughtException",
         function(err,origin)
          {caml_fatal_uncaught_exception(err);g.process.exit(2)});
      else
       if(g.addEventListener)
        g.addEventListener
         ("error",
          function(event)
           {if(event.error)caml_fatal_uncaught_exception(event.error)})}
    caml_setup_uncaught_exception_handler();
    globalThis.jsoo_runtime
    =
    {caml_raise_with_string:caml_raise_with_string,
     custom_reraise_exn:custom_reraise_exn,
     caml_fatal_uncaught_exception:caml_fatal_uncaught_exception,
     plonk_wasm:plonk_wasm,
     UInt32:UInt32,
     integers_int32_of_uint32:integers_int32_of_uint32,
     integers_size_t_size:integers_size_t_size,
     integers_uint16_of_string:integers_uint16_of_string,
     integers_uint32_add:integers_uint32_add,
     integers_uint32_sub:integers_uint32_sub,
     integers_uint32_div:integers_uint32_div,
     integers_uint32_logand:integers_uint32_logand,
     integers_uint32_logor:integers_uint32_logor,
     integers_uint32_logxor:integers_uint32_logxor,
     integers_uint32_max:integers_uint32_max,
     integers_uint32_mul:integers_uint32_mul,
     integers_uint32_of_int:integers_uint32_of_int,
     integers_uint32_of_int32:integers_uint32_of_int32,
     integers_uint32_of_int64:integers_uint32_of_int64,
     integers_uint32_of_string:integers_uint32_of_string,
     integers_uint32_rem:integers_uint32_rem,
     integers_uint32_shift_left:integers_uint32_shift_left,
     integers_uint32_shift_right:integers_uint32_shift_right,
     integers_uint32_to_int:integers_uint32_to_int,
     integers_uint32_to_int64:integers_uint32_to_int64,
     integers_uint32_to_string:integers_uint32_to_string,
     UInt64:UInt64,
     integers_uint64_add:integers_uint64_add,
     integers_uint64_div:integers_uint64_div,
     integers_uint64_logand:integers_uint64_logand,
     integers_uint64_logor:integers_uint64_logor,
     integers_uint64_logxor:integers_uint64_logxor,
     integers_uint64_max:integers_uint64_max,
     integers_uint64_mul:integers_uint64_mul,
     integers_uint64_of_int:integers_uint64_of_int,
     integers_uint64_of_int64:integers_uint64_of_int64,
     integers_uint_of_string:integers_uint_of_string,
     integers_uint64_of_string:integers_uint64_of_string,
     integers_uint64_rem:integers_uint64_rem,
     integers_uint64_shift_left:integers_uint64_shift_left,
     integers_uint64_shift_right:integers_uint64_shift_right,
     integers_uint64_sub:integers_uint64_sub,
     integers_uint64_to_int:integers_uint64_to_int,
     integers_uint64_to_int64:integers_uint64_to_int64,
     integers_uint64_to_string:integers_uint64_to_string,
     integers_uint64_unmarshal:integers_uint64_unmarshal,
     integers_uint64_marshal:integers_uint64_marshal,
     integers_uint64_hash:integers_uint64_hash,
     integers_uint8_of_string:integers_uint8_of_string,
     integers_uint_size:integers_uint_size,
     integers_ulong_size:integers_ulong_size,
     integers_ulonglong_size:integers_ulonglong_size,
     integers_unsigned_init:integers_unsigned_init,
     integers_ushort_size:integers_ushort_size,
     integers_uint32_serialize:integers_uint32_serialize,
     integers_uint8_deserialize:integers_uint8_deserialize,
     integers_uint16_deserialize:integers_uint16_deserialize,
     integers_uint32_deserialize:integers_uint32_deserialize,
     integers_uint32_hash:integers_uint32_hash,
     integers_uint32_compare:integers_uint32_compare,
     integers_uint64_compare:integers_uint64_compare,
     caml_bytes_of_uint8array:caml_bytes_of_uint8array,
     caml_bytes_to_uint8array:caml_bytes_to_uint8array,
     caml_bigint_256_of_numeral:caml_bigint_256_of_numeral,
     caml_bigint_256_of_decimal_string:caml_bigint_256_of_decimal_string,
     caml_bigint_256_num_limbs:caml_bigint_256_num_limbs,
     caml_bigint_256_bytes_per_limb:caml_bigint_256_bytes_per_limb,
     caml_bigint_256_div:caml_bigint_256_div,
     caml_bigint_256_compare:caml_bigint_256_compare,
     caml_bigint_256_print:caml_bigint_256_print,
     caml_bigint_256_to_string:caml_bigint_256_to_string,
     caml_bigint_256_test_bit:caml_bigint_256_test_bit,
     caml_bigint_256_to_bytes:caml_bigint_256_to_bytes,
     caml_bigint_256_of_bytes:caml_bigint_256_of_bytes,
     caml_bigint_256_deep_copy:caml_bigint_256_deep_copy,
     caml_pasta_fp_copy:caml_pasta_fp_copy,
     caml_option_of_maybe_undefined:caml_option_of_maybe_undefined,
     caml_option_to_maybe_undefined:caml_option_to_maybe_undefined,
     caml_pasta_fp_size_in_bits:caml_pasta_fp_size_in_bits,
     caml_pasta_fp_size:caml_pasta_fp_size,
     caml_pasta_fp_add:caml_pasta_fp_add,
     caml_pasta_fp_sub:caml_pasta_fp_sub,
     caml_pasta_fp_negate:caml_pasta_fp_negate,
     caml_pasta_fp_mul:caml_pasta_fp_mul,
     caml_pasta_fp_div:caml_pasta_fp_div,
     caml_pasta_fp_inv:caml_pasta_fp_inv,
     caml_pasta_fp_square:caml_pasta_fp_square,
     caml_pasta_fp_is_square:caml_pasta_fp_is_square,
     caml_pasta_fp_sqrt:caml_pasta_fp_sqrt,
     caml_pasta_fp_of_int:caml_pasta_fp_of_int,
     caml_pasta_fp_to_string:caml_pasta_fp_to_string,
     caml_pasta_fp_of_string:caml_pasta_fp_of_string,
     caml_pasta_fp_print:caml_pasta_fp_print,
     caml_pasta_fp_mut_add:caml_pasta_fp_mut_add,
     caml_pasta_fp_mut_sub:caml_pasta_fp_mut_sub,
     caml_pasta_fp_mut_mul:caml_pasta_fp_mut_mul,
     caml_pasta_fp_mut_square:caml_pasta_fp_mut_square,
     caml_pasta_fp_compare:caml_pasta_fp_compare,
     caml_pasta_fp_equal:caml_pasta_fp_equal,
     caml_pasta_fp_random:caml_pasta_fp_random,
     caml_pasta_fp_rng:caml_pasta_fp_rng,
     caml_pasta_fp_to_bigint:caml_pasta_fp_to_bigint,
     caml_pasta_fp_of_bigint:caml_pasta_fp_of_bigint,
     caml_pasta_fp_two_adic_root_of_unity:caml_pasta_fp_two_adic_root_of_unity,
     caml_pasta_fp_domain_generator:caml_pasta_fp_domain_generator,
     caml_pasta_fp_to_bytes:caml_pasta_fp_to_bytes,
     caml_pasta_fp_of_bytes:caml_pasta_fp_of_bytes,
     caml_pasta_fp_deep_copy:caml_pasta_fp_deep_copy,
     caml_pasta_fq_copy:caml_pasta_fq_copy,
     caml_pasta_fq_size_in_bits:caml_pasta_fq_size_in_bits,
     caml_pasta_fq_size:caml_pasta_fq_size,
     caml_pasta_fq_add:caml_pasta_fq_add,
     caml_pasta_fq_sub:caml_pasta_fq_sub,
     caml_pasta_fq_negate:caml_pasta_fq_negate,
     caml_pasta_fq_mul:caml_pasta_fq_mul,
     caml_pasta_fq_div:caml_pasta_fq_div,
     caml_pasta_fq_inv:caml_pasta_fq_inv,
     caml_pasta_fq_square:caml_pasta_fq_square,
     caml_pasta_fq_is_square:caml_pasta_fq_is_square,
     caml_pasta_fq_sqrt:caml_pasta_fq_sqrt,
     caml_pasta_fq_of_int:caml_pasta_fq_of_int,
     caml_pasta_fq_to_string:caml_pasta_fq_to_string,
     caml_pasta_fq_of_string:caml_pasta_fq_of_string,
     caml_pasta_fq_print:caml_pasta_fq_print,
     caml_pasta_fq_mut_add:caml_pasta_fq_mut_add,
     caml_pasta_fq_mut_sub:caml_pasta_fq_mut_sub,
     caml_pasta_fq_mut_mul:caml_pasta_fq_mut_mul,
     caml_pasta_fq_mut_square:caml_pasta_fq_mut_square,
     caml_pasta_fq_compare:caml_pasta_fq_compare,
     caml_pasta_fq_equal:caml_pasta_fq_equal,
     caml_pasta_fq_random:caml_pasta_fq_random,
     caml_pasta_fq_rng:caml_pasta_fq_rng,
     caml_pasta_fq_to_bigint:caml_pasta_fq_to_bigint,
     caml_pasta_fq_of_bigint:caml_pasta_fq_of_bigint,
     caml_pasta_fq_two_adic_root_of_unity:caml_pasta_fq_two_adic_root_of_unity,
     caml_pasta_fq_domain_generator:caml_pasta_fq_domain_generator,
     caml_pasta_fq_to_bytes:caml_pasta_fq_to_bytes,
     caml_pasta_fq_of_bytes:caml_pasta_fq_of_bytes,
     caml_pasta_fq_deep_copy:caml_pasta_fq_deep_copy,
     caml_u8array_vector_to_rust_flat_vector:
     caml_u8array_vector_to_rust_flat_vector,
     caml_u8array_vector_of_rust_flat_vector:
     caml_u8array_vector_of_rust_flat_vector,
     js_class_vector_to_rust_vector:js_class_vector_to_rust_vector,
     js_class_vector_of_rust_vector:js_class_vector_of_rust_vector,
     caml_fp_vector_create:caml_fp_vector_create,
     caml_fp_vector_length:caml_fp_vector_length,
     caml_fp_vector_emplace_back:caml_fp_vector_emplace_back,
     caml_fp_vector_get:caml_fp_vector_get,
     caml_fp_vector_to_rust:caml_fp_vector_to_rust,
     caml_fp_vector_of_rust:caml_fp_vector_of_rust,
     caml_fq_vector_create:caml_fq_vector_create,
     caml_fq_vector_length:caml_fq_vector_length,
     caml_fq_vector_emplace_back:caml_fq_vector_emplace_back,
     caml_fq_vector_get:caml_fq_vector_get,
     caml_fq_vector_to_rust:caml_fq_vector_to_rust,
     caml_fq_vector_of_rust:caml_fq_vector_of_rust,
     free_finalization_registry:free_finalization_registry,
     free_on_finalize:free_on_finalize,
     rust_affine_to_caml_affine:rust_affine_to_caml_affine,
     rust_affine_of_caml_affine:rust_affine_of_caml_affine,
     caml_pallas_one:caml_pallas_one,
     caml_pallas_add:caml_pallas_add,
     caml_pallas_sub:caml_pallas_sub,
     caml_pallas_negate:caml_pallas_negate,
     caml_pallas_double:caml_pallas_double,
     caml_pallas_scale:caml_pallas_scale,
     caml_pallas_random:caml_pallas_random,
     caml_pallas_rng:caml_pallas_rng,
     caml_pallas_to_affine:caml_pallas_to_affine,
     caml_pallas_of_affine:caml_pallas_of_affine,
     caml_pallas_of_affine_coordinates:caml_pallas_of_affine_coordinates,
     caml_pallas_endo_base:caml_pallas_endo_base,
     caml_pallas_endo_scalar:caml_pallas_endo_scalar,
     caml_pallas_affine_deep_copy:caml_pallas_affine_deep_copy,
     caml_vesta_one:caml_vesta_one,
     caml_vesta_add:caml_vesta_add,
     caml_vesta_sub:caml_vesta_sub,
     caml_vesta_negate:caml_vesta_negate,
     caml_vesta_double:caml_vesta_double,
     caml_vesta_scale:caml_vesta_scale,
     caml_vesta_random:caml_vesta_random,
     caml_vesta_rng:caml_vesta_rng,
     caml_vesta_to_affine:caml_vesta_to_affine,
     caml_vesta_of_affine:caml_vesta_of_affine,
     caml_vesta_of_affine_coordinates:caml_vesta_of_affine_coordinates,
     caml_vesta_endo_base:caml_vesta_endo_base,
     caml_vesta_endo_scalar:caml_vesta_endo_scalar,
     caml_vesta_affine_deep_copy:caml_vesta_affine_deep_copy,
     caml_array_of_rust_vector:caml_array_of_rust_vector,
     caml_array_to_rust_vector:caml_array_to_rust_vector,
     caml_poly_comm_of_rust_poly_comm:caml_poly_comm_of_rust_poly_comm,
     caml_poly_comm_to_rust_poly_comm:caml_poly_comm_to_rust_poly_comm,
     caml_vesta_poly_comm_of_rust:caml_vesta_poly_comm_of_rust,
     caml_vesta_poly_comm_to_rust:caml_vesta_poly_comm_to_rust,
     caml_pallas_poly_comm_of_rust:caml_pallas_poly_comm_of_rust,
     caml_pallas_poly_comm_to_rust:caml_pallas_poly_comm_to_rust,
     caml_fp_srs_create:caml_fp_srs_create,
     caml_fp_srs_write:caml_fp_srs_write,
     caml_fp_srs_read:caml_fp_srs_read,
     caml_fp_srs_lagrange_commitment:caml_fp_srs_lagrange_commitment,
     caml_fp_srs_commit_evaluations:caml_fp_srs_commit_evaluations,
     caml_fp_srs_b_poly_commitment:caml_fp_srs_b_poly_commitment,
     caml_fp_srs_batch_accumulator_check:caml_fp_srs_batch_accumulator_check,
     caml_fp_srs_batch_accumulator_generate:
     caml_fp_srs_batch_accumulator_generate,
     caml_fp_srs_h:caml_fp_srs_h,
     caml_fq_srs_create:caml_fq_srs_create,
     caml_fq_srs_write:caml_fq_srs_write,
     caml_fq_srs_read:caml_fq_srs_read,
     caml_fq_srs_lagrange_commitment:caml_fq_srs_lagrange_commitment,
     caml_fq_srs_commit_evaluations:caml_fq_srs_commit_evaluations,
     caml_fq_srs_b_poly_commitment:caml_fq_srs_b_poly_commitment,
     caml_fq_srs_batch_accumulator_check:caml_fq_srs_batch_accumulator_check,
     caml_fq_srs_batch_accumulator_generate:
     caml_fq_srs_batch_accumulator_generate,
     caml_fq_srs_h:caml_fq_srs_h,
     caml_fq_srs_add_lagrange_basis:caml_fq_srs_add_lagrange_basis,
     caml_plonk_wire_of_rust:caml_plonk_wire_of_rust,
     caml_plonk_wire_to_rust:caml_plonk_wire_to_rust,
     caml_plonk_wires_of_rust:caml_plonk_wires_of_rust,
     caml_plonk_wires_to_rust:caml_plonk_wires_to_rust,
     caml_plonk_gate_of_rust:caml_plonk_gate_of_rust,
     caml_fp_plonk_gate_to_rust:caml_fp_plonk_gate_to_rust,
     caml_fq_plonk_gate_to_rust:caml_fq_plonk_gate_to_rust,
     caml_pasta_fp_plonk_gate_vector_create:
     caml_pasta_fp_plonk_gate_vector_create,
     caml_pasta_fp_plonk_gate_vector_add:caml_pasta_fp_plonk_gate_vector_add,
     caml_pasta_fp_plonk_gate_vector_get:caml_pasta_fp_plonk_gate_vector_get,
     caml_pasta_fp_plonk_gate_vector_len:caml_pasta_fp_plonk_gate_vector_len,
     caml_pasta_fp_plonk_gate_vector_wrap:caml_pasta_fp_plonk_gate_vector_wrap,
     caml_pasta_fp_plonk_gate_vector_digest:
     caml_pasta_fp_plonk_gate_vector_digest,
     caml_pasta_fp_plonk_circuit_serialize:
     caml_pasta_fp_plonk_circuit_serialize,
     caml_pasta_fq_plonk_gate_vector_create:
     caml_pasta_fq_plonk_gate_vector_create,
     caml_pasta_fq_plonk_gate_vector_add:caml_pasta_fq_plonk_gate_vector_add,
     caml_pasta_fq_plonk_gate_vector_get:caml_pasta_fq_plonk_gate_vector_get,
     caml_pasta_fq_plonk_gate_vector_len:caml_pasta_fq_plonk_gate_vector_len,
     caml_pasta_fq_plonk_gate_vector_wrap:caml_pasta_fq_plonk_gate_vector_wrap,
     caml_pasta_fq_plonk_gate_vector_digest:
     caml_pasta_fq_plonk_gate_vector_digest,
     caml_pasta_fq_plonk_circuit_serialize:
     caml_pasta_fq_plonk_circuit_serialize,
     caml_pasta_fp_plonk_index_create:caml_pasta_fp_plonk_index_create,
     caml_pasta_fp_plonk_index_max_degree:caml_pasta_fp_plonk_index_max_degree,
     caml_pasta_fp_plonk_index_public_inputs:
     caml_pasta_fp_plonk_index_public_inputs,
     caml_pasta_fp_plonk_index_domain_d1_size:
     caml_pasta_fp_plonk_index_domain_d1_size,
     caml_pasta_fp_plonk_index_domain_d4_size:
     caml_pasta_fp_plonk_index_domain_d4_size,
     caml_pasta_fp_plonk_index_domain_d8_size:
     caml_pasta_fp_plonk_index_domain_d8_size,
     caml_pasta_fp_plonk_index_read:caml_pasta_fp_plonk_index_read,
     caml_pasta_fp_plonk_index_write:caml_pasta_fp_plonk_index_write,
     caml_pasta_fq_plonk_index_create:caml_pasta_fq_plonk_index_create,
     caml_pasta_fq_plonk_index_max_degree:caml_pasta_fq_plonk_index_max_degree,
     caml_pasta_fq_plonk_index_public_inputs:
     caml_pasta_fq_plonk_index_public_inputs,
     caml_pasta_fq_plonk_index_domain_d1_size:
     caml_pasta_fq_plonk_index_domain_d1_size,
     caml_pasta_fq_plonk_index_domain_d4_size:
     caml_pasta_fq_plonk_index_domain_d4_size,
     caml_pasta_fq_plonk_index_domain_d8_size:
     caml_pasta_fq_plonk_index_domain_d8_size,
     caml_pasta_fq_plonk_index_read:caml_pasta_fq_plonk_index_read,
     caml_pasta_fq_plonk_index_write:caml_pasta_fq_plonk_index_write,
     caml_plonk_domain_of_rust:caml_plonk_domain_of_rust,
     caml_plonk_domain_to_rust:caml_plonk_domain_to_rust,
     caml_plonk_verification_evals_of_rust:
     caml_plonk_verification_evals_of_rust,
     caml_plonk_verification_evals_to_rust:
     caml_plonk_verification_evals_to_rust,
     caml_plonk_verification_shifts_of_rust:
     caml_plonk_verification_shifts_of_rust,
     caml_plonk_verification_shifts_to_rust:
     caml_plonk_verification_shifts_to_rust,
     column_of_rust:column_of_rust,
     variable_of_rust:variable_of_rust,
     polish_token_of_rust:polish_token_of_rust,
     index_term_of_rust:index_term_of_rust,
     wrap:wrap,
     linearization_of_rust:linearization_of_rust,
     None:None,
     caml_plonk_verifier_index_of_rust:caml_plonk_verifier_index_of_rust,
     caml_plonk_verifier_index_to_rust:caml_plonk_verifier_index_to_rust,
     caml_pasta_fp_plonk_verifier_index_of_rust:
     caml_pasta_fp_plonk_verifier_index_of_rust,
     caml_pasta_fp_plonk_verifier_index_to_rust:
     caml_pasta_fp_plonk_verifier_index_to_rust,
     caml_pasta_fp_plonk_verifier_index_create:
     caml_pasta_fp_plonk_verifier_index_create,
     caml_pasta_fp_plonk_verifier_index_read:
     caml_pasta_fp_plonk_verifier_index_read,
     caml_pasta_fp_plonk_verifier_index_write:
     caml_pasta_fp_plonk_verifier_index_write,
     caml_pasta_fp_plonk_verifier_index_shifts:
     caml_pasta_fp_plonk_verifier_index_shifts,
     caml_pasta_fp_plonk_verifier_index_dummy:
     caml_pasta_fp_plonk_verifier_index_dummy,
     caml_pasta_fp_plonk_verifier_index_deep_copy:
     caml_pasta_fp_plonk_verifier_index_deep_copy,
     caml_pasta_fq_plonk_verifier_index_of_rust:
     caml_pasta_fq_plonk_verifier_index_of_rust,
     caml_pasta_fq_plonk_verifier_index_to_rust:
     caml_pasta_fq_plonk_verifier_index_to_rust,
     caml_pasta_fq_plonk_verifier_index_create:
     caml_pasta_fq_plonk_verifier_index_create,
     caml_pasta_fq_plonk_verifier_index_read:
     caml_pasta_fq_plonk_verifier_index_read,
     caml_pasta_fq_plonk_verifier_index_write:
     caml_pasta_fq_plonk_verifier_index_write,
     caml_pasta_fq_plonk_verifier_index_shifts:
     caml_pasta_fq_plonk_verifier_index_shifts,
     caml_pasta_fq_plonk_verifier_index_dummy:
     caml_pasta_fq_plonk_verifier_index_dummy,
     caml_pasta_fq_plonk_verifier_index_deep_copy:
     caml_pasta_fq_plonk_verifier_index_deep_copy,
     COLUMNS:COLUMNS,
     PERMUTS_MINUS_1:PERMUTS_MINUS_1,
     caml_pasta_fp_proof_evaluations_to_rust:
     caml_pasta_fp_proof_evaluations_to_rust,
     caml_pasta_fp_proof_evaluations_of_rust:
     caml_pasta_fp_proof_evaluations_of_rust,
     caml_pasta_fp_opening_proof_to_rust:caml_pasta_fp_opening_proof_to_rust,
     caml_pasta_fp_opening_proof_of_rust:caml_pasta_fp_opening_proof_of_rust,
     caml_pasta_fp_commitments_to_rust:caml_pasta_fp_commitments_to_rust,
     caml_pasta_fp_commitments_of_rust:caml_pasta_fp_commitments_of_rust,
     caml_pasta_fp_proof_to_rust:caml_pasta_fp_proof_to_rust,
     caml_pasta_fp_proof_of_rust:caml_pasta_fp_proof_of_rust,
     caml_pasta_fp_plonk_proof_create:caml_pasta_fp_plonk_proof_create,
     caml_pasta_fp_plonk_proof_verify:caml_pasta_fp_plonk_proof_verify,
     caml_pasta_fp_plonk_proof_batch_verify:
     caml_pasta_fp_plonk_proof_batch_verify,
     caml_pasta_fp_plonk_proof_dummy:caml_pasta_fp_plonk_proof_dummy,
     caml_pasta_fp_plonk_proof_deep_copy:caml_pasta_fp_plonk_proof_deep_copy,
     caml_pasta_fq_proof_evaluations_to_rust:
     caml_pasta_fq_proof_evaluations_to_rust,
     caml_pasta_fq_proof_evaluations_of_rust:
     caml_pasta_fq_proof_evaluations_of_rust,
     caml_pasta_fq_opening_proof_to_rust:caml_pasta_fq_opening_proof_to_rust,
     caml_pasta_fq_opening_proof_of_rust:caml_pasta_fq_opening_proof_of_rust,
     caml_pasta_fq_commitments_to_rust:caml_pasta_fq_commitments_to_rust,
     caml_pasta_fq_commitments_of_rust:caml_pasta_fq_commitments_of_rust,
     caml_pasta_fq_proof_to_rust:caml_pasta_fq_proof_to_rust,
     caml_pasta_fq_proof_of_rust:caml_pasta_fq_proof_of_rust,
     caml_pasta_fq_plonk_proof_create:caml_pasta_fq_plonk_proof_create,
     caml_pasta_fq_plonk_proof_verify:caml_pasta_fq_plonk_proof_verify,
     caml_pasta_fq_plonk_proof_batch_verify:
     caml_pasta_fq_plonk_proof_batch_verify,
     caml_pasta_fq_plonk_proof_dummy:caml_pasta_fq_plonk_proof_dummy,
     caml_pasta_fq_plonk_proof_deep_copy:caml_pasta_fq_plonk_proof_deep_copy,
     caml_random_oracles_of_rust:caml_random_oracles_of_rust,
     caml_random_oracles_to_rust:caml_random_oracles_to_rust,
     caml_oracles_of_rust:caml_oracles_of_rust,
     caml_oracles_to_rust:caml_oracles_to_rust,
     fp_oracles_create:fp_oracles_create,
     fp_oracles_dummy:fp_oracles_dummy,
     fp_oracles_deep_copy:fp_oracles_deep_copy,
     fq_oracles_create:fq_oracles_create,
     fq_oracles_dummy:fq_oracles_dummy,
     fq_oracles_deep_copy:fq_oracles_deep_copy,
     caml_pasta_fp_poseidon_params_create:caml_pasta_fp_poseidon_params_create,
     caml_pasta_fq_poseidon_params_create:caml_pasta_fq_poseidon_params_create,
     caml_pasta_fp_poseidon_block_cipher:caml_pasta_fp_poseidon_block_cipher,
     caml_pasta_fq_poseidon_block_cipher:caml_pasta_fq_poseidon_block_cipher,
     prover_to_json:prover_to_json,
     integers_uint64_of_uint32:integers_uint64_of_uint32,
     caml_pasta_fp_plonk_proof_example_with_ffadd:
     caml_pasta_fp_plonk_proof_example_with_ffadd,
     caml_pasta_fp_plonk_proof_example_with_foreign_field_mul:
     caml_pasta_fp_plonk_proof_example_with_foreign_field_mul,
     caml_pasta_fp_plonk_proof_example_with_range_check:
     caml_pasta_fp_plonk_proof_example_with_range_check,
     caml_pasta_fp_plonk_proof_example_with_range_check0:
     caml_pasta_fp_plonk_proof_example_with_range_check0,
     caml_pasta_fp_plonk_proof_example_with_rot:
     caml_pasta_fp_plonk_proof_example_with_rot,
     caml_pasta_fp_plonk_proof_example_with_xor:
     caml_pasta_fp_plonk_proof_example_with_xor,
     caml_pasta_fp_plonk_proof_example_with_lookup:
     caml_pasta_fp_plonk_proof_example_with_lookup,
     deferred_run:deferred_run,
     deferred_map:deferred_map,
     deferred_bind:deferred_bind,
     deferred_upon:deferred_upon,
     deferred_upon_exn:deferred_upon_exn,
     deferred_is_determined:deferred_is_determined,
     deferred_peek:deferred_peek,
     deferred_value_exn:deferred_value_exn,
     deferred_return:deferred_return,
     deferred_create:deferred_create,
     deferred_to_promise:deferred_to_promise,
     deferred_of_promise:deferred_of_promise,
     ml_z_normalize:ml_z_normalize,
     ml_z_mul_overflows:ml_z_mul_overflows,
     ml_z_init:ml_z_init,
     ml_z_install_frametable:ml_z_install_frametable,
     ml_z_neg:ml_z_neg,
     ml_z_add:ml_z_add,
     ml_z_sub:ml_z_sub,
     ml_z_mul:ml_z_mul,
     ml_z_div:ml_z_div,
     ml_z_cdiv:ml_z_cdiv,
     ml_z_fdiv:ml_z_fdiv,
     ml_z_rem:ml_z_rem,
     ml_z_div_rem:ml_z_div_rem,
     ml_z_succ:ml_z_succ,
     ml_z_pred:ml_z_pred,
     ml_z_abs:ml_z_abs,
     ml_z_logand:ml_z_logand,
     ml_z_logor:ml_z_logor,
     ml_z_logxor:ml_z_logxor,
     ml_z_lognot:ml_z_lognot,
     ml_z_shift_left:ml_z_shift_left,
     ml_z_shift_right:ml_z_shift_right,
     ml_z_shift_right_trunc:ml_z_shift_right_trunc,
     ml_z_of_int:ml_z_of_int,
     ml_z_of_int32:ml_z_of_int32,
     ml_z_of_nativeint:ml_z_of_nativeint,
     ml_z_of_int64:ml_z_of_int64,
     ml_z_of_float:ml_z_of_float,
     ml_z_to_int:ml_z_to_int,
     ml_z_to_int32:ml_z_to_int32,
     ml_z_to_int64:ml_z_to_int64,
     ml_z_testbit:ml_z_testbit,
     ml_z_to_nativeint:ml_z_to_nativeint,
     ml_z_format:ml_z_format,
     jsoo_z_of_js_string_base:jsoo_z_of_js_string_base,
     ml_z_of_substring_base:ml_z_of_substring_base,
     ml_z_compare:ml_z_compare,
     ml_z_equal:ml_z_equal,
     ml_z_sign:ml_z_sign,
     ml_z_gcd:ml_z_gcd,
     ml_z_numbits:ml_z_numbits,
     ml_z_fits_int:ml_z_fits_int,
     ml_z_fits_int32:ml_z_fits_int32,
     ml_z_fits_int64:ml_z_fits_int64,
     ml_z_fits_nativeint:ml_z_fits_nativeint,
     ml_z_powm:ml_z_powm,
     ml_z_pow:ml_z_pow,
     ml_z_hash:ml_z_hash,
     ml_z_to_bits:ml_z_to_bits,
     ml_z_of_bits:ml_z_of_bits,
     ml_z_powm_sec:ml_z_powm_sec,
     ml_z_root:ml_z_root,
     ml_z_invert:ml_z_invert,
     ml_z_perfect_power:ml_z_perfect_power,
     ml_z_perfect_square:ml_z_perfect_square,
     ml_z_probab_prime:ml_z_probab_prime,
     ml_z_nextprime:ml_z_nextprime,
     ml_z_extract:ml_z_extract,
     ml_z_gcdext_intern:ml_z_gcdext_intern,
     ml_z_sqrt:ml_z_sqrt,
     ml_z_sqrt_rem:ml_z_sqrt_rem,
     ml_z_trailing_zeros:ml_z_trailing_zeros,
     ml_z_popcount:ml_z_popcount,
     ml_z_hamdist:ml_z_hamdist,
     ml_z_size:ml_z_size,
     ml_z_divexact:ml_z_divexact,
     caml_zarith_marshal:caml_zarith_marshal,
     caml_zarith_unmarshal:caml_zarith_unmarshal,
     bigInt:bigInt,
     bigstringaf_blit_to_bytes:bigstringaf_blit_to_bytes,
     bigstringaf_blit_to_bigstring:bigstringaf_blit_to_bigstring,
     bigstringaf_blit_from_bytes:bigstringaf_blit_from_bytes,
     bigstringaf_memcmp_bigstring:bigstringaf_memcmp_bigstring,
     bigstringaf_memcmp_string:bigstringaf_memcmp_string,
     core_array_unsafe_int_blit:core_array_unsafe_int_blit,
     core_array_unsafe_float_blit:core_array_unsafe_float_blit,
     core_kernel_time_ns_format:core_kernel_time_ns_format,
     core_kernel_gc_compactions:core_kernel_gc_compactions,
     core_kernel_gc_heap_chunks:core_kernel_gc_heap_chunks,
     core_kernel_gc_heap_words:core_kernel_gc_heap_words,
     core_kernel_gc_major_collections:core_kernel_gc_major_collections,
     core_kernel_gc_major_plus_minor_words:
     core_kernel_gc_major_plus_minor_words,
     core_kernel_gc_major_words:core_kernel_gc_major_words,
     core_kernel_gc_minor_collections:core_kernel_gc_minor_collections,
     core_kernel_gc_minor_words:core_kernel_gc_minor_words,
     core_kernel_gc_promoted_words:core_kernel_gc_promoted_words,
     core_kernel_gc_top_heap_words:core_kernel_gc_top_heap_words,
     Core_kernel_heap_block_is_heap_block:Core_kernel_heap_block_is_heap_block,
     core_md5_fd:core_md5_fd,
     core_md5_digest_subbigstring:core_md5_digest_subbigstring,
     bigstring_destroy_stub:bigstring_destroy_stub,
     bigstring_realloc:bigstring_realloc,
     bigstring_alloc:bigstring_alloc,
     bigstring_is_mmapped_stub:bigstring_is_mmapped_stub,
     bigstring_blit_stub:bigstring_blit_stub,
     bigstring_blit_bytes_bigstring_stub:bigstring_blit_bytes_bigstring_stub,
     bigstring_blit_bigstring_bytes_stub:bigstring_blit_bigstring_bytes_stub,
     bigstring_blit_string_bigstring_stub:bigstring_blit_string_bigstring_stub,
     bigstring_memset_stub:bigstring_memset_stub,
     bigstring_memcmp_stub:bigstring_memcmp_stub,
     internalhash_fold_bigstring:internalhash_fold_bigstring,
     bigstring_find:bigstring_find,
     expect_test_collector_saved_stdout:expect_test_collector_saved_stdout,
     expect_test_collector_saved_stderr:expect_test_collector_saved_stderr,
     expect_test_collector_before_test:expect_test_collector_before_test,
     expect_test_collector_after_test:expect_test_collector_after_test,
     caml_out_channel_pos_fd:caml_out_channel_pos_fd,
     time_now_nanoseconds_since_unix_epoch_or_zero:
     time_now_nanoseconds_since_unix_epoch_or_zero,
     caml_check_bound_bigstring:caml_check_bound_bigstring,
     bin_prot_blit_buf_float_array_stub:bin_prot_blit_buf_float_array_stub,
     bin_prot_blit_buf_bytes_stub:bin_prot_blit_buf_bytes_stub,
     bin_prot_blit_float_array_buf_stub:bin_prot_blit_float_array_buf_stub,
     bin_prot_blit_string_buf_stub:bin_prot_blit_string_buf_stub,
     bin_prot_blit_bytes_buf_stub:bin_prot_blit_bytes_buf_stub,
     bin_prot_blit_buf_stub:bin_prot_blit_buf_stub,
     Base_int_math_int_popcount:Base_int_math_int_popcount,
     Base_clear_caml_backtrace_pos:Base_clear_caml_backtrace_pos,
     Base_int_math_int32_clz:Base_int_math_int32_clz,
     Base_int_math_int_clz:Base_int_math_int_clz,
     Base_int_math_nativeint_clz:Base_int_math_nativeint_clz,
     Base_int_math_int64_clz:Base_int_math_int64_clz,
     Base_int_math_int32_ctz:Base_int_math_int32_ctz,
     Base_int_math_int_ctz:Base_int_math_int_ctz,
     Base_int_math_nativeint_ctz:Base_int_math_nativeint_ctz,
     Base_int_math_int64_ctz:Base_int_math_int64_ctz,
     Base_int_math_int_pow_stub:Base_int_math_int_pow_stub,
     Base_int_math_int64_pow_stub:Base_int_math_int64_pow_stub,
     Base_hash_string:Base_hash_string,
     Base_hash_double:Base_hash_double,
     Base_am_testing:Base_am_testing,
     Base_internalhash_fold_int64:Base_internalhash_fold_int64,
     Base_internalhash_fold_int:Base_internalhash_fold_int,
     Base_internalhash_fold_float:Base_internalhash_fold_float,
     Base_internalhash_fold_string:Base_internalhash_fold_string,
     Base_internalhash_get_hash_value:Base_internalhash_get_hash_value,
     caml_ephe_key_offset:caml_ephe_key_offset,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_weak_create:caml_weak_create,
     caml_weak_set:caml_weak_set,
     caml_weak_get:caml_weak_get,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_check:caml_weak_check,
     caml_weak_blit:caml_weak_blit,
     caml_ephe_create:caml_ephe_create,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_check_data:caml_ephe_check_data,
     unix_gettimeofday:unix_gettimeofday,
     unix_time:unix_time,
     unix_gmtime:unix_gmtime,
     unix_localtime:unix_localtime,
     unix_mktime:unix_mktime,
     win_startup:win_startup,
     win_cleanup:win_cleanup,
     win_handle_fd:win_handle_fd,
     unix_isatty:unix_isatty,
     make_unix_err_args:make_unix_err_args,
     unix_stat:unix_stat,
     unix_stat_64:unix_stat_64,
     unix_lstat:unix_lstat,
     unix_lstat_64:unix_lstat_64,
     unix_mkdir:unix_mkdir,
     unix_rmdir:unix_rmdir,
     unix_symlink:unix_symlink,
     unix_readlink:unix_readlink,
     unix_unlink:unix_unlink,
     unix_getuid:unix_getuid,
     unix_getpwuid:unix_getpwuid,
     unix_has_symlink:unix_has_symlink,
     re_match:re_match,
     re_search_forward:re_search_forward,
     re_search_backward:re_search_backward,
     re_string_match:re_string_match,
     re_partial_match:re_partial_match,
     re_replacement_text:re_replacement_text,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_sys_exit:caml_sys_exit,
     caml_is_special_exception:caml_is_special_exception,
     caml_format_exception:caml_format_exception,
     caml_set_static_env:caml_set_static_env,
     caml_sys_getenv:caml_sys_getenv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_argv:caml_argv,
     caml_executable_name:caml_executable_name,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_time:caml_sys_time,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     os_type:os_type,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_isatty:caml_sys_isatty,
     caml_runtime_variant:caml_runtime_variant,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_install_signal_handler:caml_install_signal_handler,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_runtime_warnings:caml_runtime_warnings,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_call_gen:caml_call_gen,
     caml_named_values:caml_named_values,
     caml_register_named_value:caml_register_named_value,
     caml_named_value:caml_named_value,
     caml_global_data:caml_global_data,
     caml_register_global:caml_register_global,
     caml_get_global_data:caml_get_global_data,
     caml_is_printable:caml_is_printable,
     caml_parse_engine:caml_parse_engine,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_update_dummy:caml_update_dummy,
     caml_obj_is_block:caml_obj_is_block,
     caml_obj_tag:caml_obj_tag,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_dup:caml_obj_dup,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_get_public_method:caml_get_public_method,
     caml_oo_last_id:caml_oo_last_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_obj_raw_field:caml_obj_raw_field,
     caml_obj_set_raw_field:caml_obj_set_raw_field,
     caml_obj_reachable_words:caml_obj_reachable_words,
     caml_obj_add_offset:caml_obj_add_offset,
     initialize_nat:initialize_nat,
     MlNat:MlNat,
     caml_hash_nat:caml_hash_nat,
     nat_of_array:nat_of_array,
     create_nat:create_nat,
     set_to_zero_nat:set_to_zero_nat,
     blit_nat:blit_nat,
     set_digit_nat:set_digit_nat,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat_native:nth_digit_nat_native,
     num_digits_nat:num_digits_nat,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     is_digit_int:is_digit_int,
     is_digit_zero:is_digit_zero,
     is_digit_odd:is_digit_odd,
     incr_nat:incr_nat,
     add_nat:add_nat,
     complement_nat:complement_nat,
     decr_nat:decr_nat,
     sub_nat:sub_nat,
     mult_digit_nat:mult_digit_nat,
     mult_nat:mult_nat,
     square_nat:square_nat,
     shift_left_nat:shift_left_nat,
     div_helper:div_helper,
     div_digit_nat:div_digit_nat,
     div_nat:div_nat,
     shift_right_nat:shift_right_nat,
     compare_digits_nat:compare_digits_nat,
     compare_nat:compare_nat,
     compare_nat_real:compare_nat_real,
     land_digit_nat:land_digit_nat,
     lor_digit_nat:lor_digit_nat,
     lxor_digit_nat:lxor_digit_nat,
     serialize_nat:serialize_nat,
     deserialize_nat:deserialize_nat,
     caml_str_repeat:caml_str_repeat,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_get:caml_string_get,
     caml_string_get16:caml_string_get16,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get32:caml_string_get32,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get64:caml_string_get64,
     caml_bytes_get64:caml_bytes_get64,
     caml_bytes_get:caml_bytes_get,
     caml_string_set:caml_string_set,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set16:caml_string_set16,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set32:caml_string_set32,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set64:caml_string_set64,
     caml_bytes_set:caml_bytes_set,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     MlBytes:MlBytes,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_array_of_string:caml_array_of_string,
     caml_create_string:caml_create_string,
     caml_create_bytes:caml_create_bytes,
     caml_string_of_array:caml_string_of_array,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_equal:caml_bytes_equal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_fill_bytes:caml_fill_bytes,
     caml_fill_string:caml_fill_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_blit_string:caml_blit_string,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_compare:caml_string_compare,
     caml_string_equal:caml_string_equal,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_ml_bytes_content:caml_ml_bytes_content,
     caml_is_ml_string:caml_is_ml_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_new_string:caml_new_string,
     caml_js_from_string:caml_js_from_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_to_string:caml_js_to_string,
     caml_md5_chan:caml_md5_chan,
     caml_md5_string:caml_md5_string,
     caml_md5_bytes:caml_md5_bytes,
     caml_marshal_constants:caml_marshal_constants,
     MlStringReader:MlStringReader,
     BigStringReader:BigStringReader,
     caml_float_of_bytes:caml_float_of_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_custom_ops:caml_custom_ops,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_marshal_data_size:caml_marshal_data_size,
     MlObjectTable:MlObjectTable,
     caml_legacy_custom_code:caml_legacy_custom_code,
     caml_output_val:caml_output_val,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_lex_array:caml_lex_array,
     caml_lex_engine:caml_lex_engine,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_get_console:caml_js_get_console,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_js_set:caml_js_set,
     caml_js_get:caml_js_get,
     caml_js_delete:caml_js_delete,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_typeof:caml_js_typeof,
     caml_trampoline:caml_trampoline,
     caml_trampoline_return:caml_trampoline_return,
     js_print_stdout:js_print_stdout,
     js_print_stderr:js_print_stderr,
     caml_is_js:caml_is_js,
     caml_wrap_exception:caml_wrap_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_js_error_option_of_exception:caml_js_error_option_of_exception,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_array:caml_js_to_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_js_var:caml_js_var,
     caml_js_call:caml_js_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_new:caml_js_new,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_equals:caml_js_equals,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_expr:caml_js_expr,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_object:caml_js_object,
     caml_sys_close:caml_sys_close,
     caml_std_output:caml_std_output,
     caml_sys_open:caml_sys_open,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_ml_channels:caml_ml_channels,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_channel_descriptor:caml_channel_descriptor,
     win_filedescr_of_channel:win_filedescr_of_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_input:caml_ml_input,
     caml_input_value:caml_input_value,
     caml_ml_input_char:caml_ml_input_char,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_flush:caml_ml_flush,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_output:caml_ml_output,
     caml_ml_output_char:caml_ml_output_char,
     caml_output_value:caml_output_value,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_is_buffered:caml_ml_is_buffered,
     caml_ml_set_buffered:caml_ml_set_buffered,
     caml_format_int:caml_format_int,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_parse_digit:caml_parse_digit,
     caml_int_of_string:caml_int_of_string,
     caml_mul:caml_mul,
     caml_div:caml_div,
     caml_mod:caml_mod,
     caml_bswap16:caml_bswap16,
     caml_int32_bswap:caml_int32_bswap,
     caml_int64_bswap:caml_int64_bswap,
     caml_int64_offset:caml_int64_offset,
     MlInt64:MlInt64,
     caml_int64_ult:caml_int64_ult,
     caml_int64_compare:caml_int64_compare,
     caml_int64_neg:caml_int64_neg,
     caml_int64_add:caml_int64_add,
     caml_int64_sub:caml_int64_sub,
     caml_int64_mul:caml_int64_mul,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_and:caml_int64_and,
     caml_int64_or:caml_int64_or,
     caml_int64_xor:caml_int64_xor,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_div:caml_int64_div,
     caml_int64_mod:caml_int64_mod,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_format:caml_int64_format,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_hash:caml_int64_hash,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_nextafter_float:caml_nextafter_float,
     caml_trunc_float:caml_trunc_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_classify_float:caml_classify_float,
     caml_modf_float:caml_modf_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_frexp_float:caml_frexp_float,
     caml_float_compare:caml_float_compare,
     caml_copysign_float:caml_copysign_float,
     caml_signbit_float:caml_signbit_float,
     caml_expm1_float:caml_expm1_float,
     caml_exp2_float:caml_exp2_float,
     caml_log1p_float:caml_log1p_float,
     caml_log2_float:caml_log2_float,
     caml_hypot_float:caml_hypot_float,
     caml_log10_float:caml_log10_float,
     caml_cosh_float:caml_cosh_float,
     caml_acosh_float:caml_acosh_float,
     caml_sinh_float:caml_sinh_float,
     caml_asinh_float:caml_asinh_float,
     caml_tanh_float:caml_tanh_float,
     caml_atanh_float:caml_atanh_float,
     caml_round_float:caml_round_float,
     caml_cbrt_float:caml_cbrt_float,
     caml_erf_float:caml_erf_float,
     caml_erfc_float:caml_erfc_float,
     caml_fma_float:caml_fma_float,
     caml_format_float:caml_format_float,
     caml_float_of_string:caml_float_of_string,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash:caml_hash,
     caml_gr_state:caml_gr_state,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gc_minor:caml_gc_minor,
     caml_gc_major:caml_gc_major,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_counters:caml_gc_counters,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_stat:caml_gc_stat,
     caml_gc_set:caml_gc_set,
     caml_gc_get:caml_gc_get,
     caml_memprof_set:caml_memprof_set,
     caml_final_register:caml_final_register,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_release:caml_final_release,
     caml_memprof_start:caml_memprof_start,
     caml_memprof_stop:caml_memprof_stop,
     caml_eventlog_resume:caml_eventlog_resume,
     caml_eventlog_pause:caml_eventlog_pause,
     caml_gc_huge_fallback_count:caml_gc_huge_fallback_count,
     caml_gc_major_slice:caml_gc_major_slice,
     caml_gc_minor_words:caml_gc_minor_words,
     caml_get_minor_free:caml_get_minor_free,
     caml_get_major_bucket:caml_get_major_bucket,
     caml_get_major_credit:caml_get_major_credit,
     fs_node_supported:fs_node_supported,
     MlNodeDevice:MlNodeDevice,
     MlNodeFile:MlNodeFile,
     MlFakeDevice:MlFakeDevice,
     MlFakeFile:MlFakeFile,
     caml_trailing_slash:caml_trailing_slash,
     caml_current_dir:caml_current_dir,
     caml_get_root:caml_get_root,
     caml_root:caml_root,
     MlFile:MlFile,
     path_is_absolute:path_is_absolute,
     caml_make_path:caml_make_path,
     jsoo_mount_point:jsoo_mount_point,
     caml_list_mount_point:caml_list_mount_point,
     resolve_fs_device:resolve_fs_device,
     caml_mount_autoload:caml_mount_autoload,
     caml_unmount:caml_unmount,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_sys_chdir:caml_sys_chdir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_rename:caml_sys_rename,
     caml_sys_mkdir:caml_sys_mkdir,
     caml_sys_rmdir:caml_sys_rmdir,
     caml_ba_map_file:caml_ba_map_file,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     jsoo_create_file_extern:jsoo_create_file_extern,
     caml_fs_init:caml_fs_init,
     caml_create_file:caml_create_file,
     jsoo_create_file:jsoo_create_file,
     caml_read_file_content:caml_read_file_content,
     caml_parse_format:caml_parse_format,
     caml_finish_formatting:caml_finish_formatting,
     caml_raise_constant:caml_raise_constant,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_raise_with_args:caml_raise_with_args,
     caml_failwith:caml_failwith,
     caml_invalid_argument:caml_invalid_argument,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_not_found:caml_raise_not_found,
     caml_array_bound_error:caml_array_bound_error,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val:caml_compare_val,
     caml_compare:caml_compare,
     caml_int_compare:caml_int_compare,
     caml_equal:caml_equal,
     caml_notequal:caml_notequal,
     caml_greaterequal:caml_greaterequal,
     caml_greaterthan:caml_greaterthan,
     caml_lessequal:caml_lessequal,
     caml_lessthan:caml_lessthan,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_of_typed_array:bigstring_of_typed_array,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_ba_init:caml_ba_init,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_custom_name:caml_ba_custom_name,
     Ml_Bigarray:Ml_Bigarray,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     caml_ba_compare:caml_ba_compare,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_create:caml_ba_create,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_layout:caml_ba_layout,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_dim:caml_ba_dim,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_fill:caml_ba_fill,
     caml_ba_blit:caml_ba_blit,
     caml_ba_sub:caml_ba_sub,
     caml_ba_slice:caml_ba_slice,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_hash:caml_ba_hash,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ml_debug_info_status:caml_ml_debug_info_status,
     caml_backtrace_status:caml_backtrace_status,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_array_sub:caml_array_sub,
     caml_array_append:caml_array_append,
     caml_array_concat:caml_array_concat,
     caml_array_blit:caml_array_blit,
     caml_floatarray_blit:caml_floatarray_blit,
     caml_array_set:caml_array_set,
     caml_array_get:caml_array_get,
     caml_array_fill:caml_array_fill,
     caml_check_bound:caml_check_bound,
     caml_make_vect:caml_make_vect,
     caml_make_float_vect:caml_make_float_vect,
     caml_floatarray_create:caml_floatarray_create};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),-1],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-2],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-3],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-4],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-5],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-6],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-7],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-8],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-9],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-10],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-11],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-12],
      "Undefined_recursive_module");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzbmFya3lfanNfd2ViLmJjLnJ1bnRpbWUuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiT2JqZWN0IiwiZ2xvYmFsVGhpcyIsInRoaXMiLCJnZXQiLCJfVF8iLCJnbG9iYWwiLCJzZWxmIiwiRGVmYXVsdExvY2FsZSIsImRlZmF1bHRTdHJmdGltZSIsIlN0cmZ0aW1lIiwiaXNDb21tb25KUyIsIm1vZHVsZSIsIm5hbWVzcGFjZSIsImFkYXB0ZWRTdHJmdGltZSIsImRlcHJlY2F0ZWRTdHJmdGltZSIsImpvb19nbG9iYWxfb2JqZWN0IiwiZXZhbCIsIl9yZXF1aXJlIiwiX2RlcHJlY2F0aW9uV2FybmluZ3MiLCJkZXByZWNhdGlvbldhcm5pbmciLCJuYW1lIiwiaW5zdGVhZCIsImNvbnNvbGUiLCJkZXByZWNhdGVkU3RyZnRpbWVUWiIsImRlcHJlY2F0ZWRTdHJmdGltZVVUQyIsImRlcHJlY2F0ZWRTdHJmdGltZUxvY2FsaXplZCIsImFkYXB0Rm9yd2FyZHMiLCJmbiIsImZtdCIsImQiLCJsb2NhbGUiLCJ1bmRlZmluZWQiLCJzdHJmdGltZSIsInRpbWV6b25lIiwibnVsbCIsInV0Y1N0cmZ0aW1lIiwiRGF0ZSIsImN1c3RvbVRpbWV6b25lT2Zmc2V0IiwidXNlVXRjVGltZXpvbmUiLCJfbG9jYWxlIiwiX2N1c3RvbVRpbWV6b25lT2Zmc2V0IiwiX3VzZVV0Y0Jhc2VkRGF0ZSIsIl9jYWNoZWREYXRlVGltZXN0YW1wIiwiX2NhY2hlZERhdGUiLCJfc3RyZnRpbWUiLCJmb3JtYXQiLCJkYXRlIiwidGltZXN0YW1wIiwiY3VycmVudFRpbWVzdGFtcCIsImdldFRpbWVzdGFtcFRvVXRjT2Zmc2V0Rm9yIiwiX3Byb2Nlc3NGb3JtYXQiLCJyZXN1bHRTdHJpbmciLCJwYWRkaW5nIiwiaXNJblNjb3BlIiwibGVuZ3RoIiwiZXh0ZW5kZWRUWiIsImkiLCJjdXJyZW50Q2hhckNvZGUiLCJwYWRUaWxsMiIsIk1hdGgiLCJob3VyczEyIiwicGFkVGlsbDMiLCJ3ZWVrTnVtYmVyIiwidHpTdHJpbmciLCJ5IiwiZGF5IiwiU3RyaW5nIiwib3JkaW5hbCIsIm9mZiIsInNpZ24iLCJzZXAiLCJob3VycyIsIm1pbnMiLCJ1c2VVdGNCYXNlZERhdGUiLCJ0aW1lem9uZVR5cGUiLCJwYXJzZUludCIsIm1pbnV0ZXMiLCJudW1iZXJUb1BhZCIsInBhZGRpbmdDaGFyIiwiaG91ciIsImZpcnN0V2Vla2RheSIsIndlZWtkYXkiLCJmaXJzdERheU9mWWVhclV0YyIsImRhdGVVdGMiLCJ5ZGF5Iiwid2Vla051bSIsIm51bWJlciIsImlpIiwicGxvbmtfd2FzbSIsInJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lIiwicHQiLCJpbmZpbml0eSIsIngiLCJqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IiLCJ2Iiwia2xhc3MiLCJsZW4iLCJyZXMiLCJBcnJheSIsInBvcyIsImNhbWxfYXJyYXlfb2ZfcnVzdF92ZWN0b3IiLCJjb252ZXJ0Iiwic2hvdWxkX2ZyZWUiLCJydXN0X3ZhbCIsImNhbWxfcG9seV9jb21tX29mX3J1c3RfcG9seV9jb21tIiwicG9seV9jb21tIiwicnVzdF9zaGlmdGVkIiwicnVzdF91bnNoaWZ0ZWQiLCJjYW1sX3NoaWZ0ZWQiLCJjYW1sX3Vuc2hpZnRlZCIsImNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3QiLCJjYW1sX2V4cG0xX2Zsb2F0IiwiY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QiLCJjYW1sX2pzc3RyaW5nX29mX3N0cmluZyIsInMiLCJmc19ub2RlX3N1cHBvcnRlZCIsIm1ha2VfcGF0aF9pc19hYnNvbHV0ZSIsInBvc2l4IiwicGF0aCIsIndpbjMyIiwic3BsaXREZXZpY2VSZSIsInJlc3VsdCIsImRldmljZSIsImlzVW5jIiwiQm9vbGVhbiIsInJvb3QiLCJwYXRoX2lzX2Fic29sdXRlIiwiY2FtbF90cmFpbGluZ19zbGFzaCIsImNhbWxfY3VycmVudF9kaXIiLCJjYW1sX21ha2VfcGF0aCIsImNvbXAwIiwiY29tcCIsIm5jb21wIiwianNvb19pc19hc2NpaSIsImNhbWxfdXRmOF9vZl91dGYxNiIsImIiLCJ0IiwiYyIsImwiLCJqIiwiY2FtbF9zdHJfcmVwZWF0IiwibiIsInIiLCJjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMiLCJhIiwiZiIsImNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMiLCJjYW1sX3V0ZjE2X29mX3V0ZjgiLCJjMSIsImMyIiwiTWxCeXRlcyIsInRhZyIsImNvbnRlbnRzIiwiY29udGVudCIsImNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmciLCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZyIsInVuaXhfZXJyb3IiLCJtYWtlX3VuaXhfZXJyX2FyZ3MiLCJjb2RlIiwic3lzY2FsbCIsImVycm5vIiwidmFyaWFudCIsImFyZ3MiLCJjYW1sX25hbWVkX3ZhbHVlcyIsImNhbWxfbmFtZWRfdmFsdWUiLCJubSIsImNhbWxfcmFpc2Vfd2l0aF9hcmdzIiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9hcnJheSIsImNhbWxfYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9qc2J5dGVzIiwiY2FtbF9zdHJpbmdfb2ZfanNieXRlcyIsImNhbWxfcmFpc2Vfd2l0aF9zdHJpbmciLCJtc2ciLCJjYW1sX2dsb2JhbF9kYXRhIiwiY2FtbF9yYWlzZV9zeXNfZXJyb3IiLCJjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSIsImNhbWxfaW52YWxpZF9hcmd1bWVudCIsImNhbWxfYnl0ZXNfYm91bmRfZXJyb3IiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2J5dGVzX2dldCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsImkxIiwiczIiLCJpMiIsImNhbWxfYmxpdF9zdHJpbmciLCJlIiwiTWxGaWxlIiwiTWxGYWtlRmlsZSIsIm9sZCIsIm9mZnNldCIsImJ1ZiIsImNsZW4iLCJuZXdfc3RyIiwib2xkX2RhdGEiLCJNbEZha2VEZXZpY2UiLCJTeW1ib2wiLCJuYW1lX3NsYXNoIiwibW9kZSIsInJhaXNlX3VuaXgiLCJwYXJlbnQiLCJSZWdFeHAiLCJzZWVuIiwibSIsIm9rIiwiZmlsZSIsImJ5dGVzIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfYXJyYXlfb2Zfc3RyaW5nIiwiY2FtbF9hcnJheV9vZl9ieXRlcyIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfYnl0ZXNfc2V0IiwiTWxOb2RlRmlsZSIsImZkIiwicmVxdWlyZSIsImVyciIsImJ1Zl9vZmZzZXQiLCJidWZmZXIiLCJNbE5vZGVEZXZpY2UiLCJjb25zdHMiLCJrZXkiLCJvIiwianNfc3RhdHMiLCJ0b19kaXIiLCJ0YXJnZXQiLCJsaW5rIiwiZmlsZV9raW5kIiwiY2FtbF9nZXRfcm9vdCIsImNhbWxfZmFpbHdpdGgiLCJjYW1sX3Jvb3QiLCJqc29vX21vdW50X3BvaW50IiwicmVzb2x2ZV9mc19kZXZpY2UiLCJjYW1sX3N5c19pc19kaXJlY3RvcnkiLCJmcmVlX2ZpbmFsaXphdGlvbl9yZWdpc3RyeSIsImluc3RhbmNlX3JlcHJlc2VudGF0aXZlIiwiZnJlZV9vbl9maW5hbGl6ZSIsImNhbWxfcGxvbmtfZG9tYWluX3RvX3J1c3QiLCJydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSIsImpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvciIsImNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IiLCJta19uZXciLCJjbGFzc192YWwiLCJjYW1sX3BvbHlfY29tbV90b19ydXN0X3BvbHlfY29tbSIsInBvbHlfY29tbV9jbGFzcyIsIm1rX2FmZmluZSIsImNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX2V2YWxzX3RvX3J1c3QiLCJjb252ZXJ0QXJyYXkiLCJjb21tcyIsInNpZ21hX2NvbW0iLCJjb2VmZmljaWVudHNfY29tbSIsImdlbmVyaWNfY29tbSIsInBzbV9jb21tIiwiY29tcGxldGVfYWRkX2NvbW0iLCJtdWxfY29tbSIsImVtdWxfY29tbSIsImVuZG9tdWxfc2NhbGFyX2NvbW0iLCJjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9zaGlmdHNfdG9fcnVzdCIsImNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCIsImRvbWFpbl9jbGFzcyIsInZlcmlmaWNhdGlvbl9ldmFsc19jbGFzcyIsInZlcmlmaWNhdGlvbl9zaGlmdHNfY2xhc3MiLCJkb21haW4iLCJtYXhfcG9seV9zaXplIiwicHVibGljXyIsInByZXZfY2hhbGxlbmdlcyIsInNycyIsImV2YWxzIiwic2hpZnRzIiwiY2FtbF9yYWlzZV9jb25zdGFudCIsImNhbWxfcmFpc2Vfbm90X2ZvdW5kIiwiY2FtbF9zeXNfZ2V0ZW52IiwiZyIsInNoaWZ0X3JpZ2h0X25hdCIsIm5hdDEiLCJvZnMxIiwibGVuMSIsIm5hdDIiLCJvZnMyIiwibmJpdHMiLCJ3cmFwIiwiTWxPYmplY3RUYWJsZSIsIk5haXZlTG9va3VwIiwib2JqcyIsImNhbWxfaW50NjRfb2Zmc2V0IiwiY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSIsIk1sSW50NjQiLCJsbyIsIm1pIiwiaGkiLCJ4aGkiLCJoIiwibW9kdWx1cyIsImRpdmlzb3IiLCJxdW90aWVudCIsInEiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSIsImNhbWxfaW50NjRfb2ZfaW50MzIiLCJjYW1sX3BhcnNlX2RpZ2l0IiwiY2FtbF9pbnQ2NF91bHQiLCJjYW1sX2ludDY0X2FkZCIsImNhbWxfaW50NjRfbXVsIiwiY2FtbF9pbnQ2NF9uZWciLCJpbnRlZ2Vyc191aW50X29mX3N0cmluZyIsIm1heF92YWwiLCJuZWdhdGl2ZSIsIm5vX2RpZ2l0cyIsInRlbiIsIm1heF9iYXNlXzEwIiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsIlVJbnQzMiIsImludGVnZXJzX3VpbnQzMl9vZl9pbnQ2NCIsImludGVnZXJzX3VpbnQzMl9vZl9zdHJpbmciLCJjYW1sX2xvZzEwX2Zsb2F0IiwiY2FtbF9wYXN0YV9mcV9jb3B5IiwiY2FtbF9wYXN0YV9mcV9zdWIiLCJjYW1sX3Bhc3RhX2ZxX211dF9zdWIiLCJ1bml4X3VubGluayIsImNhbWxfcnVudGltZV93YXJuaW5ncyIsImNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MiLCJib29sIiwiY2FtbF9jbGFzc2lmeV9mbG9hdCIsImlzRmluaXRlIiwiaXNOYU4iLCJ1bml4X3JtZGlyIiwiY29sdW1uX29mX3J1c3QiLCJjb2wiLCJnYXRlX3R5cGUiLCJ2YXJpYWJsZV9vZl9ydXN0IiwidmFyaWFibGUiLCJyb3ciLCJwb2xpc2hfdG9rZW5fb2ZfcnVzdCIsInRva2VuIiwiaTAiLCJwdHIiLCJvYmoiLCJpbmRleF90ZXJtX29mX3J1c3QiLCJ0ZXJtIiwidG9rZW5fY2xhc3MiLCJjb2x1bW4iLCJjb2VmZmljaWVudCIsImxpbmVhcml6YXRpb25fb2ZfcnVzdCIsImxpbmVhcml6YXRpb24iLCJhZmZpbmVfY2xhc3MiLCJGIiwiV2FzbVBvbGlzaFRva2VuIiwiV2FzbUluZGV4VGVybSIsImNvbnN0YW50X3Rlcm0iLCJpbmRleF90ZXJtcyIsIndhc21JbmRleFRlcm0iLCJjYW1sX3Bsb25rX2RvbWFpbl9vZl9ydXN0IiwibG9nX3NpemVfb2ZfZ3JvdXAiLCJncm91cF9nZW4iLCJjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9ldmFsc19vZl9ydXN0IiwiYWZmaW5lX2tsYXNzIiwiY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX29mX3J1c3QiLCJOb25lIiwiY2FtbF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0IiwibG9va3VwX2luZGV4IiwiY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0IiwiY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0IiwiY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9kZWVwX2NvcHkiLCJjYW1sX3Bhc3RhX2ZxX3ByaW50IiwiY2FtbF9hcnJheV9ib3VuZF9lcnJvciIsImNhbWxfaW50NjRfb2ZfYnl0ZXMiLCJjYW1sX2JhX3VpbnQ4X2dldDY0IiwiYmEiLCJvZnMiLCJiMSIsImIyIiwiYjMiLCJiNCIsImI1IiwiYjYiLCJiNyIsImI4IiwiaW50ZWdlcnNfdWxvbmdsb25nX3NpemUiLCJ1bml0IiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyIsImJhMSIsInBvczEiLCJieXRlczIiLCJwb3MyIiwic2xpY2UiLCJiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YiIsInNyYyIsInNyY19wb3MiLCJkc3QiLCJkc3RfcG9zIiwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlIiwiY2FtbF9saXN0X29mX2pzX2FycmF5IiwiY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9jcmVhdGUiLCJnYXRlcyIsInB1YmxpY19pbnB1dHMiLCJ1cnMiLCJ1bml4X2dldHRpbWVvZmRheSIsImNhbWxfdmVzdGFfZW5kb19iYXNlIiwiY2FtbF9tdWwiLCJjYW1sX2hhc2hfbWl4X2ludCIsIm51bV9kaWdpdHNfbmF0IiwibmF0IiwiY2FtbF9oYXNoX25hdCIsImNhbWxfY2FsbF9nZW4iLCJhcmdzTGVuIiwiZXh0cmFfYXJncyIsImFyZ3VtZW50cyIsIm5hcmdzIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfZ2NfY291bnRlcnMiLCJjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9wYXJzZV9mb3JtYXQiLCJjYW1sX2dyX3N5bmNocm9uaXplIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9jcmVhdGUiLCJ1bml4X2hhc19zeW1saW5rIiwiY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9jcmVhdGUiLCJsb2cyX29rIiwianNvb19mbG9vcl9sb2cyIiwiSW5maW5pdHkiLCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQiLCJmbG9hdDMyYSIsImludDMyYSIsImNhbWxfaW50NjRfYml0c19vZl9mbG9hdCIsImV4cCIsImsiLCJyMyIsInIyIiwicjEiLCJjYW1sX2ludDY0X3RvX2J5dGVzIiwiY2FtbF9iYV9zZXJpYWxpemUiLCJ3cml0ZXIiLCJzeiIsImNvbXBsZXgiLCJjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50Iiwia2luZCIsImNhbWxfYmFfY3JlYXRlX2J1ZmZlciIsInNpemUiLCJ2aWV3IiwiZGF0YSIsImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyIsImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyIsIk5hTiIsImNhbWxfYmFfZ2V0X3NpemUiLCJkaW1zIiwibl9kaW1zIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkiLCJjYW1sX2ludDY0X2hpMzIiLCJjYW1sX2ludDY0X2xvMzIiLCJjYW1sX2JhX2N1c3RvbV9uYW1lIiwiTWxfQmlnYXJyYXkiLCJsYXlvdXQiLCJhcmciLCJpbSIsInJlIiwidG90YWwiLCJrMSIsImsyIiwiTWxfQmlnYXJyYXlfY18xXzEiLCJjYW1sX2JhX2NyZWF0ZV91bnNhZmUiLCJzaXplX3Blcl9lbGVtZW50IiwiY2FtbF9iYV9kZXNlcmlhbGl6ZSIsInJlYWRlciIsIm51bV9kaW1zIiwic2l6ZV9kaW0iLCJzaXplX2RpbV9oaSIsInNpemVfZGltX2xvIiwic2l4dHkiLCJpbnQ2NCIsImNhbWxfYmFfY29tcGFyZSIsImNhbWxfaGFzaF9taXhfaW50NjQiLCJjYW1sX2hhc2hfbWl4X2Zsb2F0IiwidjAiLCJjYW1sX2JhX2hhc2giLCJudW1fZWx0cyIsInciLCJjYW1sX2ludDMyX3VubWFyc2hhbCIsImNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCIsImNhbWxfaW50NjRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF9tYXJzaGFsIiwic2l6ZXMiLCJjYW1sX2ludDY0X2NvbXBhcmUiLCJjYW1sX2ludDY0X2hhc2giLCJjYW1sX2N1c3RvbV9vcHMiLCJjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20iLCJjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20iLCJudW0iLCJjdXN0b20iLCJzd2FwIiwiY2FtbF9jb21wYXJlX3ZhbF90YWciLCJOdW1iZXIiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9ieXRlc19jb21wYXJlIiwiY2FtbF9zdHJpbmdfY29tcGFyZSIsImNhbWxfY29tcGFyZV92YWwiLCJzdGFjayIsInRhZ19hIiwidGFnX2IiLCJjYW1sX2dyZWF0ZXJ0aGFuIiwiY2FtbF9pbnQ2NF9kaXYiLCJjYW1sX2pzX2h0bWxfZW50aXRpZXMiLCJlbnRpdHkiLCJzdHIiLCJ0ZW1wIiwiZG9jdW1lbnQiLCJjYW1sX2JhX3NldF8yIiwiY2FtbF9wYXN0YV9mcV9kb21haW5fZ2VuZXJhdG9yIiwiY2FtbF9qc19ldmFsX3N0cmluZyIsInNlcmlhbGl6ZV9uYXQiLCJjYW1sX21lbXByb2Zfc2V0IiwiX2NvbnRyb2wiLCJjYW1sX3BhbGxhc19uZWdhdGUiLCJjYW1sX2ZxX3Nyc19oIiwiY2FtbF9zeXNfZXhpdCIsImNhbWxfbWxfY2hhbm5lbHMiLCJjYW1sX2NoYW5uZWxfZGVzY3JpcHRvciIsImNoYW5pZCIsImNoYW4iLCJjYW1sX3Bsb25rX3dpcmVfb2ZfcnVzdCIsIndpcmUiLCJjYW1sX3Bsb25rX3dpcmVzX29mX3J1c3QiLCJ3aXJlcyIsImNhbWxfdThhcnJheV92ZWN0b3Jfb2ZfcnVzdF9mbGF0X3ZlY3RvciIsImlubmVyX2xlbiIsIm91dHB1dF9sZW4iLCJpbm5lcl9yZXMiLCJjYW1sX3Bsb25rX2dhdGVfb2ZfcnVzdCIsImdhdGUiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2dldCIsImNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvciIsImNhbWxfb3B0aW9uX3RvX21heWJlX3VuZGVmaW5lZCIsImNhbWxfcmFuZG9tX29yYWNsZXNfdG9fcnVzdCIsInJvS2xhc3MiLCJqb2ludF9jb21iaW5lcl9vY2FtbCIsImpvaW50X2NvbWJpbmVyX2NoYWwiLCJqb2ludF9jb21iaW5lciIsIlVJbnQ2NCIsImludGVnZXJzX3VpbnQ2NF9vZl9zdHJpbmciLCJjYW1sX2dyX3N0YXRlIiwiY2FtbF9ncl9zdGF0ZV9nZXQiLCJjYW1sX2dyX2ZpbGxfcmVjdCIsImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhIiwic3RyMSIsImJhMiIsImNhbWxfZnBfc3JzX2giLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2NyZWF0ZSIsInZrIiwidmtfY2FtbCIsImNhbWxfZ2V0X2dsb2JhbF9kYXRhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCIsImNhbWxfYmFfdWludDhfZ2V0MTYiLCJjYW1sX3Bhc3RhX2ZxX2RlZXBfY29weSIsImJpZ3N0cmluZ19pc19tbWFwcGVkX3N0dWIiLCJjYW1sX2NoZWNrX2JvdW5kIiwiYXJyYXkiLCJpbmRleCIsImNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nIiwiYmlnc3RyaW5nIiwiYmluX3Byb3RfYmxpdF9idWZfZmxvYXRfYXJyYXlfc3R1YiIsImNhbWxfcGFsbGFzX3JhbmRvbSIsImNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfd3JpdGUiLCJhcHBlbmQiLCJjYW1sX3Bhc3RhX2ZwX3RvX2JpZ2ludCIsImNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QiLCJjYW1sX3Bhc3RhX2ZwX2NvbW1pdG1lbnRzX3RvX3J1c3QiLCJ3X2NvbW0iLCJ6X2NvbW0iLCJ0X2NvbW0iLCJjYW1sX3Bhc3RhX2ZwX29wZW5pbmdfcHJvb2ZfdG9fcnVzdCIsImNvbnZlcnRfYWZmaW5lcyIsImFmZmluZXMiLCJsciIsImRlbHRhIiwiejEiLCJ6MiIsInNnIiwibF9vY2FtbCIsInJfb2NhbWwiLCJjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0IiwiUEVSTVVUU19NSU5VU18xIiwiQ09MVU1OUyIsImNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfdG9fcnVzdCIsImNhbWxfcGFzdGFfZnBfcHJvb2ZfdG9fcnVzdCIsImNvbW1pdG1lbnRzIiwicHJvb2YiLCJmdF9ldmFsMSIsImNoYWxzX2xlbiIsInByZXZfY2hhbGxlbmdlc19zY2FsYXJzIiwicHJldl9jaGFsbGVuZ2VzX2NvbW1zIiwiY2FtbF9wYXN0YV9mcF9jb21taXRtZW50c19vZl9ydXN0IiwiY2FtbF9wYXN0YV9mcF9vcGVuaW5nX3Byb29mX29mX3J1c3QiLCJFcnJvciIsInR1cGxlIiwiY2FtbF9mcF92ZWN0b3Jfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnBfcHJvb2Zfb2ZfcnVzdCIsIm1lc3NhZ2VzIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9kZWVwX2NvcHkiLCJjYW1sX29vX2xhc3RfaWQiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9pbnQ2NF90b19mbG9hdCIsImNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZHVtbXkiLCJjYW1sX2VyZl9mbG9hdCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJwIiwiY2FtbF9iYV91aW50OF9nZXQzMiIsImJpZ0ludCIsIkJBU0UiLCJMT0dfQkFTRSIsIk1BWF9JTlQiLCJNQVhfSU5UX0FSUiIsInNtYWxsVG9BcnJheSIsIkRFRkFVTFRfQUxQSEFCRVQiLCJCaWdJbnQiLCJzdXBwb3J0c05hdGl2ZUJpZ0ludCIsIkludGVnZXIiLCJyYWRpeCIsImFscGhhYmV0IiwiY2FzZVNlbnNpdGl2ZSIsInBhcnNlVmFsdWUiLCJwYXJzZUJhc2UiLCJCaWdJbnRlZ2VyIiwidmFsdWUiLCJTbWFsbEludGVnZXIiLCJOYXRpdmVCaWdJbnQiLCJpc1ByZWNpc2UiLCJhcnJheVRvU21hbGwiLCJhcnIiLCJ0cmltIiwiY29tcGFyZUFicyIsImNyZWF0ZUFycmF5IiwidHJ1bmNhdGUiLCJhZGQiLCJsX2EiLCJsX2IiLCJjYXJyeSIsImJhc2UiLCJzdW0iLCJhZGRBbnkiLCJhZGRTbWFsbCIsInN1YnRyYWN0IiwiYV9sIiwiYl9sIiwiYm9ycm93IiwiZGlmZmVyZW5jZSIsInN1YnRyYWN0QW55Iiwic3VidHJhY3RTbWFsbCIsInNtYWxsIiwibXVsdGlwbHlMb25nIiwicHJvZHVjdCIsImFfaSIsImJfaiIsIm11bHRpcGx5U21hbGwiLCJzaGlmdExlZnQiLCJtdWx0aXBseUthcmF0c3ViYSIsImFjIiwiYmQiLCJhYmNkIiwidXNlS2FyYXRzdWJhIiwibDEiLCJsMiIsImFicyIsIm11bHRpcGx5U21hbGxBbmRBcnJheSIsInNxdWFyZSIsImFfaiIsImRpdk1vZDEiLCJkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQiLCJsYW1iZGEiLCJyZW1haW5kZXIiLCJxdW90aWVudERpZ2l0Iiwic2hpZnQiLCJkaXZNb2RTbWFsbCIsImRpdk1vZDIiLCJwYXJ0IiwiZ3Vlc3MiLCJ4bGVuIiwiaGlnaHgiLCJoaWdoeSIsImNoZWNrIiwiZGl2TW9kQW55IiwiY29tcGFyaXNvbiIsInFTaWduIiwibW9kIiwibVNpZ24iLCJfMCIsIl8xIiwiXzIiLCJpc0Jhc2ljUHJpbWUiLCJtaWxsZXJSYWJpblRlc3QiLCJuUHJldiIsInN0cmljdCIsImlzUHJpbWUiLCJiaXRzIiwibG9nTiIsIml0ZXJhdGlvbnMiLCJuZXdUIiwibmV3UiIsImxhc3RUIiwibGFzdFIiLCJwb3dlcnNPZlR3byIsInBvd2VyczJMZW5ndGgiLCJoaWdoZXN0UG93ZXIyIiwic2hpZnRfaXNTbWFsbCIsInJlbVF1byIsImJpdHdpc2UiLCJ4U2lnbiIsInlTaWduIiwieFJlbSIsInlSZW0iLCJ4RGlnaXQiLCJ5RGlnaXQiLCJ4RGl2TW9kIiwieURpdk1vZCIsIkxPQk1BU0tfSSIsIkxPQk1BU0tfQkkiLCJyb3VnaExPQiIsImludGVnZXJMb2dhcml0aG0iLCJ0bXAiLCJtYXgiLCJtaW4iLCJnY2QiLCJsY20iLCJyYW5kQmV0d2VlbiIsImxvdyIsImhpZ2giLCJyYW5nZSIsImRpZ2l0cyIsInRvQmFzZSIsInJlc3RyaWN0ZWQiLCJ0b3AiLCJkaWdpdCIsInRleHQiLCJhYnNCYXNlIiwiYWxwaGFiZXRWYWx1ZXMiLCJpc05lZ2F0aXZlIiwic3RhcnQiLCJwYXJzZUJhc2VGcm9tQXJyYXkiLCJ2YWwiLCJwb3ciLCJzdHJpbmdpZnkiLCJuZWciLCJvdXQiLCJsZWZ0IiwiZGl2bW9kIiwidG9CYXNlU3RyaW5nIiwiemVyb3MiLCJwYXJzZVN0cmluZ1ZhbHVlIiwic3BsaXQiLCJkZWNpbWFsUGxhY2UiLCJpc1ZhbGlkIiwicGFyc2VOdW1iZXJWYWx1ZSIsIm1sX3pfbm9ybWFsaXplIiwibWxfel9zaGlmdF9yaWdodCIsImFtdCIsImNhbWxfb2JqX2Jsb2NrIiwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciIsImJzIiwiaW50ZWdlcnNfdWludDMyX2NvbXBhcmUiLCJjYW1sX3Bhc3RhX2ZwX2NvcHkiLCJjYW1sX3Bhc3RhX2ZwX3NxdWFyZSIsImNhbWxfcGFzdGFfZnBfbXV0X3NxdWFyZSIsImNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQiLCJfdW5pdCIsImNhbWxfb2JqX2FkZF9vZmZzZXQiLCJjYW1sX2ZpbmFsX3JlbGVhc2UiLCJjYW1sX2pzX3RvX2FycmF5IiwiY2FtbF9ncl9wbG90IiwiY29sb3IiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3JlYWQiLCJjYW1sX2J5dGVzX3NldDE2IiwiaTE2IiwiY2FtbF9zdHJpbmdfc2V0MTYiLCJjYW1sX2J5dGVzX3NldDY0IiwiaTY0IiwiY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0IiwiY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl92ZXJpZnkiLCJjYW1sX2ludDY0X2Jzd2FwIiwiY2FtbF9maWxsX2J5dGVzIiwiY2FtbF9maWxsX3N0cmluZyIsImNhbWxfZ2NfbWFqb3IiLCJtbF96X3NoaWZ0X2xlZnQiLCJkZWNyX25hdCIsImNhcnJ5X2luIiwidW5peF9nZXR1aWQiLCJjYW1sX2pzX3RvX2Jvb2wiLCJjYW1sX3Bhc3RhX2ZxX2lzX3NxdWFyZSIsImNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMiLCJjYW1sX29wdGlvbl9vZl9tYXliZV91bmRlZmluZWQiLCJjYW1sX3JhbmRvbV9vcmFjbGVzX29mX3J1c3QiLCJjYW1sX29yYWNsZXNfb2ZfcnVzdCIsImNhbWxfaGFzaF9taXhfZmluYWwiLCJjYW1sX2JhX3VpbnQ4X3NldDY0IiwiY2FtbF9wbG9ua193aXJlX3RvX3J1c3QiLCJjYW1sX3Bsb25rX3dpcmVzX3RvX3J1c3QiLCJjYW1sX2ZwX3Bsb25rX2dhdGVfdG9fcnVzdCIsImNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfYWRkIiwiY29yZV9rZXJuZWxfZ2NfbWlub3Jfd29yZHMiLCJjYW1sX2FyZ3YiLCJtYWluIiwiYXJndiIsImFyZ3MyIiwiY2FtbF9leGVjdXRhYmxlX25hbWUiLCJjYW1sX3N5c19leGVjdXRhYmxlX25hbWUiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfZnBfdmVjdG9yX2dldCIsImludGVnZXJzX3VpbnQzMl90b19pbnQiLCJjYW1sX21sX3NldF9idWZmZXJlZCIsImNhbWxfaGFzaF9taXhfanNieXRlcyIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiY2FtbF9oYXNoX21peF9ieXRlc19hcnIiLCJjYW1sX21sX2J5dGVzX2NvbnRlbnQiLCJjYW1sX2hhc2hfbWl4X2J5dGVzIiwiY2FtbF9oYXNoIiwiY291bnQiLCJsaW1pdCIsInNlZWQiLCJxdWV1ZSIsInJkIiwid3IiLCJoaCIsIkJhc2VfaGFzaF9zdHJpbmciLCJjYW1sX3N0ZF9vdXRwdXQiLCJzbGVuIiwianNfcHJpbnRfc3RkZXJyIiwianNfcHJpbnRfc3Rkb3V0IiwiY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCIsImlkeCIsIm91dHB1dCIsImZsYWdzIiwiaW5mbyIsImNhbWxfc3lzX29wZW4iLCJfcGVybXMiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiIsInJlZmlsbCIsImZzIiwiY2hhbm5lbCIsImNhbWxfcmFpc2VfZW5kX29mX2ZpbGUiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfc3RyaW5nX29mX2FycmF5IiwiY2FtbF9tZDVfYnl0ZXMiLCJ4eCIsImZmIiwiZ2ciLCJtZDUiLCJjYW1sX21kNV9zdHJpbmciLCJjYW1sX21kNV9jaGFuIiwiY2hhbl9sZW4iLCJjYW1sX3N5c19jbG9zZSIsImNhbWxfbWxfZmx1c2giLCJjYW1sX21sX2Nsb3NlX2NoYW5uZWwiLCJjb3JlX21kNV9mZCIsImljIiwiY2FtbF9lcGhlX2tleV9vZmZzZXQiLCJjYW1sX3dlYWtfZ2V0IiwiY2FtbF9lcGhlX2dldF9rZXkiLCJqc29vX3pfb2ZfanNfc3RyaW5nX2Jhc2UiLCJiYyIsIm1sX3pfb2Zfc3Vic3RyaW5nX2Jhc2UiLCJjYW1sX2J5dGVzX3RvX3VpbnQ4YXJyYXkiLCJvY2FtbF9ieXRlcyIsImNhbWxfcGFzdGFfZnFfb2ZfYnl0ZXMiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kOF9zaXplIiwid2luX2NsZWFudXAiLCJjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZSIsImV4biIsImZvcmNlIiwiY2FtbF9zeXNfaXNhdHR5IiwiX2NoYW4iLCJ1bml4X2luZXRfYWRkcl9vZl9zdHJpbmciLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kMV9zaXplIiwibWxfel9nY2RleHRfaW50ZXJuIiwibGFzdHgiLCJsYXN0eSIsImludGVnZXJzX3VpbnQ4X2Rlc2VyaWFsaXplIiwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50IiwiY2FtbF9sZXhfYXJyYXkiLCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZSIsImNhbWxfbWxfc2Vla19pbl82NCIsImNhbWxfbm90ZXF1YWwiLCJpbnRlZ2Vyc191aW50MzJfbWF4IiwibWxfel9hYnMiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayIsImNhbWxfaXNfanMiLCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0Iiwib3NfdHlwZSIsInVuaXhfbG9jYWx0aW1lIiwiZF9udW0iLCJqYW51YXJ5Zmlyc3QiLCJkb3kiLCJqYW4iLCJqdWwiLCJzdGRUaW1lem9uZU9mZnNldCIsImNhbWxfanNfZnJvbV9hcnJheSIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2ludDY0X29yIiwiaW50ZWdlcnNfdWludDY0X2xvZ29yIiwiYmlnc3RyaW5nX2Rlc3Ryb3lfc3R1YiIsInZfYnN0ciIsImJpZ3N0cmluZ19yZWFsbG9jIiwibmV3X2RhdGEiLCJuZXdfYmlnc3RyaW5nIiwiY2FtbF90cmFtcG9saW5lIiwiaW50ZWdlcnNfdWludDMyX29mX2ludDMyIiwiY2FtbF9mcF9zcnNfd3JpdGUiLCJtbF96X3JlbSIsImNhbWxfd2Vha19zZXQiLCJjYW1sX3N0cmluZ19ib3VuZF9lcnJvciIsImNhbWxfc3RyaW5nX2dldDMyIiwiZGVmZXJyZWRfaXNfZGV0ZXJtaW5lZCIsImRlZmVycmVkIiwiY2FtbF92ZXN0YV9vZl9hZmZpbmUiLCJpbnRlZ2Vyc191aW50NjRfZGl2IiwiY2FtbF9qc19jYWxsIiwiY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSIsImNhbWxfcGFsbGFzX3BvbHlfY29tbV90b19ydXN0IiwiY2FtbF9wYXN0YV9mcV9jb21taXRtZW50c190b19ydXN0IiwiY2FtbF9wYXN0YV9mcV9vcGVuaW5nX3Byb29mX3RvX3J1c3QiLCJjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0IiwiY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0IiwiY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0IiwiY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl92ZXJpZnkiLCJpbnRlZ2Vyc191aW50MzJfbG9neG9yIiwiY2FtbF9lcGhlX3Vuc2V0X2tleSIsImRlZmVycmVkX2NyZWF0ZSIsInByb21pc2VfY3JlYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwibWxfel9tdWxfb3ZlcmZsb3dzIiwieiIsIkJhc2VfYW1fdGVzdGluZyIsImNhbWxfZ3JfZmlsbF9wb2x5IiwiYXIiLCJjYW1sX2djX3F1aWNrX3N0YXQiLCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSIsImNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfcHVibGljX2lucHV0cyIsImNhbWxfb2JqX3JlYWNoYWJsZV93b3JkcyIsIm50aF9kaWdpdF9uYXQiLCJjYW1sX2FycmF5X2JsaXQiLCJjYW1sX3BhbGxhc19hZmZpbmVfZGVlcF9jb3B5IiwiY2FtbF9zeXNfZ2V0Y3dkIiwiY2FtbF9iaWdpbnRfMjU2X3RvX3N0cmluZyIsImNhbWxfbGlzdF90b19qc19hcnJheSIsImNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlIiwiY2FtbF9vdXRwdXRfdmFsIiwiV3JpdGVyIiwibm9fc2hhcmluZyIsImNsb3N1cmVzIiwiaW50ZXJuX29ial90YWJsZSIsIm1lbW8iLCJleGlzdGluZ19vZmZzZXQiLCJleHRlcm5fcmVjIiwib3BzIiwic3pfMzJfNjQiLCJoZWFkZXJfcG9zIiwib2xkX3BvcyIsInR5cGVfb2ZfdiIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyIsImNhbWxfcmFpc2Vfbm90X2FfZGlyIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9leGFtcGxlX3dpdGhfcmFuZ2VfY2hlY2swIiwidW5peF9pc2F0dHkiLCJmaWxlRGVzY3JpcHRvciIsInR0eSIsIk1sTmF0IiwiZGVzZXJpYWxpemVfbmF0IiwiaW5pdGlhbGl6ZV9uYXQiLCJjYW1sX3Zlc3RhX3RvX2FmZmluZSIsImNhbWxfYmFfZ2V0XzEiLCJiaWdzdHJpbmdfbWVtY21wX3N0dWIiLCJ2X3MxIiwidl9zMV9wb3MiLCJ2X3MyIiwidl9zMl9wb3MiLCJ2X2xlbiIsImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3ciLCJpbnRlZ2Vyc191aW50MzJfYWRkIiwiY2FtbF9jb3B5c2lnbl9mbG9hdCIsImNhbWxfcGFsbGFzX2RvdWJsZSIsImNhbWxfZXBoZV9zZXRfa2V5IiwiY2FtbF9iaWdpbnRfMjU2X3Rlc3RfYml0IiwiY2FtbF92ZXN0YV9hZGQiLCJjYW1sX2J5dGVzX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbCIsImNhbWxfZ3Jfc2l6ZV95IiwiY2FtbF9wYXN0YV9mcV9jb21wYXJlIiwiY2FtbF9tbF9wb3NfaW4iLCJjYW1sX2ludDY0X2FuZCIsImludGVnZXJzX3VpbnQzMl90b19pbnQ2NCIsImludGVnZXJzX3VpbnQzMl9tdWwiLCJ4XzY0IiwieV82NCIsImNhbWxfcGFzdGFfZnFfY29tbWl0bWVudHNfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnFfb3BlbmluZ19wcm9vZl9vZl9ydXN0IiwiY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnFfcHJvb2Zfb2ZfcnVzdCIsImV2YWxzMSIsImNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfY3JlYXRlIiwid2l0bmVzc19jb2xzIiwicHJldl9zZ3MiLCJjYW1sX2ludDY0X2lzX3plcm8iLCJCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViIiwiZXhwb25lbnQiLCJvbmUiLCJtdWwiLCJjYW1sX3N5c19jb25zdF93b3JkX3NpemUiLCJpbnRlZ2Vyc191aW50NjRfdG9faW50NjQiLCJtbF96X211bCIsIm1sX3pfcG9wY291bnQiLCJ6ZXJvIiwibWxfel9oYW1kaXN0IiwibWxfel9wb3ciLCJjYW1sX2JhX2NyZWF0ZSIsImRpbXNfbWwiLCJiaWdzdHJpbmdfYWxsb2MiLCJfIiwiY2FtbF9zdHJpbmdfZ2V0IiwicmVfbWF0Y2giLCJyZV93b3JkX2xldHRlcnMiLCJvcGNvZGVzIiwiaXNfd29yZF9sZXR0ZXIiLCJpbl9iaXRzZXQiLCJyZV9tYXRjaF9pbXBsIiwicGFydGlhbCIsInByb2ciLCJjcG9vbCIsIm5vcm10YWJsZSIsIm51bWdyb3VwcyIsIm51bXJlZ2lzdGVycyIsInN0YXJ0Y2hhcnMiLCJwYyIsInF1aXQiLCJncm91cHMiLCJyZV9yZWdpc3RlciIsImJhY2t0cmFjayIsIml0ZW0iLCJwdXNoIiwiYWNjZXB0IiwicHJlZml4X21hdGNoIiwib3AiLCJzYXJnIiwidWFyZyIsImdyb3VwIiwicmVfc2VhcmNoX2JhY2t3YXJkIiwiZGVmZXJyZWRfcGVlayIsIm1sX3pfbG9nYW5kIiwiY2FtbF92ZXN0YV9vZl9hZmZpbmVfY29vcmRpbmF0ZXMiLCJjdXN0b21fcmVyYWlzZV9leG4iLCJmYWxsYmFja01lc3NhZ2UiLCJjYW1sX2dyX3NpZ2lvX3NpZ25hbCIsImNhbWxfYmFfdWludDhfc2V0MzIiLCJjYW1sX3NpZ25iaXRfZmxvYXQiLCJjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUiLCJqc25hbWUiLCJjYW1sX2dyX3NldF9saW5lX3dpZHRoIiwiY2FtbF9ncl9zZXRfdGV4dF9zaXplIiwiY2FtbF9ncl9zZXRfZm9udCIsImNhbWxfZ3Jfc2V0X2NvbG9yIiwiY19zdHIiLCJjYW1sX2dyX21vdmV0byIsImNhbWxfZ3JfcmVzaXplX3dpbmRvdyIsImNhbWxfZ3Jfc3RhdGVfaW5pdCIsImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSIsInRhIiwiY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IiwiY2FtbF9tbF9zZWVrX291dCIsImNhbWxfanNfdHlwZW9mIiwiZGVmZXJyZWRfdG9fcHJvbWlzZSIsIkJhc2VfaW50X21hdGhfaW50MzJfY3R6IiwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY3R6IiwiZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVyciIsImV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXQiLCJleHBlY3RfdGVzdF9jb2xsZWN0b3JfYWZ0ZXJfdGVzdCIsInZzdGRvdXQiLCJ2c3RkZXJyIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIiwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkIiwiY3JlYXRlX25hdCIsIm1sX3pfZml0c19pbnQiLCJjYW1sX2pzX2Zyb21fYm9vbCIsImNhbWxfZ3JfY2xvc2VfZ3JhcGgiLCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludCIsImNhbWxfY3JlYXRlX3N0cmluZyIsImNhbWxfYmlnaW50XzI1Nl9vZl9kZWNpbWFsX3N0cmluZyIsIkJhc2VfaW50X21hdGhfaW50MzJfY2x6IiwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6IiwiY2FtbF9wYXN0YV9mcF9hZGQiLCJjb3JlX2tlcm5lbF90aW1lX25zX2Zvcm1hdCIsInRpbWUiLCJmb3JtYXRqcyIsImpzdHJpbmciLCJjYW1sX29ial9kdXAiLCJjYW1sX3dlYWtfZ2V0X2NvcHkiLCJjYW1sX2F0YW5oX2Zsb2F0IiwiY2FtbF9tbF9vdXRwdXRfYnl0ZXMiLCJzdHJpbmciLCJqc3N0cmluZyIsImlkIiwiY2FtbF9tbF9vdXRwdXQiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3dyaXRlIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImludGVnZXJzX3VpbnQxNl9kZXNlcmlhbGl6ZSIsImNhbWxfaGFzaF9taXhfYmlnc3RyaW5nIiwiaW50ZXJuYWxoYXNoX2ZvbGRfYmlnc3RyaW5nIiwiaW5jcl9uYXQiLCJtbF96X3NpZ24iLCJjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbCIsImNhbWxfZnBfc3JzX2JfcG9seV9jb21taXRtZW50IiwiY2hhbHMiLCJtbF96X25leHRwcmltZSIsInR3byIsImNhbWxfanNfZXhwciIsImNhbWxfcGFzdGFfZnFfZXF1YWwiLCJjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCIsImZxX29yYWNsZXNfY3JlYXRlIiwibGdyX2NvbW0iLCJ2ZXJpZmllcl9pbmRleCIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIiwiY2FtbF9ldmVudGxvZ19yZXN1bWUiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kMV9zaXplIiwiY2FtbF9oYXNoX3VuaXZfcGFyYW0iLCJoYXNoX2FjY3UiLCJoYXNoX2F1eCIsImpzYnl0ZXMiLCJjYW1sX3Zlc3RhX25lZ2F0ZSIsIm1sX3pfZGl2IiwibWxfel9kaXZleGFjdCIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciIsImNhbWxfdmVzdGFfcm5nIiwiY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9yZWFkIiwianNvb19jcmVhdGVfZmlsZV9leHRlcm4iLCJjYW1sX3RvX2pzX3N0cmluZyIsImNhbWxfcGFzdGFfZnBfcGxvbmtfY2lyY3VpdF9zZXJpYWxpemUiLCJwdWJsaWNfaW5wdXRfc2l6ZSIsImdhdGVfdmVjdG9yIiwiY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmciLCJjYW1sX21ha2VfdmVjdCIsImluaXQiLCJjYW1sX21sX291dHB1dF9jaGFyIiwiY2FtbF9vYmpfaXNfYmxvY2siLCJjYW1sX2Zsb2F0X29mX2J5dGVzIiwiY2FtbF9mcV9zcnNfcmVhZCIsImNhbWxfcGFzdGFfZnFfcGxvbmtfY2lyY3VpdF9zZXJpYWxpemUiLCJjYW1sX29ial9zZXRfcmF3X2ZpZWxkIiwiY2FtbF9maW5pc2hfZm9ybWF0dGluZyIsInJhd2J1ZmZlciIsImNhbWxfcGFzdGFfZnBfbXV0X2FkZCIsImNhbWxfdHJ1bmNfZmxvYXQiLCJjYW1sX3phcml0aF9tYXJzaGFsIiwiYmxvY2siLCJjYW1sX2ZwX3ZlY3Rvcl9lbXBsYWNlX2JhY2siLCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludDY0IiwiY2FtbF92ZXN0YV9lbmRvX3NjYWxhciIsImNhbWxfZXF1YWwiLCJjYW1sX21sX3JlZmlsbF9pbnB1dCIsInN0cl9sZW4iLCJ3aW5fZmlsZWRlc2NyX29mX2NoYW5uZWwiLCJjb21wYXJlX25hdCIsImxlbjIiLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSIsImNhbWxfaW50X29mX3N0cmluZyIsInRocmVzaG9sZCIsImNhbWxfbGlzdF9tb3VudF9wb2ludCIsInByZXYiLCJjYW1sX2ZxX3Nyc19iX3BvbHlfY29tbWl0bWVudCIsImNhbWxfbWFyc2hhbF9jb25zdGFudHMiLCJjYW1sX29ial9yYXdfZmllbGQiLCJjYW1sX2pzX2VxdWFscyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIiLCJfbWFnaWMiLCJfYmxvY2tfbGVuIiwibnVtX29iamVjdHMiLCJfc2l6ZV8zMiIsIl9zaXplXzY0Iiwib2JqX2NvdW50ZXIiLCJpbnRlcm5fcmVjIiwiaGVhZGVyIiwiZXhwZWN0ZWRfc2l6ZSIsImJpZ3N0cmluZ190b190eXBlZF9hcnJheSIsImludGVnZXJzX3VpbnQxNl9vZl9zdHJpbmciLCJtbF96X2ZpdHNfbmF0aXZlaW50IiwiY2FtbF9ncl9hcmNfYXV4IiwiY3R4IiwiY3giLCJjeSIsInJ5IiwicngiLCJyb3QiLCJ4UG9zIiwieVBvcyIsInhQb3NfcHJldiIsInlQb3NfcHJldiIsInNwYWNlIiwiY2FtbF9ncl9maWxsX2FyYyIsImNhbWxfaW50NjRfeG9yIiwiaW50ZWdlcnNfdWludDY0X2xvZ3hvciIsImludGVnZXJzX3VpbnQzMl9vZl9pbnQiLCJjYW1sX3Bhc3RhX2ZwX2NvbXBhcmUiLCJjYW1sX3BhbGxhc19vZl9hZmZpbmUiLCJjYW1sX21hcnNoYWxfZGF0YV9zaXplIiwiZ2V0MzIiLCJNbFN0cmluZ1JlYWRlciIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWUiLCJjYW1sX2JhX2tpbmQiLCJjYW1sX291dF9jaGFubmVsX3Bvc19mZCIsImNhbWxfanNfZnVuX2NhbGwiLCJjYW1sX2djX21ham9yX3NsaWNlIiwid29yayIsImNhbWxfaW50NjRfaXNfbmVnYXRpdmUiLCJjYW1sX2ludDY0X2Zvcm1hdCIsIndiYXNlIiwiY3Z0YmwiLCJjYW1sX25ld19zdHJpbmciLCJpbnRlZ2Vyc191aW50NjRfdG9fc3RyaW5nIiwiY2FtbF9ncl93YWl0X2V2ZW50IiwiX2V2bCIsImludGVnZXJzX3VpbnQzMl9zZXJpYWxpemUiLCJjYW1sX3Bhc3RhX2ZwX3Bvc2VpZG9uX3BhcmFtc19jcmVhdGUiLCJjYW1sX3JlY29yZF9iYWNrdHJhY2UiLCJ1bml4X2dtdGltZSIsImNhbWxfcGFzdGFfZnFfc3FydCIsInVuaXhfdGltZSIsImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QiLCJjYW1sX2NyZWF0ZV9maWxlIiwianNvb19jcmVhdGVfZmlsZSIsIm1sX3pfaGFzaCIsImFjYyIsImludGVnZXJzX3VpbnQ2NF9sb2dhbmQiLCJyZV9zdHJpbmdfbWF0Y2giLCJCaWdTdHJpbmdSZWFkZXIiLCJjYW1sX2JhX2dldF9nZW5lcmljIiwiY2FtbF9mcV92ZWN0b3JfZW1wbGFjZV9iYWNrIiwiQmFzZV9pbnRfbWF0aF9pbnRfY2x6IiwiY2FtbF9wYXN0YV9mcF9vZl9iaWdpbnQiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmciLCJtbF96X3Jvb3QiLCJlbmQiLCJhbnMiLCJtaWQiLCJwbyIsIm1sX3pfc3FydF9yZW0iLCJkaWZmIiwiY2FtbF9lcGhlX2RhdGFfb2Zmc2V0IiwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkiLCJjYW1sX21lbXByb2Zfc3RhcnQiLCJyYXRlIiwic3RhY2tfc2l6ZSIsInRyYWNrZXIiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X21heF9kZWdyZWUiLCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IiwiY2FtbF9mcF9zcnNfYmF0Y2hfYWNjdW11bGF0b3JfZ2VuZXJhdGUiLCJydXN0X2NoYWxzIiwicnVzdF9jb21tcyIsImFkZF9uYXQiLCJuYXRfb2ZfYXJyYXkiLCJtdWx0X2RpZ2l0X25hdCIsIm5hdDMiLCJvZnMzIiwieDEiLCJ4MiIsIngzIiwibXVsdF9uYXQiLCJsZW4zIiwic3F1YXJlX25hdCIsImNhbWxfanNfZnJvbV9mbG9hdCIsImNhbWxfZ2Nfc3RhdCIsImludGVnZXJzX3VpbnQ2NF9vZl91aW50MzIiLCJjYW1sX3Bhc3RhX2ZxX2FkZCIsImNhbWxfc3lzX21vZGlmeV9hcmd2IiwiY2FtbF9tZXRob2RfY2FjaGUiLCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kIiwiY2FjaGVpZCIsIm1ldGhzIiwibGkiLCJjYW1sX3Zlc3RhX2FmZmluZV9kZWVwX2NvcHkiLCJiaW5fcHJvdF9ibGl0X2J1Zl9ieXRlc19zdHViIiwiY2FtbF9qc19nZXRfY29uc29sZSIsImNhbWxfc3lzX3Vuc2FmZV9nZXRlbnYiLCJiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkiLCJjYW1sX3JvdW5kX2Zsb2F0IiwibWxfel9vZl9iaXRzIiwiYmFzZTEiLCJ1bml4X3N0YXQiLCJ1bml4X3N0YXRfNjQiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX3NpbmhfZmxvYXQiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3JlYWQiLCJjYW1sX2xkZXhwX2Zsb2F0IiwiY2FtbF96YXJpdGhfdW5tYXJzaGFsIiwibmVnYXRlIiwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2siLCJjYW1sX2J5dGVzX2xlc3N0aGFuIiwiY2FtbF9zdHJpbmdfbGVzc3RoYW4iLCJjYW1sX3Bhc3RhX2ZxX29mX2ludCIsImNhbWxfb2JqX3NldF90YWciLCJpbnRlZ2Vyc191aW50OF9vZl9zdHJpbmciLCJjYW1sX2JhX3NldF8zIiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsImNhbWxfZ2V0X21ham9yX2J1Y2tldCIsImludGVnZXJzX3VpbnQzMl9zdWIiLCJjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZyIsImNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfY3JlYXRlIiwic2V0X2RpZ2l0X25hdF9uYXRpdmUiLCJudGhfZGlnaXRfbmF0X25hdGl2ZSIsImNhbWxfc3RyaW5nX3NldDY0IiwiaW50ZWdlcnNfdWludDMyX2RpdiIsImNhbWxfZ3JfZHJhd19hcmMiLCJjYW1sX2JhX21hcF9maWxlIiwidmZkIiwic2hhcmVkIiwiY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZSIsImFyZ24iLCJ1bml4X3N5bWxpbmsiLCJzcmNfcm9vdCIsImRzdF9yb290IiwiZnBfb3JhY2xlc19jcmVhdGUiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2V4YW1wbGVfd2l0aF94b3IiLCJjYW1sX2JhX2NyZWF0ZV9mcm9tIiwiZGF0YTEiLCJkYXRhMiIsImpzdHlwIiwiY2FtbF9mcV92ZWN0b3JfZ2V0IiwiQmFzZV9pbnRfbWF0aF9pbnRfY3R6IiwiYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViIiwiY2FtbF9ncl9kcmF3X3N0ciIsImR4IiwiY2FtbF9ncl9kcmF3X3N0cmluZyIsImNhbWxfZnBfdmVjdG9yX2NyZWF0ZSIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmciLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9wYWxsYXNfdG9fYWZmaW5lIiwiY2FtbF9mcV9zcnNfY3JlYXRlIiwiY2FtbF9tbF9wb3Nfb3V0IiwiY29yZV9hcnJheV91bnNhZmVfZmxvYXRfYmxpdCIsImNhbWxfc3BhY2V0aW1lX2VuYWJsZWQiLCJjYW1sX2pzX29iamVjdCIsImludGVnZXJzX3VpbnQ2NF9tYXJzaGFsIiwiY2FtbF9mbWFfZmxvYXQiLCJTUExJVCIsIk1JTl9WQUxVRSIsIkVQU0lMT04iLCJDIiwiQSIsIkIiLCJtdWx0aXBseSIsImF0IiwiYWhpIiwiYWxvIiwiYnQiLCJiaGkiLCJibG8iLCJhZGp1c3QiLCJzY2FsZSIsInhzIiwieXMiLCJ6cyIsInh5IiwidSIsImNhbWxfYnl0ZXNfb2ZfdWludDhhcnJheSIsInVpbnQ4YXJyYXkiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2RpZ2VzdCIsImNvcmVfa2VybmVsX2djX2NvbXBhY3Rpb25zIiwiY2FtbF9zdHJpbmdfZ2V0MTYiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kNF9zaXplIiwiY2FtbF9lcGhlX3Vuc2V0X2RhdGEiLCJjYW1sX3dlYWtfYmxpdCIsImNhbWxfZXBoZV9ibGl0X2tleSIsImNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfZGlnZXN0IiwiY2FtbF9pbml0aWFsX3RpbWUiLCJjYW1sX3N5c190aW1lIiwibm93IiwiY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuIiwiZnBfb3JhY2xlc19kdW1teSIsIkJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9leGFtcGxlX3dpdGhfcmFuZ2VfY2hlY2siLCJjYW1sX2JpZ2ludF8yNTZfY29tcGFyZSIsImNhbWxfYmFfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2ZyZXhwX2Zsb2F0IiwiQ29yZV9rZXJuZWxfaGVhcF9ibG9ja19pc19oZWFwX2Jsb2NrIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYSIsImJpZ3N0cmluZ19ibGl0X2J5dGVzX2JpZ3N0cmluZ19zdHViIiwibWxfel9wcmVkIiwibWxfel9leHRyYWN0IiwibWxfel9sb2dub3QiLCJjYW1sX3Bhc3RhX2ZxX3JuZyIsImNhbWxfcGFzdGFfZnBfaXNfc3F1YXJlIiwiY2FtbF9vcmFjbGVzX3RvX3J1c3QiLCJmcF9vcmFjbGVzX2RlZXBfY29weSIsImNhbWxfZ2V0X21pbm9yX2ZyZWUiLCJjYW1sX3NldF9zdGF0aWNfZW52IiwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0IiwibmV3X2RpbXMiLCJjb3JlX2tlcm5lbF9nY190b3BfaGVhcF93b3JkcyIsImNhbWxfcGFzdGFfZnFfcG9zZWlkb25fcGFyYW1zX2NyZWF0ZSIsInVuaXhfbWtkaXIiLCJwZXJtIiwiY2FtbF9ncl9jdXJyZW50X3kiLCJjYW1sX2Zvcm1hdF9pbnQiLCJjYW1sX29ial90cnVuY2F0ZSIsImNhbWxfZnFfc3JzX2xhZ3JhbmdlX2NvbW1pdG1lbnQiLCJkb21haW5fc2l6ZSIsImNhbWxfcnVudGltZV92YXJpYW50IiwiY2FtbF9hcnJheV9jb25jYXQiLCJjYW1sX2dyX3N0YXRlX3NldCIsImNhbWxfZ3Jfc3RhdGVfY3JlYXRlIiwiY2FudmFzIiwiY29udGV4dCIsImNhbWxfZ3Jfb3Blbl9ncmFwaCIsInNwZWNzIiwic3RhdHVzIiwid2luIiwiZG9jIiwidGl0bGUiLCJib2R5IiwiY2FtbF9wYWxsYXNfZW5kb19zY2FsYXIiLCJjYW1sX2VwaGVfc2V0X2RhdGEiLCJjYW1sX21ha2VfZmxvYXRfdmVjdCIsImNhbWxfYmlnaW50XzI1Nl9vZl9udW1lcmFsIiwiY2FtbF9iaWdpbnRfMjU2X3ByaW50IiwiY2FtbF9tZW1wcm9mX3N0b3AiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfcGFzdGFfZnFfc3F1YXJlIiwiY2FtbF9wYXN0YV9mcV9tdXRfc3F1YXJlIiwibWxfel9udW1iaXRzIiwidXBwZXJCb3VuZCIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIiwiY2FtbF9sb2cxcF9mbG9hdCIsImNhbWxfcGFzdGFfZnFfcG9zZWlkb25fYmxvY2tfY2lwaGVyIiwiX2Zha2VfcGFyYW1zIiwiZnFfdmVjdG9yIiwid2FzbV9mbGF0X3ZlY3RvciIsIm5ld19mcV92ZWN0b3IiLCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImludGVnZXJzX3VpbnQ2NF9tdWwiLCJtbF96X2NvbXBhcmUiLCJtbF96X2luaXQiLCJjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uIiwiY2FtbF9mb3JtYXRfZXhjZXB0aW9uIiwiYnVja2V0IiwiY2FtbF9ncl9kb2Nfb2Zfc3RhdGUiLCJzdGF0ZSIsImNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfcmVhZCIsImNhbWxfcGFzdGFfZnBfbmVnYXRlIiwiYmluX3Byb3RfYmxpdF9zdHJpbmdfYnVmX3N0dWIiLCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfcGFzdGFfZnBfc3ViIiwiY2FtbF9wYXN0YV9mcF9tdXRfc3ViIiwiY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IiwiaW50ZWdlcnNfdWludDY0X3VubWFyc2hhbCIsIm1sX3pfZml0c19pbnQ2NCIsIm1sX3pfdG9faW50NjQiLCJtYXNrIiwibWxfel9zaXplIiwiY2FtbF9iYWNrdHJhY2Vfc3RhdHVzIiwiY2FtbF9tb2RmX2Zsb2F0IiwiY2FtbF9nY19nZXQiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX2ZwX3Nyc19jb21taXRfZXZhbHVhdGlvbnMiLCJmcHMiLCJjYW1sX3BhcnNlX2VuZ2luZSIsInRhYmxlcyIsImVudiIsImNtZCIsIkVSUkNPREUiLCJsb29wIiwidGVzdHNoaWZ0Iiwic2hpZnRfcmVjb3ZlciIsInJlZHVjZSIsIlJFQURfVE9LRU4iLCJSQUlTRV9QQVJTRV9FUlJPUiIsIkdST1dfU1RBQ0tTXzEiLCJHUk9XX1NUQUNLU18yIiwiQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04iLCJDQUxMX0VSUk9SX0ZVTkNUSU9OIiwiZW52X3Nfc3RhY2siLCJlbnZfdl9zdGFjayIsImVudl9zeW1iX3N0YXJ0X3N0YWNrIiwiZW52X3N5bWJfZW5kX3N0YWNrIiwiZW52X3N0YWNrc2l6ZSIsImVudl9zdGFja2Jhc2UiLCJlbnZfY3Vycl9jaGFyIiwiZW52X2x2YWwiLCJlbnZfc3ltYl9zdGFydCIsImVudl9zeW1iX2VuZCIsImVudl9hc3AiLCJlbnZfcnVsZV9sZW4iLCJlbnZfcnVsZV9udW1iZXIiLCJlbnZfc3AiLCJlbnZfc3RhdGUiLCJlbnZfZXJyZmxhZyIsInRibF90cmFuc2xfY29uc3QiLCJ0YmxfdHJhbnNsX2Jsb2NrIiwidGJsX2xocyIsInRibF9sZW4iLCJ0YmxfZGVmcmVkIiwidGJsX2Rnb3RvIiwidGJsX3NpbmRleCIsInRibF9yaW5kZXgiLCJ0YmxfZ2luZGV4IiwidGJsX3RhYmxlc2l6ZSIsInRibF90YWJsZSIsInRibF9jaGVjayIsIm4xIiwibjIiLCJzdGF0ZTEiLCJzcCIsImVycmZsYWciLCJhc3AiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2NyZWF0ZSIsImNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZXhhbXBsZV93aXRoX2ZvcmVpZ25fZmllbGRfbXVsIiwiY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9sZW4iLCJjYW1sX3Bhc3RhX2ZxX3R3b19hZGljX3Jvb3Rfb2ZfdW5pdHkiLCJjYW1sX3Zlc3RhX3NjYWxlIiwibWxfel9pbnN0YWxsX2ZyYW1ldGFibGUiLCJjYW1sX3N5c19ta2RpciIsImJpZ3N0cmluZ19ibGl0X3N0dWIiLCJjYW1sX2J5dGVzX2VxdWFsIiwiY2FtbF9zdHJpbmdfZXF1YWwiLCJjYW1sX3N0cmluZ19ub3RlcXVhbCIsImNhbWxfcGFzdGFfZnBfc3FydCIsIkJhc2VfaW50X21hdGhfaW50X3BvcGNvdW50IiwiY2FtbF9yZWFkX2ZpbGVfY29udGVudCIsImNhbWxfanNfdG9fZmxvYXQiLCJjYW1sX3Bhc3RhX2ZwX3JuZyIsImNhbWxfcGFzdGFfZnBfdG9fc3RyaW5nIiwiY2FtbF9ncl9wb2ludF9jb2xvciIsImRlZmVycmVkX29mX3Byb21pc2UiLCJwcm9taXNlIiwiY2FtbF9zeXNfcmVuYW1lIiwib19yb290Iiwibl9yb290IiwiY2FtbF9wYXN0YV9mcF9lcXVhbCIsImludGVnZXJzX3VpbnQzMl9kZXNlcmlhbGl6ZSIsImNhbWxfYmlnaW50XzI1Nl9kaXYiLCJpbnRlZ2Vyc191aW50MzJfdG9fc3RyaW5nIiwiY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IiwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUiLCJjYW1sX2djX21pbm9yIiwiY2FtbF92ZXN0YV9zdWIiLCJjYW1sX2JhX251bV9kaW1zIiwiYmlnc3RyaW5nYWZfbWVtY21wX2JpZ3N0cmluZyIsImJhMV9vZmYiLCJiYTJfb2ZmIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfZnNfaW5pdCIsIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nIiwiY2FtbF9zeXNfY2hkaXIiLCJkaXIiLCJjYW1sX2ZxX3Nyc19iYXRjaF9hY2N1bXVsYXRvcl9jaGVjayIsImNhbWxfcGFzdGFfZnBfZGVlcF9jb3B5IiwibWxfel9hZGQiLCJtbF96X2NkaXYiLCJ6MV9wb3MiLCJ6Ml9wb3MiLCJjYW1sX2JhX3NldF8xIiwiYmlnc3RyaW5nYWZfYmxpdF9mcm9tX2J5dGVzIiwic3JjX29mZiIsImRzdF9vZmYiLCJjYW1sX2ZxX3Nyc19jb21taXRfZXZhbHVhdGlvbnMiLCJmcXMiLCJjYW1sX3Bhc3RhX2ZwX29mX2J5dGVzIiwiZGl2X2hlbHBlciIsImRpdl9kaWdpdF9uYXQiLCJuYXRxIiwib2ZzcSIsIm5hdHIiLCJvZnNyIiwicmVtIiwibnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0Iiwic2hpZnRfbGVmdF9uYXQiLCJzZXRfdG9femVyb19uYXQiLCJzdWJfbmF0IiwiZGl2X25hdCIsInF1byIsImNhbWxfYmFfYmxpdCIsImlzX2RpZ2l0X2ludCIsImludGVnZXJzX3VpbnQzMl9oYXNoIiwiYmlnc3RyaW5nX2ZpbmQiLCJjaHIiLCJjYW1sX3N0cmluZ191bnNhZmVfc2V0IiwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjQiLCJjYW1sX3Bhc3RhX2ZxX211bCIsIm1sX3pfb2ZfaW50NjQiLCJpbnRlZ2Vyc191aW50NjRfb2ZfaW50IiwibWxfel9uZWciLCJjYW1sX2JhX3Jlc2hhcGUiLCJ2aW5kIiwibmV3X2RpbSIsImV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9iZWZvcmVfdGVzdCIsInZvdXRwdXQiLCJjYW1sX3NldF9vb19pZCIsIm1sX3pfb2ZfaW50IiwibWxfel9vZl9pbnQzMiIsImkzMiIsImNhbWxfcmFpc2Vfd2l0aF9hcmciLCJjYW1sX2NvbXBhcmUiLCJjYW1sX3Bhc3RhX2ZxX3RvX2J5dGVzIiwiY2FtbF9wYWxsYXNfc3ViIiwiY2FtbF9iaWdzdHJpbmdfbWVtY21wIiwiY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCIsImNhbWxfZ3JfY2xlYXJfZ3JhcGgiLCJjYW1sX3Bhc3RhX2ZxX211dF9hZGQiLCJseG9yX2RpZ2l0X25hdCIsImludGVnZXJzX3VpbnQ2NF9yZW0iLCJtbF96X2xvZ29yIiwibWxfel9maXRzX2ludDMyIiwiY2FtbF9sZXhfZW5naW5lIiwidGJsIiwic3RhcnRfc3RhdGUiLCJsZXhidWYiLCJsZXhfYnVmZmVyIiwibGV4X2J1ZmZlcl9sZW4iLCJsZXhfc3RhcnRfcG9zIiwibGV4X2N1cnJfcG9zIiwibGV4X2xhc3RfcG9zIiwibGV4X2xhc3RfYWN0aW9uIiwibGV4X2VvZl9yZWFjaGVkIiwibGV4X2Jhc2UiLCJsZXhfYmFja3RyayIsImxleF9kZWZhdWx0IiwibGV4X3RyYW5zIiwibGV4X2NoZWNrIiwiYmFja3RyayIsImNhbWxfc3lzX2ZpbGVfZXhpc3RzIiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfYXJyYXlfc3ViIiwiY2FtbF9ncl9zaXplX3giLCJjYW1sX3Bhc3RhX2ZwX3NpemUiLCJjYW1sX3Bhc3RhX2ZxX211dF9tdWwiLCJjYW1sX2JpZ2ludF8yNTZfbnVtX2xpbWJzIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiIsImNhbWxfY29zaF9mbG9hdCIsImNhbWxfcGFzdGFfZnBfb2ZfaW50IiwiY2FtbF93ZWFrX2NoZWNrIiwiY2FtbF9lcGhlX2NoZWNrX2tleSIsImNhbWxfZ3JfdGV4dF9zaXplIiwidHh0IiwiY2FtbF9sZXhfcnVuX21lbSIsIm1lbSIsImN1cnJfcG9zIiwiY2FtbF9sZXhfcnVuX3RhZyIsImNhbWxfbmV3X2xleF9lbmdpbmUiLCJsZXhfbWVtIiwibGV4X2Jhc2VfY29kZSIsImxleF9iYWNrdHJrX2NvZGUiLCJsZXhfZGVmYXVsdF9jb2RlIiwibGV4X3RyYW5zX2NvZGUiLCJsZXhfY2hlY2tfY29kZSIsImxleF9jb2RlIiwicGNfb2ZmIiwicHN0YXRlIiwiYmFzZV9jb2RlIiwiaW50ZWdlcnNfdWxvbmdfc2l6ZSIsImNhbWxfYWNvc2hfZmxvYXQiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2RlZXBfY29weSIsImNhbWxfbWxfc2Vla19vdXRfNjQiLCJjb21wYXJlX25hdF9yZWFsIiwiY2FtbF9nY19zZXQiLCJpbnRlZ2Vyc191aW50MzJfc2hpZnRfbGVmdCIsImNhbWxfanNfZ2V0IiwiY2FtbF9nY19jb21wYWN0aW9uIiwiYmluX3Byb3RfYmxpdF9mbG9hdF9hcnJheV9idWZfc3R1YiIsImZsb2F0NjQiLCJmbG9hdDY0X3VpbnQ4IiwiQmFzZV9pbnRfbWF0aF9pbnRfcG93X3N0dWIiLCJpc19kaWdpdF96ZXJvIiwiY2FtbF9qc19zZXQiLCJjYW1sX3Bhc3RhX2ZwX29mX3N0cmluZyIsImNhbWxfdmVzdGFfZG91YmxlIiwiY2FtbF9wYXN0YV9mcF9wb3NlaWRvbl9ibG9ja19jaXBoZXIiLCJmcF92ZWN0b3IiLCJuZXdfZnBfdmVjdG9yIiwibWxfel90ZXN0Yml0IiwiY29yZV9rZXJuZWxfZ2NfbWFqb3JfcGx1c19taW5vcl93b3JkcyIsImNhbWxfYXJyYXlfZ2V0IiwicHJvdmVyX3RvX2pzb24iLCJjYW1sX2xvZzJfZmxvYXQiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3NoaWZ0cyIsImxvZzJfc2l6ZSIsImJpbl9wcm90X2JsaXRfYnl0ZXNfYnVmX3N0dWIiLCJjYW1sX2ludDY0X3N1YiIsImJpbl9wcm90X2JsaXRfYnVmX3N0dWIiLCJjYW1sX2ludDY0X3NoaWZ0X2xlZnQiLCJjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSIsImNhbWxfZnBfc3JzX2xhZ3JhbmdlX2NvbW1pdG1lbnQiLCJjYW1sX2JhX2RpbSIsImNhbWxfYmFfZGltXzEiLCJtbF96X3NxcnQiLCJjYW1sX2ZwX3Nyc19iYXRjaF9hY2N1bXVsYXRvcl9jaGVjayIsImNhbWxfanNfdG9fYnl0ZV9zdHJpbmciLCJkZWZlcnJlZF92YWx1ZV9leG4iLCJtbF96X3Byb2JhYl9wcmltZSIsInVuaXhfbWt0aW1lIiwidG0iLCJ0bTIiLCJjYW1sX2JpZ2ludF8yNTZfZGVlcF9jb3B5IiwiY2FtbF9mcV9zcnNfYWRkX2xhZ3JhbmdlX2Jhc2lzIiwiY2FtbF9ieXRlc19nZXQ2NCIsImNhbWxfcGFzdGFfZnFfb2ZfYmlnaW50IiwiY2FtbF9mcV92ZWN0b3JfbGVuZ3RoIiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9oeXBvdF9mbG9hdCIsImNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfd3JpdGUiLCJjYW1sX3Bhc3RhX2ZxX2ludiIsImNhbWxfZnBfdmVjdG9yX2xlbmd0aCIsIm1sX3pfdG9faW50IiwiYmlnc3RyaW5nYWZfYmxpdF90b19ieXRlcyIsImNhbWxfZXJmY19mbG9hdCIsImNhbWxfbWxfaW5wdXRfaW50IiwiY2FtbF9wYXN0YV9mcF9pbnYiLCJjYW1sX2Zsb2F0X29mX3N0cmluZyIsIm0zIiwibWFudGlzc2EiLCJjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuIiwiY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQiLCJjb3JlX2tlcm5lbF9nY19tYWpvcl93b3JkcyIsImNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uIiwiaW50ZWdlcnNfdWludDMyX2xvZ2FuZCIsIm1sX3pfc3VjYyIsInVuaXhfbHN0YXQiLCJ1bml4X2xzdGF0XzY0IiwiY2FtbF9iYV9zZXRfZ2VuZXJpYyIsImNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfZHVtbXkiLCJjYW1sX25leHRhZnRlcl9mbG9hdCIsImludGVnZXJzX3VpbnQ2NF9tYXgiLCJpbnRlZ2Vyc191aW50NjRfb2ZfaW50NjQiLCJtbF96X2djZCIsImNhbWxfcGFzdGFfZnBfdG9fYnl0ZXMiLCJpbnRlZ2Vyc19zaXplX3Rfc2l6ZSIsImNhbWxfanNfZnJvbV9zdHJpbmciLCJjYW1sX2JhX3N1YiIsImNoYW5nZWRfZGltIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9kb21haW5fZDRfc2l6ZSIsImNhbWxfZ2NfZnVsbF9tYWpvciIsImNhbWxfYnl0ZXNfc2V0MzIiLCJtbF96X2Rpdl9yZW0iLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCIsImNhbWxfZ3JfY3VycmVudF94IiwiY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2V4YW1wbGVfd2l0aF9mZmFkZCIsImNhbWxfZ3JfbGluZXRvIiwiY2FtbF9iYV9kaW1fMyIsImNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uIiwidGhyb3dfZXJyb3JzIiwiY29sbGVjdF9zdHJpbmdzIiwiY2FtbF9wYWxsYXNfcm5nIiwiY2FtbF9lcGhlX2NoZWNrX2RhdGEiLCJjYW1sX2J5dGVzX2dldDE2IiwiY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9jcmVhdGUiLCJjYW1sX21sX3NldF9jaGFubmVsX25hbWUiLCJjYW1sX2V4cDJfZmxvYXQiLCJjYW1sX3Bhc3RhX2ZwX3ByaW50IiwiY2FtbF9wYXN0YV9mcF9tdWwiLCJjYW1sX3Bhc3RhX2ZwX211dF9tdWwiLCJiaWdzdHJpbmdfbWVtc2V0X3N0dWIiLCJ2X3BvcyIsInZfY2hhciIsImNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfZG9tYWluX2Q4X3NpemUiLCJjYW1sX3Bhc3RhX2ZwX3NpemVfaW5fYml0cyIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwiY2FtbF9tbF9pc19idWZmZXJlZCIsImNhbWxfZnFfcGxvbmtfZ2F0ZV90b19ydXN0IiwiY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9hZGQiLCJjYW1sX3Zlc3RhX29uZSIsIkJhc2VfaW50X21hdGhfaW50NjRfY2x6IiwiY2FtbF9hcnJheV9hcHBlbmQiLCJjYW1sX3BhbGxhc19lbmRvX2Jhc2UiLCJjYW1sX3Bhc3RhX2ZwX2RpdiIsIm1sX3pfc3ViIiwibWxfel9mZGl2IiwiY2FtbF9mcV9zcnNfd3JpdGUiLCJtbF96X3RvX2JpdHMiLCJyZV9yZXBsYWNlbWVudF90ZXh0IiwicmVwbCIsIm9yaWciLCJjdXIiLCJjYW1sX3B1cmVfanNfZXhwciIsImJsaXRfbmF0IiwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSIsImNhbWxfcGFzdGFfZnBfZG9tYWluX2dlbmVyYXRvciIsImNhbWxfaW50NjRfb2Zfc3RyaW5nIiwiYmFzZTY0IiwiZGVmZXJyZWRfdXBvbl9leG4iLCJmdW5jIiwicmVfc2VhcmNoX2ZvcndhcmQiLCJjYW1sX21sX3NlZWtfaW4iLCJjYW1sX3N5c19yZWFkX2RpcmVjdG9yeSIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiIsImNhbWxfbWxfaW5wdXRfY2hhciIsImNhbWxfanNfdmFyIiwiaW50ZWdlcnNfdWludDY0X3RvX2ludCIsImNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3Jfd3JhcCIsImNhbWxfZXBoZV9ibGl0X2RhdGEiLCJjb3JlX2tlcm5lbF9nY19wcm9tb3RlZF93b3JkcyIsImNhbWxfaXNfcHJpbnRhYmxlIiwicmVfcGFydGlhbF9tYXRjaCIsImNhbWxfc3lzX3JhbmRvbV9zZWVkIiwiYnVmZiIsImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8yIiwid2luX2hhbmRsZV9mZCIsImNhbWxfYmFfdWludDhfc2V0MTYiLCJjYW1sX2JpZ2ludF8yNTZfdG9fYnl0ZXMiLCJjb3JlX2tlcm5lbF9nY19oZWFwX2NodW5rcyIsImNhbWxfYmFfc2xpY2UiLCJudW1faW5kcyIsInN1Yl9kaW1zIiwibWxfel9vZl9uYXRpdmVpbnQiLCJtbF96X2ludmVydCIsIm1sX3pfcG93bSIsInozIiwiaW52IiwibWxfel9wb3dtX3NlYyIsImNhbWxfanNfcHVyZV9leHByIiwiY29yZV9hcnJheV91bnNhZmVfaW50X2JsaXQiLCJjb21wYXJlX2RpZ2l0c19uYXQiLCJjYW1sX21sX2lucHV0IiwiY2FtbF9mcV9zcnNfYmF0Y2hfYWNjdW11bGF0b3JfZ2VuZXJhdGUiLCJjYW1sX2dyX3NpZ2lvX2hhbmRsZXIiLCJjYW1sX3Bhc3RhX2ZxX3RvX2JpZ2ludCIsImNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSIsImNhbWxfc3lzX2dldF9jb25maWciLCJjYW1sX2ZwX3Nyc19yZWFkIiwiZGVmZXJyZWRfYmluZCIsIm5ld0RlZmVycmVkIiwiYW5vdGhlckRlZmVycmVkIiwiY2FtbF9iaWdpbnRfMjU2X29mX2J5dGVzIiwiY2FtbF9hc2luaF9mbG9hdCIsImNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfbWF4X2RlZ3JlZSIsImNvcmVfa2VybmVsX2djX21pbm9yX2NvbGxlY3Rpb25zIiwiYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlciIsImFiIiwiY2FtbF9tb2QiLCJjYW1sX2JhX2luaXQiLCJjYW1sX3Bhc3RhX2ZxX3NpemVfaW5fYml0cyIsImNhbWxfZ3JfZHVtcF9pbWFnZSIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UiLCJpbnRlZ2Vyc191aW50NjRfY29tcGFyZSIsImNhbWxfZm9ybWF0X2Zsb2F0IiwidG9GaXhlZCIsImRwIiwicHJlYyIsImNhbWxfbW91bnRfYXV0b2xvYWQiLCJtbF96X2VxdWFsIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4iLCJjYW1sX2RpdiIsIm1sX3pfcGVyZmVjdF9zcXVhcmUiLCJjYW1sX3N5c19nZXRfYXJndiIsImNhbWxfZ3JfY3JlYXRlX2ltYWdlIiwiY2FtbF9lcGhlX2dldF9rZXlfY29weSIsImNhbWxfbGVzc3RoYW4iLCJtbF96X3RvX25hdGl2ZWludCIsImJpZ3N0cmluZ2FmX21lbWNtcF9zdHJpbmciLCJiYV9vZmYiLCJzdHJfb2ZmIiwiY2FtbF9yZWdpc3Rlcl9nbG9iYWwiLCJuYW1lX29wdCIsImNvcmVfbWQ1X2RpZ2VzdF9zdWJiaWdzdHJpbmciLCJyZXMyIiwiY2FtbF9mcF9zcnNfY3JlYXRlIiwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSIsImNhbWxfZ2V0X21ham9yX2NyZWRpdCIsImNhbWxfcGFsbGFzX29mX2FmZmluZV9jb29yZGluYXRlcyIsImNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZXhhbXBsZV93aXRoX2xvb2t1cCIsImRlZmVycmVkX21hcCIsImNhbWxfb2pzX25ld19hcnIiLCJpbnRlZ2Vyc191aW50NjRfc2hpZnRfbGVmdCIsImNhbWxfdmVzdGFfcmFuZG9tIiwiY29tcGxlbWVudF9uYXQiLCJjYW1sX3Bhc3RhX2ZxX2RpdiIsIm1sX3pfbG9neG9yIiwiY2FtbF9wYXN0YV9mcV9zaXplIiwiY2FtbF9qc19yZWdleHBzIiwiY2FtbF9qc19odG1sX2VzY2FwZSIsImNhbWxfYmFfZGltXzIiLCJtbF96X3RyYWlsaW5nX3plcm9zIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCIsImFyaXR5IiwiY2FtbF9nY19taW5vcl93b3JkcyIsImNhbWxfcGFsbGFzX3NjYWxlIiwibGFuZF9kaWdpdF9uYXQiLCJjYW1sX2ludDY0X21vZCIsInVuaXhfcmVhZGxpbmsiLCJjYW1sX2ludDMyX2Jzd2FwIiwid2luX3N0YXJ0dXAiLCJjYW1sX2pzX2luc3RhbmNlb2YiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2siLCJpbnRlZ2Vyc191aW50MzJfc2hpZnRfcmlnaHQiLCJjYW1sX3RhbmhfZmxvYXQiLCJpbnRlZ2Vyc191aW50X3NpemUiLCJjYW1sX2dyX2RyYXdfY2hhciIsImNhbWxfdW5tb3VudCIsImNhbWxfcGFzdGFfZnFfbmVnYXRlIiwiY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9kZWVwX2NvcHkiLCJpbnRlZ2Vyc191c2hvcnRfc2l6ZSIsImNhbWxfbWxfcG9zX2luXzY0IiwiY2FtbF9ncl9kcmF3X2ltYWdlIiwiaW1hZ2UiLCJjYW1sX3N0cmluZ19zZXQiLCJjYW1sX3N5c19ybWRpciIsIkJhc2VfaW50X21hdGhfaW50NjRfY3R6IiwiaXNfemVybyIsImxhbmQiLCJzbWFsbF9pbnQ2NCIsImludGVnZXJzX3VpbnQzMl9yZW0iLCJjYW1sX2J5dGVzX25vdGVxdWFsIiwiY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3NoaWZ0cyIsImludGVnZXJzX3VpbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSIsImNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZHVtbXkiLCJCYXNlX2ludGVybmFsaGFzaF9nZXRfaGFzaF92YWx1ZSIsImludGVnZXJzX3VpbnQ2NF9zdWIiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3dyaXRlIiwiY2FtbF9ic3dhcDE2IiwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiY2FtbF9ncl9kcmF3X3JlY3QiLCJjYW1sX3Bhc3RhX2ZwX3JhbmRvbSIsImNhbWxfb3V0cHV0X3ZhbHVlIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl93cmFwIiwiY2FtbF9iYV9nZXRfMyIsImNhbWxfZnFfdmVjdG9yX2NyZWF0ZSIsImNhbWxfcGFzdGFfZnFfcmFuZG9tIiwibWxfel90b19pbnQzMiIsImNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZHVtbXkiLCJkZWZlcnJlZF91cG9uIiwiZGVmZXJyZWRfcnVuIiwidW5peF9nZXRwd3VpZCIsImNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZXhhbXBsZV93aXRoX3JvdCIsImNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfYmF0Y2hfdmVyaWZ5IiwiaW5kZXhlcyIsInByb29mcyIsImNhbWxfb2JqX3RhZyIsIkZ1bmN0aW9uIiwiY2FtbF9ieXRlc19nZXQzMiIsImNvcmVfa2VybmVsX2djX21ham9yX2NvbGxlY3Rpb25zIiwiY2FtbF9zdHJpbmdfZ2V0NjQiLCJjYW1sX2pzX2Vycm9yX29wdGlvbl9vZl9leGNlcHRpb24iLCJjYW1sX21sX3Bvc19vdXRfNjQiLCJtbF96X29mX2Zsb2F0IiwiZjEiLCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyIsImNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfbGVuIiwiY2FtbF9mbG9hdGFycmF5X2JsaXQiLCJmcV9vcmFjbGVzX2R1bW15IiwiZGVmZXJyZWRfcmV0dXJuIiwiQmFzZV9oYXNoX2RvdWJsZSIsImNhbWxfanNfbmV3IiwiY2FtbF9wYXN0YV9mcF90d29fYWRpY19yb290X29mX3VuaXR5IiwiY2FtbF9qc190b19zdHJpbmciLCJjYW1sX3Bhc3RhX2ZxX29mX3N0cmluZyIsImlzX2RpZ2l0X29kZCIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCIsImludGVnZXJzX3VpbnQ2NF9oYXNoIiwiY2FtbF9jYnJ0X2Zsb2F0IiwiY2FtbF9ldmVudGxvZ19wYXVzZSIsImNvcmVfa2VybmVsX2djX2hlYXBfd29yZHMiLCJiaWdzdHJpbmdhZl9ibGl0X3RvX2JpZ3N0cmluZyIsImNhbWxfcGFsbGFzX29uZSIsIm1zX3RvX25hbm8iLCJ0aW1lX25vd19uYW5vc2Vjb25kc19zaW5jZV91bml4X2Vwb2NoX29yX3plcm8iLCJtcyIsIm1zX2k2MyIsImxvcl9kaWdpdF9uYXQiLCJjYW1sX2dyX2JsaXRfaW1hZ2UiLCJpbTIiLCJjYW1sX2dyX3dpbmRvd19pZCIsImNhbWxfYmlnaW50XzI1Nl9ieXRlc19wZXJfbGltYiIsImNhbWxfanNfb25faWUiLCJ1YSIsImNhbWxfYmFfbGF5b3V0IiwiaW50ZWdlcnNfaW50MzJfb2ZfdWludDMyIiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJjYW1sX2FycmF5X3NldCIsIm5ld3ZhbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsIiwibWxfel9wZXJmZWN0X3Bvd2VyIiwibG9nMnoiLCJ6cCIsInNldF9kaWdpdF9uYXQiLCJjYW1sX21sX291dHB1dF9pbnQiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2dldCIsImludGVnZXJzX3VpbnQzMl9sb2dvciIsImNhbWxfb2JqX3dpdGhfdGFnIiwiY2FtbF9tbF9jaGFubmVsX3NpemUiLCJjYW1sX2hleHN0cmluZ19vZl9mbG9hdCIsInN0eWxlIiwiZXhwX3NpZ24iLCJzaWduX3N0ciIsImNzdCIsInhfc3RyIiwiY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9wdWJsaWNfaW5wdXRzIiwiY2FtbF9wYXN0YV9mcV90b19zdHJpbmciLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QiLCJtbF96X2Zvcm1hdCIsImNhcyIsIndpZHRoIiwiYWx0IiwicGFkIiwicHJlZml4IiwicHJlIiwiZnFfb3JhY2xlc19kZWVwX2NvcHkiLCJjYW1sX3N5c19hcmd2IiwiY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyIiwiY2FtbF9iYV9maWxsIiwibWxfel9zaGlmdF9yaWdodF90cnVuYyIsImNhbWxfc3RyaW5nX3NldDMyIiwiaW50ZWdlcnNfdW5zaWduZWRfaW5pdCIsImludGVnZXJzX3VpbnQ2NF9hZGQiLCJjYW1sX3BhbGxhc19hZGQiLCJjYW1sX3VwZGF0ZV9kdW1teSIsImNhbWxfYXJyYXlfZmlsbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4iLCJjYW1sX2dyX21ha2VfaW1hZ2UiLCJjYW1sX21sX3NldF9jaGFubmVsX291dHB1dCIsImNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfYmF0Y2hfdmVyaWZ5IiwiY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsIm9yaWdpbiIsImV2ZW50Il0sInNvdXJjZXMiOlsiIiwiL1VzZXJzL21hcnRpbm9uZGVqa2EvLm9wYW0vbWluYS9saWIvY29yZV9rZXJuZWwvc3RyZnRpbWUuanMiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2xpYi9zbmFya3lqcy9zcmMvYmluZGluZ3Mva2ltY2hpL2pzL3dlYi93ZWJfYmFja2VuZC5qcyIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvbGliL3NuYXJreWpzL3NyYy9iaW5kaW5ncy9raW1jaGkvanMvYmluZGluZ3MuanMiLCIvYnVpbHRpbi8raWVlZV83NTQuanMiLCIvYnVpbHRpbi8rbWxCeXRlcy5qcyIsIi9idWlsdGluLytmc19ub2RlLmpzIiwiL2J1aWx0aW4vK2ZzLmpzIiwiL2J1aWx0aW4vK3VuaXguanMiLCIvYnVpbHRpbi8rc3RkbGliLmpzIiwiL2J1aWx0aW4vK2ZhaWwuanMiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2xpYi9zbmFya3lqcy9zcmMvYmluZGluZ3Mvb2NhbWwvb3ZlcnJpZGVzLmpzIiwiL2J1aWx0aW4vK3N5cy5qcyIsIi9idWlsdGluLytmc19mYWtlLmpzIiwiL2J1aWx0aW4vK25hdC5qcyIsIi9idWlsdGluLyttYXJzaGFsLmpzIiwiL2J1aWx0aW4vK2ludDY0LmpzIiwiL2J1aWx0aW4vK2ludHMuanMiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2xpYi9pbnRlZ2Vyc19zdHVic19qcy9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK2JpZ2FycmF5LmpzIiwiL2J1aWx0aW4vK2JpZ3N0cmluZy5qcyIsIi9Vc2Vycy9tYXJ0aW5vbmRlamthLy5vcGFtL21pbmEvbGliL2Jhc2VfYmlnc3RyaW5nL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rcGFyc2luZy5qcyIsIi9idWlsdGluLytqc2xpYi5qcyIsIi9idWlsdGluLytoYXNoLmpzIiwiL2J1aWx0aW4vK2djLmpzIiwiL2J1aWx0aW4vK2Zvcm1hdC5qcyIsIi9idWlsdGluLytncmFwaGljcy5qcyIsIi9idWlsdGluLytjb21wYXJlLmpzIiwiL2J1aWx0aW4vK2pzbGliX2pzX29mX29jYW1sLmpzIiwiL2J1aWx0aW4vK2lvLmpzIiwiL2J1aWx0aW4vK2FycmF5LmpzIiwiL1VzZXJzL21hcnRpbm9uZGVqa2EvLm9wYW0vbWluYS9saWIvYmluX3Byb3QvcnVudGltZS5qcyIsIi9idWlsdGluLytvYmouanMiLCIvVXNlcnMvbWFydGlub25kZWprYS8ub3BhbS9taW5hL2xpYi96YXJpdGhfc3R1YnNfanMvYmlnaW50ZWdlci5qcyIsIi9Vc2Vycy9tYXJ0aW5vbmRlamthLy5vcGFtL21pbmEvbGliL3phcml0aF9zdHVic19qcy9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK2JhY2t0cmFjZS5qcyIsIi9Vc2Vycy9tYXJ0aW5vbmRlamthLy5vcGFtL21pbmEvbGliL2NvcmVfa2VybmVsL3J1bnRpbWUuanMiLCIvVXNlcnMvbWFydGlub25kZWprYS8ub3BhbS9taW5hL2xpYi9iYXNlL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rbWQ1LmpzIiwiL2J1aWx0aW4vK3dlYWsuanMiLCIvYnVpbHRpbi8rbGV4aW5nLmpzIiwiL1VzZXJzL21hcnRpbm9uZGVqa2EvLm9wYW0vbWluYS9saWIvYmFzZS9iYXNlX2ludGVybmFsaGFzaF90eXBlcy9ydW50aW1lLmpzIiwiL3dvcmtzcGFjZV9yb290L3NyYy9saWIvcHJvbWlzZS9qcy9wcm9taXNlLmpzIiwiL2J1aWx0aW4vK3N0ci5qcyIsIi9Vc2Vycy9tYXJ0aW5vbmRlamthLy5vcGFtL21pbmEvbGliL3BweF9leHBlY3QvY29sbGVjdG9yL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rYmlnc3RyaW5nLWNzdHJ1Y3QuanMiLCIvVXNlcnMvbWFydGlub25kZWprYS8ub3BhbS9taW5hL2xpYi9iaWdzdHJpbmdhZi9ydW50aW1lLmpzIiwiL1VzZXJzL21hcnRpbm9uZGVqa2EvLm9wYW0vbWluYS9saWIvdGltZV9ub3cvcnVudGltZS5qcyJdLCJtYXBwaW5ncyI6IjtDQUNDLFNBQVVBO1dBQ0ZDOzs7O0tBQ0xDO09BQ0U7UUFDQztVQUFzQkYsOENBRWhCRztRQUNIQztJQUVSLFNBQVNEO01BQ1AsSUFBSUUsT0FBU0gsUUFBUUk7TUFDckJELG9CQUFvQkE7YUFDYkwsb0JBQ1QsQ0FiRDtHQWNDQTs7O0tDSkE7UUFFRTtTQUFrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FxQkUsb0JBQU1TLFNBQVNGO1NBQ3BCLGtCQUFTSTtTQUNwQkM7UUFHSixHQUFJRjtTQUFZLENBQ1pFLFlBQVlELGlCQUFpQkU7VUFDN0JELHFCQUFxQkU7VUFDckIsR0FBR0Msa0JBQW1CQSw2QkFBNkJGOztTQUdsRCxDQUVERDs7VUFBWUc7O1VBQXNCLFdBQWEsT0FBT2IsUUFBUSxHQUFHYyxhQUEvQjtVQUNsQ0oscUJBQXFCQztRQW5DekI7U0F1Q2EsU0FBRUg7U0FDVTtRQUN6QixTQUFTUyxtQkFBbUJDLEtBQU1DO1VBQzlCLEtBQUtILHFCQUFxQkU7V0FBTyxDQUM3QjtxQkFBV0U7Ozs7cUJBQWtDQTs7O2FBQTRCOzs7ZUFDekNGOzs7O2VBQTZFQzs7O1lBRTdHSCxxQkFBcUJFLGFBRTdCO1FBRUFSLHVCQUF1Qlc7UUFDdkJYLHdCQUF3Qlk7UUFDeEJaLDhCQUE4QmE7UUFHOUIsU0FBU0MsY0FBY0M7VUFDbkJBLGNBQWMsOEJBQThCbkI7VUFDNUNtQixjQUFjLDhCQUE4Qm5CO1VBQzVDbUIsU0FBUyx5QkFBeUJuQixnQkFDdEM7UUFFQSxjQUFjSztRQUNkLFNBQVNBLGdCQUFnQmUsSUFBS0MsRUFBR0M7VUFFN0IsR0FBSUQsS0FBS0EsT0FBUSxDQUNiQyxTQUFTRCxFQUNUQSxJQUFJRTtVQUVSLEdBQUlEO1dBQVE7bUJBQ2lCYjswQkFBdURBO1VBRXBGO1dBQUllO1lBQVdGLE9BQVMseUJBQXlCQSxRQUFVdEI7VUFDM0QsT0FBTyxTQUFTb0IsSUFBS0MsRUFDekI7UUFFQSxjQUFjZjtRQUNkLFNBQVNBLG1CQUFtQmMsSUFBS0MsRUFBR0M7VUFDaEMsR0FBSUE7V0FBUTttQkFDaUJiOzBCQUFnRUE7O1dBRXhGO21CQUN3QkE7YUFBeUNBO1VBRXRFO1dBQUllO1lBQVdGLE9BQVMseUJBQXlCQSxRQUFVdEI7VUFDM0QsT0FBTyxTQUFTb0IsSUFBS0MsRUFDekI7UUFFQSxTQUFTTixxQkFBcUJLLElBQUtDLEVBQUdDLE9BQVFHO1VBRTFDO29CQUFZSCw2QkFBNkJBOztZQUF1Qkc7O1lBQVlDO1dBQU0sQ0FDOUVELFdBQVdILE9BQ1hBLFNBQVNDO1VBR2IsR0FBSUQ7V0FBUTttQkFDaUJiOzs7YUFBa0VBOzs7O2FBQStFQTs7OztXQUV6SzttQkFDd0JBOzs7YUFBMERBOzs7O2FBQXNEQTs7O1VBRzdJO1dBQUllO1lBQVcsQ0FBQ0YsT0FBUyx5QkFBeUJBLFFBQVV0QjtjQUEwQnlCO1VBQ3RGLE9BQU8sU0FBU0wsSUFBS0MsRUFDekI7UUFFQSxJQUFJTSxZQUFjO1FBQ2xCLFNBQVNYLHNCQUFzQkksSUFBS0MsRUFBR0M7VUFDbkMsR0FBSUE7V0FBUTttQkFDaUJiOzs7YUFBK0RBOzs7O1dBRXZGO21CQUN3QkE7MEJBQXlEQTtVQUV0RixJQUFJZSxTQUFXRixPQUFTLHFCQUFxQkEsUUFBVUs7VUFDdkQsT0FBTyxTQUFTUCxJQUFLQyxFQUN6QjtRQUVBLFNBQVNKLDRCQUE0Qks7VUFDakM7a0JBQXlCYjtZQUEwQ0E7VUFDbkUsT0FBTyx5QkFBeUJhLE9BQ3BDO1FBSUEsVUFBV007U0FBeUIsc0JBRTlCLGFBQVlBLE1BREg7UUFLZixTQUFTM0IsU0FBU3FCLE9BQVFPLHFCQUFzQkM7VUFDNUM7V0FBWSxRQUFFUixVQUFVdkI7V0FDRSxzQkFBRThCO1dBQ1AsaUJBQUVDO1dBTUU7V0FDckJLO1VBRUosU0FBU0MsVUFBVUMsT0FBUUM7WUFDdkIsSUFBSUM7WUFFSixLQUFLRDthQUFNLENBQ1AsSUFBSUUsaUJBQW1CO2NBQ3ZCLEdBQUlBLG1CQUFtQk47ZUFBc0IsQ0FDekNBLHVCQUF1Qk07Z0JBQ3ZCTCxrQkFBa0JQLEtBQUtNO2dCQUV2QkssWUFBWUw7Z0JBRVosR0FBSUQ7aUJBQWtCOzs7a0JBR0FMO21CQUFLTTs7bUJBQXVCLDJCQUEyQkM7O21CQUFlSDtjQUdoR00sT0FBT0g7O2FBRU4sQ0FDREksWUFBWTtjQUVaLEdBQUlOO2VBQWtCOzs7Z0JBQ1BMO2lCQUFLOztpQkFBaUIsMkJBQTJCVTs7aUJBQVFOO1lBSTVFLE9BQU8sZUFBZUssT0FBUUMsS0FBTVAsUUFBU1EsVUFDakQ7VUFFQSxTQUFTRyxlQUFlTCxPQUFRQyxLQUFNaEIsT0FBUWlCO1lBQzFDO2FBQWlCO2FBQ0wsUUFBRWI7YUFDQTthQUNILE9BQUVXO2FBQ0U7WUFFZixJQUFXLElBQUZXLElBQU9BLElBQUlGLE9BQVFFO2FBQUssQ0FFN0IsSUFBSUMsZ0JBQWtCLGtCQUFrQkQ7Y0FFeEMsR0FBSUg7ZUFBb0IsQ0FFcEIsR0FBSUk7aUJBQXdCLENBQ3hCTCxhQUNBOztpQkFHQyxHQUFJSztrQkFBd0IsQ0FDN0JMLGNBQ0E7O2tCQUdDLEdBQUlLO21CQUF3QixDQUM3QkwsY0FDQTs7bUJBR0MsR0FBSUs7b0JBQXdCLENBQy9CLEdBQUlGO3NCQUFZOytCQUNIakM7Ozs7K0JBQWtDQTs7O3VCQUE0Qjs7cUJBSTNFaUM7cUJBQ0E7Z0JBR0YsT0FBUUU7MEJBT0FOLGdCQUFnQnJCLFlBQVksZUFDNUI7O21CQUtBcUIsZ0JBQWdCckIsY0FBYyxpQkFDOUI7O21CQUtBcUI7O21CQUFnQixTQUFTLFdBQVcsMEJBQTJCQzttQkFDL0Q7O21CQUtBRDs7bUJBQWdCLGVBQWVyQixpQkFBa0JnQixLQUFNaEIsT0FBUWlCO21CQUMvRDs7bUJBS0FJOzttQkFBZ0IsZUFBZXJCLGlCQUFrQmdCLEtBQU1oQixPQUFRaUI7bUJBQy9EOzttQkFLQUksZ0JBQWdCLFNBQVMsZ0JBQWlCQyxTQUMxQzs7bUJBS0FELGdCQUFnQixTQUFTLFFBQVEsaUJBQWtCQzttQkFDbkQ7O21CQUtBRCxnQkFBZ0IsU0FBUyxXQUFXSjttQkFDcEM7O21CQUtBSSxnQkFBZ0IsU0FBUyxrQkFBbUJDLFNBQzVDOzttQkFLQUQsZ0JBQWdCLHFCQUF1QnJCLFVBQVlBO21CQUNuRDs7bUJBS0FxQjs7bUJBQWdCLGVBQWVyQixpQkFBa0JnQixLQUFNaEIsT0FBUWlCO21CQUMvRDs7bUJBS0FJLGdCQUFnQixTQUFTLGtCQUFtQkMsU0FDNUM7O21CQUtBRDs7bUJBQWdCLGVBQWVyQixpQkFBa0JnQixLQUFNaEIsT0FBUWlCO21CQUMvRDs7bUJBS0FJLGdCQUFnQixTQUFTLFdBQVdMLGVBQWlCTTttQkFDckQ7O21CQUtBRCxnQkFBZ0IsU0FBUyxXQUFXTCxlQUFpQk07bUJBQ3JEOzttQkFLQUQ7O21CQUFnQixlQUFlckIsaUJBQWtCZ0IsS0FBTWhCLE9BQVFpQjttQkFDL0Q7MEJBS0FJLGdCQUFnQixtQkFDaEI7O21CQUtBLEdBQUlWLG9CQUFvQkQ7b0JBQTZCOztvQkFHaEQsQ0FFRCxJQUFJdUIsU0FBVztxQkFDZlosZ0JBQWdCWSxZQUFZQTttQkFFaEM7O21CQUtBWixnQkFBZ0JyQixpQkFBaUIsZUFDakM7O21CQUtBcUIsZ0JBQWdCckIsbUJBQW1CLGlCQUNuQzs7bUJBS0FxQjs7bUJBQWdCLGVBQWVyQixpQkFBa0JnQixLQUFNaEIsT0FBUWlCO21CQUMvRDs7bUJBS0FJLGdCQUFnQixTQUFTLGVBQWdCQyxTQUN6Qzs7bUJBS0FEOzttQkFBZ0IsU0FBUyxlQUFnQkMsV0FBV2xCLFNBQWFrQjttQkFDakU7O21CQUtBRCxnQkFBZ0JyQixtQkFBbUIsaUJBQ25DOzttQkFLQTtvQkFBTSxNQUFNTSxLQUFLO29CQUNUO3FCQUFFO3dCQUFXLGlCQUFpQjttQkFDdENlLGdCQUFnQixTQUFTYzttQkFDekI7O21CQUtBZDs7bUJBQWdCLFNBQVMsZ0JBQWlCQyxXQUFXbEIsU0FBYWtCO21CQUNsRTs7bUJBS0FEOzttQkFBZ0I7cUJBQVMsUUFBUSxpQkFBa0JDLFdBQVdsQixTQUFha0I7bUJBQzNFOzttQkFLQUQsZ0JBQWdCLFNBQVMsb0JBQXFCQyxTQUM5QzsyQkFLQUQscUJBQ0E7O21CQUtBQTs7bUJBQWdCLE9BQU87O21CQUFrQixRQUFRO21CQUNqRDs7bUJBS0FBLGdCQUFnQixxQkFBdUJyQixVQUFZQTttQkFDbkQ7O21CQUtBcUI7O21CQUFnQixlQUFlckIsaUJBQWtCZ0IsS0FBTWhCLE9BQVFpQjttQkFDL0Q7MkJBS0FJLGdCQUFnQixXQUFXSixrQkFDM0I7MkJBS0FJLHFCQUNBOzttQkFLQSxJQUFJYyxJQUFNLGNBQ1ZkLGdCQUFnQmMsWUFBZ0JBLElBQ2hDOzttQkFLQWQ7O21CQUFnQixlQUFlckIsaUJBQWtCZ0IsS0FBTWhCLE9BQVFpQjttQkFDL0Q7MkJBS0FJLGdCQUFnQixjQUNoQjs7bUJBS0FBOzttQkFBZ0IsZUFBZXJCLGlCQUFrQmdCLEtBQU1oQixPQUFRaUI7bUJBQy9EOzttQkFLQUksZ0JBQWdCLE1BQU0sNkJBQ3RCOzttQkFLQSxHQUFJVixvQkFBb0JEO29CQUE2QixnQkFDakNlOztvQkFFZixDQUNELElBQUlhO3FCQUNKLEdBQUk1QjtzQkFBNkIsTUFDdkJBOztzQkFFTCxRQUNNO3FCQUxYO3NCQU9TLEtBQUU0QjtzQkFDSCxJQUFFYjtzQkFDQSxNQUFFLFdBQVcsU0FBU2E7c0JBQ3ZCLEtBQUUsU0FBU0E7cUJBQ3BCakI7O3FCQUFnQmtCOztxQkFBTyxTQUFTRTs7cUJBQVNEOztxQkFBTSxTQUFTRTttQkFFNUQ7MEJBR0FyQixnQkFBZ0JOLE9BQU9XLEdBQ3ZCO2dCQUdSSixVQUFVbEI7Z0JBQ1ZtQjtnQkFDQTtjQUlKLEdBQUlJLHVCQUF3QixDQUN4QkosaUJBQ0E7Y0FHSkYsZ0JBQWdCTixPQUFPVztZQUczQixPQUFPTCxZQUNYO1VBRUEsSUFBSW5CLFNBQVdZO1VBRWZaOzttQkFBNkJGO1lBQ3pCO29CQUFXckI7cUJBQVNxQixVQUFVUyxRQUFTQyxzQkFBdUJDLGlCQUQ5QztVQUlwQlQ7O21CQUE2QkM7WUFDekI7YUFBeUIscUJBQUVPO2FBQ1AsZ0JBQUVDO2FBRUwsb0JBQVNSO1lBQzFCLEdBQUl5Qyw2QkFBNkJBO2FBQTJCLENBQ3hERDtjQUdBLEdBQUlDO2VBQTJCLENBQzNCO2lCQUFTLEtBQUV6QztpQkFDRCxNQUFFLFNBQVM7aUJBQ1QsUUFBRSxTQUFTO2dCQUV2Qkk7O2dCQUF1QmdDOztzQkFBY0UsUUFBU0s7Ozs7OztlQUc3QyxHQUFJRjtnQkFBMkIsdUJBQ1R6QztZQUkvQixXQUFXeEIsU0FBUzhCLFFBQVNGLHFCQUFzQm9DLGdCQXRCbkM7VUF5QnBCekM7O3FCQUNJLFdBQVd2QixTQUFTOEIsUUFBU0MsMkJBRGxCO1VBSWYsT0FBT1IsUUFDWDtRQUVBLFNBQVMwQixTQUFTbUIsWUFBYUM7VUFDM0IsR0FBSUEsc0JBQXNCRCxnQkFBaUIsT0FDaENBO1VBRVgsR0FBSUMsZUFBZTVDLEtBQU07VUFHekIsT0FBTzRDLGNBQWNELFdBQ3pCO1FBRUEsU0FBU2hCLFNBQVNnQjtVQUNkLEdBQUlBLGlCQUFrQixPQUNYQTtVQUVYLEdBQUlBLGdCQUFpQixhQUNKQTtVQUVqQixjQUFjQSxXQUNsQjtRQUVBLFNBQVNqQixRQUFRbUI7VUFDYixHQUFJQSxXQUFZLGVBR1gsR0FBSUEsVUFBVyxPQUNUQTtVQUVYLE9BQU9BLElBQ1g7UUFLQSxTQUFTakIsV0FBV2hCLEtBQU1rQztVQUN0QkEsZUFBZUE7VUFJZixJQUFJQyxRQUFVO1VBQ2QsR0FBSUQ7V0FBMkIsR0FDdkJDLGNBQ0FBLGlCQUVBQTtVQUxSO1dBUXNCLGtCQUFFLFNBQVM7V0FDckIsUUFBRSxTQUFTLG1CQUFvQixnQkFBaUI7V0FDbkQsS0FBRSxZQUFZRSxVQUFVRDtXQUNyQixTQUFHRSxXQUFXSDtVQUUxQixPQUFPLFdBQVdJLFFBQ3RCO1FBR0EsU0FBU2xCLFFBQVFtQjtVQUNiLElBQU0sRUFBRUEsWUFDRCxHQUFFQTtVQUVULEdBQUtDLFlBQVlBLFlBQWEvQixXQUFXQSxPQUFRO1VBR2pELE9BQVFBLFVBQ0ksbUJBQ0EsbUJBQ0EsWUFFaEI7UUFFQSxTQUFTUCwyQkFBMkJIO1VBQ2hDLFFBQVEsc0NBQ1osQ0FybUJGO1M7Ozs7SUNWRixpQ0FBZSxXQUFFL0I7SUNvbEJjLFNBQTNCMEUsMkJBQXVDQztNQUN2QyxJQUFJQyxTQUFXRDtNQUNmLEdBQUlDO09BQVUsQ0FDVixVQUNBOztPQUNHLENBQ0gsSUFBTSxFQUFFRCxLQUNGLEVBQUVBLEtBQ1IsVUFDQSxhQUFlRSxFQUFHNUIsSUFUTztJQS9IRSxTQUEvQjZCLCtCQUEyQ0MsRUFBR0M7TUFFOUMsSUFBUSxJQUFFRCxTQUNGLFFBQU1JLE1BQU1GO01BQ3BCLFFBQVcsSUFBUyxNQUFLeEMsSUFBSXdDLElBQUt4QyxJQUFLLElBRS9CQSxLQUFLLGFBQWFzQyxFQUFFdEM7TUFFNUIsT0FBT3lDLEdBUjBCO0lBa1hQLFNBQTFCRywwQkFBc0NOLEVBQUdDLE1BQU9NLFFBQVNDO01BQ3pEUixJQUFJLCtCQUErQkEsRUFBR0M7TUFDdEMsSUFBUSxJQUFFRCxTQUNGLFFBQU1JLE1BQU1GO01BQ3BCQztNQUNBLElBQVcsSUFBRnpDLElBQU9BLElBQUl3QyxJQUFLeEM7T0FBSyxDQUMxQixJQUFJK0MsU0FBV1QsRUFBRXRDO1FBQ2pCeUMsSUFBSXpDLFNBQVMsUUFBUStDO1FBQ3JCLEdBQUlELFlBQWE7TUFFckIsT0FBT0wsR0FWcUI7SUFnQ0ssU0FBakNPLGlDQUE2Q0MsVUFBV1YsTUFBT087TUFDL0Q7T0FBaUIsYUFBRUc7T0FDQSxlQUFFQTtPQUNqQkc7TUFDSixHQUFJRixpQkFBaUIzRTtPQUFXOztPQUV6QixrQkFDZ0IsMkJBQTJCMkU7TUFObEQ7T0FRSUc7UUFBaUI7VUFBMEJGLGVBQWdCWixNQUFPTiwyQkFBNEJhO01BQ2xHLFVBQVdPLGVBQWdCRCxhQVZRO0lBZ0NOLFNBQTdCRSw2QkFBeUNsQjtNQUN6QyxPQUFPLGlDQUFpQ0EsRUFBR0osNEJBRFo7SUM5bkJuQyxTQUFTdUIsaUJBQWtCbkIsR0FBSyxPQUFPLFdBQVdBLEVBQUk7SUQ4b0JwQixTQUE5Qm9CLDhCQUEwQ3BCO01BQzFDLE9BQU8saUNBQWlDQSxFQUFHSiw2QkFEWDtJRTNHcEMsU0FBU3lCLHdCQUF3QkMsR0FDL0IsT0FBTyxXQUNUO0lDM3hCQSxTQUFTQztNQUNQLGNBQ1NsSDs7OztvQkFDS0E7Ozs7b0JBQ0FBOzt3QkFDaEI7SUMwQkEsU0FBU21IO01BQ1AsU0FBU0MsTUFBTUM7UUFDYixHQUFJLHVCQUF3QixXQUFZLG1CQUN4QyxNQUNGO01BRUEsU0FBU0MsTUFBTUQ7UUFFYjtTQUFrQjs7U0FDUCxPQUFFLG1CQUFtQkE7U0FDckIsT0FBRUc7U0FDSCxNQUFFLFFBQVFDLFVBQVU7UUFHOUIsR0FBSSxRQUFRRCxhQUFhRTtTQUFRLENBQy9CLElBQVMsS0FBR0YsZ0JBQ0osSUFBR0E7VUFDWCxRQUFRSSxLQUFNLGVBQWVBLGNBQWN2RDtRQUU3QyxNQUNGO01BQ0EsT0FBRzs7Y0FBd0JyRTs7Y0FBc0JBO2VBQ3hDQSx3Q0FBMENzSCxNQUFRRjtlQUUvQ0EsS0FDZDtJQUNBLElBQUlTLGlCQUFtQjtJQXZEdkIsU0FBU0Msb0JBQW9CM0c7TUFDM0IsT0FBUSx3QkFBMkJBLFdBQWNBLElBQ25EO0lBSUEsR0FBRyx1QkFBd0JuQixzQkFBc0JBO0tBQy9DLElBQUkrSCxpQkFBbUI7O0tBRXZCLElBQUlBO0lBQ05BLG1CQUFtQixvQkFBb0JBO0lBa0R2QyxTQUFTQyxlQUFnQjdHO01BQ3ZCQSxPQUFLLHdCQUF3QkE7TUFDN0IsS0FBSyxpQkFBaUJBLE1BQ3BCQSxPQUFPNEcsbUJBQW1CNUc7TUFDNUIsSUFBVSxNQUFFLGlCQUFpQkEsTUFDcEIsS0FBRSxvQkFDRDtNQUNWLElBQVUsSUFBRm9DLElBQU9BLElBQUUyRSxZQUFhM0U7T0FBSSxPQUN6QjJFLEtBQUszRTttQkFDRCxHQUFHNEUsaUJBQWdCLFlBQWE7a0JBQ2pDO2lCQUNELFdBQVdELEtBQUszRSxJQUFJO01BRy9CLGNBQWMwRTtNQUNkRSxhQUFhaEg7TUFDYixPQUFPZ0gsS0FDVDtJRmlFQSxTQUFTQyxjQUFlbkI7TUFFdEIsR0FBSUE7T0FBZSxDQUVqQixJQUFXLElBQUYxRCxJQUFPQSxJQUFJMEQsU0FBVTFELElBQUssR0FBSSxhQUFhQSxTQUFVO1FBQzlEOztPQUVBLFNBQVEsb0JBQW9CMEQsRUFDaEM7SUExRkEsU0FBU29CLG1CQUFtQnBCO01BQzFCLFFBQVcsS0FBUSxFQUFFcUIsRUFBR0UsRUFBRzVHLEVBQUssSUFBTyxFQUFFcUYsU0FBVTFELElBQUlrRixFQUFHbEY7T0FBSyxDQUM3RGlGLElBQUksYUFBYWpGO1FBQ2pCLEdBQUlpRjtTQUFVLENBQ1osSUFBVyxJQUFGRSxFQUFJbkYsTUFBUW1GLElBQUlELE1BQU9ELElBQUksYUFBYUUsV0FBWUEsSUFBSTtVQUNqRSxHQUFJQSxJQUFJbkY7V0FBUyxDQUFFLGNBQWdCK0UsS0FBS0MsRUFBR0EsT0FBUUQsS0FBSyxRQUFRL0UsRUFBR21GOztXQUM5REgsS0FBSyxRQUFRaEYsRUFBR21GO1VBQ3JCLEdBQUlBLEtBQUtELEVBQUc7VUFDWmxGLElBQUltRjtRQUVOLEdBQUlGO1NBQVcsQ0FDYkQsS0FBSywyQkFBNEJDO1VBQ2pDRCxLQUFLLDJCQUE0QkM7O1NBQzVCLEdBQUlBLGNBQWNBO1VBQWE7O1VBQy9CO21CQUE0QkEsZUFDQ0EscUJBQ0RBOztVQUM1QjtZQUFJQTs7OztZQUFlakY7Ozs7WUFBU2tGOzthQUN2QjdHLElBQUksYUFBYTJCOzs7O1lBQW9CM0I7OztXQUFZOztXQUd0RCxDQUNMMkI7WUFDQWlGLEtBQUtBLFdBQVc1RztZQUNoQjJHOztZQUFLO3FCQUE0QkM7cUJBQ0NBO3FCQUNBQTtxQkFDREE7UUFFbkMsR0FBSUQsZ0JBQWlCLENBQUMsY0FBZ0JELEtBQUtDLEVBQUdBO01BRWhELE9BQU9ELElBQUVDLENBQ1g7SUFqRUEsU0FBU0ksZ0JBQWdCQyxFQUFHM0I7TUFDMUIsR0FBRzJCLE9BQVE7TUFDWCxHQUFJM0IsU0FBVSxPQUFRLFNBQVMyQjtNQUMvQixJQUFNLEtBQVE7TUFDZDtPQUFRLENBQ04sR0FBSUEsTUFBT0MsS0FBSzVCO1FBQ2hCMkI7UUFDQSxHQUFJQSxPQUFRLE9BQU9DO1FBQ25CNUIsS0FBS0E7UUFDTHdCO1FBQ0EsR0FBSUEsT0FBUSxhQU1oQjtJQU9BLFNBQVNLLHlCQUEwQkMsRUFBR3hGLEVBQUd3QztNQUN2QyxJQUFJaUQsRUFBSS9FO01BQ1IsR0FBSVYsVUFBVXdDLGVBQWVBLE9BQU9nRCxTQUFVLE9BQU8sUUFBUzlHLEtBQU04RztNQURwRSxJQUVJOUI7TUFDSixTQUFXbEIsSUFBS3hDLFVBQVV3QztPQUN4QmtCLEtBQUssUUFBU2hGLEtBQU0sUUFBUXNCLEVBQUVBLElBQUksU0FBU3dDO01BQzdDLE9BQU9rQixDQUNUO0lBMldBLFNBQVNnQyw2QkFBOEJoQztNQUVyQyxHQUFJQTtPQUNGQSxPQUFPLGdCQUFnQkEsTUFBTUE7O09BRTdCQSxNQUFNLHlCQUEwQkEsTUFBUUE7TUFDMUNBLE9BQ0Y7SUE1VUEsU0FBU2lDLG1CQUFtQmpDO01BQzFCLFFBQVcsS0FBUSxLQUFNdUIsRUFBR1csR0FBSUMsR0FBSXZELEVBQUssSUFBTyxFQUFFb0IsU0FBVTFELElBQUlrRixFQUFHbEY7T0FBSyxDQUN0RTRGLEtBQUssYUFBYTVGO1FBQ2xCLEdBQUk0RjtTQUFXLENBQ2IsSUFBVyxJQUFGVCxFQUFJbkYsTUFBUW1GLElBQUlELE1BQU9VLEtBQUssYUFBYVQsV0FBWUEsSUFBSTtVQUNsRSxHQUFJQSxJQUFJbkY7V0FBUyxDQUFFLGNBQWdCK0UsS0FBS0MsRUFBR0EsT0FBUUQsS0FBSyxRQUFRL0UsRUFBR21GOztXQUM5REgsS0FBSyxRQUFRaEYsRUFBR21GO1VBQ3JCLEdBQUlBLEtBQUtELEVBQUc7VUFDWmxGLElBQUltRjtRQUVON0M7UUFDQSxLQUFPdEMsSUFBSWtGLE9BQVNXLEtBQUssYUFBYTdGO1NBQW9CLENBQ3hEaUYsSUFBSVksTUFBTUQ7VUFDVixHQUFJQTtXQUFXLENBQ2J0RCxJQUFJMkMsV0FDSixHQUFJM0MsU0FBVUE7O1dBQ1QsQ0FDTEE7WUFDQSxLQUFPdEMsSUFBSWtGLE9BQVNXLEtBQUssYUFBYTdGO2FBQW9CLENBQ3hEaUYsSUFBSVksTUFBTVo7Y0FDVixHQUFJVztlQUFXLENBQ2J0RCxJQUFJMkM7Z0JBQ0osR0FBSzNDLGFBQWdCQSxlQUFpQkEsV0FBY0E7O2VBQy9DLENBQ0xBO2dCQUNBO29CQUFPdEM7O2tCQUFJa0Y7O29CQUFTVyxLQUFLLGFBQWE3Rjs7OztrQkFDakM0Rjs7O2lCQUFZLENBQ2Z0RCxJQUFJdUQsa0JBQWtCWjtrQkFDdEIsR0FBSTNDLGVBQWVBLGFBQWNBO1FBTTNDLEdBQUlBO1NBQU8sQ0FDVHRDLEtBQUtzQyxFQUNMMEM7O1NBQ0ssR0FBSTFDO1VBQ1QwQyxLQUFLLDhCQUE4QjFDLG1CQUFvQkE7O1VBRXZEMEMsS0FBSyxvQkFBb0IxQztRQUMzQixHQUFJMEMsZ0JBQWlCLENBQUMsY0FBZ0JELEtBQUtDLEVBQUdBO01BRWhELE9BQU9ELElBQUVDLENBQ1g7SUEwUEEsU0FBU2MsUUFBU0MsSUFBS0MsU0FBVWxHO01BQy9CcEQsU0FBT3FKLElBQUtySixTQUFPc0osU0FBVXRKLFNBQU9vRCxNQUN0QztJQUNBZ0c7OztNQUNFLE9BQVFwSjtlQUVOLE9BQU9BO2dCQUVQLDZCQUE2QkE7U0FFN0IsR0FBSSxjQUFjQSxRQUFTLENBQ3pCQSxXQUNBLE9BQU9BLE9BRVRBO2VBRUEsT0FBT0E7U0Fia0I7SUFnQjdCb0o7OztNQUNFLElBQUlSLEVBQUk7TUFDUixHQUFHNUksWUFBYSxPQUFPNEk7TUFDdkIsT0FBTyxtQkFBbUJBLEVBSEE7SUFLNUJROzs7TUFDRSxJQUFJRyxRQUFVdkosWUFBYyxlQUFpQkE7TUFDN0MsV0FBV29KLFFBQVFwSixPQUFPdUosUUFBUXZKLE9BRlY7SUFsQzFCLFNBQVN3Siw2QkFBOEJ4QztNQUNyQyxJQUFJcUM7TUFDSixLQUFLLGNBQWNyQyxHQUNqQnFDLFFBQWlDckMsSUFBSSxtQkFBbUJBO01BQzFELFdBQVdvQyxRQUFRQyxJQUFLckMsRUFBR0EsU0FDN0I7SUE4WkEsU0FBU3lDLHdCQUF5QnpDO01BQ2hDLE9BQU8sNkJBQTZCQSxFQUN0QztJR2p2QkE7S0FBSTBDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFpQkosU0FBU0MsbUJBQW1CQyxLQUFNQyxRQUFTekMsS0FBTTBDO01BQy9DLElBQUlDLFFBQVUsbUJBQW1CSDtNQUNqQyxHQUFJRyxZQUFhLENBRWYsR0FBSUQsU0FBUzlILEtBQU0sZUFJbkIrSCxhQUFtQkQ7TUFQckI7T0FTSUU7U0FDRkQ7U0FDQSx3QkFBd0JGO1NBQ3hCLHdCQUF3QnpDO01BRTFCLE9BQU80QyxJQUNUO0lDdkRBLElBQUlDO0lBV0osU0FBU0MsaUJBQWlCQyxJQUN4QixPQUFPRixrQkFBa0JFLEdBQzNCO0lDL0JBLFNBQVNDLHFCQUFzQmYsSUFBS1csTUFBUSxNQUFNLEdBQUlYLFlBQVlXLEtBQU87SUw2eEJ6RSxTQUFTSyxpQkFBaUJyRCxHQUN4QixPQUFRQSxhQUFhb0MsT0FDdkI7SUF5QkEsU0FBU2tCLGtCQUFrQnRELEdBQ3pCLE9BQU8saUJBQWlCQSxFQUMxQjtJQXBWQSxTQUFTdUQsb0JBQXFCekIsR0FDNUIsV0FBV00sVUFBVU4sRUFBRUEsU0FDekI7SUF3UkEsU0FBUzBCLHFCQUFxQnhELEdBQUssT0FBT0EsQ0FBRTtJQTVENUMsU0FBU3lELHNCQUFzQnpELEdBQUssV0FBV29DLFVBQVVwQyxFQUFFQSxTQUFXO0lBaUV0RSxTQUFTMEQsdUJBQXVCMUQsR0FBSyxPQUFPLHNCQUFzQkEsRUFBSTtJTTl4QnRFLFNBQVMyRCx1QkFBdUJ0QixJQUFLdUIsS0FDbkMsTUFBTSxpQkFBaUJBLE1BQ3pCO0lGeURBLElBQUlDO0lHMUNKLFNBQVNDLHFCQUFzQkY7TUFDN0IsdUJBQXVCQywyQkFBNEJELElBQ3JEO0lMdUtBLFNBQVNHLHdCQUF3QjdKO01BQy9CLHFCQUFzQkEscUNBQ3hCO0lHaEpBLFNBQVM4SixzQkFBdUJKO01BQzlCLHVCQUF1QkMsa0NBQW1DRCxJQUM1RDtJTGlLQSxTQUFTSztNQUNQLDRDQUNGO0lBdENBLFNBQVNDLHNCQUF1QmxFLEVBQUcxRDtNQUNqQyxPQUFRMEQ7Z0JBRU4sR0FBSTFELEtBQUswRCxXQUFZLGdCQUVyQixPQUFPLGVBQWUxRDtlQUV0QixPQUFPMEQsSUFBSTFEO1NBRWY7SUE0R0EsU0FBUzZILGVBQWdCbkUsRUFBRzFEO01BQzFCLEdBQUlBLFdBQVcwRCxJQUFLO01BQ3BCLE9BQU8sc0JBQXVCQSxFQUFHMUQsRUFDbkM7SUErTUEsU0FBUzhILGtCQUFrQnRGO01BQ3pCLEdBQUlBLFFBQVM7TUFDYixXQUFXc0QsUUFBUXRELFdBQVdBLElBQ2hDO0lBZ0pBLFNBQVN1RixxQkFBcUJyRSxHQUFLLE9BQU9BLEdBQUk7SUFyTTlDLFNBQVNzRSw0QkFBNkJ0RTtNQUVwQyxHQUFHakg7T0FBdUIsSUFDcEIrSSxPQUFRL0ksdUJBQXNCaUg7O09BQzdCLElBQ0Q4QixNQUFROUMsTUFBTWdCO01BRXBCLElBQU0sRUFBRUEsSUFBTyxFQUFFcUIsU0FBWTtNQUM3QixLQUFPL0UsSUFBSWtGLEVBQUdsRixJQUFLd0YsRUFBRXhGLEtBQUssYUFBYUE7TUFDdkMsSUFBS2tGLElBQUl4QixJQUFLMUQsSUFBSWtGLEVBQUdsRixJQUFLd0YsRUFBRXhGO01BQzVCMEQsTUFBTThCO01BQ045QjtNQUNBLE9BQU84QixDQUNUO0lBaUpBLFNBQVN5QyxnQkFBZ0JDLEdBQUlDLEdBQUlDLEdBQUlDLEdBQUk3RjtNQUN2QyxHQUFJQSxTQUFVO01BQ2QsR0FBSzZGLFlBQ0E3RixPQUFPNEYsUUFBU0EsYUFBMkI1RixPQUFPNEY7T0FBZSxDQUNwRUE7O1FBQVFGO1VBQ04seUJBQXlCQSxLQUFNQyxHQUFJM0Y7VUFDbEMyRixXQUFXRCxlQUFlMUYsSUFBSzBGLEtBQUssWUFBWUMsR0FBSTNGO1FBQ3ZENEYsT0FBUUEsZUFBZUE7O09BQ2xCLEdBQUlBLGFBQTJCQyxNQUFNRDtRQUFhLENBQ3ZEQTs7U0FBU0Y7V0FDUCx5QkFBeUJBLEtBQU1DLEdBQUkzRjtXQUNsQzJGLFdBQVdELGVBQWUxRixJQUFLMEYsS0FBSyxZQUFZQyxHQUFJM0Y7U0FDdkQ0RixPQUFRQSxlQUFlQTs7UUFDbEIsQ0FDTCxHQUFJQSxVQUF1Qiw0QkFBNEJBO1NBQ3ZELElBQU8sR0FBRUYsS0FBUyxHQUFFRTtTQUNwQixHQUFJRjtVQUF1QixHQUNyQkcsTUFBTUY7V0FBSSxJQUNELElBQUZuSSxJQUFPQSxJQUFJd0MsSUFBS3hDLElBQUs2RixHQUFJd0MsS0FBS3JJLEtBQUs0RixHQUFJdUMsS0FBS25JOztXQUNoRCxJQUNNLElBQUZBLEVBQUl3QyxRQUFTeEMsT0FBUUEsSUFBSzZGLEdBQUl3QyxLQUFLckksS0FBSzRGLEdBQUl1QyxLQUFLbkk7O1VBRXZELENBQ0wsSUFBSWtGLEVBQUksU0FBVTFDLElBQUtvRCxZQUFZdUM7V0FDbkMsSUFBVyxJQUFGbkksSUFBT0EsSUFBSWtGLEVBQUdsRixJQUFLNkYsR0FBSXdDLEtBQUtySSxLQUFLLGNBQWNtSSxLQUFLbkk7V0FDN0QsS0FBT0EsSUFBSXdDLElBQUt4QyxJQUFLNkYsR0FBSXdDLEtBQUtySTtNQUdsQyxRQUNGO0lBSUEsU0FBU3NJLGlCQUFpQjlDLEVBQUVULEVBQUVFLEVBQUU1RyxFQUFFa0s7TUFDaEMsZ0JBQWdCLHFCQUFxQi9DLEdBQUdULEVBQUVFLEVBQUU1RyxFQUFFa0ssR0FDOUMsUUFDRjtJRXZsQkEsU0FBU0MsU0FBVztJTTRKcEIsU0FBU0MsV0FBV3hDLFNBQ2xCdkosWUFBWXVKLE9BQ2Q7SUFDQXdDLDJCQUEyQkQ7SUFDM0JDOzthQUF5Q2pHO01BQ3ZDLElBQUlrRyxJQUFNaE07TUFDVkEsWUFBWSxrQkFBa0I4RjtNQUM5QixnQkFBZ0JrRyxNQUFRaE0sWUFBYzhGLElBSFI7SUFLaENpRzs7ZUFDRSxPQUFPLHFCQUFxQi9MLFVBREE7SUFHOUIrTDs7YUFBc0NFLE9BQU9DLElBQUlqRyxJQUFJSDtNQUNuRCxJQUFJcUcsS0FBTztNQUNYLEdBQUdGLFNBQVNuRyxPQUFPcUc7T0FBTSxDQUN2QixJQUFZLFFBQUUsa0JBQWtCRixTQUFTbkcsS0FDNUIsU0FBRTlGO1FBQ2ZBLFlBQVlvTTtRQUNaLGdCQUFnQkMsV0FBYXJNLFlBQWNtTTtNQUU3QyxpQkFBaUJELElBQUtqRyxJQUFLakcsVUFBV2lNLE9BQVFuRztNQUM5QyxRQVQyQjtJQVc3QmlHOzthQUFxQ0UsT0FBT0MsSUFBSWpHLElBQUlIO01BQ2xELElBQUlxRyxLQUFPO01BQ1gsZ0JBQWdCbk0sVUFBV2lNLE9BQVFDLElBQUtqRyxJQUFLSDtNQUM3QyxRQUgwQjtJQUs1QmlHOzthQUF5Q0UsUUFDdkMsT0FBTyxlQUFlak0sVUFBV2lNLE9BREg7SUFHaENGLHdDQUE2QjtJQUc3QkEsbUNBQW1DQTtJQWxObkMsU0FBU08sYUFBYzNFLEtBQU1vQjtNQUMzQi9JLGtCQUNBQSxZQUFZMkgsS0FDWjNILGlCQUFpQitJLENBQ25CO0lBQ0F1RCxxQ0FBcUNwTCxNQUNuQyxPQUFRbEIsWUFBWWtCLElBRE07SUFHNUJvTDs7YUFBdURwTDtNQUNyRCxJQUFTLEtBQUUsZ0JBQ0g7TUFDUixJQUFVLElBQUZvQyxJQUFPQSxJQUFJMkUsZ0JBQWlCM0U7T0FBSSxDQUN0Q3lDLE9BQU9rQyxLQUFLM0U7UUFDWixHQUFHdEQsYUFBYStGLEtBQU07UUFDdEIvRixhQUFhK0YsT0FBTyxvQkFOc0I7SUFTOUN1Rzs7YUFBd0NwTCxNQUN0QyxPQUFPLFdBQVdBLE1BQU1BLEtBQU1BLFVBREQ7SUFHL0JvTDs7YUFBeUNwTDtNQUN2QyxLQUFJbEIsYUFBYWtCLFNBQVNsQjtPQUFnQixDQUN4QztTQUFJK0Y7VUFBTTtZQUFlLHVCQUF1Qi9GLFdBQVksdUJBQXVCa0I7UUFDbkYsR0FBRzZFO1NBQVcsQ0FDWiwwQkFBMEI3RTtVQUMxQmxCLGFBQWFrQixZQUFVNkssV0FBVyxxQkFBcUJoRyxVQUw3QjtJQVNoQ3VHOzthQUF5Q3BMO01BRXZDLEdBQUdBLFdBQVk7TUFFZixJQUFJc0wsV0FBYSxXQUFXdEw7TUFDNUIsR0FBR2xCLGFBQWF3TSxZQUFhO01BRTdCLFlBQVl0TDtNQUNaLE9BQU9sQixhQUFha0IsU0FSVTtJQVVoQ29MOzthQUF3Q3BMLEtBQUt1TCxLQUFNQztNQUNqRCxJQUFJaEQsV0FBYWdELGNBQWM7TUFDL0IsR0FBRyxZQUFZeEw7T0FBTyxHQUNoQndJO1FBQVk7VUFDT0EsV0FBWSxvQ0FBc0MsUUFBUXhJOztRQUU1RSxxQkFDa0JBO01BTnpCLElBU0l5TCxPQUFTLG9CQUFvQnpMO01BQ2pDeUwsU0FBVUEsVUFBVUE7TUFDcEIsS0FBSSxZQUFZQTtPQUFRLEdBQ2xCakQ7UUFBWTtVQUNPQSxXQUFZLG9DQUFzQyxRQUFRaUQ7O1FBRTVFLHFCQUNrQkE7TUFHekIsS0FBSSxZQUFZQTtPQUFRLEdBQ2xCakQ7UUFBWTtVQUNPQSxXQUFZLHFDQUF1QyxRQUFRaUQ7O1FBRTdFLHFCQUNrQkE7TUFHekIsMEJBQTBCLFdBQVd6TCxNQTVCUjtJQThCL0JvTDs7YUFBd0NwTCxLQUFNd0w7TUFDNUM7T0FBZSxXQUFFQSxjQUFjO09BQ2hCLFdBQUd4TCxjQUFnQixXQUFXQTtPQUN2QyxNQUFNMEwsYUFBYUo7TUFDekIsS0FBSSxZQUFZdEw7T0FBTyxHQUNqQndJO1FBQVk7VUFDT0EsV0FBWSxvQ0FBc0MsUUFBUXhJOztRQUU1RSxxQkFDa0JBO01BR3pCLEtBQUksWUFBWUE7T0FBTyxHQUNqQndJO1FBQVk7VUFDT0EsV0FBWSxxQ0FBdUMsUUFBUXhJOztRQUU3RSxxQkFDa0JBO01BR3pCLFFBQVF5SCxLQUFLM0k7T0FBYyxHQUN0QixRQUFRNEk7UUFBSSxHQUNUYztTQUFZO1dBQ09BLFdBQVksdUNBQXlDLFFBQVF4STs7U0FDN0UscUJBQ2dCLFFBQVFBO2FBSTVCbEIsYUFBYXdNLFdBN0JTO0lBK0IvQkY7O2FBQTBDcEw7TUFDeEMsSUFBSXNMLFdBQWN0TCxjQUFnQixXQUFXQTtNQUM3QyxLQUFJLFlBQVlBO09BQU8scUJBQ0FBO01BRXZCLEtBQUksWUFBWUEsTUFBTyxxQkFDQUE7TUFMdkIsSUFPTSxNQUFNMEwsYUFBYUosd0JBQ2hCLFFBQ0g7TUFDTixRQUFRN0QsS0FBSzNJO09BQWMsQ0FDekIsSUFBSThNLEVBQUksUUFBUWxFO1FBQ2hCLEdBQUdrRSxPQUFNRCxLQUFLQyxNQUFPLENBQUNELEtBQUtDLGFBQWMsT0FBT0E7TUFFbEQsT0FBT2hFLENBZndCO0lBaUJqQ3dEOzthQUF5Q3BMO01BQ3ZDLEdBQUdBLFdBQWE7TUFDaEIsSUFBSXNMLFdBQWEsV0FBV3RMO01BQzVCLE9BQU9sQixhQUFhd00sZUFIVTtJQUtoQ0Y7O2FBQXlDcEw7TUFDdkMsSUFBSTZMLEdBQUsvTSxhQUFha0I7YUFDZmxCLGFBQWFrQjtNQUNwQixPQUFPNkwsRUFIdUI7SUFLaENUOzthQUF1Q3BMLEtBQU02SDtNQUMzQyxHQUFHQSxZQUFZQTtPQUNiO1NBQXFCLFFBQVE3SDs7O01BQy9CLEdBQUc2SCxVQUFVQTtPQUNYO1NBQXFCLFFBQVE3SDs7O01BQy9CLFlBQVlBO01BQ1osR0FBSWxCLGFBQWFrQjtPQUFPLENBQ3RCLEdBQUksWUFBWUE7U0FBTyxxQkFBcUIsUUFBUUE7UUFDcEQsR0FBSTZILFlBQVlBO1NBQVEscUJBQXFCLFFBQVE3SDtRQUNyRCxJQUFJOEwsS0FBT2hOLGFBQWFrQjtRQUN4QixHQUFHNkgsV0FBWTtRQUNmLE9BQU9pRTs7T0FDRixHQUFJakU7UUFBVSxDQUNuQiwwQkFBMEI3SDtTQUMxQmxCLGFBQWFrQixZQUFZNkssV0FBVztTQUNwQyxPQUFPL0wsYUFBYWtCOztRQUNmLHdCQUNvQixRQUFRQSxNQWpCUDtJQXFCOUJvTDs7YUFBMkNwTCxLQUFLcUk7TUFDOUMsSUFBSXlEO01BQ0osR0FBR2hOLGFBQWFrQjtPQUFPLHFCQUFxQixRQUFRQTtNQUNwRCxHQUFHLGlCQUFpQnFJLFNBQ2xCeUQsV0FBV2pCLFdBQVd4QztNQUN4QixHQUFHLGtCQUFrQkE7T0FDbkJ5RCxXQUFXakIsV0FBVyxxQkFBcUJ4Qzs7T0FDeEMsR0FBR0EsbUJBQW1CdkQ7UUFDekJnSCxXQUFXakIsV0FBVyxvQkFBb0J4Qzs7UUFDdkMsVUFBVUE7U0FDYnlELFdBQVdqQixXQUFXLHNCQUFzQnhDOztTQUN6QyxHQUFHQTtVQUFrQixDQUN4QjtZQUFJMEQ7YUFBUSxxQkFBcUIsd0JBQXdCO1dBQ3pERCxXQUFXakIsV0FBV2tCO01BRXhCLEdBQUdEO09BQUssQ0FDTiwwQkFBMEI5TCxNQUMxQmxCLGFBQWFrQixRQUFROEw7O09BRWxCO1NBQXFCLFFBQVE5TCx3REFuQkg7SUFzQmpDb0wscUNBQXFDQTtJUmtqQnJDLFNBQVNZLHNCQUFzQmxHLEdBQzdCLE9BQU8scUJBQXFCQSxFQUM5QjtJQWhCQSxTQUFTbUcsdUJBQXdCbkcsRUFBRzFELEdBQ2xDLE9BQU8sc0JBQXNCMEQsRUFBRTFELEVBQ2pDO0lBOVFBLFNBQVM4SixxQkFBc0JwRztNQUM3QixJQUFNLEVBQUUsc0JBQXNCQSxHQUN4QixNQUFNaEIsTUFBTXdDLEdBQ1o7TUFDTixLQUFPbEYsSUFBSWtGLEVBQUdsRixJQUFLd0YsRUFBRXhGLEtBQUssdUJBQXVCMEQsRUFBRTFEO01BQ25ELE9BQU93RixDQUNUO0lBZEEsU0FBU3VFLG9CQUFxQnJHO01BQzVCLEdBQUlBLFNBQXNCLDRCQUE0QkEsR0FDdEQsT0FBT0EsR0FDVDtJQTVSQSxTQUFTc0csc0JBQXVCdEcsRUFBRzFELEVBQUdpRjtNQUVwQ0E7TUFDQSxHQUFJdkI7T0FBc0IsQ0FDeEIsR0FBSTFELEtBQUswRDtTQUFZLENBQ25CQSxPQUFPLG9CQUFxQnVCLEdBQzVCLEdBQUlqRixTQUFTMEQsSUFBS0EsUUFDbEI7UUFFRiw0QkFBNkJBO01BRS9CQSxJQUFJMUQsS0FBS2lGO01BQ1QsUUFDRjtJQWlNQSxTQUFTZ0YsZUFBZ0J2RyxFQUFHMUQsRUFBR2lGO01BQzdCLEdBQUlqRixXQUFXMEQsSUFBSztNQUNwQixPQUFPLHNCQUF1QkEsRUFBRzFELEVBQUdpRixFQUN0QztJQ3JLQSxTQUFTaUYsV0FBV0MsSUFDbEJ6TixVQUFVLGNBQ1ZBLFVBQVV5TixFQUNaO0lBQ0FELDJCQUEyQjFCO0lBRTNCMEI7O2FBQXlDMUg7TUFDdkM7UUFDRSxzQkFBc0I5RixRQUFROEY7WUFDdkI2SCxLQUNQLHFCQUFxQixnQkFKTztJQU9oQ0g7OztNQUNFO1FBQ0UsT0FBTyxrQkFBa0J4TjtZQUNsQjJOLEtBQ1AscUJBQXFCLGdCQUpLO0lBTzlCSDs7YUFBc0N2QixPQUFPQyxJQUFJMEIsV0FBVzlIO01BQzFELElBQUlnRCxFQUFJLHFCQUFxQm9EO01BQzdCLE1BQU1wRCxhQUFhL0k7T0FDakIrSSxTQUFRL0ksdUJBQXNCK0k7TUFGaEMsSUFHSStFLE9BQVMsdUJBQXVCL0U7TUFDcEM7UUFDRSxrQkFBa0I5SSxRQUFTNk4sT0FBUUQsV0FBWTlILElBQUttRztZQUM3QzBCLEtBQ1AscUJBQXFCO01BRXZCLFFBVjJCO0lBWTdCSDs7YUFBcUN2QixPQUFPQyxJQUFJMEIsV0FBVzlIO01BQ3pELElBQUlnRCxFQUFJLG9CQUFvQm9EO01BQzVCLE1BQU1wRCxhQUFhL0k7T0FDakIrSSxTQUFRL0ksdUJBQXNCK0k7TUFGaEMsSUFHSStFLE9BQVMsdUJBQXVCL0U7TUFDcEM7UUFDRSxpQkFBaUI5SSxRQUFTNk4sT0FBUUQsV0FBWTlILElBQUttRztZQUM1QzBCLEtBQ1AscUJBQXFCO01BRXZCLElBQVUsSUFBRnJLLElBQU9BLElBQUl3QyxJQUFLeEM7T0FBSSxlQUNYNEksSUFBSTBCLGFBQWF0SyxFQUFFdUssT0FBT0QsYUFBV3RLO01BRXRELFFBYjBCO0lBZTVCa0s7O2FBQXlDdkI7TUFDdkMsSUFBTSxPQUFNbE0sMEJBQ0QsT0FBRSx1QkFBdUIrSTtNQUNwQztRQUNFLGlCQUFpQjlJLFFBQVM2TixXQUFjNUI7WUFDakMwQixLQUNQLHFCQUFxQjtNQUV2QixPQUFPRSxTQVJ1QjtJQVVoQ0w7OztNQUNFO1FBQ0Usa0JBQWtCeE47WUFDWDJOLEtBQ1AscUJBQXFCLGdCQUpJO0lBUTdCSCxtQ0FBbUNBO0lBclFuQyxTQUFTTSxhQUFhbkcsTUFDcEIzSCxVQUFVLGNBQ1ZBLFlBQVkySCxJQUNkO0lBQ0FtRyxxQ0FBcUM1TSxNQUNuQyxPQUFRbEIsWUFBWWtCLElBRE07SUFHNUI0TTs7YUFBeUM1TTtNQUN2QyxLQUNFLE9BQU8sbUJBQW1CLFFBQVFBLGlCQUMzQnlNLEtBQ1AsU0FKNEI7SUFPaENHOzthQUF3QzVNLEtBQU11TCxLQUFNQztNQUNsRDtRQUNFLGtCQUFrQixRQUFReEwsWUFBWXVMLE9BQ3RDO1lBQ09rQixLQUNQLHdCQUF3QkEsSUFBS2pCLFlBTEY7SUFRL0JvQjs7YUFBd0M1TSxLQUFNd0w7TUFDNUM7UUFDRSxrQkFBa0IsUUFBUXhMLE9BQzFCO1lBQ095TSxLQUNQLHdCQUF3QkEsSUFBS2pCLFlBTEY7SUFRL0JvQjs7YUFBMEM1TSxLQUFNd0w7TUFDOUM7UUFDRSxPQUFPLG9CQUFvQixRQUFReEw7WUFDNUJ5TSxLQUNQLHdCQUF3QkEsSUFBS2pCLFlBSkE7SUFPakNvQjs7YUFBeUM1TTtNQUN2QztRQUNFLE9BQU8saUJBQWlCLFFBQVFBO1lBQ3pCeU0sS0FDUCxxQkFBcUIsZ0JBSk87SUFPaENHOzthQUF5QzVNLEtBQU13TDtNQUM3QztRQUNFLElBQUlyRSxFQUFJLG1CQUFtQixRQUFRbkg7UUFDbkMsbUJBQW1CLFFBQVFBO1FBQzNCLE9BQU9tSDtZQUNBc0YsS0FDUCx3QkFBd0JBLElBQUtqQixZQU5EO0lBU2hDb0I7O2FBQXVDNU0sS0FBTTZILEVBQUcyRDtNQUM5QyxJQUFXLE9BQUUscUJBQ0w7TUFDUixRQUFRc0IsT0FBT2pGO09BQUUsT0FDUmlGO3VCQUNVakksT0FBT2dJLGdCQUFpQjt1QkFDeEJoSSxPQUFPZ0ksZ0JBQWlCO3VCQUV2Q2hJLE9BQU9nSSxrQkFBa0JBLGdCQUN6Qjt1QkFDZ0JoSSxPQUFPZ0ksZUFBbUI7eUJBQzFCaEksT0FBT2dJLGVBQW1CO3FCQUMxQmhJLE9BQU9nSSxjQUFtQjt1QkFDMUJoSSxPQUFPZ0ksZ0JBQW1CO3FCQUMxQmhJLE9BQU9nSSxjQUFtQjt5QkFDMUJoSSxPQUFPZ0ksa0JBQW1COztNQUc5QztRQUNFLElBQUlOLEdBQUssaUJBQWlCLFFBQVF2TSxNQUFPNkUsS0FDekMsV0FBV3lILFdBQVdDO1lBQ2ZFLEtBQ1Asd0JBQXdCQSxJQUFLakIsWUF0Qkg7SUEwQjlCb0I7O2FBQXlDRyxFQUFHdEYsRUFBRytEO01BQzdDO1FBQ0UsbUJBQW1CLFFBQVF1QixHQUFJLFFBQVF0RjtZQUNoQ2dGLEtBQ1Asd0JBQXdCQSxJQUFLakIsWUFKRDtJQU9oQ29COzthQUF1QzVNLEtBQU13TDtNQUMzQztRQUNFLElBQUl3QixTQUFXLGlCQUFpQixRQUFRaE47UUFDeEMsT0FBTyxtQkFBbUJnTjtZQUNuQlAsS0FDUCx3QkFBd0JBLElBQUtqQixZQUxIO0lBUTlCb0I7O2FBQXdDNU0sS0FBTXdMO01BQzVDO1FBQ0UsSUFBSXdCLFNBQVcsa0JBQWtCLFFBQVFoTjtRQUN6QyxPQUFPLG1CQUFtQmdOO1lBQ25CUCxLQUNQLHdCQUF3QkEsSUFBS2pCLFlBTEY7SUFRL0JvQjs7YUFBMENLLE9BQVFDLE9BQVFoSCxLQUFNc0Y7TUFDOUQ7UUFDRSxvQkFBb0IsUUFBUTBCLFFBQVMsUUFBUWhILE1BQU8rRztRQUNwRDtZQUNPUixLQUNQLHdCQUF3QkEsSUFBS2pCLFlBTEE7SUFRakNvQjs7YUFBMkM1TSxLQUFNd0w7TUFDL0M7UUFDRSxJQUFJMkIsS0FBTyxxQkFBcUIsUUFBUW5OO1FBQ3hDLE9BQU8sd0JBQXdCbU47WUFDeEJWLEtBQ1Asd0JBQXdCQSxJQUFLakIsWUFMQztJQVFsQ29COzthQUFxREgsSUFBS2pCO01BQ3hELElBQUloRCxXQUFhO01BQ2pCLEdBQUlnRCxjQUFjaEQ7T0FBWSxDQUM1QixJQUFJTSxLQUFPLG1CQUFtQjJELFNBQVVBLFlBQWFBLFNBQVVBO1FBQy9ELHFCQUFxQmpFLFdBQVlNOztPQUM1QixxQkFDZ0IsZUFObUI7SUFTNUM4RDs7YUFBZ0RJO01BVzlDLElBQUlJO01BQ0osR0FBSTtPQUFtQjs7T0FFaEIsR0FBSTtRQUF3Qjs7UUFFNUIsR0FBSTtTQUE4Qjs7U0FFbEMsR0FBSTtVQUEwQjs7VUFFOUIsR0FBSTtXQUEyQjs7V0FFL0IsR0FBSTtZQUFtQjs7WUFFdkIsR0FBSSxvQkFBcUI7TUFtQmhDO2NBRUVKO2NBQ0FBO2NBQ0FJO2NBQ0FKO2NBQ0FBO2NBQ0FBO2NBQ0FBO2NBQ0FBO2NBQ0FBO2NBQ0FBO2NBQ0FBO2NBQ0FBLGlCQXhEbUM7SUE0RHZDSixxQ0FBcUNBO0lDM0xyQyxTQUFTUyxjQUFjbkg7TUFDckIsSUFBSTFCLEVBQUksaUJBQWlCMEIsTUFDekIsS0FBSzFCLEVBQUcsT0FDUixPQUFPQSxVQUFVO0lHQW5CLFNBQVM4SSxjQUFlNUQ7TUFDdEIsS0FBSUM7T0FDRkEsZ0NBQThCO01BQ2hDLHVCQUF1QkEseUJBQTBCRCxJQUNuRDtJSEFBO0tBQWM7TUFBRSxjQUFjOUM7O01BQXFCO0tBNEQ5QjtJQUNyQixHQUFJO0tBQXFCO2FBQ0syRyxxQkFBcUJYLGFBQWFXOztLQUN6RDthQUN1QkEscUJBQXFCbkMsYUFBYW1DO0lBRWhFO2tDQUFtRG5DO0lBZW5ELFNBQVNxQyxrQkFBa0J6TjtNQUN6QjtPQUFTLEtBQUUsZUFBZUE7T0FDakIsS0FBRTtPQUNJLFdBQUUsb0JBQW9CQTtPQUNqQzZFO01BQ0osSUFBVSxJQUFGekMsSUFBT0EsSUFBSW9MLHdCQUF5QnBMO09BQUssQ0FDL0MsSUFBSXdKLEVBQUk0QixpQkFBaUJwTDtRQUN6QjtVQUFHLGtCQUFrQndKOzs7O2FBQ2IvRyxPQUFPQSxrQkFBa0IrRztTQUMvQi9HOztlQUFZK0c7aUJBQWNBO2VBQWMsZUFBZUEsY0FBYzVMO01BRXpFLEtBQUs2RSxPQUFPO09BQXFCLENBQy9CLElBQUk0QixLQUFPLGNBQWN6RztRQUN6QixHQUFJeUcsUUFBUTtTQUE0QixDQUN0QyxJQUFJbUYsUUFBVW5GLGdCQUFnQm1HLGFBQWFuRztVQUMzQyxzQkFBc0JtRjtVQUN0Qi9HOztnQkFBWStHO2tCQUFjQTtnQkFBYyxlQUFlQSxjQUFjNUw7TUFHekUsR0FBSTZFLElBQU0sT0FBT0E7TUFDakIsOENBQThDeUcsV0FDaEQ7SUFzRkEsU0FBU29DLHNCQUFzQjFOO01BQzdCLElBQVMsS0FBRSxrQkFBa0JBLE1BQ3ZCLEVBQUUsbUJBQW1CeUc7TUFDM0IsT0FBT21CLEtBQ1Q7SUo2VUE7S0FBSStGOztRQUNJaE87aUJBQWlEaU8seUJBQ2pELDhCQUR1QztJQU0xQixTQUFqQkMsaUJBQTZCcko7TUFZN0IsSUFBSW9KLHdCQUEwQixxQkFBcUJwSjtNQUNuRCxvQ0FBb0NBLEVBQUdvSix3QkFBeUJwSjtNQUNoRSxPQUFPQSxDQWRZO0lBc3lCTyxTQUExQnNKLDBCQUFzQ3RKLEVBQUdHLE9BRXpDLFdBQVdBLE1BQU1ILEtBQU1BLEtBRks7SUFsd0JELFNBQTNCdUosMkJBQXVDekosR0FBSUs7TUFDM0MsSUFBSUUsUUFBVUY7TUFDZCxHQUFJTCxTQUFVLHdCQUVQLENBSUhPLFFBQVFQLFNBQ1JPLFFBQVFQO01BRVosT0FBT08sR0FYc0I7SUF6SkUsU0FBL0JtSiwrQkFBMkN0SjtNQUMzQyxJQUFRLElBQUVBLFNBQ0YsU0FBTS9FLCtCQUE4QmlGO01BQzVDLElBQVcsSUFBRnhDLElBQU9BLElBQUl3QyxJQUFLeEMsSUFBSyxJQUd0QkEsS0FBS3NDLEVBQUV0QztNQUVmLE9BQU95QyxHQVIwQjtJQTZZUCxTQUExQm9KLDBCQUFzQ3ZKLEVBQUdPLFFBQVNpSjtNQUNsRHhKLElBQUk7TUFDSixRQUFXLElBQU8sRUFBRUEsU0FBVXRDLElBQUlrRixFQUFHbEY7T0FBSyxDQUN0QyxJQUFJK0wsVUFBWSxRQUFRekosRUFBRXRDLEdBQUk4TDtRQUM5QnhKLEVBQUV0QyxLQUFLK0w7UUFFUCxzQ0FBc0NBO01BRTFDLE9BQU8sK0JBQStCekosRUFSVjtJQWdDSyxTQUFqQzBKO01BQTZDL0ksVUFBV2dKLGdCQUFpQkM7TUFDekU7T0FBbUIsZUFBRWpKO09BQ0osYUFBRUE7T0FDRixhQUFFMUU7TUFDbkIsR0FBSTZFO09BQW9CLGVBQ0wsMkJBQTJCQSxnQkFBaUI4STtNQUovRDtPQU1JL0k7UUFBaUI7VUFBMEJFLGVBQWdCc0ksMkJBQTRCTztNQUMzRixXQUFXRCxnQkFBZ0I5SSxlQUFnQkQsYUFSUjtJQW1pQkcsU0FBdENpSjtNQUFrRC9KLEVBQUdHLE1BQU8wSixnQkFBaUJDO01BQ2pFLFNBQVJySixRQUFvQkk7UUFDcEIsT0FBTztpQkFBaUNBLFVBQVdnSixnQkFBaUJDLFVBRDFEO01BSUcsU0FBYkUsYUFBeUJDO1FBQ3pCLElBQU0sRUFBRUEsYUFDQSxRQUFNM0osTUFBTTJDO1FBQ3BCLElBQVcsSUFBRnJGLElBQU9BLElBQUlxRixFQUFHckYsSUFBSyxJQUNwQkEsU0FBUyxRQUFRcU0sTUFBTXJNO1FBRS9CLE9BQU8sK0JBQStCeUMsSUFOdkI7TUFTbkI7T0FBZSxXQUFFLGFBQWFMO09BQ1Isa0JBQUUsYUFBYUE7T0FDcEIsYUFBRSxRQUFRQTtPQUNkLFNBQUUsUUFBUUE7T0FDRCxrQkFBRSxRQUFRQTtPQUNuQixTQUFFLFFBQVFBO09BQ1QsVUFBRSxRQUFRQTtPQUNBLG9CQUFFLFFBQVFBO01BRWxDO2NBQVdHO2VBQ1ArSjtlQUNBQztlQUNBQztlQUNBQztlQUNBQztlQUNBQztlQUNBQztlQUNBQyxvQkEvQm9DO0lBMENELFNBQXZDQyx1Q0FBbUQxSyxFQUFHRztNQUN0RCxXQUFXQSxNQUFNSCxLQUFNQSxLQUFNQSxLQUFNQSxLQUFNQSxLQUFNQSxLQUFNQSxLQURaO0lBZ0hQLFNBQWxDMks7TUFBOEMzSztNQUFHRztNQUFPeUs7TUFBY0M7TUFBMEJoQjtNQUFpQkM7TUFBV2dCO01BQzVIO09BQVcsT0FBRSwwQkFBMEI5SyxLQUFNNEs7T0FDM0IsY0FBRTVLO09BQ1IsUUFBRUE7T0FDTSxnQkFBRUE7T0FDZCxJQUFFQTtPQUNBO1FBQUU7VUFBc0NBLEtBQU02Syx5QkFBMEJoQixnQkFBaUJDO09BQ3hGO1FBQUUsdUNBQXVDOUosS0FBTThLO01BQzFEO2NBQVczSztlQUFNNEssT0FBUUMsY0FBZUMsUUFBU0MsZ0JBQWlCQyxJQUFLQyxNQUFPQyxPQVIxQztJT2hpRHhDLFNBQVNDLG9CQUFxQjNILEtBQU8sTUFBTUEsR0FBSztJQThDaEQsU0FBUzRIO01BQ1Asb0JBQW9CcEcsMkJBQTZCO0lFOENuRCxTQUFTcUcsZ0JBQWlCaFE7TUFDeEIsSUFBTSxFQUFFbkIsV0FDRixFQUFFLHdCQUF3Qm1CO01BRWhDLEdBQUdpUSxhQUNHQSxpQkFDQUEsY0FBY3hJLE1BQU05RztPQUN4QixPQUFPLHdCQUF3QnNQLGNBQWN4STtNQUMvQyxHQUFHNUksOEJBQ0dBLDJCQUEyQjRJO09BQy9CLE9BQU8sd0JBQXdCNUksMkJBQTJCNEk7TUFDNUQsc0JBQ0Y7SUU4TUEsU0FBU3lJLGdCQUFnQkMsS0FBTUMsS0FBTUMsS0FBTUMsS0FBTUMsS0FBTUM7TUFDckQsR0FBR0EsV0FBWSxDQUNiRixVQUFVQyxVQUNWO01BRUYsSUFBSUU7TUFDSixJQUFVLElBQUZyTyxFQUFJaU8sU0FBUWpPLE9BQVFBO09BQUssQ0FDL0IsSUFBSXdGLEVBQUl1SSxVQUFVQyxPQUFLaE87UUFDdkIrTixVQUFVQyxPQUFLaE8sS0FBTXdGLE1BQU00SSxRQUFTQztRQUNwQ0EsT0FBTzdJLFVBQVc0STtNQUVwQkYsVUFBVUMsUUFBUUU7TUFDbEIsUUFDRjtJQ3FFQSxJQUFJQztJQUNKLFVBQVc3UjtLQUFvQzs7S0FDN0I7UUFFZCxTQUFTOFIsWUFBWUMsTUFBUTlSLFlBQVk4UixJQUFNO1FBQy9DRDs7aUJBQXFDak07VUFDbkMsSUFBVyxJQUFGdEMsSUFBT0EsSUFBSXRELGlCQUFrQnNELElBQUssR0FDckN0RCxVQUFVc0QsT0FBT3NDLEVBQUcsT0FBT3RDLENBRlA7UUFLNUJ1Tyx1Q0FBNEI7UUFJNUI7VUFDRTdSLGVBQWdCQSxrQkFBa0I2UixZQUFZN1IsVUFEekMsQ0FaTzs7O0tBaUJiOztnQkFFREEsZUFBZ0JBLG1CQUFrQkQscUJBRHBCO0lBS2xCNlI7O2FBQXlDaE0sR0FDdkMsZ0JBQWdCQSxFQUFHNUYsa0JBQ25CLGVBQWU0RixFQUZlO0lBS2hDZ007O2FBQTBDaE07TUFDeEMsSUFBSXRDLEVBQUksZ0JBQWdCc0M7TUFDeEIsT0FBUXRDLE1BQU16QixVQUNWQSxVQUFZN0IsbUJBQW1Cc0QsQ0FISjtJQTlCakMsSUN6WUl5TyxrQkFBb0I7SU53Q3hCLFNBQVNDO01BQ1Asb0JBQW9Cbkgsa0NBQ3RCO0lNdENBLFNBQVNvSCxRQUFTQyxHQUFHQyxHQUFHQztNQUN0QnBTLFVBQVVrUyxjQUNWbFMsVUFBVW1TLGNBQ1ZuUyxVQUFVb1MsV0FDWjtJQUNBSDtJQUNBQTs7ZUFDRSxXQUFXQSxRQUFRalMsUUFBUUEsUUFBUUEsUUFEWjtJQUl6QmlTOzthQUF1Q3ZNO01BQ3JDLEdBQUkxRixVQUFVMEYsS0FBTTtNQUNwQixHQUFJMUYsVUFBVTBGLEtBQU07TUFDcEIsR0FBSTFGLFVBQVUwRixLQUFNO01BQ3BCLEdBQUkxRixVQUFVMEYsS0FBTTtNQUNwQixHQUFJMUYsVUFBVTBGLEtBQU07TUFDcEIsR0FBSTFGLFVBQVUwRixLQUFNO01BQ3BCLFFBUDJCO0lBUzdCdU07O2FBQXNDdk07TUFDcEMsSUFBTyxHQUFFMUYsY0FDRCxJQUFFMEY7TUFDVixHQUFJME0sS0FBS0MsSUFBSztNQUNkLEdBQUlELEtBQUtDLElBQUs7TUFDZCxHQUFJclMsVUFBVTBGLEtBQU07TUFDcEIsR0FBSTFGLFVBQVUwRixLQUFNO01BQ3BCLEdBQUkxRixVQUFVMEYsS0FBTTtNQUNwQixHQUFJMUYsVUFBVTBGLEtBQU07TUFDcEIsUUFUMEI7SUFXNUJ1TTs7O01BQ0UsSUFBTyxLQUFJalMsUUFDSixLQUFJQSxXQUFXa1MsVUFDZixLQUFJbFMsV0FBV21TO01BQ3RCLFdBQVdGLFFBQVFDLEdBQUlDLEdBQUlDLEdBSkw7SUFNeEJIOzthQUFrQ3ZNO01BQ2hDO09BQU8sR0FBRTFGLFVBQVUwRjtPQUNaLEdBQUUxRixVQUFVMEYsUUFBUXdNO09BQ3BCLEdBQUVsUyxVQUFVMEYsUUFBUXlNO01BQzNCLFdBQVdGLFFBQVFDLEdBQUlDLEdBQUlDLEdBSkw7SUFNeEJIOzthQUFrQ3ZNO01BQ2hDO09BQU8sR0FBRTFGLFVBQVUwRjtPQUNaLEdBQUUxRixVQUFVMEYsUUFBUXdNO09BQ3BCLEdBQUVsUyxVQUFVMEYsUUFBUXlNO01BQzNCLFdBQVdGLFFBQVFDLEdBQUlDLEdBQUlDLEdBSkw7SUFNeEJIOzthQUFrQ3ZNO01BQ2hDO09BQU8sR0FBRTFGLFVBQVUwRjtPQUNaLElBQUl3TSxLQUFLSCx5QkFBMEIvUixVQUFVMEYsT0FBTzFGLFVBQVUwRjtPQUM5RDtTQUFJeU0sS0FBS0o7O1FBQTBCL1I7O1FBQVUwRjs7UUFBTzFGOztRQUFVMEY7O1FBQU8xRjs7UUFBVTBGO01BQ3RGLFdBQVd1TSxRQUFRQyxHQUFJQyxHQUFJQyxHQUpMO0lBTXhCSDs7ZUFDRSxRQUFRalMsVUFBUUEsVUFBUUEsYUFEQztJQUczQmlTLHFDQUNFLE9BQVFqUyxpQkFEZ0I7SUFHMUJpUzs7YUFBa0N2TTtNQUNoQyxXQUFXdU0sUUFBUWpTLFVBQVUwRixLQUFNMUYsVUFBVTBGLEtBQU0xRixVQUFVMEYsS0FEdkM7SUFHeEJ1TTs7YUFBaUN2TTtNQUMvQixXQUFXdU0sUUFBUWpTLFVBQVEwRixLQUFNMUYsVUFBUTBGLEtBQU0xRixVQUFRMEYsS0FEbEM7SUFHdkJ1TTs7YUFBa0N2TTtNQUNoQyxXQUFXdU0sUUFBUWpTLFVBQVEwRixLQUFNMUYsVUFBUTBGLEtBQU0xRixVQUFRMEYsS0FEakM7SUFHeEJ1TTs7YUFBeUNqTDtNQUN2Q0EsSUFBSUE7TUFDSixHQUFJQSxPQUFRLE9BQU9oSDtNQUNuQixHQUFJZ0g7T0FBUTtlQUNDaUw7Z0JBQVNqUyxXQUFXZ0g7Z0JBQ1ZoSCxXQUFXZ0gsSUFBTWhILGdCQUFpQmdIO2dCQUNsQ2hILFdBQVdnSCxJQUFNaEgsZ0JBQWlCZ0g7TUFFekQsR0FBSUE7T0FDRjtlQUFXaUw7a0JBQ1NqUyxXQUFZZ0gsT0FDWGhILFdBQVlnSCxTQUFZaEgsZ0JBQWlCZ0g7TUFDaEUsV0FBV2lMLFlBQWNqUyxXQUFZZ0gsT0FaUjtJQWMvQmlMOzthQUFtRGpMO01BQ2pEQSxJQUFJQTtNQUNKLEdBQUlBLE9BQVEsT0FBT2hIO01BQ25CLEdBQUlnSDtPQUNGO2VBQVdpTDtnQkFDUmpTLFdBQVdnSCxJQUFNaEgsZ0JBQWlCZ0g7Z0JBQ2xDaEgsV0FBV2dILElBQU1oSCxnQkFBaUJnSDtnQkFDbENoSCxXQUFXZ0g7TUFDaEIsR0FBSUE7T0FDRjtlQUFXaUw7Z0JBQ1JqUyxXQUFZZ0gsU0FBWWhILGdCQUFpQmdILEVBQ3pDaEgsV0FBWWdIO01BRWpCLFdBQVdpTCxRQUFTalMsV0FBWWdILFdBYk87SUFlekNpTDs7YUFBMENqTDtNQUN4Q0EsSUFBSUE7TUFDSixHQUFJQSxPQUFRLE9BQU9oSDtNQUNuQixJQUFJc1MsRUFBS3RTO01BQ1QsR0FBSWdIO09BQ0Y7ZUFBV2lMO2dCQUNSalMsV0FBV2dILElBQU1oSCxnQkFBaUJnSDtnQkFDbENoSCxXQUFXZ0gsSUFBTXNMLFVBQVd0TDtnQkFDM0JoSCxpQkFBa0JnSDtNQUx4QixJQU1JN0MsS0FBUW5FO01BQ1osR0FBSWdIO09BQ0Y7ZUFBV2lMO2dCQUNSalMsV0FBWWdILFNBQVloSCxnQkFBaUJnSDtnQkFDekNoSCxpQkFBbUJnSDtnQkFDcEI3QztNQUNKLFdBQVc4TixRQUFValMsaUJBQW1CZ0gsT0FBUzdDLEtBQU1BLEtBZnpCO0lBaUJoQzhOOzs7TUFDRWpTLFVBQVdBLGVBQWlCQTtNQUM1QkEsV0FBWUEsZUFBaUJBO01BQzdCQSxVQUFXQSx1QkFIWTtJQUt6QmlTOzs7TUFDRWpTLFdBQVlBLGdCQUFrQkE7TUFDOUJBLFdBQVlBLGdCQUFrQkE7TUFDOUJBLFVBQVVBLGFBSGE7SUFLekJpUzs7YUFBc0N2TTtNQUNwQztPQUFXO09BQ0MsUUFBRTtPQUNGLFFBQUU7T0FDRCxhQUFNdU07TUFDbkIsTUFBTyxpQkFBaUJPLGFBQWMsQ0FDcEN2RyxTQUNBO01BRUYsTUFBT0E7T0FBYSxDQUNsQkE7UUFDQTtRQUNBLEdBQUksaUJBQWlCdUc7U0FBZSxDQUNsQ0MsY0FDQUYsVUFBVSxZQUFZQztRQUV4QjtNQUVGLGlCQUFvQkMsaUJBQW9CRixRQWxCZDtJQW9CNUJOOzthQUFrQ25PO01BRWhDLElBQUk0QixFQUFJMUY7TUFDUixHQUFJLFdBQVk7TUFEaEIsSUFFSW1FLEtBQU91QixPQUFPNUI7TUFDbEIsR0FBSTRCLGNBQWVBLElBQUk7TUFDdkIsR0FBSTVCLGNBQWVBLElBQUk7TUFKdkIsSUFLSTRPLEVBQUksVUFBVTVPO01BQ2xCLEdBQUlLLGNBQWV1TyxJQUFJO01BQ3ZCLE9BQU9BLENBVGU7SUFXeEJUOzthQUFrQ25PO01BRWhDLElBQUk0QixFQUFJMUY7TUFDUixHQUFJLFdBQVk7TUFEaEIsSUFFSW1FLEtBQU91QjtNQUNYLEdBQUlBLGNBQWVBLElBQUk7TUFDdkIsR0FBSTVCLGNBQWVBLElBQUk7TUFKdkIsSUFLSThFLEVBQUksVUFBVTlFO01BQ2xCLEdBQUlLLGNBQWV5RSxJQUFJO01BQ3ZCLE9BQU9BLENBVGU7SUFXeEJxSixxQ0FDRSxPQUFPalMsVUFBV0EsYUFETTtJQUcxQmlTOzs7TUFDRSxRQUFTalM7O2FBQWlCOzthQUFrQkE7O2FBQVU7O2FBQW1CQSxPQUQvQztJQUc1QmlTOzs7TUFDRSxRQUFRalM7Y0FDQUE7Y0FDQUE7Y0FDQ0E7Y0FDREE7Y0FDQUE7Y0FDQ0E7Y0FDREEsZUFSa0I7SUFVNUJpUzs7ZUFDRSxPQUFPalMsV0FBWUEscUJBREk7SUFHekJpUzs7ZUFDRSxPQUFTalMseUJBQTRCQSxhQURkO0lBMEl6QixTQUFTMlMsMkJBQTJCVCxHQUFJQyxHQUFJQztNQUMxQyxXQUFXSCxRQUFRQyxHQUFJQyxHQUFJQyxHQUM3QjtJQXJGQSxTQUFTUSxvQkFBcUJsTjtNQUM1QixXQUFXdU0sUUFBUXZNLGFBQWVBLG1CQUFzQkEsaUJBQzFEO0lDck5BLFNBQVNtTixpQkFBaUJ0SztNQUN4QixHQUFJQSxXQUFXQSxRQUFVLE9BQU9BO01BQ2hDLEdBQUlBLFdBQVdBLFFBQVUsT0FBT0E7TUFDaEMsR0FBSUEsV0FBV0EsU0FBVSxPQUFPQTtNQUNoQyxVQUNGO0lENEpBLFNBQVN1SyxlQUFlcE4sRUFBRTVCLEdBQUssT0FBTyxXQUFXQSxNQUFRO0lBU3pELFNBQVNpUCxlQUFnQnJOLEVBQUc1QixHQUFLLE9BQU8sTUFBTUEsRUFBRztJQU9qRCxTQUFTa1AsZUFBZXROLEVBQUU1QixHQUFLLE9BQU8sTUFBTUEsRUFBRztJQVYvQyxTQUFTbVAsZUFBZ0J2TixHQUFLLE9BQU8sT0FBUTtJRUk3QyxTQUFTd04sd0JBQXdCbE0sRUFBR21NO01BT2hDLElBQU0sSUFBUyxJQUFFLHNCQUFzQm5NLEdBQWE7TUFDcEQsR0FBSTFELEtBQUt3QyxJQUFLO01BRGQsSUFJSXlDLEVBQUksdUJBQXVCdkIsRUFBRzFEO01BQ2xDLEdBQUlpRixTQUFVLENBQ1ZqRixJQUNBOFAscUJBQ0csR0FBSTdLLFNBQVU7TUFSckIsSUFXSThLO01BRUpGLGFBQWFBO01BYmI7T0FjUSxJQUFFO09BQ00sWUFBRSxnQkFBZ0JHO09BQzFCLElBQUU7TUFDVixLQUFPaFEsSUFBSXdDLElBQUt4QztPQUFLLENBQ2pCLElBQU0sRUFBRSx1QkFBdUIwRCxFQUFHMUQsR0FDNUIsRUFBRSxpQkFBaUJpRjtRQUN6QixHQUFJNUcsU0FBU0EsUUFBUztRQUd0QjBSO1FBRUEsR0FBSSxlQUFlRSxZQUFheE4sS0FBTSxPQUMzQm9OO1FBRVh4UixJQUFJLG9CQUFvQkE7UUFDeEJvRSxNQUFNLGVBQWUsZUFBZXVOLElBQUt2TixLQUFNcEU7UUFFL0MsR0FBSSxlQUFlb0UsSUFBS3BFLEdBQUksT0FDakJ3UjtNQUdmLEdBQUlFLFVBQVc7TUFHZixHQUFJRCxTQUFVLE1BQ0osZUFBZXJOO01BR3pCQSxTQUFTQTtNQUNULE9BQU9BLEdBQ1g7SUZOQSxTQUFTeU4sb0JBQXFCOU4sR0FBSyxPQUFPLFNBQVU7SUVuUXBEO0tBQUkrTjtNQUFTO1NBQ0UsU0FBUEEsT0FBa0IvTixHQUNsQjFGLGFBQWEwRixPQURKO1NBR2IrTjtTQUNBLE9BQU9BLE1BTEc7O0lBMEZkLFNBQVNDLHlCQUF5QnBRO01BQzlCLFdBQVdtUSxPQUFPLG9CQUFvQm5RLEdBQzFDO0lBSUEsU0FBU3FRLDBCQUEwQjNNO01BRy9CLElBQUltTSxRQUFVO01BQ2QsT0FBTyx5QkFBeUIsd0JBQXdCbk0sRUFBR21NLFNBQy9EO0lkb0tBLFNBQVNTLGlCQUFrQmxPLEdBQUssT0FBTyxXQUFXQSxFQUFJO0lEVC9CLFNBQW5CbU8sbUJBQStCbk8sRUFBRzVCO01BQ2xDLFFBQVcsSUFBTyxFQUFFNEIsU0FBVXBDLElBQUlrRixFQUFHbEYsSUFBSyxFQUNwQ0EsS0FBS1EsRUFBRVIsRUFGUTtJQW9CekIsSUFBSXdRLGtCQUFvQnhPO0lBZ0VFLFNBQXRCeU8sc0JBQWtDck8sRUFBRzVCO01BQ3JDLG1CQUFtQjRCLEVBQUcsa0JBQWtCQSxFQUFHNUIsR0FEbkI7SUs5SzVCLFNBQVNrUSxZQUFZOVM7TUFDbkIsSUFBSXlHLEtBQU8sa0JBQWtCekc7TUFDN0IsS0FBS3lHLG1CQUFvQjtNQUd6QixPQUFPLG1CQUFtQkEsZUFDNUI7SUlvSEEsSUFBSXNNO0lBSUosU0FBU0MsZ0NBQWlDQztNQUN4Q0Ysd0JBQXdCRSxLQUN4QixRQUNGO0lSM0hBLFNBQVNDLG9CQUFxQjFPO01BQzVCLEdBQUksU0FBVUE7T0FBSSxDQUNoQixHQUFJLFNBQVNBLDhCQUErQjtRQUM1QyxHQUFJQSxPQUFRO1FBQ1o7TUFFRixPQUFPLE1BQU1BLE1BQ2Y7SUk5Q0EsU0FBUzZPLFdBQVdyVDtNQUNsQixJQUFJeUcsS0FBTyxrQkFBa0J6RztNQUM3QixLQUFLeUcsa0JBQW1CO01BR3hCLE9BQU8sa0JBQWtCQSxlQUMzQjtJTG16Q0EsU0FBUzZNLGVBQWVDO01BRXBCLElBQVEsSUFBRUEsUUFDSSxVQUFFQSxjQUNWLEVBQUVBO01BQ1I7TUFDQSxXQUNRcEwsSUFBSy9GLE1BQ0wrRixJQUFLL0YsTUFDTCtGLElBQUsvRixNQUNMK0YsSUFBS3FMLGNBQ0xyTCxJQUFLL0YsSUFDWCtGOzthQUFRQSxHQUNkO0lBSUEsU0FBU3NMLGlCQUFpQkM7TUFFdEIsSUFBUSxJQUFFQSxhQUNGLElBQUVBO01BQ1Y7TUFDQSxVQUFXLGVBQWVILEtBQU1JLElBQ3BDO0lBSUEsU0FBU0MscUJBQXFCQztNQUMxQjtPQUFRLElBQUVBO09BQ0gsR0FBRUE7T0FDRixHQUFFQTtPQUNILEVBQUVBO09BQ0YsRUFBRSxpQkFBaUJBO01BQ3pCO01BQ0EsYUFDV0MsR0FBSXZKLFNBQ0oxQyxRQUNBbkQsUUFDQW9QLFdBQ0VBLFdBQ0FBLEtBQ1gzTDs7YUFBUUEsR0FDZDtJQWdCQSxTQUFTc0ksS0FBS3NELElBQUtwUDtNQUNmLElBQUlxUCxJQUFNLGNBQWNyUCxpQkFDeEJxUCxVQUFVRCxJQUNWLE9BQU9DLEdBQ1g7SUFoQkEsU0FBU0MsbUJBQW1CQyxLQUFNQztNQUc5QjtPQUFXLE9BQUUsZUFBZUQ7T0FDWjtRQUFFLCtCQUErQkEsaUJBQWtCQztNQUNuRUUsY0FBYyxnQkFBZ0JUO01BQzlCUyxjQUFjLFdBQVdBO01BQ3pCO01BQ0EsVUFBV0QsT0FBUUMsWUFDdkI7SUFXQSxTQUFTQyxzQkFBc0JDLGNBQWVDO01BQzFDO09BQU0sRUFBRUEsaUJBQWlCcFE7T0FDTCxnQkFBRUEsb0JBQW9CcVE7T0FDeEIsY0FBRXJRLG9CQUFvQnFRO09BRXRCO1FBQUU7VUFBK0JGLDRCQUE2Qkc7TUFDaEZFLGdCQUFnQixrQkFBa0JoQjtNQUNsQ2dCLGdCQUFnQixXQUFXQTtNQU4zQjtPQVFJQztRQUFjLFdBQVdOO21CQUNWUjtZQUNYLElBQUllLGNBQWdCLEtBQUtmLElBQUtZO1lBQzlCLE9BQU8sbUJBQW1CRyxjQUFlSixnQkFGeEM7TUFJVEcsY0FBYyxXQUFXQTtNQUV6QjtNQUNBLFVBQVdELGNBQWVDLFlBQzlCO0lBak04QixTQUExQkUsMEJBQXNDdlE7TUFDdEMsSUFBc0Isa0JBQUVBLG9CQUNWLFVBQUVBO01BQ2hCO01BQ0EsVUFBV3dRLGtCQUFtQkMsVUFKRjtJQWdCVSxTQUF0Q0Msc0NBQWtEMVEsRUFBRzJRO01BQ3pDLFNBQVJsUSxRQUFvQkk7UUFDcEIsT0FBTyxpQ0FBaUNBLFVBQVc4UCxtQkFEekM7TUFlRyxTQUFiM0csYUFBeUJDO1FBQ3pCQTs7UUFBUSwrQkFBK0JBLE1BQU9ySztRQUU5QyxPQUFPLFdBQVcsVUFBVWEsU0FIYjtNQU1uQjtPQUFlLFdBQUUsYUFBYVQ7T0FDUixrQkFBRSxhQUFhQTtPQUNwQixhQUFFLFFBQVFBO09BQ2QsU0FBRSxRQUFRQTtPQUNELGtCQUFFLFFBQVFBO09BQ25CLFNBQUUsUUFBUUE7T0FDVCxVQUFFLFFBQVFBO09BQ0Esb0JBQUUsUUFBUUE7TUFFbEM7TUFDQTtjQUNNa0s7Y0FDQUM7Y0FDQUM7Y0FDQUM7Y0FDQUM7Y0FDQUM7Y0FDQUM7Y0FDQUM7Z0JBeENrQztJQWlGRCxTQUF2Q21HLHVDQUFtRDVRO01BQ25ELElBQUlLLE9BQVVMLEtBQU1BLEtBQU1BLEtBQU1BLEtBQU1BLEtBQU1BLEtBQU1BLE1BQ2xELFNBQ0EsT0FBT0ssR0FIa0M7SUFtRzdDLElBQUl3UTtJQUlrQyxTQUFsQ0Msa0NBQThDOVEsRUFBR2dRO01BQ2pEO09BQVcsT0FBRSwwQkFBMEJoUTtPQUNyQixjQUFFQTtPQUNSLFFBQUVBO09BQ00sZ0JBQUVBO09BQ2QsSUFBRSxpQkFBaUJBO09BQ2pCLE1BQUUsc0NBQXNDQSxRQUFTZ1E7T0FDaEQsT0FBRSx1Q0FBdUNoUTtPQUduQyxhQUFFNlE7TUFDbkI7TUFDQTtjQUFXOUY7Y0FBUUM7Y0FBZUM7Y0FBU0M7Y0FBaUJDO2NBQUtDO2NBQU9DO2NBQVF3RixLQVo1QztJQW1HTyxTQUEzQ0csMkNBQXVEaFI7TUFDdkQsT0FBTyxrQ0FBa0NBLEVBQUdKLHVCQURDO0lBTUYsU0FBM0NxUiwyQ0FBdURqUjtNQUN2RCxPQUFPO2VBQWtDQTtlQUFHSjtlQUFxQ0E7ZUFBeUJBO2VBQXlDQTtlQUEyQkE7ZUFBbUNBLHdCQURwSztJQThDQSxTQUE3Q3NSLDZDQUF5RGxSO01BQ3pELE9BQU87ZUFBMkM7aUJBQXdELDJDQUEyQ0EsSUFEdEc7SUF0MkNuRCxJQUFJbVIsb0JBQXNCdlI7SU83UTFCLFNBQVN3UjtNQUNQLDRDQUNGO0lNcVNBLFNBQVNDLG9CQUFvQmpPO01BQzNCO2NBQVdtSjtlQUFRbkosWUFBYUEsWUFBY0E7ZUFDM0JBLFlBQWFBLFlBQWNBO2VBQzNCQSxZQUFhQSxVQUNsQztJR3dDQSxTQUFTa08sb0JBQW9CQyxHQUFJakM7TUFDL0IsSUFBSWtDLElBQU0sVUFBVWxDO01BQ3BCLEdBQUdrQyxXQUFXRCxlQUFnQjtNQUQ5QjtPQUVPLEdBQUUsT0FBT0M7T0FDVCxHQUFFLE9BQU9BO09BQ1QsR0FBRSxPQUFPQTtPQUNULEdBQUUsT0FBT0E7T0FDVCxHQUFFLE9BQU9BO09BQ1QsR0FBRSxPQUFPQTtPQUNULEdBQUUsT0FBT0E7T0FDVCxHQUFFLE9BQU9BO01BQ2hCLE9BQU8scUJBQXFCUSxHQUFHRCxHQUFHRCxHQUFHRCxHQUFHRCxHQUFHRCxHQUFHRCxHQUFHRCxJQUNuRDtJRHJEQSxTQUFTUSx3QkFBd0JDLE1BQzdCLFFBQ0o7SUV6UUEsU0FBU0MsZ0NBQWdDQyxJQUFLQyxLQUFNQyxPQUFRQyxLQUFNblM7TUFDaEUsU0FBU2dTO09BQ1A7O01BQ0YsR0FBR2hTLFNBQVU7TUFDYixJQUFJd0wsS0FBTyxXQUFXeUc7TUFDdEIsR0FBR3pHLE9BQU94TCxNQUFNZ1MsZ0JBQWdCO01BR2hDLEdBQUdHLE9BQU9uUyxNQUFNLHFCQUFxQmtTLFFBQVE7TUFKN0MsSUFPSUUsTUFBUSxlQUFlNUcsS0FBTUEsT0FBS3hMO01BQ3RDLGdCQUFnQixvQkFBb0JvUyxTQUFXRixPQUFRQyxLQUFNblM7TUFDN0QsUUFDRjtJQzlGQSxTQUFTcVMsb0NBQW9DQyxJQUFLQyxRQUFTQyxJQUFLQyxRQUFTelM7TUFDdkUsT0FBTyxnQ0FBZ0NzUyxJQUFJQyxRQUFRQyxJQUFJQyxRQUFRelMsSUFDakU7SUM4TUEsU0FBUzBTLHdCQUEwQixRQUFVO0lDaEY3QyxTQUFTQyxzQkFBc0IzUDtNQUM3QixJQUFJTjtNQUNKLElBQVMsSUFBRGxGLEVBQUV3RixhQUFjeEYsT0FBTUEsSUFBSSxDQUNoQyxJQUFJdUksRUFBSS9DLEVBQUV4RixHQUNWa0YsT0FBT3FELEVBQUVyRDtNQUVYLE9BQU9BLENBQ1Q7SXBCa2xDcUMsU0FBakNrUTtNQUE2Q0MsTUFBT0MsY0FBZWhJLGdCQUFpQmlJO01BQ3BGO09BQUl2UTtRQUFJO1VBQTRDcVEsTUFBT0MsY0FBZWhJLGdCQUFpQmlJO01BQzNGLE9BQU8saUJBQWlCdlEsRUFGVztJS252Q3ZDLFNBQVN3USxvQkFDUCxPQUFPLElBQUs1Vyx1QkFDZDtJTG96QkEsSUFBSTZXLHFCQUF1QnpUO0ljMXRCM0IsU0FBUzBULFNBQVNsUSxFQUFFVCxHQUNsQixPQUFPLFVBQVVTLEVBQUVULEVBQ3JCO0lPWEEsU0FBUzRRLGtCQUFrQjNHLEVBQUUzUTtNQUMzQkEsSUFBSSxTQUFTQTtNQUNiQSxJQUFNQSxVQUFZQTtNQUNsQkEsSUFBSSxTQUFTQTtNQUNiMlEsS0FBSzNRO01BQ0wyUSxJQUFNQSxVQUFZQTtNQUNsQixRQUFVQSxLQUFLQSxtQ0FDakI7SVZIQSxTQUFTNEcsZUFBZUMsSUFBS2pDLElBQUtwUjtNQUNoQyxJQUFVLElBQUZ4QyxFQUFJd0MsUUFBU3hDLE9BQVFBLElBQUssR0FDN0I2VixTQUFTakMsTUFBSTVULFFBQVMsT0FBT0E7TUFFbEMsUUFDRjtJQXRFQSxTQUFTOFYsY0FBYzFUO01BQ3JCLElBQVEsSUFBRSxlQUFlQSxJQUFNQSxlQUN6QjtNQUNOLElBQVcsSUFBRnBDLElBQU9BLElBQUl3QyxJQUFLeEMsSUFBSyxJQUN4QixrQkFBa0JnUCxFQUFHNU0sT0FBT3BDO01BRWxDLE9BQU9nUCxDQUNUO0lMVEEsU0FBUytHLGNBQWN0USxFQUFHaUI7TUFDeEIsR0FBR2pCLE1BQ0QsT0FBTyxjQUFjQSxNQUFPaUI7TUFFOUIsVUFBVWpCLGlCQUFrQixPQUFPQTtNQUNuQyxJQUFJSixFQUFJSTtNQUNSLEdBQUdKLFFBQVMsT0FBTyxRQUFRM0csS0FBS2dJO01BRGhDLElBRVksUUFBRUEsZ0JBQ1IsRUFBRXJCLElBQUkyUTtNQUNaLEdBQUkzWDtPQUNGLE9BQU8sUUFBUUssS0FBTWdJOztPQUNsQixHQUFJckk7UUFBTyxPQUNQLGNBQWMsUUFBUUssS0FBSyxhQUFhMkcsSUFBSSxXQUFXQTs7UUFFM0Q7VUFFRDtXQUFlLFdBQUc2USx3QkFBeUJBO1dBQ2pDLFVBQU14VCxNQUFNZ0UsY0FBWXVQO1VBQ2xDLElBQVUsSUFBRmpXLElBQU9BLElBQUkwRyxZQUFhMUcsSUFBTW1XLE1BQU1uVyxLQUFLMEcsS0FBSzFHO1VBQ3RELElBQVUsSUFBRkEsSUFBT0EsSUFBSWtXLGlCQUFrQmxXO1dBQU1tVyxNQUFNelAsY0FBWTFHLEtBQUtrVyxVQUFVbFc7VUFDNUUsT0FBTyxjQUFjeUYsRUFBRzBRLE1BTG5CLENBUVg7SWN3TkEsU0FBU0MsZ0NBQWdDM1E7TUFDdkM7UUFDRSxJQUFRLElBQUV5USxpQkFDRCxTQUFNeFQsTUFBTUY7UUFDckIsSUFBVyxJQUFGeEMsSUFBT0EsSUFBSXdDLElBQUt4QyxJQUFLMEcsS0FBSzFHLEtBQUtrVyxVQUFVbFc7UUFDbEQsT0FBTyxjQUFjeUYsR0FBSWlCLE1BSnBCLENBTVQ7SUVoUUEsU0FBUzJQLG1CQUFxQixrQkFBbUI7SXBCNHhCakQsU0FBU0MsdUJBQXVCNVM7TUFDN0JBLFdBQVksNkJBQTZCQSxHQUMxQyxPQUFPQSxHQUFJO0lxQnB4QmIsU0FBUzZTLGtCQUFtQm5ZO01BQzFCQSxNQUFNLHVCQUF1QkE7TUFDN0IsSUFBSW9FLElBQU1wRTtNQUNWLEdBQUlvRSxTQUFVO01BRGQ7T0FFSWlEOzs7Ozs7Ozs7Ozs7TUFJSixJQUFXLElBQUZ6RixJQUFPQSxJQUFJd0MsSUFBS3hDO09BQUssQ0FDNUIsSUFBSWlGLEVBQUksV0FBV2pGO1FBQ25CLE9BQVFpRjttQkFFTlEsZ0JBQWlCOzttQkFFakJBLGNBQWNSLEVBQUc7bUJBRWpCUSxlQUFnQjttQkFFaEJBLG1CQUFvQjs7Ozs7Ozs7OztXQUdwQkE7V0FDQSxNQUFPUixJQUFFLGVBQWVqRixRQUFTaUYsVUFBVUE7WUFBUSxDQUNqRFEsVUFBVUEsZUFBZVIsRUFBR2pGO1dBRTlCQTtXQUNBOztXQUVBeUY7V0FDQXpGO1dBQ0EsTUFBT2lGLElBQUUsZUFBZWpGLFFBQVNpRixVQUFVQTtZQUFRLENBQ2pEUSxTQUFTQSxjQUFjUixFQUFHakY7V0FFNUJBOzttQkFFQXlGO21CQUVBQSxZQUFhO21CQUViQSxZQUFhO21CQUViQSxZQUFhQSxtQkFBb0I7bUJBRWpDQSxXQUFZOzs7bUJBRVpBLG9CQUFxQkEsU0FBU1IsRUFBRzs7OztXQUVqQ1E7V0FBcUJBO1dBQ3JCQSxTQUFTO1dBQWtCOztNQUcvQixPQUFPQSxDQUNUO0lDaWFBLFNBQVMrUTtNQUNQLG9EQUNGO0l4QjhxQjJDLFNBQXZDQztNQUNBLE9BQU87ZUFBaUIsb0RBRGlCO0lLaDlCN0MsU0FBU0MsaUJBQWlCcEMsTUFDeEIsT0FBTyx1QkFDVDtJTHU4QzhDLFNBQTFDcUMsMENBQXNEdlU7TUFDdEQsT0FBTztlQUEyQyxxREFBcURBLEdBRDNEO0lDL25EaEQsSUFBSXdVLFFBQVV6VyxhQUFhO0lBQzNCLFNBQVMwVyxnQkFBZ0J6VTtNQUN2QixHQUFHd1UsUUFBUyxPQUFPLFdBQVcsVUFBVXhVO01BQ3hDLElBQUlwQztNQUNKLEdBQUlvQyxPQUFRLFNBQVEwVTtNQUNwQixHQUFHMVUsT0FBTSxNQUFRQSxPQUFNLENBQUNBLE9BQU1wQyxTQUN6QixNQUFRb0MsTUFBTyxDQUFDQSxPQUFNcEM7TUFDM0IsT0FBT0EsQ0FDVDtJQXdDQSxTQUFTK1cseUJBQTBCM1U7TUFDakMsSUFBSTRVLGNBQWV2YTtNQUNuQnVhLGNBQWM1VTtNQURkLElBRUk2VSxZQUFheGEsdUJBQXNCdWE7TUFDdkMsT0FBT0MsYUFDVDtJQXpDQSxTQUFTQyx5QkFBMEI5VTtNQUNqQyxLQUFLLFNBQVNBO09BQUksQ0FDaEIsR0FBSSxNQUFNQSxHQUNSLE9BQU87UUFDVCxPQUFJQTtpQkFDSztpQkFFQTtNQUVYLElBQUl2QixLQUFRdUIsY0FBVUEsT0FBTTBVLGdCQUFrQjFVO01BQzlDLEdBQUl2QixLQUFNdUIsTUFBS0E7TUFEZixJQUlJK1UsSUFBTSxnQkFBZ0IvVTtNQUMxQixHQUFJK1U7T0FBVSxDQUNaQSxRQUNBL1UsS0FBSzs7T0FDQSxDQUNMQSxLQUFLLFdBQVcrVTtRQUNoQixHQUFJL1UsT0FBUSxDQUNWQSxPQUFRK1U7UUFDVixHQUFJQSxTQUFVO01BWmhCLElBZU0sRUFBRSxlQUNELEdBQUUvVTtNQUNUQSxLQUFLQSxJQUFJaVYsTUFBTUQ7TUFqQmYsSUFrQklFLEdBQUtsVjtNQUNUQSxLQUFLQSxJQUFJa1YsTUFBTUY7TUFuQmYsSUFvQklHLEdBQUtuVjtNQUNUaVYsS0FBTUEsV0FBV3hXLE9BQU9zVztNQUN4QixPQUFPLDJCQUEyQkksR0FBSUQsR0FBSUQsR0FDNUM7SVlxVEEsU0FBU0csb0JBQW9CcFYsR0FBSyxPQUFPLFdBQVk7SUd3T3JELFNBQVNxVixrQkFBa0JDLE9BQVEvRCxHQUFJZ0U7TUFDckMsZ0JBQWlCaEU7TUFDakIsZ0JBQWtCQSxVQUFXQTtNQUM3QixHQUFHQTtPQUNELElBQVUsSUFBRjNULElBQU9BLElBQUkyVCxlQUFnQjNUO1FBQUssR0FDbkMyVCxRQUFRM1Q7U0FDVCxnQkFBaUIyVCxRQUFRM1Q7O1NBQ3RCLENBQ0g7VUFDQTtVQUNBLGdCQUFpQjJULFFBQVEzVDs7T0FJN0IsSUFBVSxJQUFGQSxJQUFPQSxJQUFJMlQsZUFBZ0IzVCxJQUFLLGdCQUFnQjJULFFBQVEzVDtNQUNsRSxPQUFPMlQ7Ozs7U0FJTCxJQUFVLElBQUYzVCxJQUFPQSxJQUFJMlQsZUFBZ0IzVCxJQUFJLGVBQ3JCMlQsUUFBUTNULElBRTFCOzs7U0FHQSxJQUFVLElBQUZBLElBQU9BLElBQUkyVCxlQUFnQjNULElBQUksZ0JBQ3BCMlQsUUFBUTNULElBRTNCOztTQUVBLElBQVUsSUFBRkEsSUFBT0EsSUFBSTJULGVBQWdCM1QsSUFBSSxnQkFDcEIyVCxRQUFRM1QsSUFFM0I7OztTQUdBO1NBQ0EsSUFBVSxJQUFGQSxJQUFPQSxJQUFJMlQsZUFBZ0IzVCxJQUFJLGdCQUNwQjJULFFBQVEzVDtTQUUzQjs7U0FFQSxJQUFVLElBQUZBLElBQU9BLElBQUkyVCxtQkFBb0IzVDtVQUFJLENBQ3pDLElBQUkrRSxFQUFJLG9CQUFvQixPQUFPL0U7V0FDbkMsSUFBVyxJQUFGbUYsSUFBT0EsTUFBT0EsSUFBSyxlQUFpQkosRUFBRUk7U0FFakQ7O1NBRUEsSUFBVSxJQUFGbkYsSUFBT0EsSUFBSTJULGVBQWdCM1Q7VUFBSSxDQUNyQyxJQUFJK0UsRUFBSSxvQkFBb0IseUJBQXlCLE9BQU8vRTtXQUM1RCxJQUFXLElBQUZtRixJQUFPQSxNQUFPQSxJQUFLLGVBQWlCSixFQUFFSTtTQUVqRDs7U0FFQSxJQUFVLElBQUZuRixJQUFPQSxJQUFJMlQsZUFBZ0IzVDtVQUFJLENBQ3JDLElBQUkrRSxFQUFJLHlCQUF5QixPQUFPL0UsSUFDeEMsZ0JBQWlCK0U7U0FFbkI7O1NBRUEsSUFBVSxJQUFGL0UsSUFBT0EsSUFBSTJULG1CQUFvQjNUO1VBQUksQ0FDekMsSUFBSW1GLEVBQUksT0FBT25GO1dBQ2YsZ0JBQWlCLHlCQUF5Qm1GO1dBQzFDLGdCQUFpQix5QkFBeUJBO1NBRTVDOztTQUVBLElBQVUsSUFBRm5GLElBQU9BLElBQUkyVCxtQkFBb0IzVDtVQUFJLENBQ3pDO1lBQVksUUFBRSxPQUFPQTtZQUNmLEVBQUUsb0JBQW9CLHlCQUF5QjRYO1dBQ3JELElBQVcsSUFBRnpTLElBQU9BLE1BQU9BLElBQUssZUFBaUJKLEVBQUVJO1dBRi9DLElBR0lKLEVBQUksb0JBQW9CLHlCQUF5QjZTO1dBQ3JELElBQVcsSUFBRnpTLElBQU9BLE1BQU9BLElBQUssZUFBaUJKLEVBQUVJO1NBRWpEOztNQUVGd1MsYUFBYWhFO01BQ2JnRSxhQUFhaEUsbUJBQ2Y7SUE5bkJBLFNBQVNrRSw2QkFBNkJDO01BQ3BDLE9BQU9BLDZCQUNtQixpQkFDakIsU0FFWDtJQUtBLFNBQVNDLHNCQUFzQkQsS0FBTUU7TUFDbkMsSUFBTSxFQUFFdmIsV0FDSndiO01BQ0osT0FBT0g7ZUFDRUcsT0FBT3BLLGVBQWdCO2VBQ3ZCb0ssT0FBT3BLLGVBQWdCO2VBQ3ZCb0ssT0FBT3BLLFlBQWE7ZUFDcEJvSyxPQUFPcEssYUFBYztlQUNyQm9LLE9BQU9wSyxhQUFjO2VBQ3JCb0ssT0FBT3BLLGNBQWU7ZUFDdEJvSyxPQUFPcEssYUFBYztlQUNyQm9LLE9BQU9wSyxhQUFjO2VBQ3JCb0ssT0FBT3BLLGFBQWM7ZUFDckJvSyxPQUFPcEssYUFBYztnQkFDckJvSyxPQUFPcEssZUFBZ0I7Z0JBQ3ZCb0ssT0FBT3BLLGVBQWdCO2dCQUN2Qm9LLE9BQU9wSyxhQUFjOztNQUU5QixLQUFLb0ssS0FBTTtNQWpCWCxJQWtCSUMsU0FBV0QsS0FBS0QsT0FBTyw2QkFBNkJGO01BQ3hELE9BQU9JLElBQ1Q7SWZtR0EsU0FBU0MseUJBQTBCL1Y7TUFDakMsSUFBSTZVLFlBQWF4YTtNQUNqQndhLFlBQVk3VTtNQURaLElBRUk0VSxjQUFldmEseUJBQXdCd2E7TUFDM0MsT0FBT0QsV0FDVDtJQXJEQSxTQUFTb0IseUJBQTBCaFc7TUFDakMsSUFBTyxHQUFFQSxLQUNGLEdBQUVBLEtBQ0YsR0FBRUEsS0FDRCxLQUFHME07TUFDWCxHQUFJcUk7T0FBYSxRQUNWdkksS0FBR0MsS0FBSUMsZUFDRkEsY0FBZWdJLFNBQVVBLFNBRTFCdUI7TUFSWCxJQVVNLEVBQUUsaUJBQ0EsS0FBR3pKLEtBQUd3SSxJQUFFdkksTUFBSXVJLEtBQUd0STtNQUN2QixHQUFJcUk7T0FBUyxDQUNYMVUsVUFDQUEsT0FBTyxXQUFXMFU7O09BRWxCMVUsT0FBTztNQUNULEdBQUlxTSxZQUFhck0sUUFBUUE7TUFDekIsT0FBT0EsR0FDVDtJZWxIQSxTQUFTNlYsaUJBQWlCQztNQUN4QixJQUFXLE9BQUVBLFlBQ0o7TUFDVCxJQUFXLElBQUZ2WSxJQUFPQSxJQUFJd1ksT0FBUXhZO09BQUssQ0FDL0IsR0FBSXVZLEtBQUt2WTtTQUNQO1FBQ0ZnWSxPQUFPQSxPQUFPTyxLQUFLdlk7TUFFckIsT0FBT2dZLElBQ1Q7SUh1VEEsU0FBU1Msd0JBQXdCN0osR0FBSUU7TUFDbkM7Y0FBV0g7ZUFDVEM7ZUFDRUEsb0JBQXVCRTtlQUN4QkEsbUJBQ0w7SUFLQSxTQUFTNEosZ0JBQWdCcFcsR0FBSSxPQUFPLFFBQVM7SUFIN0MsU0FBU3FXLGdCQUFnQnJXLEdBQUksT0FBTyxRQUFTO0lHcFI3QyxJQUFJc1c7SUFLSixTQUFTQyxZQUFhZixLQUFNZ0IsT0FBUVAsS0FBTWhPO01BRXhDN04sWUFBY29iO01BQ2RwYixjQUFjb2M7TUFDZHBjLFlBQWM2YjtNQUNkN2IsWUFBWTZOLE1BQ2Q7SUFFQXNPLG9DQUFvQ0Q7SUFFcENDOzthQUF5Q0U7TUFDdkMsSUFBSW5GO01BQ0osVUFBVW1GLGlCQUFrQkEsT0FBT0E7TUFDbkMsTUFBT0EsZUFBZXJXO09BQVE7TUFDOUIsR0FBSWhHLG9CQUFvQnFjO09BQ3RCO01BQ0YsR0FBR3JjO09BQWlDLElBQ3ZCLElBQUZzRCxJQUFPQSxJQUFJdEQsaUJBQWtCc0Q7UUFBSyxDQUN6QyxHQUFJK1ksSUFBSS9ZLFVBQVUrWSxJQUFJL1ksTUFBTXRELFVBQVVzRCxHQUNwQztTQUNGNFQsTUFBT0EsTUFBTWxYLFVBQVVzRCxLQUFNK1ksSUFBSS9ZOztPQUU5QixJQUNNLElBQUZBLEVBQUl0RCxxQkFBc0JzRCxPQUFRQTtRQUFLLENBQzlDLEdBQUkrWSxJQUFJL1ksVUFBVStZLElBQUkvWSxLQUFLdEQsVUFBVXNELEdBQUc7U0FHeEM0VCxNQUFPQSxNQUFNbFgsVUFBVXNELE1BQU8rWSxJQUFJL1k7TUFHdEMsT0FBTzRULEdBcEJzQjtJQXVCL0JpRjs7YUFBc0NqRjtNQUNwQyxPQUFPbFg7O1NBR0wsSUFBTSxFQUFFQSxVQUFVa1gsYUFDWixFQUFFbFgsVUFBVWtYO1NBQ2xCLE9BQU8sd0JBQXdCMU8sRUFBRThKOzs7U0FHakMsSUFBTSxFQUFFdFMsVUFBVWtYLGFBQ1osRUFBRWxYLFVBQVVrWDtTQUNsQixZQUFhdE8sRUFBR3RGO2dCQUVoQixPQUFPdEQsVUFBVWtYLEtBYk87SUFpQjVCaUY7O2FBQXNDakYsSUFBSXRSO01BQ3hDLE9BQU81Rjs7U0FHTEEsVUFBVWtYLGVBQWUsZ0JBQWdCdFI7U0FDekM1RixVQUFVa1gsZUFBZSxnQkFBZ0J0UjtTQUN6Qzs7O1NBR0E1RixVQUFVa1gsZUFBZXRSLEtBQ3pCNUYsVUFBVWtYLGVBQWV0UixLQUN6QjtnQkFFQTVGLFVBQVVrWCxPQUFPdFIsRUFDakI7TUFFRixRQWhCMEI7SUFvQjVCdVc7O2FBQXVDdlc7TUFDckMsT0FBTzVGOztTQUdMLElBQU0sRUFBRSxnQkFBZ0I0RixHQUNsQixFQUFFLGdCQUFnQkE7U0FDeEIsR0FBR2tELEtBQUtUO1VBQUUsZUFDT1M7O1VBRVosSUFDTyxJQUFGeEYsSUFBT0EsSUFBRXRELGlCQUFrQnNELElBQUksVUFDM0JBLEtBQU1BLFdBQVl3RixFQUFJVDtTQUdwQzs7O1NBR0EsSUFBTyxHQUFFekMsS0FDRixHQUFFQTtTQUNULEdBQUcwVyxNQUFNQztVQUFHLGVBQ0tEOztVQUVaLElBQ08sSUFBRmhaLElBQU9BLElBQUV0RCxpQkFBa0JzRDtXQUFJLFVBQzNCQSxLQUFNQSxXQUFZZ1osR0FBS0M7U0FHckM7Z0JBRUEsZUFBZTNXLEdBQ2YsTUE5QnlCO0lBbUM3QnVXOzthQUEwQzlULEVBQUdtVTtNQUMzQyxHQUFJeGMsZUFBZXFJLFlBQVlySSxhQUFhcUk7T0FBUSxDQUNsRCxJQUFPLEdBQUVySSxZQUFhQSxpQkFDZixHQUFLcUksU0FBVUE7UUFDdEIsT0FBT3FVLEtBQUtEO01BRWQsR0FBSXpjLG9CQUFvQnFJO09BQWUsT0FDOUJBLGdCQUFnQnJJO01BRXpCLElBQVcsSUFBRnNELElBQU9BLElBQUl0RCxpQkFBa0JzRDtPQUNwQyxHQUFJdEQsVUFBVXNELE1BQU0rRSxPQUFPL0UsR0FDekIsT0FBUXRELFVBQVVzRCxLQUFLK0UsT0FBTy9FO01BQ2xDLE9BQVF0RDs7Ozs7U0FNTixJQUFJMEYsRUFBRzVCO1NBQ1AsSUFBVyxJQUFGUixJQUFPQSxJQUFJdEQsaUJBQWtCc0Q7VUFBSyxDQUN6Q29DLElBQUkxRixVQUFVc0Q7V0FDZFEsSUFBSXVFLE9BQU8vRTtXQUNYLEdBQUlvQyxJQUFJNUIsRUFDTjtXQUNGLEdBQUk0QixJQUFJNUIsRUFDTjtXQUNGLEdBQUk0QixLQUFLNUI7WUFBRyxDQUNWLEtBQUswWSxNQUFPLE9BQU9iLElBQ25CLEdBQUlqVyxLQUFLQSxFQUFHLFNBQ1osR0FBSTVCLEtBQUtBLEVBQUc7U0FHaEI7O1NBR0EsSUFBVyxJQUFGUixJQUFPQSxJQUFJdEQsaUJBQWtCc0Q7VUFBTSxDQUUxQyxHQUFJdEQsVUFBVXNELFNBQU8rRSxPQUFPL0UsT0FDMUI7V0FDRixHQUFJdEQsVUFBVXNELFNBQU8rRSxPQUFPL0UsT0FDMUI7V0FDRixHQUFLdEQsVUFBVXNELFdBQWErRSxPQUFPL0UsU0FDakM7V0FDRixHQUFLdEQsVUFBVXNELFdBQWErRSxPQUFPL0UsU0FDakM7U0FFSjs7Ozs7Ozs7O1NBU0EsSUFBVyxJQUFGQSxJQUFPQSxJQUFJdEQsaUJBQWtCc0Q7VUFBSyxDQUN6QyxHQUFJdEQsVUFBVXNELEtBQUsrRSxPQUFPL0UsR0FDeEI7V0FDRixHQUFJdEQsVUFBVXNELEtBQUsrRSxPQUFPL0UsR0FDeEI7U0FFSjs7TUFFRixRQS9EOEI7SUFvRWhDLFNBQVNxWixrQkFBa0J2QixLQUFNZ0IsT0FBUVAsS0FBTWhPO01BQzdDN04sWUFBY29iO01BQ2RwYixjQUFjb2M7TUFDZHBjLFlBQWM2YjtNQUNkN2IsWUFBYzZOLE1BQ2hCO0lBRUE4TyxrQ0FBa0NSO0lBQ2xDUTs7YUFBK0NOO01BQzdDLFVBQVVBO09BQWlCLEdBQ3JCQSxlQUFlclcsU0FBVXFXO1FBQzNCQSxNQUFNQTs7UUFDSDtNQUVQLEdBQUlBLFdBQVdBLE9BQU9yYyxhQUNwQjtNQUNGLE9BQU9xYyxHQVI0QjtJQVdyQ00sMkNBQTRDekYsS0FDMUMsT0FBT2xYLFVBQVVrWCxJQURlO0lBSWxDeUY7O2FBQTRDekYsSUFBSXRSLEdBQzlDNUYsVUFBVWtYLE9BQU90UixFQUNqQixRQUZnQztJQUtsQytXOzthQUE2Qy9XLEdBQzNDLGVBQWVBLEdBQ2YsUUFGaUM7SUFhbkMsU0FBU2dYLHNCQUFzQnhCLEtBQU1nQixPQUFRUCxLQUFNTDtNQUNqRCxJQUFJcUIsaUJBQW1CLDZCQUE2QnpCO01BQ3BELEdBQUcsaUJBQWlCUyxRQUFRZ0Isb0JBQW9CckI7T0FBYTtNQUc3RCxHQUFHWSxlQUNBUCxvQkFDQWdCO09BQ0QsV0FBV0Ysa0JBQWtCdkIsS0FBTWdCLE9BQVFQLEtBQU1MO01BQ25ELFdBQVdXLFlBQVlmLEtBQU1nQixPQUFRUCxLQUFNTCxLQUU3QztJQXlYQSxTQUFTc0Isb0JBQW9CQyxPQUFROUIsR0FBSS9aO01BQ3ZDLElBQUk4YixTQUFXO01BQ2YsR0FBSUEsZ0JBQWdCQTtPQUNsQjtNQUZGLElBR1EsSUFBRSxpQkFDRCxLQUFFM1QsV0FDQSxPQUFHQSxhQUNMO01BQ1QsR0FBR25JO09BQ0QsSUFBVyxJQUFGb0MsSUFBT0EsSUFBSTBaLFNBQVUxWjtRQUFLLENBQ2pDLElBQUkyWixTQUFXO1NBQ2YsR0FBR0E7VUFBbUIsQ0FDcEIsSUFBZ0IsWUFBRSxpQkFDRixZQUFFO1dBQ2xCLEdBQUdDO1lBQ0Q7V0FDRkQsV0FBV0U7U0FFYixVQUFVRjs7T0FHWixJQUFXLElBQUYzWixJQUFPQSxJQUFJMFosU0FBVTFaLElBQUssVUFBVTtNQXBCL0M7T0FxQlMsS0FBRSxpQkFBaUJ1WTtPQUNuQixLQUFFLHNCQUFzQlQsS0FBTUU7T0FDaEMsR0FBRSxzQkFBc0JGLEtBQU1nQixPQUFRUCxLQUFNTDtNQUNuRCxPQUFPSjtlQUVMLElBQVUsSUFBRjlYLElBQU9BLElBQUlnWSxLQUFNaFksSUFBSSxLQUN0QkEsS0FBSyxnQkFFWjs7Z0JBR0EsSUFBVSxJQUFGQSxJQUFPQSxJQUFJZ1ksS0FBTWhZLElBQUksS0FDdEJBLEtBQUssZ0JBRVo7ZUFFQSxJQUFVLElBQUZBLElBQU9BLElBQUlnWSxLQUFNaFksSUFBSSxLQUN0QkEsS0FBSyxpQkFFWjtlQUVBLElBQVUsSUFBRkEsSUFBT0EsSUFBSWdZLEtBQU1oWSxJQUFJLEtBQ3RCQSxLQUFLLGlCQUVaO2VBRUEsSUFBVSxJQUFGQSxJQUFPQSxJQUFJZ1ksS0FBTWhZLElBQUksS0FDdEJBLEtBQUssaUJBRVo7OztTQUdBLElBQUk4WixNQUFRO1NBQ1osR0FBR0E7VUFBTzs7U0FDVixJQUFVLElBQUY5WixJQUFPQSxJQUFJZ1ksS0FBTWhZLElBQUksS0FDdEJBLEtBQUs7U0FFWjs7U0FFQSxJQUFJZ0YsTUFBUXRDO1NBQ1osSUFBVSxJQUFGMUMsSUFBT0EsSUFBSWdZLEtBQU1oWTtVQUFJLENBQzNCLElBQVcsSUFBRm1GLElBQU1BLE1BQU1BLElBQUtILEVBQUVHLEtBQUs7V0FDakMsSUFBSTRVLE1BQVEsb0JBQW9CL1U7V0FDaEMsT0FBT2hGLEVBQUUrWjtTQUVYOztTQUVBLElBQUkvVSxNQUFRdEM7U0FDWixJQUFVLElBQUYxQyxJQUFPQSxJQUFJZ1ksS0FBTWhZO1VBQUksQ0FDM0IsSUFBVyxJQUFGbUYsSUFBTUEsTUFBTUEsSUFBS0gsRUFBRUcsS0FBSztXQUNqQyxJQUFJTSxFQUFJLHlCQUF5QixvQkFBb0JUO1dBQ3JELE9BQU9oRixFQUFFeUY7U0FFWDs7U0FFQSxJQUFVLElBQUZ6RixJQUFPQSxJQUFJZ1ksS0FBTWhZO1VBQUksQ0FDM0IsSUFBSXlGLEVBQUkseUJBQXlCLGtCQUNqQyxPQUFPekYsRUFBRXlGO1NBRVg7O1NBRUEsSUFBVSxJQUFGekYsSUFBT0EsSUFBSWdZLEtBQU1oWTtVQUFJLENBQzNCO1lBQU8sR0FBRSx5QkFBeUI7WUFDM0IsR0FBRSx5QkFBeUI7V0FDbEMsT0FBT0EsT0FBT2laLEdBQUdEO1NBRW5COztTQUVBLElBQUloVSxNQUFRdEM7U0FDWixJQUFVLElBQUYxQyxJQUFPQSxJQUFJZ1ksS0FBTWhZO1VBQUksQ0FDM0IsSUFBVyxJQUFGbUYsSUFBTUEsTUFBTUEsSUFBS0gsRUFBRUcsS0FBSztXQUNqQyxJQUFJOFQsR0FBSyx5QkFBeUIsb0JBQW9CalU7V0FDdEQsSUFBVyxJQUFGRyxJQUFNQSxNQUFNQSxJQUFLSCxFQUFFRyxLQUFLO1dBRGpDLElBRUk2VCxHQUFLLHlCQUF5QixvQkFBb0JoVTtXQUN0RCxPQUFPaEYsT0FBT2laLEdBQUdEO1NBRW5COztNQUVGckIsYUFBYStCO01BQ2IsT0FBTyxzQkFBc0I1QixLQUFNZ0IsT0FBUVAsS0FBTUwsS0FDbkQ7SUFqZkEsU0FBUzhCLGdCQUFnQnhVLEVBQUVULEVBQUVtVSxPQUMzQixPQUFPLFVBQVVuVSxFQUFFbVUsTUFDckI7SUsxTEEsU0FBU2Usb0JBQXFCakwsRUFBRzFNO01BQy9CME0sSUFBSSxrQkFBa0JBLEVBQUcsZ0JBQWdCMU07TUFDekMwTSxJQUFJLGtCQUFrQkEsRUFBRyxnQkFBZ0IxTTtNQUN6QyxPQUFPME0sQ0FDVDtJQVZBLFNBQVNrTCxvQkFBcUJsTCxFQUFHbUw7TUFDL0IsT0FBTyxvQkFBb0JuTCxFQUFHLHlCQUEwQm1MLElBQzFEO0lMMnJCQSxTQUFTQyxhQUFhekc7TUFDcEIsSUFBYSxTQUFFLGlCQUFpQkEsU0FDMUI7TUFDTixPQUFPQTs7OztTQUlMLEdBQUcwRyxlQUFnQkE7U0FDbkIsSUFBTSxJQUFPO1NBQ2IsSUFBSXJhLE1BQU9BLFNBQVMyVCxlQUFnQjNUO1VBQUssQ0FDdkNzYTs7V0FBSTNHLFFBQVEzVDs7V0FBUTJULFFBQVEzVDs7OztXQUFjMlQsUUFBUTNUOzs7O1dBQWUyVCxRQUFRM1Q7OztXQUN6RWdQLElBQUksa0JBQWtCQSxFQUFFc0w7U0FFMUJBO1NBQ0EsT0FBUUQ7a0JBQ0FDLElBQUszRyxRQUFRM1Q7a0JBQ2JzYSxLQUFLM0csUUFBUTNUO2tCQUNic2EsS0FBSzNHLFFBQVEzVCxPQUNuQmdQLElBQUksa0JBQWtCQSxFQUFHc0w7O1NBRTNCOzs7U0FHQSxHQUFHRCxlQUFnQkE7U0FDbkIsSUFBTSxJQUFPO1NBQ2IsSUFBSXJhLE1BQU9BLFNBQVMyVCxlQUFnQjNUO1VBQUssQ0FDdkNzYSxJQUFJM0csUUFBUTNULFNBQVEyVCxRQUFRM1Q7V0FDNUJnUCxJQUFJLGtCQUFrQkEsRUFBRXNMO1NBRTFCLElBQUtELG1CQUNIckwsSUFBSSxrQkFBa0JBLEVBQUcyRSxRQUFRM1Q7U0FDbkM7O1NBRUEsR0FBSXFhLGNBQWVBO1NBQ25CLElBQVcsSUFBRnJhLElBQU9BLElBQUlxYSxTQUFVcmEsSUFBS2dQLElBQUksa0JBQWtCQSxFQUFHMkUsUUFBUTNUO1NBQ3BFOzs7U0FHQSxHQUFJcWEsY0FBZUE7U0FDbkIsSUFBVyxJQUFGcmEsSUFBT0EsSUFBSXFhLFNBQVVyYSxJQUFLZ1AsSUFBSSxrQkFBa0JBLEVBQUcyRSxRQUFRM1Q7U0FDcEU7O1NBRUEsR0FBSXFhLGNBQWVBO1NBQ25CQTtTQUNBLElBQVcsSUFBRnJhLElBQU9BLElBQUlxYSxTQUFVcmEsSUFBSyxJQUM3QixrQkFBa0JnUCxFQUFHMkUsUUFBUTNUO1NBRW5DO2dCQUVBcWE7O1NBRUEsR0FBSUEsY0FBZUE7U0FDbkIsSUFBVyxJQUFGcmEsSUFBT0EsSUFBSXFhLFNBQVVyYSxJQUFLZ1AsSUFBSSxvQkFBb0JBLEVBQUcyRSxRQUFRM1Q7U0FDdEU7Z0JBRUFxYTs7U0FFQSxHQUFJQSxjQUFlQTtTQUNuQixJQUFXLElBQUZyYSxJQUFPQSxJQUFJcWEsU0FBVXJhLElBQUtnUCxJQUFJLG9CQUFvQkEsRUFBRzJFLFFBQVEzVDtTQUN0RTs7TUFFRixPQUFPZ1AsQ0FDVDtJSmxzQkEsU0FBU3VMLHFCQUFxQmQsT0FBUXpCO01BQ3BDQSxZQUNBLE9BQU8sZ0JBQ1Q7SUFJQSxTQUFTd0MseUJBQXlCZixPQUFRekI7TUFDeEMsT0FBUTtlQUVOQSxZQUNBLE9BQU87ZUFFUDtnQkFDTyx3REFFWDtJQWhDQSxTQUFTeUMscUJBQXFCaEIsT0FBUXpCO01BQ3BDLElBQUloVCxNQUFRdEM7TUFDWixJQUFXLElBQUZ5QyxJQUFNQSxNQUFNQSxJQUFLSCxFQUFFRyxLQUFLO01BQ2pDNlM7TUFDQSxPQUFPLG9CQUFxQmhULEVBQzlCO0lBSUEsU0FBUzBWLG1CQUFtQmhELE9BQVFwVixFQUFHcVk7TUFDckMsSUFBSTVWLEVBQUksb0JBQXFCekM7TUFDN0IsSUFBVyxJQUFGdEMsSUFBT0EsTUFBT0EsSUFBSyxlQUFpQitFLEVBQUUvRTtNQUMvQzJhO01BQWNBLFlBQ2hCO0lDMERBLFNBQVNDLG1CQUFtQnhZLEVBQUU1QixFQUFHMFksT0FBUyxPQUFPLFVBQVUxWSxFQUFHO0lBOEo5RCxTQUFTcWEsZ0JBQWdCdlksR0FDdkIsT0FBUSxXQUFhLFFBQ3ZCO0lEak1BO0tBQUl3WTs7b0JBRWdCTDtrQkFDREM7O2dCQUVIRTthQUNIQzt5QkFHUU47eUJBSUFDOzs7aUJBSVdmLE9BQVE5QixJQUFLLE9BQU8sb0JBQXFCOEIsT0FBTzlCLGVBQTFEO2tCQUNIRjtnQkFDRnVDO2FBQ0pJOzs7aUJBR21CWCxPQUFROUIsSUFBSyxPQUFPLG9CQUFxQjhCLE9BQU85QixlQUExRDtrQkFDSEY7Z0JBQ0Z1QzthQUNKSTtJYXpLYixTQUFTVyw0QkFBNEJ2VjtNQUNuQyxPQUFPc1YsZ0JBQWdCdFY7O2FBQWtCc1YsZ0JBQWdCdFYsc0JBQzNEO0lBSUEsU0FBU3dWLCtCQUErQkMsSUFBS0MsT0FBUUMsS0FBTWpDO01BQ3pELElBQUl2VSxLQUFPLDRCQUE0QnVXO01BQ3ZDLEdBQUd2VztPQUFNLENBQ1AsSUFBSXZDLEVBQUsrWSxTQUFVLEtBQUtELE9BQU9ELElBQUkvQixPQUFPLEtBQUsrQixJQUFJQyxPQUFPaEM7UUFDMUQsR0FBR0EsU0FBUzlXLEtBQUtBLEVBQUcsT0FBTytZO1FBQzNCLEtBQUkvWSxPQUFNQSxFQUFHLFNBQVFBO1FBQ3JCLElBQUlBLFlBQWEsT0FBUUE7TUFFM0IsT0FBTytZLElBQ1Q7SUF0Q0EsU0FBU0MscUJBQXFCNVY7TUFDNUIsVUFBV0E7T0FBZ0I7O09BQ3RCLEdBQUksaUJBQWlCQTtRQUFJOztRQUN6QixHQUFJLGtCQUFrQkE7U0FBSTs7U0FDMUIsR0FBSUEsYUFBYTlDLFNBQVM4QyxTQUFVQSxjQUFhQTtVQUFhLENBRWpFLElBQUlPLElBQU1QLFNBR1YsT0FBUU8sYUFBY0E7O1VBRW5CLEdBQUlQLGFBQWE5RTtXQUFROztXQUN6QixVQUFXOEU7WUFBZTs7WUFDMUIsR0FBSUEsYUFBYTZWO2FBQVE7O2FBQ3pCLEdBQUk3VixLQUFLQTtjQUFlOztjQUN4QixHQUFJQSxLQUFLQTtlQUFXOztlQUNwQixVQUFXQTtnQkFBaUI7O2dCQUM1QixVQUFXQSxjQUFlO01BQy9CLFdBQ0Y7SUFxTUEsU0FBUzhWLGlCQUFrQjlWLEVBQUdUO01BQzVCLEdBQUlTLElBQUlULEVBQUcsV0FBYSxHQUFJUyxLQUFLVCxFQUFHLFNBQVUsUUFDaEQ7SXZCNFJBLFNBQVN3VyxtQkFBbUJyVCxHQUFJRTtNQUM3QkYsWUFBYSw2QkFBNkJBO01BQzFDRSxZQUFhLDZCQUE2QkE7TUFDM0MsT0FBUUYsT0FBT0UsU0FBVUYsT0FBT0UsUUFDbEM7SUFpUEEsU0FBU29ULG9CQUFvQnRULEdBQUlFLElBQy9CLE9BQU8sbUJBQW1CRixHQUFHRSxHQUMvQjtJdUJoc0JBLFNBQVNxVCxpQkFBa0JqVyxFQUFHVCxFQUFHbVU7TUFDL0IsSUFBSXdDO01BQ0o7T0FBUSxDQUNOLE1BQU14QyxTQUFTMVQsTUFBTVQ7U0FBSSxDQUN2QixJQUFJNFcsTUFBUSxxQkFBcUJuVztVQUVqQyxHQUFHbVcsYUFBYyxDQUFFblcsSUFBSUEsS0FBTTtVQUY3QixJQUlJb1csTUFBUSxxQkFBcUI3VztVQUVqQyxHQUFHNlcsYUFBYyxDQUFFN1csSUFBSUEsS0FBTTtVQUc3QixHQUFHNFcsVUFBVUM7V0FBTyxDQUNsQixHQUFHRDthQUFlLENBQ2hCLEdBQUdDO2VBQWUsT0FDVCwrQkFBK0JwVyxFQUFHVCxNQUFPbVU7Y0FFbEQ7WUFFRixHQUFHMEM7YUFBZSxDQUNoQixHQUFHRDtlQUFlLE9BQ1QsK0JBQStCNVcsRUFBR1MsSUFBTTBUO2NBRWpEO1lBRUYsT0FBUXlDLFFBQVFDO1VBRWxCLE9BQU9EO3FCQUlMLG1EQUNBOzthQUVBLElBQUl2WixFQUFJLGlCQUFpQm9ELEtBQU1ULE1BQy9CLEdBQUkzQyxPQUFRLE9BQVFBLE1BQ3BCO3FCQUdBLG1EQUNBOzthQUdBOzthQUNBO3FCQUVBLCtDQUNBOzthQUVBLEdBQUlvRCxNQUFNVCxFQUFHLENBQ1gsSUFBSTNDLEVBQUksbUJBQW1Cb0QsRUFBR1QsR0FDOUIsR0FBSTNDLE9BQVEsT0FBUUE7YUFFdEI7O2FBR0E7YUFDQTs7YUFHQTs7YUFDQTs7YUFFQTthQUNBOzthQUVBLG1EQUNBOzthQUVBLElBQUl1QyxLQUFPLDRCQUE0QmE7YUFDdkMsR0FBR2IsUUFBUSw0QkFBNEJJO2NBQUcsT0FDaENTLGdCQUFjVDthQUV4QixLQUFJSixLQUNGO2FBTEYsSUFNSXZDLEVBQUksS0FBS29ELEVBQUVULEVBQUVtVTthQUNqQixHQUFHOVcsS0FBS0EsRUFBRSxPQUNEOFcsVUFBUzlXO2FBRWxCLEdBQUdBLE9BQU9BLE9BQUs7YUFHZixHQUFJQSxPQUFRLE9BQVFBO2FBQ3BCOzthQUVBLElBQUlBLEVBQUksVUFBVTJDLEVBQUVtVTthQUNwQixHQUFHOVcsS0FBS0EsRUFBRyxPQUNGOFcsVUFBUzlXO2FBRWxCLEdBQUdBLE9BQU9BLE9BQUs7YUFHZixHQUFJQSxPQUFRLE9BQVFBO2FBQ3BCOzthQUVBb0QsTUFBS0E7YUFDTFQsTUFBS0E7YUFDTCxHQUFJUyxJQUFJVCxFQUFHO2FBQ1gsR0FBSVMsSUFBSVQsRUFBRzthQUNYLEdBQUlTLEtBQUtUO2NBQUcsQ0FDVixLQUFLbVUsTUFBTyxPQUFPYixJQUNuQixHQUFJN1MsS0FBS0EsRUFBRyxTQUNaLEdBQUlULEtBQUtBLEVBQUc7YUFFZDs7YUFlQSxHQUFJUyxJQUFJVCxFQUFHO2FBQ1gsR0FBSVMsSUFBSVQsRUFBRzthQUNYLEdBQUlTLEtBQUtUO2NBQUcsQ0FDVixLQUFLbVUsTUFBTyxPQUFPYixJQUNuQixHQUFJN1MsS0FBS0EsRUFBRyxTQUNaLEdBQUlULEtBQUtBLEVBQUc7YUFFZDtzQkFFQSxHQUFHUyxNQUFNVCxFQUFHLENBQ1YsS0FBS21VLE1BQU8sT0FBT2IsSUFDbkIsU0FFRjs7YUFFQSxJQUFNLEVBQUUsdUJBQXVCN1MsR0FDekIsRUFBRSx1QkFBdUJUO2FBQy9CLEdBQUdTLE1BQU1ULEVBQUcsQ0FDVixHQUFHUyxJQUFJVCxFQUFHLFdBQ1YsR0FBR1MsSUFBSVQsRUFBRzthQUVaOzthQUVBLElBQU0sRUFBRSxhQUNGLEVBQUU7YUFDUixHQUFHUyxNQUFNVCxFQUFHLENBQ1YsR0FBR1MsSUFBSVQsRUFBRyxXQUNWLEdBQUdTLElBQUlULEVBQUc7YUFFWjs7OzthQUlBLEdBQUlTLFlBQVlULFNBQVUsT0FBUVMsV0FBV1Q7YUFDN0MsR0FBSVMsYUFBYyxXQUFXQSxFQUFHVDthQUNoQztRQUdKLEdBQUkyVyxrQkFBbUI7UUFDdkIsSUFBSTFiLEVBQUk7UUFDUitFLElBQUk7UUFDSlMsSUFBSTtRQUNKLEdBQUl4RixRQUFRd0YsU0FBVSxXQUFXQSxFQUFHVCxFQUFHL0U7UUFDdkN3RixJQUFJQSxFQUFFeEY7UUFDTitFLElBQUlBLEVBQUUvRSxHQUVWO0lBbUJBLFNBQVM2YixpQkFBa0J6WixFQUFHNUIsR0FBSyxVQUFTLGlCQUFpQjRCLEVBQUU1QixhQUFlO0laUzlFLFNBQVNzYixlQUFnQjFaLEVBQUc1QixHQUFLLE9BQU8sTUFBTUEsRUFBRztJYTNOakQsU0FBU3ViLHNCQUFzQnJZO01BQzdCLElBQUlzWTtNQUNKLEdBQUcsUUFBUUE7T0FDWCxDQUNFLElBQUlDLElBQVUsS0FBRTtRQUNoQkMsaUJBQWdCeFk7UUFDaEJ1WSxNQUFLQyxvQkFBb0JBO1FBQ3pCQSxPQUFLeGQ7UUFDTCxPQUFPdWQ7O09BRUosa0NBQytCdlksRUFFdEM7SVZrYkEsU0FBUzBZLGNBQWN6SSxHQUFJakMsR0FBSXZKLEdBQUk3RixHQUNqQyxPQUFPLFdBQVdvUCxHQUFHdkosS0FBTTdGLEdBQzNCLFFBQ0Y7SWhCNUZBO0tBQUkrWjtNQUFpQ3JhO0lvQnRFckMsU0FBU3NhLG9CQUFxQjVZLEdBQUksT0FBTyxLQUFLLHdCQUF3QkEsR0FBSTtJVGtFMUUsU0FBUzZZLGNBQWM3RSxPQUFRN0IsSUFBSzhCO01BQ2xDLElBQUluVixJQUFNcVQ7TUFDVixnQkFBaUJyVDtNQUNqQixJQUFVLElBQUZ4QyxJQUFPQSxJQUFJd0MsSUFBS3hDLElBQUksZ0JBQ1Q2VixTQUFTN1Y7TUFFNUIyWCxRQUFRblY7TUFDUm1WLFFBQVFuVixPQUNWO0lXalhBLFNBQVNnYSxpQkFBaUJDLFVBQ3hCLFFBQ0Y7SXRCNm1CdUIsU0FBbkJDLG1CQUErQnRhO01BQy9CLElBQUlLLElBQU0sOEJBQThCTDtNQUN4QyxpQkFBaUJLO01BQ2pCLE9BQU9BLEdBSGM7SUFpYlAsU0FBZGthLGNBQTBCM1g7TUFDMUIsT0FBTywyQkFBMkIseUJBQXlCQSxHQUQzQztJU3JpQ3BCLFNBQVM0WCxjQUFldFc7TUFDdEIsSUFBSXVILEVBQUlwUjtNQUNSLEdBQUdvUixPQUFRLE9BQU92SDtNQUVsQixHQUFHdUgsYUFBYUEsZUFDZCxlQUFldkg7TUFDakIsd0RBQ0Y7SWtCK0RBLElBQUl1VyxxQkFBdUJuYTtJQTJEM0IsU0FBU29hLHdCQUF3QkM7TUFDL0IsSUFBSUMsS0FBT0gsaUJBQWlCRSxRQUM1QixPQUFPQyxPQUNUO0kzQmc3QjRCLFNBQXhCQyx3QkFBb0NDO01BQ3BDLElBQUl6YSxPQUFVeWEsU0FBVUEsVUFDeEIsWUFDQSxPQUFPemEsR0FIbUI7SUFjRCxTQUF6QjBhLHlCQUFxQ0M7TUFDckM7T0FBSTNhOztTQUNBLHdCQUF3QjJhO1NBQ3hCLHdCQUF3QkE7U0FDeEIsd0JBQXdCQTtTQUN4Qix3QkFBd0JBO1NBQ3hCLHdCQUF3QkE7U0FDeEIsd0JBQXdCQTtTQUN4Qix3QkFBd0JBO01BQzVCO01BQ0EsT0FBTzNhLEdBVm9CO0lBdnFCYSxTQUF4QzRhLHdDQUFvRC9hLEVBQUdnYjtNQUN2RDtPQUFRLElBQUVoYjtPQUNLLFdBQUVFLE1BQU04YTtPQUNmLFFBQU01YSxNQUFNNmE7TUFDcEI5YTtNQUNBLFFBQVcsSUFBUyxNQUFLekMsS0FBS3VkLFdBQVl2ZDtPQUFLLENBQzNDLElBQUl3ZCxlQUFnQmpnQiw4QkFBNkIrZjtRQUNqRCxJQUFXLElBQUZuWSxJQUFPQSxJQUFJbVksVUFBV25ZLElBQUt4QyxNQUFPLFVBQzdCd0MsS0FBSzdDLEVBQUVLO1FBRXJCRixJQUFJekMsS0FBS3dkO01BRWIsT0FBTy9hLEdBWm1DO0lBb3NCbEIsU0FBeEJnYix3QkFBb0NDO01BRXBDO09BQUlqYjs7U0FBVWliO1NBQVUseUJBQXlCQTtTQUFhLHdDQUF3Q0E7TUFDdEc7TUFDQSxPQUFPamIsR0FKbUI7SUEwRlUsU0FBcENrYixvQ0FBZ0RyYixFQUFHdEM7TUFDbkQsT0FBTztlQUF3QiwrQ0FBK0NzQyxFQUFHdEMsR0FEM0M7SUEveUJFLFNBQXhDNGQsd0NBQW9EdGI7TUFDcEQsSUFBTSxJQUNFLElBQUVBLFdBQVd0QztNQUNyQixHQUFJd0MsVUFBVyxZQUNBakY7TUFIZjtPQUtjLFVBQUUrRSxFQUFFdEM7T0FDVixTQUFNekMsOEJBQTZCaUYsTUFBTThhO01BQ2pELElBQWEsSUFBSjNhLE1BQVMzQyxLQUFLd0MsSUFBS3hDO09BQUssSUFDbEIsSUFBRm1GLElBQU9BLElBQUltWSxVQUFXblksSUFBS3hDLE1BQU8sSUFDbkNBLE9BQU9MLEVBQUV0QyxHQUFHbUY7TUFHeEIsT0FBTzFDLEdBYm1DO0lBdFRYLFNBQS9Cb2IsK0JBQTJDemIsR0FDM0MsT0FBSUEsUUFDTzdELFVBRUE2RCxJQUpzQjtJQWcvREwsU0FBNUIwYiw0QkFBd0MxYixFQUFHMmI7TUFFM0M7T0FBeUIscUJBQUUsK0JBQStCM2I7T0FDbEMsb0JBQUU3RDtPQUNQLGVBQUVBO01BQ3JCLEdBQUl5Zix5QkFBeUJ6ZjtPQUFXLENBQ3BDMGYsc0JBQXNCRDtRQUN0QkUsaUJBQWlCRjtNQUVyQjtjQUFXRDtlQUNQRTtlQUNBQztlQUNBOWI7ZUFDQUE7ZUFDQUE7ZUFDQUE7ZUFDQUE7ZUFDQUE7ZUFDQUE7ZUFDQUE7ZUFDQUE7ZUFDQUEsU0FyQjBCO0lldDhEbEM7S0FBSStiO01BQVM7U0FDRSxTQUFQQSxPQUFtQi9iLEdBQ3JCMUYsYUFBYTBGLENBREY7U0FHYitiO1NBQ0EsT0FBT0EsTUFMRzs7SUErSGQsU0FBU0MsMEJBQTBCMWE7TUFDakMsSUFBSW1NLFFBQVU7TUFDZCxXQUFXc08sT0FBTyx3QkFBd0J6YSxFQUFHbU0sU0FDL0M7SVN4UUEsSUFBSXdPO0lBS0osU0FBU0M7TUFDUCxHQUFHRCxjQUFlLE9BQ1RBO01BRVQ7YUFBUzthQUE4QywwQ0FDekQ7SUE0UkEsU0FBU0Usa0JBQWtCbmMsRUFBRTVCLEVBQUU4WixFQUFFdEw7TUFDL0IsSUFBSXRMLEVBQUk7TUFDUixtQkFBbUJ0QixFQUFFc0IsV0FBV2xELEVBQUU4WixJQUFHdEw7TUFDckMsUUFDRjtJUHpQQSxTQUFTd1AsaUNBQWlDQyxLQUFNaEssS0FBTWlLLElBQUsvSixLQUFNblM7TUFDL0QsU0FBU2tjO09BQ1A7O01BQ0YsR0FBR2xjLFNBQVU7TUFDYixJQUFJMkwsS0FBTyxXQUFXd0c7TUFDdEIsR0FBR0YsT0FBT2pTLE1BQU0sc0JBQXNCaWMsTUFBTztNQUc3QyxHQUFHdFEsT0FBTzNMLE1BQU1rYyxnQkFBaUI7TUFKakMsSUFPSTlKLE1BQVEscUJBQXFCNkosWUFBWWhLLEtBQUtBLE9BQU9qUztNQUN6RCxhQUFhb1MsTUFBTXpHO01BQ25CLFFBQ0Y7SWpCNjVCa0IsU0FBZHdRLGNBQTBCM1o7TUFDMUIsT0FBTywyQkFBMkIseUJBQXlCQSxHQUQzQztJQXNsQjJCLFNBQTNDNFosMkNBQXVEeGM7TUFDdkQsT0FBTyxrQ0FBa0NBLEVBQUdKLHNCQURDO0lBWUgsU0FBMUM2YywwQ0FBc0R6YztNQUN0RDtPQUFPLEdBQUUscURBQXFEQTtPQUNsRCxRQUFFLDJDQUEyQzBjO01BQ3pELE9BQU9DLE9BSHFDO0lNcmdEaEQsU0FBU0MsdUJBQTBCLE9BQU96WCxnQkFBa0I7SU9nTDVELFNBQVMwWCxnQ0FBaUM3YyxFQUFHc0I7TUFBSyxPQUFPLHVCQUF1QkEsRUFBRztJR3NJbkYsU0FBU3diLG9CQUFvQnZMLEdBQUlqQztNQUMvQixJQUFJa0MsSUFBTSxVQUFVbEM7TUFDcEIsR0FBR2tDLFdBQVdELGVBQWdCO01BRDlCLElBRU8sR0FBRSxPQUFPQyxLQUNULEdBQUUsT0FBT0E7TUFDaEIsT0FBUUMsS0FBTUMsT0FDaEI7SWhCc0JBLElBQUlxTCx3QkFBMEJuZDtJa0JyWjlCLFNBQVNvZCwwQkFBMEJoZCxHQUNqQyxRQUNGO0lVc0ZBLFNBQVNpZCxpQkFBa0JDLE1BQU9DO01BQ2hDLEdBQUlBLGVBQWVELGlCQUFrQjtNQUNyQyxPQUFPQSxLQUNUO0lDaEdBLFNBQVNFLDJCQUEyQkMsVUFBV3pmO01BQzdDLEdBQUlBLFdBQVd5ZixzQkFBdUIsd0JBQ3hDO0lBSUEsU0FBU0MsbUNBQW1DM0ssUUFBU0QsSUFBS0csUUFBU0QsSUFBS3hTO01BQ3RFLEdBQUdBLFNBQVU7TUFDYixpQkFBaUJ3UyxJQUFJQztNQUNyQixpQkFBaUJELElBQUlDLFVBQVF6UztNQUM3QiwyQkFBMkJzUyxJQUFLQztNQUNoQywyQkFBMkJELElBQUtDLFVBQVV2UztNQUMxQztPQUFTLFVBQU1qRixnQ0FBK0JpRjtPQUNuQyxZQUFNakYsOEJBQTZCMGE7TUFDOUMsV0FBVyxrQkFBa0JsRCxRQUFTQSxVQUFXdlM7TUFDakQsSUFBVSxJQUFGeEMsSUFBT0EsSUFBSXdDLElBQUt4QyxJQUFJLElBRXRCaVYsVUFBUWpWLFNBQU9pWSxLQUFLalk7TUFFMUIsUUFDRjtJN0Irb0J1QixTQUFuQjJmO01BQ0EsSUFBSWxkLElBQU07TUFDVixpQkFBaUJBO01BQ2pCLE9BQU9BLEdBSGM7SUE2L0JvQixTQUF6Q21kLHlDQUFxREMsT0FBUTdhLEVBQUdsQjtNQUNoRSxHQUFJK2IsYUFBYyxTQUNMdGhCLGVBQ04sU0FDTXNoQjtNQUViLE9BQU87ZUFBb0RBO2VBQVEsMkNBQTJDN2E7ZUFBSSx3QkFBd0JsQixNQU4vRjtJQTc3Qy9DLElBQUlnYyx3QkFBMEI5ZDtJQXVxQkcsU0FBN0IrZCw2QkFBeUMzZDtNQUN6QyxPQUFPO2VBQWlDQSxFQUFHSiwwQkFBMkJBLGlDQUR2QztJQXczQkcsU0FBbENnZSxrQ0FBOEM1ZDtNQUM3QixTQUFiZ0ssYUFBeUI5SjtRQUN6QixJQUFNLEVBQUVBLGFBQ0EsUUFBTUksTUFBTTJDO1FBQ3BCLElBQVcsSUFBRnJGLElBQU9BLElBQUlxRixJQUFLckYsRUFBRyxJQUNwQkEsS0FBSyw2QkFBNkJzQyxFQUFFdEM7UUFHNUMsT0FBTywrQkFBK0J5QyxJQVB2QjtNQVVuQjtPQUFXLE9BQUUsYUFBYUw7T0FDZixPQUFFLDZCQUE2QkE7T0FDL0IsT0FBRSw2QkFBNkJBO01BQzFDLFlBQVdKLG9DQUFtQ2llLE9BQVFDLE9BQVFDLE9BZDFCO0lBbkRBLFNBQXBDQyxvQ0FBZ0RoZTtNQUM1QixTQUFoQmllLGdCQUE0QkM7UUFDNUIsT0FBTztpQkFBMEJBO2lCQUFTM1U7aUJBQTRCM0osaUNBRHBEO01BR3RCO09BQU8sR0FBRUk7T0FDQyxNQUFFLDJCQUEyQkEsS0FBTUo7T0FDdEMsR0FBRUk7T0FDRixHQUFFQTtPQUNGLEdBQUUsMkJBQTJCQSxLQUFNSjtPQUNsQyxJQUFFdWU7T0FFRSxZQUFNN2QsTUFBTUY7T0FDWixZQUFNRSxNQUFNRjtNQUN4QixJQUFXLElBQUZ4QyxJQUFPQSxJQUFJd0MsSUFBS3hDLElBQUssQ0FDMUI0Z0IsUUFBUTVnQixLQUFLdWdCLEdBQUd2Z0IsTUFDaEI2Z0IsUUFBUTdnQixLQUFLdWdCLEdBQUd2Z0I7TUFYcEIsSUFhTSxFQUFFLGdCQUFnQjRnQixTQUNsQixFQUFFLGdCQUFnQkM7TUFDeEIsWUFBVzdlLCtCQUE4QmtELEVBQUdJLEVBQUdrYixNQUFPQyxHQUFJQyxHQUFJQyxHQW5CeEI7SUFwdENmLFNBQXZCRyx1QkFBbUN4ZTtNQUNuQyxPQUFPLHdDQUF3Q0EsRUFEdEI7SUFvc0M3QixJQUFvQixrQkFGUjtJQU1nQyxTQUF4QzJlLHdDQUFtRDdlLEdBQ25ELE9BQU9BLENBRG1DO0lBc0dkLFNBQTVCOGUsNEJBQXdDOWU7TUFDeEM7T0FBZ0IsWUFBRSxrQ0FBa0NBO09BQzFDLE1BQUUsb0NBQW9DQTtPQUN0QyxNQUFFLHdDQUF3Q0E7T0FDdkMsU0FBRUE7T0FDSCxRQUFFLHVCQUF1QkE7T0FDakIsZ0JBQUVBO09BQ1IsVUFBRWtMO09BQ1ksNkJBQU10TCx5QkFBd0JzZjtPQUNoQywwQkFBTTVlLE1BQU00ZTtNQUN0QyxJQUFXLElBQUZ0aEIsSUFBT0EsSUFBSXNoQixVQUFXdGhCO09BQUssQ0FDaEM7VUFBNkIsdUJBQXVCc04sZ0JBQWdCdE47UUFDcEV3aEIsc0JBQXNCeGhCOztRQUFTLDZCQUE2QnNOLGdCQUFnQnROO01BRWhGd2hCOztNQUF3QiwrQkFBK0JBO01BQ3ZEO2VBQVd4ZjtlQUE2Qm1mO2VBQWFDO2VBQU81VDtlQUFPNlQ7ZUFBVWhVO2VBQVNrVTtlQUF5QkMsc0JBZmpGO0lBcEJJLFNBQWxDQyxrQ0FBOENyZjtNQUM3QixTQUFiZ0ssYUFBeUI5SjtRQUN6QjtTQUFNLEVBQUUsK0JBQStCQSxFQUFHTjtTQUNsQztRQUNSLElBQVcsSUFBRmhDLElBQU9BLElBQUl3RixXQUFZeEY7U0FBRyxTQUV0Qiw2QkFBNkJ3RixFQUFFeEY7UUFFNUMsT0FBT3lDLEdBUFE7TUFVbkI7T0FBVyxPQUFFLGFBQWFMO09BQ2YsT0FBRSw2QkFBNkJBO09BQy9CLE9BQUUsNkJBQTZCQTtNQUMxQztNQUNBLFVBQVc2ZCxPQUFRQyxPQUFRQyxPQWZTO0lBOUNBLFNBQXBDdUIsb0NBQWdEdGY7TUFDNUIsU0FBaEJpZSxnQkFBNEJDO1FBQzVCLE9BQU87aUJBQTBCQTtpQkFBU3RlO2lCQUF1QkM7dUJBRC9DO01BR3RCO09BQU0sRUFBRSxnQkFBZ0JHO09BQ2xCLEVBQUUsZ0JBQWdCQTtPQUNkLE1BQUUsMkJBQTJCQTtPQUNoQyxHQUFFQTtPQUNGLEdBQUVBO09BQ0YsR0FBRSwyQkFBMkJBO01BQ3BDO01BTkEsSUFPSUksSUFBTTBDO01BQ1YsR0FBSTFDLFFBQVE4QyxTQUFVLFVBQVlxYztNQVJsQyxJQVNJcEIsT0FBUzdkLE1BQU1GO01BQ25CK2Q7TUFDQSxJQUFXLElBQUZ2Z0IsSUFBT0EsSUFBSXdDLElBQUt4QztPQUFLLENBQzFCLElBQUk0aEIsVUFBWWxmO1FBQ2hCa2Y7UUFDQUEsV0FBVzFjLEVBQUVsRjtRQUNiNGhCLFdBQVd0YyxFQUFFdEY7UUFDYnVnQixHQUFHdmdCLEtBQUs0aEI7TUFFWixVQUFXckIsR0FBSUMsTUFBT0MsR0FBSUMsR0FBSUMsR0F0QlE7SUF0dUNmLFNBQXZCa0IsdUJBQW1DdmY7TUFFbkMsT0FBTyx3Q0FBd0NBLEtBRnRCO0lBd3NDZSxTQUF4Q3dmLHdDQUFtRDFmLEdBQ25ELE9BQU9BLENBRG1DO0lBb0hkLFNBQTVCMmYsNEJBQXdDM2Y7TUFDeEM7T0FBYSxTQUFFLGtDQUFrQ0E7T0FDdkMsTUFBRSxvQ0FBb0NBO09BQ3RDLE1BQUUsd0NBQXdDQTtPQUN2QyxTQUFFQTtPQUNILFFBQUUsdUJBQXVCQTtPQUNULHdCQUFFQTtPQUNKO1FBQUU7VUFBK0JBLHdCQUF5Qko7T0FDdEUsVUFBRXdmO09BQ0ksb0JBQU05ZSxNQUFNNGU7TUFDaENoVTtNQUNBLElBQVcsSUFBRnROLElBQU9BLElBQUlzaEIsVUFBV3RoQjtPQUFLLENBQ2hDLElBQUl5QyxRQUFVQztRQUNkRDtRQUNBQSxTQUFTLHVCQUF1Qiw0QkFBNEJ6QztRQUU1RHlDLFNBQVMsNkJBQTZCK2Usc0JBQXNCeGhCO1FBQzVEc04sZ0JBQWdCdE4sS0FBS3lDO01BRXpCLFVBQVd1ZixTQUFVWixNQUFPNVQsTUFBTzZULFNBQVVoVSxRQUFTQyxnQkFuQnhCO0lBNkRNLFNBQXBDMlUsb0NBQWdEYjtNQUNoRCxPQUFPO2VBQTRCO2lCQUErQyw0QkFBNEJBLFFBRHhFO0k4QjF3RDFDLElBQUljO0lBV0osU0FBU0MsbUJBQ1AsT0FBT0QsaUJBQ1Q7SWpCZ0pBLFNBQVNFLG9CQUFxQmhnQixHQUFLLE9BQU8sV0FBYTtJYm82Q1YsU0FBekNpZ0I7TUFDQSxPQUFPO2VBQTJDLHNEQURQO0lDOTRDL0MsU0FBU0MsZUFBZWxnQjtNQUN0QjtPQUFPO09BQ0E7T0FDQTtPQUNBO09BQ0E7T0FDRDtPQUVHO01BQ1QsR0FBSUEsTUFBTztNQUdYQSxJQUFJLFNBQVNBO01BWGI7T0FZTSxlQUFld2dCLElBQUl4Z0I7T0FDbkI7OztZQUFZdWdCLEtBQUszZCxJQUFJMGQsTUFBTTFkLElBQUl5ZCxNQUFNemQsSUFBSXdkLE1BQU14ZCxJQUFJdWQ7O1FBQU12ZDs7UUFBSSxZQUFVNUMsSUFBSUE7TUFFakYsT0FBT3ZCLE9BQU9MLENBQ2hCO0llb0ZBLFNBQVNxaUIsb0JBQW9CbFAsR0FBSWpDO01BQy9CLElBQUlrQyxJQUFNLFVBQVVsQztNQUNwQixHQUFHa0MsV0FBV0QsZUFBZ0I7TUFEOUI7T0FFTyxHQUFFLE9BQU9DO09BQ1QsR0FBRSxPQUFPQTtPQUNULEdBQUUsT0FBT0E7T0FDVCxHQUFFLE9BQU9BO01BQ2hCLE9BQVVDLFVBQ0FDLFVBQ0FDLFdBQ0FDLFFBQ1o7SWVwWkE7S0FBSThPO01BQVMsU0FBV3ZrQjs7U0FHcEI7VUFBUztVQUNJO1VBQ0Q7VUFDSSxZQUFFLGFBQWEwa0I7VUFDVjtVQUVWLE9BQUUxbEI7VUFFWSw0QkFBUzhsQjtTQUVsQyxTQUFTRSxRQUFRamhCLEVBQUdraEIsTUFBT0MsU0FBVUM7V0FDakMsVUFBV3BoQixrQkFBbUIsT0FBT2loQjtXQUNyQyxVQUFXQztZQUF1QixTQUFRQSxrQkFBaUJDO3FCQUFXLFdBQVduaEI7cUJBQUssVUFBVUEsRUFBR2toQixNQUFPQyxTQUFVQztXQUNwSCxPQUFPLFdBQVdwaEIsRUFDdEI7U0FFQSxTQUFTdWhCLFdBQVdDLE1BQU9qakI7V0FDdkJuRSxhQUFhb25CO1dBQ2JwbkIsWUFBWW1FO1dBQ1puRTtXQUNBQSx1QkFDSjtTQUNBbW5CLHVCQUF1QixjQUFjTjtTQUVyQyxTQUFTUSxhQUFhRDtXQUNsQnBuQixhQUFhb25CO1dBQ2JwbkIsWUFBWW9uQjtXQUNacG5CO1dBQ0FBLHVCQUNKO1NBQ0FxbkIseUJBQXlCLGNBQWNSO1NBRXZDLFNBQVNTLGFBQWFGO1dBQ2xCcG5CLGFBQWFvbkIsTUFDYnBuQix1QkFDSjtTQUNBc25CLHlCQUF5QixjQUFjVDtTQUV2QyxTQUFTVSxVQUFVNWUsR0FDZixTQUFRNGQsVUFBVTVkLEtBQUtBLElBQUk0ZCxPQUMvQjtTQUVBLFNBQVNFLGFBQWE5ZDtXQUNsQixHQUFJQSxRQUNBLFFBQVFBO1dBQ1osR0FBSUEsU0FDQSxRQUFRQSxRQUFTLFdBQVdBO1dBQ2hDLFFBQVFBLFFBQVMsV0FBV0EsZUFBZ0IsV0FBV0EsVUFDM0Q7U0FFQSxTQUFTNmUsYUFBYUM7V0FDbEIsS0FBS0E7V0FDTCxJQUFJcmtCLE9BQVNxa0I7V0FDYixHQUFJcmtCLGNBQWMsV0FBV3FrQixJQUFLakI7WUFBa0IsT0FDeENwakI7cUJBQ0k7cUJBQ0EsT0FBT3FrQjtxQkFDUCxPQUFPQSxTQUFTQSxTQUFTcEI7c0JBQ3hCLE9BQU9vQixVQUFVQSxTQUFTQSxTQUFTcEIsUUFBUUE7V0FHNUQsT0FBT29CLEdBQ1g7U0FFQSxTQUFTQyxLQUFLOWhCLEdBQ1YsSUFBSXRDLEVBQUlzQyxTQUNSLE1BQU9BLElBQUl0QyxTQUFTLENBQ3BCc0MsV0FBV3RDLEtBQ2Y7U0FFQSxTQUFTc2tCLFlBQVl4a0I7V0FDakIsSUFBTSxNQUFNNEMsTUFBTTVDLFFBQ1osTUFDTixRQUFTRSxJQUFJRixPQUFRLEVBQ2ZFLE9BRU4sT0FBT29DLENBQ1g7U0FFQSxTQUFTbWlCLFNBQVNsZjtXQUNkLEdBQUlBLE1BQU8sT0FBTyxXQUFXQSxHQUM3QixPQUFPLFVBQVVBLEVBQ3JCO1NBRUEsU0FBU21mLElBQUloZixFQUFHVDtXQUNaO1lBQVEsSUFBRVM7WUFDRixJQUFFVDtZQUNKLE1BQU1yQyxNQUFNK2hCO1lBQ1I7WUFDRCxLQUFFMUI7WUFDUDhCO1lBQUs3a0I7V0FDVCxJQUFLQSxNQUFPQSxJQUFJMGtCLElBQUsxa0I7WUFBSyxDQUN0QjZrQixNQUFNcmYsRUFBRXhGLEtBQUsrRSxFQUFFL0UsS0FBSzJrQjthQUNwQkEsUUFBUUUsT0FBT0Q7YUFDZnRmLEVBQUV0RixLQUFLNmtCLE1BQU1GLFFBQVFDO1dBRXpCLE1BQU81a0IsSUFBSXlrQjtZQUFLLENBQ1pJLE1BQU1yZixFQUFFeEYsS0FBSzJrQjthQUNiQSxRQUFRRSxRQUFRRDthQUNoQnRmLEVBQUV0RixPQUFPNmtCLE1BQU1GLFFBQVFDO1dBRTNCLEdBQUlELFVBQVcsT0FBT0E7V0FDdEIsT0FBT3JmLENBQ1g7U0FFQSxTQUFTd2YsT0FBT3RmLEVBQUdUO1dBQ2YsR0FBSVMsWUFBWVQsU0FBVSxPQUFPLElBQUlTLEVBQUdULEdBQ3hDLE9BQU8sSUFBSUEsRUFBR1MsRUFDbEI7U0FFQSxTQUFTdWYsU0FBU3ZmLEVBQUdtZjtXQUNqQixJQUFNLEVBQUVuZixTQUNGLE1BQU05QyxNQUFNd0MsR0FDVCxLQUFFNmQsS0FDUDhCLElBQUs3a0I7V0FDVCxJQUFLQSxNQUFPQSxJQUFJa0YsRUFBR2xGO1lBQUssQ0FDcEI2a0IsTUFBTXJmLEVBQUV4RixLQUFLNGtCLE9BQU9EO2FBQ3BCQSxRQUFRLFdBQVdFLE1BQU1EO2FBQ3pCdGYsRUFBRXRGLEtBQUs2a0IsTUFBTUYsUUFBUUM7YUFDckJEO1dBRUosTUFBT0E7WUFBVyxDQUNkcmYsRUFBRXRGLE9BQU8ya0IsUUFBUUMsS0FDakJELFFBQVEsV0FBV0EsUUFBUUM7V0FFL0IsT0FBT3RmLENBQ1g7U0FFQXVlOztrQkFBcUN2aEI7V0FDakMsSUFBSStDLEVBQUksV0FBVy9DO1dBQ25CLEdBQUk1RixjQUFjMkksT0FBUSxPQUNmLGNBQWM7V0FGekIsSUFJTSxFQUFFM0ksV0FBYyxFQUFFMkk7V0FDeEIsR0FBSUE7WUFBVyxXQUNBd2UsV0FBVyxTQUFTcmUsRUFBRyxTQUFTVCxJQUFLckk7V0FFcEQsV0FBV21uQixXQUFXLE9BQU9yZSxFQUFHVCxHQUFJckksVUFUYjtTQVczQm1uQiw0QkFBNEJBO1NBRTVCRTs7a0JBQXVDemhCO1dBQ25DLElBQU0sRUFBRSxXQUFXQSxHQUNiLEVBQUU1RjtXQUNSLEdBQUk4SSxVQUFVSCxPQUFRLE9BQ1gsY0FBYztXQUh6QixJQUtJTixFQUFJTTtXQUNSLEdBQUlBO1lBQVcsQ0FDWCxHQUFJLFVBQVVHLElBQUlULEdBQUksV0FBV2dmLGFBQWF2ZSxJQUFJVDthQUNsREEsSUFBSSxhQUFhLFNBQVNBO1dBRTlCLFdBQVc4ZSxXQUFXLFNBQVM5ZSxFQUFHLFNBQVNTLElBQUtBLE1BWHZCO1NBYTdCdWUsOEJBQThCQTtTQUU5QkM7O2tCQUF1QzFoQjtXQUNuQyxXQUFXMGhCLGFBQWF0bkIsYUFBYSxXQUFXNEYsU0FEdkI7U0FHN0IwaEIsOEJBQThCQTtTQUU5QixTQUFTZ0IsU0FBU3hmLEVBQUdUO1dBQ2pCO1lBQVEsSUFBRVM7WUFDRixJQUFFVDtZQUNKLE1BQU1yQyxNQUFNdWlCO1lBQ1A7WUFDRixLQUFFbEM7WUFDUC9pQjtZQUFHb2xCO1dBQ1AsSUFBS3BsQixNQUFPQSxJQUFJa2xCLElBQUtsbEI7WUFBSyxDQUN0Qm9sQixhQUFhNWYsRUFBRXhGLEtBQUttbEIsU0FBU3BnQixFQUFFL0U7YUFDL0IsR0FBSW9sQixlQUFnQixDQUNoQkEsY0FBY1IsS0FDZE8sZ0JBQ0dBO2FBQ1A3ZixFQUFFdEYsS0FBS29sQjtXQUVYLElBQUtwbEIsSUFBSWtsQixJQUFLbGxCLElBQUlpbEIsSUFBS2psQjtZQUFLLENBQ3hCb2xCLGFBQWE1ZixFQUFFeEYsS0FBS21sQjthQUNwQixHQUFJQztjQUFnQkEsY0FBY1I7O2NBQzdCLENBQ0R0ZixFQUFFdEYsT0FBT29sQixXQUNUO2FBRUo5ZixFQUFFdEYsS0FBS29sQjtXQUVYLEtBQU9wbEIsSUFBSWlsQixJQUFLamxCLElBQUssRUFDZkEsS0FBS3dGLEVBQUV4RjtXQUViLEtBQUtzRjtXQUNMLE9BQU9BLENBQ1g7U0FFQSxTQUFTK2YsWUFBWTdmLEVBQUdULEVBQUdsRTtXQUN2QixJQUFJaWpCO1dBQ0osR0FBSSxXQUFXdGUsRUFBR1Q7WUFBUyxRQUNmLFNBQVNTLEVBQUdUOztZQUNqQixDQUNIK2UsUUFBUSxTQUFTL2UsRUFBR1MsR0FDcEIzRSxTQUFRQTtXQUVaaWpCLFFBQVEsYUFBYUE7V0FDckIsVUFBV0E7WUFBb0IsQ0FDM0IsR0FBSWpqQixLQUFNaWpCLFVBQVNBLE1BQ25CLFdBQVdDLGFBQWFEO1dBRTVCLFdBQVdELFdBQVdDLE1BQU9qakIsS0FDakM7U0FFQSxTQUFTeWtCLGNBQWM5ZixFQUFHVCxFQUFHbEU7V0FDekIsSUFBTSxFQUFFMkUsU0FDRixNQUFNOUMsTUFBTXdDLEdBQ1IsUUFBR0gsRUFDSixLQUFFZ2UsS0FDUC9pQixFQUFHb2xCO1dBQ1AsSUFBS3BsQixNQUFPQSxJQUFJa0YsRUFBR2xGO1lBQUssQ0FDcEJvbEIsYUFBYTVmLEVBQUV4RixLQUFLMmtCO2FBQ3BCQSxRQUFRLFdBQVdTLGFBQWFSO2FBQ2hDUSxjQUFjUjthQUNkdGYsRUFBRXRGLEtBQUtvbEIsZUFBaUJBLGFBQWFSLEtBQU9RO1dBRWhEOWYsSUFBSSxhQUFhQTtXQUNqQixVQUFXQTtZQUFnQixDQUN2QixHQUFJekUsS0FBTXlFLE1BQUtBLEVBQ2YsV0FBV3llLGFBQWF6ZTtXQUMxQixXQUFXdWUsV0FBV3ZlLEVBQUd6RSxLQUMvQjtTQUVBZ2pCOztrQkFBMEN2aEI7V0FDdEMsSUFBSStDLEVBQUksV0FBVy9DO1dBQ25CLEdBQUk1RixjQUFjMkksT0FBUSxPQUNmLFNBQVM7V0FGcEIsSUFJTSxFQUFFM0ksV0FBYyxFQUFFMkk7V0FDeEIsR0FBSUEsVUFDQSxPQUFPLGNBQWNHLEVBQUcsU0FBU1QsR0FBSXJJO1dBQ3pDLE9BQU8sWUFBWThJLEVBQUdULEVBQUdySSxVQVJHO1NBVWhDbW5CLDZCQUE2QkE7U0FFN0JFOztrQkFBNEN6aEI7V0FDeEMsSUFBTSxFQUFFLFdBQVdBLEdBQ2IsRUFBRTVGO1dBQ1IsR0FBSThJLFVBQVVILE9BQVEsT0FDWCxTQUFTO1dBSHBCLElBS0lOLEVBQUlNO1dBQ1IsR0FBSUEsVUFBVyxXQUNBMGUsYUFBYXZlLElBQUlUO1dBRWhDLE9BQU8sY0FBY0EsRUFBRyxTQUFTUyxHQUFJQSxPQVZQO1NBWWxDdWUsK0JBQStCQTtTQUUvQkM7O2tCQUE0QzFoQjtXQUN4QyxXQUFXMGhCLGFBQWF0bkIsYUFBYSxXQUFXNEYsU0FEbEI7U0FHbEMwaEIsK0JBQStCQTtTQUUvQkg7O29CQUNJLFdBQVdBLFdBQVdubkIsYUFBYUEsVUFEVDtTQUc5QnFuQjs7O1dBQ0ksSUFBUyxLQUFFcm5CLFVBQ0QsVUFBTXFuQixlQUFjcm5CO1dBQzlCNm9CLGVBQWMxa0I7V0FDZCxPQUFPMGtCLEtBSnFCO1NBTWhDdkI7O29CQUNJLFdBQVdBLGVBQWN0bkIsV0FERztTQUloQ21uQjs7b0JBQ0ksV0FBV0EsV0FBV25uQixpQkFEQztTQUczQnFuQjs7b0JBQ0ksV0FBV0EsYUFBYSxTQUFTcm5CLFlBRFI7U0FHN0JzbkI7OztXQUNJLFdBQVdBLGFBQWF0bkIsZ0JBQWtCQSxhQUFjQSxXQUQvQjtTQUs3QixTQUFTOG9CLGFBQWFoZ0IsRUFBR1Q7V0FDckI7WUFBUSxJQUFFUztZQUNGLElBQUVUO1lBQ0osRUFBRWtnQixNQUFNQztZQUNSLEVBQUUsWUFBWWhnQjtZQUNYLEtBQUU2ZDtZQUNQMEM7WUFBU2Q7WUFBTzNrQjtZQUFHMGxCO1lBQUtDO1dBQzVCLElBQUszbEIsTUFBT0EsSUFBSWlsQixNQUFPamxCO1lBQUcsQ0FDdEIwbEIsTUFBTWxnQixFQUFFeEY7YUFDUixJQUFXLElBQUZtRixJQUFPQSxJQUFJK2YsTUFBTy9mO2NBQUcsQ0FDMUJ3Z0IsTUFBTTVnQixFQUFFSTtlQUNSc2dCLFVBQVVDLE1BQU1DLE1BQU1yZ0IsRUFBRXRGLElBQUltRjtlQUM1QndmLFFBQVEsV0FBV2MsVUFBVWI7ZUFDN0J0ZixFQUFFdEYsSUFBSW1GLEtBQUtzZ0IsVUFBVWQsUUFBUUM7ZUFDN0J0ZixFQUFFdEYsSUFBSW1GLFVBQVV3ZjtXQUd4QixLQUFLcmY7V0FDTCxPQUFPQSxDQUNYO1NBRUEsU0FBU3NnQixjQUFjcGdCLEVBQUdUO1dBQ3RCLElBQU0sRUFBRVMsU0FDRixNQUFNOUMsTUFBTXdDLEdBQ1QsS0FBRTZkLEtBQ0QsUUFDTjBDLFFBQVN6bEI7V0FDYixJQUFLQSxNQUFPQSxJQUFJa0YsRUFBR2xGO1lBQUssQ0FDcEJ5bEIsVUFBVWpnQixFQUFFeEYsS0FBSytFLElBQUk0ZjthQUNyQkEsUUFBUSxXQUFXYyxVQUFVYjthQUM3QnRmLEVBQUV0RixLQUFLeWxCLFVBQVVkLFFBQVFDO1dBRTdCLE1BQU9EO1lBQVcsQ0FDZHJmLEVBQUV0RixPQUFPMmtCLFFBQVFDLEtBQ2pCRCxRQUFRLFdBQVdBLFFBQVFDO1dBRS9CLE9BQU90ZixDQUNYO1NBRUEsU0FBU3VnQixVQUFVempCLEVBQUdpRDtXQUNsQixJQUFJQyxLQUNKLE1BQU9ELFFBQVMsVUFDaEIsT0FBTyxTQUFTakQsRUFDcEI7U0FFQSxTQUFTMGpCLGtCQUFrQjFqQixFQUFHNUI7V0FDMUIsSUFBSTZFLEVBQUksU0FBU2pELFNBQVU1QjtXQUUzQixHQUFJNkUsUUFBUyxPQUFPLGFBQWFqRCxFQUFHNUI7V0FDcEM2RSxJQUFJLFVBQVVBO1dBSGQ7WUFLTSxFQUFFLFFBQVFBO1lBQ1YsRUFBRSxVQUFXQTtZQUNiLEVBQUUsUUFBUUE7WUFDVixFQUFFLFVBQVdBO1lBRVosR0FBRSxrQkFBa0JHLEVBQUdQO1lBQ3ZCLEdBQUUsa0JBQWtCRixFQUFHMUc7WUFDckIsS0FBRSxrQkFBa0IsT0FBT21ILEVBQUdULEdBQUksT0FBT0UsRUFBRzVHO1lBRXpDO2FBQUU7ZUFBTyxPQUFPMG5CLEdBQUksVUFBVSxTQUFTLFNBQVNFLEtBQU1GLElBQUtDLElBQUszZ0I7ZUFBSyxVQUFVMmdCLE9BQVEzZ0I7V0FDbkcsS0FBS29nQjtXQUNMLE9BQU9BLE9BQ1g7U0FJQSxTQUFTUyxhQUFhQyxHQUFJQztXQUN0QixrQkFBZ0JELGNBQWFDLGdCQUFnQkQsS0FBS0MsTUFDdEQ7U0FFQXZDOztrQkFBMEN2aEI7V0FDdEM7WUFBTSxFQUFFLFdBQVdBO1lBQ2IsRUFBRTVGO1lBQWMsRUFBRTJJO1lBQ2YsS0FBRTNJLGNBQWMySTtZQUNyQmdoQjtXQUNKLEdBQUloaEI7WUFBVyxDQUNYLEdBQUlOLFFBQVMsT0FBT3dlO2FBQ3BCLEdBQUl4ZSxRQUFTLE9BQU9ySTthQUNwQixHQUFJcUksVUFBVSxPQUFPO2FBQ3JCc2hCLE1BQU0sU0FBU3RoQjthQUNmLEdBQUlzaEIsTUFBTXRELEtBQU0sV0FDRGMsV0FBVyxjQUFjcmUsRUFBRzZnQixLQUFNeGxCO2FBRWpEa0UsSUFBSSxhQUFhc2hCO1dBRXJCLEdBQUksYUFBYTdnQixTQUFVVDtZQUN2QixXQUFXOGUsV0FBVyxrQkFBa0JyZSxFQUFHVCxHQUFJbEU7V0FDbkQsV0FBV2dqQixXQUFXLGFBQWFyZSxFQUFHVCxHQUFJbEUsS0FqQmQ7U0FvQmhDZ2pCLDZCQUE2QkE7U0FFN0IsU0FBU3lDLHNCQUFzQjlnQixFQUFHVCxFQUFHbEU7V0FDakMsR0FBSTJFLElBQUl1ZCxLQUFNLFdBQ0NjLFdBQVcsY0FBYzllLEVBQUdTLEdBQUkzRTtXQUUvQyxXQUFXZ2pCLFdBQVcsYUFBYTllLEVBQUcsYUFBYVMsSUFBSzNFLEtBQzVEO1NBQ0FrakI7O2tCQUFvRHZlO1dBQ2hELEdBQUksVUFBVUEsVUFBVTlJO1lBQWEsV0FDdEJxbkIsYUFBYXZlLFVBQVU5STtXQUV0QyxPQUFPO29CQUFzQixTQUFTOEk7b0JBQVUsYUFBYSxTQUFTOUk7b0JBQWNBLGNBQWM4SSxPQUo1RDtTQU0xQ3FlOztrQkFBa0RyZTtXQUM5QyxHQUFJQSxjQUFlLE9BQU8rZDtXQUMxQixHQUFJL2QsY0FBZSxPQUFPOUk7V0FDMUIsR0FBSThJLGdCQUFnQixPQUFPO1dBQzNCLE9BQU87b0JBQXNCLFNBQVNBLFNBQVU5SSxXQUFZQSxjQUFjOEksT0FKdEM7U0FNeEN1ZTs7a0JBQTRDemhCLEdBQ3hDLE9BQU8sV0FBV0Esb0JBQW9CNUYsS0FEUjtTQUdsQ3FuQiwrQkFBK0JBO1NBRS9CQzs7a0JBQTRDMWhCO1dBQ3hDLFdBQVcwaEIsYUFBYXRuQixhQUFhLFdBQVc0RixTQURsQjtTQUdsQzBoQiwrQkFBK0JBO1NBRS9CLFNBQVN1QyxPQUFPL2dCO1dBRVo7WUFBTSxFQUFFQTtZQUNGLEVBQUUsWUFBWU4sSUFBSUE7WUFDZixLQUFFNmQ7WUFDUDBDO1lBQVNkO1lBQU8za0I7WUFBRzBsQjtZQUFLYztXQUM1QixJQUFLeG1CLE1BQU9BLElBQUlrRixFQUFHbEY7WUFBSyxDQUNwQjBsQixNQUFNbGdCLEVBQUV4RjthQUNSMmtCLFlBQVllLE1BQU1BO2FBQ2xCLElBQVcsSUFBRnZnQixFQUFJbkYsRUFBR21GLElBQUlELEVBQUdDO2NBQUssQ0FDeEJxaEIsTUFBTWhoQixFQUFFTDtlQUNSc2dCLGVBQWVDLE1BQU1jLE9BQU9saEIsRUFBRXRGLElBQUltRixLQUFLd2Y7ZUFDdkNBLFFBQVEsV0FBV2MsVUFBVWI7ZUFDN0J0ZixFQUFFdEYsSUFBSW1GLEtBQUtzZ0IsVUFBVWQsUUFBUUM7YUFFakN0ZixFQUFFdEYsSUFBSWtGLEtBQUt5ZjtXQUVmLEtBQUtyZjtXQUNMLE9BQU9BLENBQ1g7U0FFQXVlOztvQkFDSSxXQUFXQSxXQUFXLE9BQU9ubkIsa0JBREg7U0FJOUJxbkI7OztXQUNJLElBQUlELE1BQVFwbkIsYUFBYUE7V0FDekIsR0FBSSxVQUFVb25CLE9BQVEsV0FBV0MsYUFBYUQ7V0FDOUM7bUJBQVdEO29CQUFXLE9BQU8sYUFBYSxTQUFTbm5CLG9CQUh2QjtTQU1oQ3NuQjs7a0JBQTBDMWhCLEdBQ3RDLFdBQVcwaEIsYUFBYXRuQixhQUFhQSxXQURUO1NBSWhDLFNBQVMrcEIsUUFBUWpoQixFQUFHVDtXQUNoQjtZQUFRLElBQUVTO1lBQ0YsSUFBRVQ7WUFDRCxLQUFFZ2U7WUFDQSxPQUFFLFlBQVloZTtZQUNPLDRCQUFFQSxFQUFFbWdCO1lBRXpCLE9BQUUsVUFBVU4sWUFBWThCO1lBQ3JCLFVBQUUsY0FBY2xoQixFQUFHbWhCO1lBQ3JCLFFBQUUsY0FBYzVoQixFQUFHNGhCO1lBQzNCRTtZQUFlQztZQUFPbkM7WUFBT1E7WUFBUW5sQjtZQUFHa0Y7WUFBR2tLO1dBQy9DLEdBQUl3WCxvQkFBb0IzQixJQUFLO1dBQzdCO1dBQ0F5Qiw4QkFBOEJ4WCxRQUFRZ1c7V0FDdEMsSUFBSzRCLFFBQVE3QixNQUFNQyxJQUFLNEIsV0FBWUE7WUFBUyxDQUN6Q0QsZ0JBQWdCakM7YUFDaEIsR0FBSWdDLFVBQVVFLFFBQVE1QixTQUFTd0I7Y0FBNkI7O2NBQ3hDO2lCQUFZRSxVQUFVRSxRQUFRNUIsT0FBT04sT0FBT2dDLFVBQVVFLFFBQVE1Qjs7Z0JBQVl3QjthQUc5Ri9CO2FBQ0FRO2FBQ0FqZ0IsSUFBSWdLO2FBQ0osSUFBS2xQLE1BQU9BLElBQUlrRixFQUFHbEY7Y0FBSyxDQUNwQjJrQixTQUFTa0MsZ0JBQWdCM1gsUUFBUWxQO2VBQ2pDb1AsSUFBSSxXQUFXdVYsUUFBUUM7ZUFDdkJPLFVBQVV5QixVQUFVRSxRQUFROW1CLE1BQU0ya0IsUUFBUXZWLElBQUl3VjtlQUM5Q0QsUUFBUXZWO2VBQ1IsR0FBSStWO2dCQUFZLENBQ1p5QixVQUFVRSxRQUFROW1CLEtBQUttbEIsU0FBU1AsS0FDaENPOztnQkFDRyxDQUNIeUIsVUFBVUUsUUFBUTltQixLQUFLbWxCLE9BQ3ZCQTthQUdSLE1BQU9BO2NBQWMsQ0FDakIwQjtlQUNBbEM7ZUFDQSxJQUFLM2tCLE1BQU9BLElBQUlrRixFQUFHbEY7Z0JBQUssQ0FDcEIya0IsU0FBU2lDLFVBQVVFLFFBQVE5bUIsS0FBSzRrQixPQUFPMVYsUUFBUWxQO2lCQUMvQyxHQUFJMmtCO2tCQUFXLENBQ1hpQyxVQUFVRSxRQUFROW1CLEtBQUsya0IsUUFBUUMsS0FDL0JEOztrQkFDRyxDQUNIaUMsVUFBVUUsUUFBUTltQixLQUFLMmtCLE1BQ3ZCQTtlQUdSUSxVQUFVUjthQUVkMWdCLE9BQU82aUIsU0FBU0Q7V0FHcEJELFlBQVksWUFBWUEsVUFBV0Q7V0FDbkMsUUFBUSxhQUFhMWlCLFFBQVMsYUFBYTJpQixXQUMvQztTQUVBLFNBQVNJLFFBQVF4aEIsRUFBR1Q7V0FFaEI7WUFBUSxJQUFFUztZQUNGLElBQUVUO1lBQ0M7WUFDRjtZQUNBLEtBQUVnZTtZQUNQbUU7WUFBT0M7WUFBTUM7WUFBT0M7WUFBT0M7V0FDL0IsTUFBT3JDO1lBQUssQ0FDUixhQUFhemYsSUFBSXlmO2FBQ2pCLEtBQUtnQzthQUNMLEdBQUksV0FBV0EsS0FBTWxpQixPQUFRLENBQ3pCLGVBQ0E7YUFFSm9pQixPQUFPRjthQUNQRyxRQUFRSCxLQUFLRSxZQUFZdkMsT0FBT3FDLEtBQUtFO2FBQ3JDRSxRQUFRdGlCLEVBQUVtZ0IsV0FBV04sT0FBTzdmLEVBQUVtZ0I7YUFDOUIsR0FBSWlDLE9BQU9qQyxJQUFLLFNBQ0hrQyxhQUFheEM7YUFFMUJzQyxRQUFRLFVBQVVFLFFBQVFDO2FBQzFCO2NBQUcsQ0FDQ0MsUUFBUSxjQUFjdmlCLEVBQUdtaUI7ZUFDekIsR0FBSSxXQUFXSSxNQUFPTCxXQUFZO2VBQ2xDQzs7ZUFDS0E7YUFDVCxZQUFZQTthQUNaRCxPQUFPLFNBQVNBLEtBQU1LO1dBRTFCO1dBQ0EsUUFBUSxhQUFhcmpCLFFBQVMsYUFBYWdqQixNQUMvQztTQUVBLFNBQVNGLFlBQVlqRCxNQUFPNkM7V0FDeEI7WUFBVyxPQUFFN0M7WUFDQSxTQUFFLFlBQVloa0I7WUFDbEIsS0FBRWlqQjtZQUNQL2lCO1lBQUdvUDtZQUFHd1g7WUFBVzFYO1dBQ3JCMFg7V0FDQSxJQUFLNW1CLElBQUlGLFdBQVlFLFNBQVVBO1lBQUcsQ0FDOUJrUCxVQUFVMFgsWUFBWWhDLE9BQU9kLE1BQU05akI7YUFDbkNvUCxJQUFJLFNBQVNGLFVBQVV5WDthQUN2QkMsWUFBWTFYLFVBQVVFLElBQUl1WDthQUMxQnhYLFNBQVNuUCxLQUFLb1A7V0FFbEIsUUFBUUQsU0FBVXlYLGNBQ3RCO1NBRUEsU0FBU1csVUFBVXpxQixLQUFNd0Y7V0FDckIsSUFBSXdoQixNQUFTLEVBQUUsV0FBV3hoQjtXQUMxQixHQUFJZ2hCO1lBQXNCLFlBQ1ZVLGFBQWFsbkIsYUFBYXVJO3dCQUFjMmUsYUFBYWxuQixhQUFhdUk7V0FGbEYsSUFJTSxFQUFFdkksV0FBYyxFQUFFdUksUUFDcEI4SjtXQUNKLEdBQUlwSyxRQUFTLFVBQVU0YztXQUN2QixHQUFJN2tCO1lBQWMsQ0FDZCxHQUFJdUk7Y0FBVyxZQUNDMGUsYUFBYSxTQUFTdmUsSUFBSVQ7MEJBQVNnZixhQUFhdmUsSUFBSVQ7YUFFcEUsUUFBUXdlLFdBQVl6bUI7V0FFeEIsR0FBSXVJO1lBQVcsQ0FDWCxHQUFJTixRQUFTLFFBQVFqSSxLQUFNeW1CO2FBQzNCLEdBQUl4ZSxTQUFTLFFBQVEsY0FBZXdlO2FBQ3BDLElBQUk4QyxJQUFNLFNBQVN0aEI7YUFDbkIsR0FBSXNoQixNQUFNdEQ7Y0FBTSxDQUNaZSxRQUFRLFlBQVl0ZSxFQUFHNmdCO2VBQ3ZCbFgsV0FBVyxhQUFhMlU7ZUFDeEIsSUFBSThDLFVBQVk5QztlQUNoQixHQUFJaG5CLFVBQVc4cEIsY0FBYUE7ZUFDNUIsVUFBV3pYO2dCQUF1QixDQUM5QixHQUFJclMsY0FBY3VJLE9BQVE4SixhQUFZQTtpQkFDdEMsWUFBWTRVLGFBQWE1VTs2QkFBZTRVLGFBQWE2QztlQUV6RCxZQUFZL0MsV0FBVzFVLFNBQVVyUyxjQUFjdUk7MkJBQWEwZSxhQUFhNkM7YUFFN0U3aEIsSUFBSSxhQUFhc2hCO1dBNUJyQixJQThCSW1CLFdBQWEsV0FBV2hpQixFQUFHVDtXQUMvQixHQUFJeWlCLG1CQUFtQixRQUFRakUsV0FBWXptQjtXQUMzQyxHQUFJMHFCO1lBQWtCLFFBQVFqRSxRQUFRem1CLGNBQWN1SSxjQUFrQmtlO1dBR3RFLEdBQUkvZCxXQUFXVDtZQUNYK2UsUUFBUSxRQUFRdGUsRUFBR1Q7O1lBQ2xCK2UsUUFBUSxRQUFRdGUsRUFBR1Q7V0FFeEJvSyxXQUFXMlU7V0F2Q1gsSUF3Q1UsTUFBRWhuQixjQUFjdUksT0FDbEIsSUFBRXllLFNBQ0EsTUFBRWhuQjtXQUNaLFVBQVdxUztZQUF1QixDQUM5QixHQUFJc1ksTUFBT3RZLGFBQVlBO2FBQ3ZCQSxlQUFlNFUsYUFBYTVVOztZQUN6QkEsZUFBZTBVLFdBQVcxVSxTQUFVc1k7V0FDM0MsVUFBV0M7WUFBa0IsQ0FDekIsR0FBSUMsTUFBT0QsUUFBT0EsSUFDbEJBLFVBQVUzRCxhQUFhMkQ7O1lBQ3BCQSxVQUFVN0QsV0FBVzZELElBQUtDO1dBQ2pDLFFBQVF4WSxTQUFVdVksSUFDdEI7U0FFQTdEOztrQkFBd0N2aEI7V0FDcEMsSUFBSTJCLE9BQVMsVUFBVXZILEtBQU00RjtXQUM3QixpQkFDYzJCLG9CQUNDQSxVQUpXO1NBTzlCK2Y7O1NBQWdDRDs7U0FBZ0NGO1NBR2hFQTs7a0JBQXdDdmhCLEdBQ3BDLE9BQU8sVUFBVTVGLEtBQU00RixLQURHO1NBRzlCMGhCOztTQUE4QkE7O2tCQUEwQzFoQjtXQUNwRSxXQUFXMGhCLGFBQWF0bkIsYUFBYSxXQUFXNEYsU0FEVTtTQUc5RHloQjs7U0FBOEJBOztTQUFnQ0Y7O1NBQTRCQTtTQUUxRkEsb0NBQXFDdmhCLEdBQ2pDLE9BQU8sVUFBVTVGLEtBQU00RixLQURBO1NBRzNCMGhCOztTQUE2QkE7O2tCQUE2QzFoQjtXQUN0RSxXQUFXMGhCLGFBQWF0bkIsYUFBYSxXQUFXNEYsU0FEWTtTQUdoRXloQjs7U0FBbUNBOztTQUE2QkY7O1NBQWlDQTtTQUVqR0E7O2tCQUFxQ3ZoQjtXQUNqQyxJQUFNLEVBQUUsV0FBV0EsR0FDYixFQUFFNUYsV0FDRixFQUFFMkksUUFDSnllLE1BQU8xaEIsRUFBRzVCO1dBQ2QsR0FBSXVFLFFBQVMsT0FBT3dlO1dBQ3BCLEdBQUkvZCxRQUFTLE9BQU8rZDtXQUNwQixHQUFJL2QsUUFBUyxPQUFPK2Q7V0FDcEIsR0FBSS9kLFVBQVUsT0FBTyxXQUFhK2QsV0FBYUE7V0FDL0MsR0FBSWxlLE9BQVEsT0FDRGtlO1dBRVgsS0FBS2xlO1lBQVcsVUFBVXNjLHdCQUF3QjtXQUNsRCxHQUFJamxCO1lBQWMsR0FDVixVQUFVb25CLFFBQVEsU0FBU3RlLEVBQUdUO2FBQzlCLFdBQVdnZixhQUFhLFNBQVNEO1dBRXpDMWhCLElBQUkxRjtXQUNKOEQsSUFBSStpQjtXQUNKO1lBQWEsQ0FDVCxHQUFJeGUsWUFBYSxDQUNidkUsSUFBSSxRQUFRNEIsS0FDVjJDO2FBRU4sR0FBSUEsUUFBUzthQUNiQTthQUNBM0MsSUFBSTtXQUVSLE9BQU81QixDQTVCZ0I7U0E4QjNCdWpCLDZCQUE2QkY7U0FFN0JHOztrQkFBdUMxaEI7V0FDbkM7WUFBTSxFQUFFLFdBQVdBO1lBQ2IsRUFBRTVGO1lBQWMsRUFBRTJJO1lBQ2pCLEdBQUU7WUFBYyxHQUFFO1lBQWMsR0FBRTtXQUN6QyxHQUFJTixNQUFNNmlCLEdBQUksT0FBT3JFO1dBQ3JCLEdBQUkvZCxNQUFNb2lCLEdBQUksT0FBT3JFO1dBQ3JCLEdBQUkvZCxNQUFNcWlCLEdBQUksT0FBT3RFO1dBQ3JCLEdBQUkvZCxNQUFNLFlBQVksT0FBTyxXQUFhK2QsV0FBYUE7V0FDdkQsR0FBSSxlQUFnQixXQUFXUyxhQUFhNEQ7V0FQNUMsSUFRTSxFQUFFbHJCLEtBQ0YsRUFBRTZtQjtXQUNSO1lBQWEsQ0FDVCxJQUFLeGUsSUFBSThpQixRQUFRQSxHQUFJLENBQ2pCcm5CLElBQUksUUFBUTRCLEtBQ1YyQzthQUVOLEdBQUlBLE1BQU02aUIsR0FBSTthQUNkN2lCLEtBQUsraUI7YUFDTDFsQixJQUFJO1dBRVIsT0FBTzVCLENBcEJrQjtTQXVCN0JxakI7O2tCQUF3QzFNLElBQUt1UTtXQUN6Q3ZRLE1BQU0sV0FBV0E7V0FDakJ1USxNQUFNLFdBQVdBO1dBQ2pCLEdBQUk7WUFBYyxVQUFVL0Y7V0FDNUIsSUFBTSxFQUFFNEIsV0FDQyxLQUFFLFNBQVNtRTtXQUNwQixHQUFJO1lBQWtCLENBQ2xCdlEsTUFBTSxhQUFhb00sY0FDbkJxQixPQUFPLFlBQVk4QztXQUV2QixNQUFPO1lBQWtCLENBQ3JCLEdBQUksY0FBZSxPQUFPbkU7YUFDMUIsR0FBSSxZQUFhamUsSUFBSSxXQUFXc2YsVUFBVThDO2FBQzFDdlEsTUFBTTthQUNOeU4sT0FBTyxrQkFBa0I4QztXQUU3QixPQUFPcGlCLENBaEJtQjtTQWtCOUIwZTs7U0FBZ0NEOztTQUFnQ0Y7U0FFaEUsU0FBU1EsV0FBVzdlLEVBQUdUO1dBQ25CLEdBQUlTLGFBQWFULFNBQVUsT0FDaEJTLFdBQVdUO1dBRXRCLElBQVcsSUFBRi9FLEVBQUl3RixhQUFjeEYsT0FBUUE7WUFBSyxHQUNoQ3dGLEVBQUV4RixPQUFPK0UsRUFBRS9FLEdBQUksT0FBT3dGLEVBQUV4RixLQUFLK0UsRUFBRS9FO1dBRXZDLFFBQ0o7U0FFQTZqQjs7a0JBQTRDdmhCO1dBQ3hDLElBQU0sRUFBRSxXQUFXQSxHQUNiLEVBQUU1RixXQUNGLEVBQUUySTtXQUNSLEdBQUlBLFVBQVc7V0FDZixPQUFPLFdBQVdHLEVBQUdULEVBTFM7U0FPbENnZjs7a0JBQThDemhCO1dBQzFDLElBQU0sRUFBRSxXQUFXQSxHQUNiLEVBQUUsU0FBUzVGLFlBQ1gsRUFBRTJJO1dBQ1IsR0FBSUEsVUFBVyxDQUNYTixJQUFJLFNBQVNBLEdBQ2IsT0FBT1MsTUFBTVQsSUFBUVMsSUFBSVQ7V0FFN0IsVUFSZ0M7U0FVcENpZjs7a0JBQThDMWhCO1dBQzFDLElBQU0sRUFBRTVGLFdBQ0YsRUFBRSxXQUFXNEY7V0FDbkJrRCxJQUFJQSxPQUFTQSxJQUFLQTtXQUNsQlQsSUFBSUEsT0FBU0EsSUFBS0E7V0FDbEIsT0FBT1MsTUFBTVQsSUFBUVMsSUFBSVQsT0FMTztTQVFwQzhlOztrQkFBeUN2aEI7V0FHckMsR0FBSUEsTUFBTXdVLFNBQVU7V0FHcEIsR0FBSXhVLFFBQU93VSxTQUFVO1dBSXJCLElBQU0sRUFBRSxXQUFXeFUsR0FDYixFQUFFNUYsV0FDRixFQUFFMkk7V0FDUixHQUFJM0ksY0FBYzJJLE9BQVEsT0FDZkE7V0FFWCxHQUFJQSxVQUFXLE9BQ0ozSTtXQUVYLE9BQU8sV0FBVzhJLEVBQUdULE1BQU1ySSxnQkFuQkE7U0FxQi9CbW5CLGlDQUFpQ0E7U0FFakNFOztrQkFBMkN6aEI7V0FDdkMsR0FBSUEsTUFBTXdVLFNBQVU7V0FHcEIsR0FBSXhVLFFBQU93VSxTQUFVO1dBSXJCLElBQU0sRUFBRSxXQUFXeFUsR0FDYixFQUFFNUYsV0FDRixFQUFFMkk7V0FDUixHQUFJQSxVQUFXLE9BQ0pHLEtBQUtULElBQVFTLElBQUlUO1dBRTVCLEdBQUlTLFVBQVVILE9BQVEsT0FDWEc7V0FFWCxPQUFPQSxXQWpCc0I7U0FtQmpDdWUsbUNBQW1DQTtTQUVuQ0M7O2tCQUEyQzFoQjtXQUN2QyxHQUFJQSxNQUFNd1UsU0FBVTtXQUdwQixHQUFJeFUsUUFBT3dVLFNBQVU7V0FHckIsSUFBTSxFQUFFcGEsV0FDRixFQUFFLFdBQVc0RjtXQUNuQixPQUFPa0QsTUFBTVQsSUFBUVMsSUFBSVQsT0FUSTtTQVdqQ2lmLG1DQUFtQ0E7U0FFbkNIOztrQkFBd0N2aEIsR0FDcEMsT0FBTyxhQUFhQSxRQURNO1NBRzlCMGhCOztTQUE0QkE7O1NBQWdDRDs7U0FBNEJBOztTQUFnQ0Y7O1NBQTBCQTtTQUVsSkE7O2tCQUEyQ3ZoQixHQUN2QyxPQUFPLGFBQWFBLFFBRFM7U0FHakMwaEI7O1NBQTZCQTs7U0FBbUNEOztTQUE2QkE7O1NBQW1DRjs7U0FBMkJBO1NBRTNKQTs7a0JBQXlDdmhCLEdBQ3JDLE9BQU8sYUFBYUEsTUFETztTQUcvQjBoQjs7U0FBNEJBOztTQUFpQ0Q7O1NBQTRCQTs7U0FBaUNGOztTQUEwQkE7U0FFcEpBOztrQkFBd0N2aEIsR0FDcEMsT0FBTyxhQUFhQSxNQURNO1NBRzlCMGhCOztTQUE0QkE7O1NBQWdDRDs7U0FBNEJBOztTQUFnQ0Y7O1NBQTBCQTtTQUVsSkE7O2tCQUFpRHZoQixHQUM3QyxPQUFPLGFBQWFBLE9BRGU7U0FHdkMwaEI7O1NBQTZCQTs7U0FBeUNEOztTQUE2QkE7O1NBQXlDRjs7U0FBMkJBO1NBRXZLQTs7a0JBQWdEdmhCLEdBQzVDLE9BQU8sYUFBYUEsT0FEYztTQUd0QzBoQjs7U0FBNkJBOztTQUF3Q0Q7O1NBQTZCQTs7U0FBd0NGOztTQUEyQkE7U0FFcktBOztvQkFDSSxRQUFRbm5CLHdCQURrQjtTQUc5QnFuQjs7b0JBQ0ksUUFBUXJuQixxQkFEb0I7U0FHaENzbkI7O29CQUNJLFFBQVF0bkIsYUFBYSxlQUFlLFNBRFI7U0FJaENtbkI7O29CQUNJLFFBQVFubkIsd0JBRGlCO1NBRzdCcW5COztvQkFDSSxRQUFRcm5CLHFCQURtQjtTQUcvQnNuQjs7b0JBQ0ksUUFBUXRuQixhQUFhLGVBQWUsU0FEVDtTQUkvQm1uQiw2Q0FDSSxTQUFRbm5CLFNBRHNCO1NBR2xDcW5COztvQkFDSSxPQUFPcm5CLGNBRHlCO1NBR3BDc25COztTQUFvQ0Q7U0FFcENGLDZDQUNJLE9BQU9ubkIsU0FEdUI7U0FHbENxbkI7O29CQUNJLE9BQU9ybkIsY0FEeUI7U0FHcENzbkI7O1NBQW9DRDtTQUVwQ0YseUNBQ0ksWUFEMEI7U0FHOUJFOztvQkFDSSxPQUFPLFNBQVNybkIsaUJBRFk7U0FHaENzbkI7O29CQUNJLE9BQU8scUJBQXFCLFNBREE7U0FJaENILHlDQUNJLFlBRDBCO1NBRzlCRSwyQ0FDSSxPQUFPcm5CLGdCQURxQjtTQUdoQ3NuQjs7b0JBQ0ksT0FBT3RuQixlQUFlLFNBRE07U0FJaENtbkI7O2tCQUErQ3ZoQjtXQUMzQyxJQUFJK0MsRUFBSSxXQUFXL0M7V0FDbkIsR0FBSSxXQUFZO1dBQ2hCLEdBQUksV0FBWTtXQUNoQixHQUFJLHNCQUF1QixPQUFPO1dBQ2xDLE9BQU8sU0FBUytDLFdBTGlCO1NBT3JDMmU7O1NBQXVDRDs7U0FBdUNGO1NBRTlFLFNBQVNrRSxhQUFhemxCO1dBQ2xCLElBQUkrQyxFQUFJO1dBQ1IsR0FBSSxXQUFZO1dBQ2hCLEdBQUksZUFBZSxlQUFlLFlBQWE7V0FDL0MsR0FBSSxjQUFjLHNCQUFzQjtZQUFvQjtXQUM1RCxHQUFJLGFBQWMsV0FFdEI7U0FFQSxTQUFTMmlCLGdCQUFnQjNpQixFQUFHRztXQUN4QixJQUFVLE1BQUUsU0FDTixFQUFFeWlCLE1BQ0YsSUFDRjVwQixFQUFHMkcsRUFBR2hGLEVBQUdvQztXQUNiLE1BQU8sV0FBWTJDLElBQUksWUFBYU87V0FDcEM7V0FBTSxJQUFLdEYsTUFBT0EsSUFBSXdGLFNBQVV4RjtZQUFLLENBQ2pDLEdBQUksU0FBU3dGLEVBQUV4RixJQUFLO2FBQ3BCb0MsSUFBSSxPQUFPb0QsRUFBRXhGLFdBQVcrRSxFQUFHTTthQUMzQixHQUFJLGNBQWMsU0FBUzRpQixPQUFRO2FBQ25DLElBQUs1cEIsSUFBSWlILE1BQU9qSCxPQUFRQTtjQUFLLENBQ3pCK0QsSUFBSSxlQUFlaUQ7ZUFDbkIsR0FBSSxXQUFZO2VBQ2hCLEdBQUksU0FBUzRpQixPQUFRO2FBRXpCO1dBRUosV0FDSjtTQUdBcEU7O2tCQUF5Q3FFO1dBQ3JDLElBQUlDLFFBQVUsYUFBYXpyQjtXQUMzQixHQUFJeXJCLFlBQVk1cEIsVUFBVyxPQUFPNHBCO1dBRGxDLElBRU0sRUFBRSxXQUNDLEtBQUU7V0FDWCxHQUFJQztZQUNBLE9BQU8sZ0JBQWdCL2lCO1dBTDNCO1lBTVMsS0FBRSxjQUFjO1lBQ25CLEVBQUUsVUFBVzZpQixvQkFBd0IsU0FBU0csUUFBWUE7V0FDaEUsUUFBVyxLQUFRLElBQUtyb0IsSUFBSWdGLEVBQUdoRixJQUFLLE9BQ3pCLE9BQU9BO1dBRWxCLE9BQU8sZ0JBQWdCcUYsRUFBR0csRUFaQztTQWMvQndlOztTQUFpQ0Q7O1NBQWlDRjtTQUVsRUE7O2tCQUFpRHlFO1dBQzdDLElBQUlILFFBQVUsYUFBYXpyQjtXQUMzQixHQUFJeXJCLFlBQVk1cEIsVUFBVyxPQUFPNHBCO1dBRGxDLElBRU0sRUFBRSxXQUNGLEVBQUVHLGVBQWUvcEIsWUFBZ0IrcEI7V0FDdkMsUUFBVyxLQUFRLElBQUt0b0IsSUFBSWdGLEVBQUdoRjtZQUFLLE9BQ3pCLHFCQUFzQjtXQUVqQyxPQUFPLGdCQUFnQnFGLEVBQUdHLEVBUlM7U0FVdkN3ZTs7U0FBeUNEOztTQUF5Q0Y7U0FFbEZBOztrQkFBd0N4ZTtXQUNwQztZQUFNLEVBQUV5ZDtZQUFrQixLQUFFQTtZQUFjLEVBQUUsV0FBV3pkO1lBQVMsS0FBRTtZQUFZK0o7WUFBR3FaO1lBQU9DO1dBQ3hGLFFBQVE7WUFBZSxDQUNuQnRaLElBQUksU0FBU29aO2FBQ2JDLFFBQVF6akI7YUFDUjBqQixRQUFRcGpCO2FBQ1JOLElBQUl1akI7YUFDSmpqQixJQUFJa2pCO2FBQ0pELE9BQU8sZUFBZSxXQUFXQTthQUNqQ0MsT0FBTyxlQUFlLFdBQVdBO1dBRXJDLEtBQUs7WUFBWTttQkFBVTdHO29CQUFNOzs7O29CQUE0Qjs7O1dBQzdELEdBQUkscUJBQXFCLElBQ2pCLE1BQU10YztXQUVkLEdBQUksa0JBQW1CLE9BQ1o7V0FFWCxPQUFPTCxDQWxCbUI7U0FxQjlCZ2Y7O1NBQWdDRDs7U0FBZ0NGO1NBRWhFQTs7O1dBQ0ksSUFBSUMsTUFBUXBuQjtXQUNaLEdBQUlBLFVBQVcsT0FDSixjQUFjb25CLFFBQVVwbkI7V0FFbkMsV0FBV21uQixXQUFXLFNBQVNDLFNBQVdwbkIsVUFMbEI7U0FPNUJxbkI7OztXQUNJLElBQUlELE1BQVFwbkI7V0FDWixHQUFJb25CLFlBQVliLFFBQVMsV0FBV2MsYUFBYUQ7V0FDakQsV0FBV0QsV0FBV1gsa0JBSEk7U0FLOUJjOztvQkFDSSxXQUFXQSxhQUFhdG5CLGFBQWEsVUFEWDtTQUk5Qm1uQjs7O1dBQ0ksSUFBSUMsTUFBUXBuQjtXQUNaLEdBQUlBLFVBQVcsV0FDQW1uQixXQUFXLFNBQVNDO1dBRW5DLE9BQU8sY0FBY0EsUUFBVXBuQixVQUxQO1NBTzVCcW5COzs7V0FDSSxJQUFJRCxNQUFRcG5CO1dBQ1osR0FBSW9uQixjQUFhYixRQUFTLFdBQVdjLGFBQWFEO1dBQ2xELFdBQVdELFdBQVdYLGlCQUhJO1NBSzlCYzs7b0JBQ0ksV0FBV0EsYUFBYXRuQixhQUFhLFVBRFg7U0FJOUIsSUFBSWlzQjtTQUNKLFVBQVdBLFlBQVlBLDJCQUEyQjVGO1VBQU0scUJBQXFCNEYsWUFBWUE7U0FEekY7VUFFa0IsY0FBRUE7VUFBa0MsY0FBRUEsWUFBWUM7U0FFcEUsU0FBU0UsY0FBY3pqQixHQUNuQixPQUFPLFNBQVNBLE1BQU0wZCxJQUMxQjtTQUVBYzs7a0JBQTJDdmhCO1dBQ3ZDLElBQUkrQyxFQUFJLFdBQVcvQztXQUNuQixLQUFLLGNBQWMrQztZQUFJLFVBQ1RzYyxNQUFNLE9BQU90YztXQUUzQixHQUFJQSxNQUFPLE9BQU8sa0JBQWlCQTtXQUpuQyxJQUtJcEIsT0FBU3ZIO1dBQ2IsR0FBSSxnQkFBaUIsT0FBT3VIO1dBQzVCLE1BQU9vQixLQUFLdWpCO1lBQWUsQ0FDdkIza0IsU0FBUyxnQkFBZ0I0a0IsZUFDekJ4akIsS0FBS3VqQjtXQUVULE9BQU8sZ0JBQWdCRCxZQUFZdGpCLEdBWk47U0FjakMyZTs7U0FBbUNEOztTQUFtQ0Y7U0FFdEVBOztrQkFBNEN2aEI7V0FDeEMsSUFBSXltQixPQUNFLEVBQUUsV0FBV3ptQjtXQUNuQixLQUFLLGNBQWMrQztZQUFJLFVBQ1RzYyxNQUFNLE9BQU90YztXQUUzQixHQUFJQSxNQUFPLE9BQU8saUJBQWdCQTtXQUxsQyxJQU1JcEIsT0FBU3ZIO1dBQ2IsTUFBTzJJLEtBQUt1akI7WUFBZSxDQUN2QixHQUFJLG1CQUFvQix1QkFBdUI7Y0FBa0IsT0FBTzNrQjthQUN4RThrQixTQUFTLFVBQVU5a0IsT0FBUTRrQjthQUMzQjVrQixTQUFTLHVCQUF5QixpQkFBbUI4a0I7YUFDckQxakIsS0FBS3VqQjtXQUVURyxTQUFTLFVBQVU5a0IsT0FBUTBrQixZQUFZdGpCO1dBQ3ZDLE9BQU8sdUJBQXlCLGlCQUFtQjBqQixTQWZyQjtTQWlCbEMvRTs7U0FBb0NEOztTQUFvQ0Y7U0FFeEUsU0FBU21GLFFBQVE1bUIsRUFBRzVCLEVBQUdyQztXQUNuQnFDLElBQUksV0FBV0E7V0FDZjtZQUFVLE1BQUU7WUFBc0IsTUFBRTtZQUMzQixLQUFFeW9CLE1BQVEsUUFBVTdtQjtZQUNwQixLQUFFOG1CLE1BQVEsUUFBVTFvQjtZQUNsQjtZQUFZO1lBQ1gsUUFBRTlCO1lBQWMsUUFBRUE7WUFDbkI7V0FDWCxRQUFRLG1CQUFrQjtZQUFlLENBQ3JDNnFCLFVBQVUsVUFBVUosS0FBTU47YUFDMUJRLFNBQVM7YUFDVCxHQUFJSixNQUFPLFNBQ0VKLG9CQUFvQlE7YUFHakNHLFVBQVUsVUFBVUosS0FBTVA7YUFDMUJTLFNBQVM7YUFDVCxHQUFJSixNQUFPLFNBQ0VMLG9CQUFvQlM7YUFHakNILE9BQU9JO2FBQ1BILE9BQU9JO2FBQ1AsWUFBWSxHQUFHSCxPQUFRQztXQXJCM0IsSUF1Qkl6RSxJQUFNLEdBQUdvRSxVQUFlQyxpQkFBdUIsWUFBYTtXQUNoRSxJQUFXLElBQUZscEIsRUFBSWlFLGtCQUFtQmpFLE9BQVFBO1lBQVEsTUFDdEMsYUFBYTZvQixtQkFBbUIsT0FBTzVrQixPQUFPakU7V0FFeEQsT0FBTzZrQixHQUNYO1NBRUFoQixzQ0FDSSxPQUFPLG9CQURnQjtTQUczQkc7O1NBQTZCRDs7U0FBNkJGO1NBRTFEQTs7a0JBQXFDeGUsR0FDakMsT0FBTyxRQUFRM0ksS0FBTTJJLFdBQWFHLEVBQUdULEdBQUssT0FBT1MsSUFBSVQsQ0FBN0IsRUFERDtTQUczQmlmOztTQUE2QkQ7O1NBQTZCRjtTQUUxREE7O2tCQUFvQ3hlLEdBQ2hDLE9BQU8sUUFBUTNJLEtBQU0ySSxXQUFhRyxFQUFHVCxHQUFLLE9BQU9TLElBQUlULENBQTdCLEVBREY7U0FHMUJpZjs7U0FBNEJEOztTQUE0QkY7U0FFeERBOztrQkFBcUN4ZSxHQUNqQyxPQUFPLFFBQVEzSSxLQUFNMkksV0FBYUcsRUFBR1QsR0FBSyxPQUFPUyxJQUFJVCxDQUE3QixFQUREO1NBRzNCaWY7O1NBQTZCRDs7U0FBNkJGO1NBRTFEO1VBQWM7VUFBc0IsWUFBR2QsU0FBUUEsU0FBU0EsU0FBUUEsUUFBUTBHO1NBQ3hFLFNBQVNFLFNBQVN0a0I7V0FHZDtZQUFNLEVBQUVBO1lBQ0Y7b0JBQVMvQztlQUFpQkEsSUFBSW1uQjtzQkFDckJubkI7aUJBQWlCQSxJQUFJLE9BQU9tbkI7aUJBQy9Cbm5CLE9BQU9BLE9BQU95Z0IsT0FBTzJHO1dBQ2pDLE9BQU90bkIsTUFBS0EsQ0FDaEI7U0FFQSxTQUFTd25CLGlCQUFpQjlGLE1BQU9jO1dBQzdCLEdBQUksZUFBZWQ7WUFBYSxDQUM1QjtjQUFRLElBQUUsaUJBQWlCQSxNQUFPLFlBQVljO2NBQ3hDLEVBQUVpRjtjQUNGLEVBQUVBO2NBQ0YsRUFBRSxXQUFXakY7YUFDbkIsT0FBTyxZQUFZZCxlQUFtQjllLElBQU11RCxjQUFtQnFhLElBQU1yYTtXQUV6RSxVQUFZLGNBQ2hCO1NBRUFzYjs7O1dBQ0ksSUFBSXhlLEVBQUkzSTtXQUNSLEdBQUksWUFBWSxlQUFnQixJQUN4QixvQkFBb0I7V0FFNUIsR0FBSSxZQUFZLGlCQUFrQixPQUN2QjtXQUVYLE9BQU8sT0FBTyxpQkFBaUIySSxFQUFHLGtCQUFrQixVQVJ2QjtTQVVqQzJlOztTQUFtQ0Q7O1NBQW1DRjtTQUV0RSxTQUFTaUcsSUFBSXRrQixFQUFHVDtXQUNaUyxJQUFJLFdBQVdBLEdBQ2ZULElBQUksV0FBV0EsR0FDZixPQUFPLFVBQVVBLEdBQUtTLEVBQUlULENBQzlCO1NBQ0EsU0FBU2dsQixJQUFJdmtCLEVBQUdUO1dBQ1pTLElBQUksV0FBV0EsR0FDZlQsSUFBSSxXQUFXQSxHQUNmLE9BQU8sU0FBU0EsR0FBS1MsRUFBSVQsQ0FDN0I7U0FDQSxTQUFTaWxCLElBQUl4a0IsRUFBR1Q7V0FDWlMsSUFBSSxXQUFXQTtXQUNmVCxJQUFJLFdBQVdBO1dBQ2YsR0FBSSxTQUFTQSxHQUFJLE9BQU9TO1dBQ3hCLEdBQUksV0FBWSxPQUFPVDtXQUN2QixHQUFJLFdBQVksT0FBT1M7V0FDdkIsSUFBTSxFQUFFK2QsV0FBWWxsQixFQUFHMkc7V0FDdkIsTUFBTyxjQUFjO1lBQVksQ0FDN0IzRyxJQUFJLElBQUksU0FBU21ILEdBQUksU0FBU1Q7YUFDOUJTLElBQUksU0FBU25IO2FBQ2IwRyxJQUFJLFNBQVMxRzthQUNiNEcsSUFBSSxXQUFXNUc7V0FFbkIsTUFBTyxXQUFZLElBQ1gsU0FBUyxTQUFTbUg7V0FFMUI7WUFBRyxDQUNDLE1BQU8sV0FBWSxJQUNYLFNBQVMsU0FBU1Q7YUFFMUIsR0FBSSxVQUFVQSxHQUFJLENBQ2RDLElBQUlELEVBQUdBLElBQUlTLEVBQUdBLElBQUlSO2FBRXRCRCxJQUFJLFdBQVdTOztlQUNUO1dBQ1YsT0FBTyxXQUFhQSxFQUFJLFdBQVdQLEVBQ3ZDO1NBQ0EsU0FBU2dsQixJQUFJemtCLEVBQUdUO1dBQ1pTLElBQUksV0FBV0E7V0FDZlQsSUFBSSxXQUFXQTtXQUNmLE9BQU8sU0FBUyxJQUFJUyxFQUFHVCxhQUFhQSxFQUN4QztTQUNBLFNBQVNtbEIsWUFBWTFrQixFQUFHVDtXQUNwQlMsSUFBSSxXQUFXQTtXQUNmVCxJQUFJLFdBQVdBO1dBQ2YsSUFBUSxJQUFFLElBQUlTLEVBQUdULEdBQVMsS0FBRSxJQUFJUyxFQUFHVCxHQUN6QixNQUFFLGNBQWNvbEI7V0FDMUIsR0FBSUUsY0FBZSxPQUFPLFFBQVEsV0FBVyxnQkFBZ0JBO1dBRjdELElBR1csT0FBRSxPQUFPQSxNQUFPdEgsWUFDaEIsVUFBaUI7V0FDNUIsSUFBVyxJQUFGL2lCLElBQU9BLElBQUlzcUIsY0FBZXRxQjtZQUFLLENBQ3BDO2NBQVEsSUFBRXdxQixXQUFhRixPQUFPdHFCLEdBQUsraUI7Y0FDekIsTUFBRSxTQUFTLGdCQUFnQjBIO2FBQ3JDLFlBQVlDO2FBQ1osR0FBSUEsUUFBUUQsSUFBS0Q7V0FFckIsT0FBTyxRQUFRLGtCQUFrQnZtQixPQUFROGUsWUFDN0M7U0FFYyxTQUFWYSxVQUFzQitHLEtBQU0vRixLQUFNbkIsU0FBVUM7V0FDNUNELFdBQVdBLFlBQVlMO1dBQ3ZCdUgsT0FBTyxPQUFPQTtXQUNkLEtBQUtqSDtZQUFlLENBQ2hCaUgsT0FBTyxtQkFDUGxILFdBQVc7V0FFZixJQUFXLE9BQUVrSCxZQUNUM3FCLEVBQ1EsUUFBRSxTQUFTNGtCLE1BQ0o7V0FDbkIsSUFBSzVrQixNQUFPQSxJQUFJeWpCLGdCQUFpQnpqQixJQUFLLGVBQ25CeWpCLFNBQVN6akIsTUFBTUE7V0FFbEMsSUFBS0EsTUFBT0EsSUFBSUYsT0FBUUU7WUFBSyxDQUN6QixJQUFJaUYsRUFBSTBsQixLQUFLM3FCO2FBQ2IsR0FBSWlGLFVBQVc7YUFDZixHQUFJQSxLQUFLNGxCO2NBQWdCLEdBQ2pCQSxlQUFlNWxCLE1BQU0ybEI7ZUFBUyxDQUM5QixHQUFJM2xCLGFBQWEybEIsY0FBZTtnQkFDaEM7dUJBQVVqSjt3QkFBTTFjLHVDQUF1QzJmO1dBSW5FQSxPQUFPLFdBQVdBO1dBakJsQixJQWtCVyxVQUNJLFdBQUUrRjtXQUNqQixJQUFLM3FCLElBQUk4cUIsZUFBb0I5cUIsSUFBSTJxQixZQUFhM3FCO1lBQUssQ0FDL0MsSUFBSWlGLEVBQUkwbEIsS0FBSzNxQjthQUNiLEdBQUlpRixLQUFLNGxCO2NBQWdCLFlBQVksV0FBV0EsZUFBZTVsQjs7Y0FDMUQsR0FBSUE7ZUFBVyxDQUNoQixJQUFJOGxCLE1BQVEvcUI7Z0JBQ1osR0FBRyxVQUFnQjJxQixLQUFLM3FCLGNBQWNBLElBQUkycUI7Z0JBQzFDLFlBQVksV0FBVyxXQUFXSSxVQUFXL3FCOztlQUU1QyxVQUFVMmhCLE1BQU0xYztXQUV6QixPQUFPLG1CQUFtQnFsQixPQUFRMUYsS0FBTWtHLFdBckM1QjtTQXdDaEIsU0FBU0UsbUJBQW1CVixPQUFRMUYsS0FBTWtHO1dBQ3RDLElBQVEsSUFBRXZILFdBQWdCLElBQUVBLFdBQVl2akI7V0FDeEMsSUFBS0EsSUFBSXNxQixrQkFBbUJ0cUIsT0FBUUE7WUFBSyxDQUNyQ2lyQixNQUFNLFFBQVEsT0FBT2pyQixTQUFTa3JCLE1BQzlCQSxNQUFNLFVBQVV0RztXQUVwQixPQUFPa0csV0FBYSxhQUFlRyxHQUN2QztTQUVBLFNBQVNFLFVBQVVULE1BQU9qSDtXQUN0QkEsV0FBV0EsWUFBWUw7V0FDdkIsR0FBSXNILFFBQVFqSCxnQkFBaUIsT0FDbEJBLFNBQVNpSDtXQUVwQixhQUFhQSxXQUNqQjtTQUVBLFNBQVNILE9BQU9sbEIsRUFBR3VmO1dBQ2ZBLE9BQU8sT0FBT0E7V0FDZCxHQUFJO1lBQWUsQ0FDZixHQUFJLFdBQVk7YUFDaEIsVUFBVWpEO1dBRWQsR0FBSTtZQUFpQixDQUNqQixHQUFJLFdBQVk7YUFDaEIsR0FBSTtjQUNBO3NCQUNXOzt3QkFBb0IsWUFBWWpqQixLQUFNLFFBQU87MEJBQzNDZ0U7O2FBS2pCO2NBQUl5aEI7ZUFBTSxZQUFZemxCLEtBQU0sTUFBTTtpQkFDekJnRTthQUNUO2FBQ0EsY0FDVyxtQkFBb0J5aEI7V0FLbkMsSUFBSWlIO1dBQ0osR0FBSSxrQkFBa0Isa0JBQW1CLENBQ3JDQSxXQUNBL2xCLElBQUk7V0FFUixHQUFJO1lBQWUsQ0FDZixHQUFJLFdBQVk7YUFFaEI7cUJBQ1csWUFBWTNHLEtBQU0sTUFBTTt1QkFDdEIyYztnQ0FDRytQO1dBWHBCLElBY1EsT0FDQyxLQUFFL2xCLEVBQUdrbUI7V0FDZCxNQUFPLHFCQUFxQixnQkFBZ0IzRztZQUFZLENBQ3BEMkcsU0FBUyxZQUFZM0c7YUFDckIwRyxPQUFPQzthQUNQLElBQUliLE1BQVFhO2FBQ1osR0FBSTtjQUFvQixDQUNwQmIsUUFBUSxXQUFXQSxhQUNuQlksT0FBTzthQUVYLFNBQVM7V0FFYixTQUFTO1dBQ1QsY0FBZ0IseUJBQTJCRixJQUMvQztTQUVBLFNBQVNJLGFBQWFubUIsRUFBR3VmLEtBQU1uQjtXQUMzQixJQUFJVSxJQUFNLE9BQU85ZSxFQUFHdWY7V0FDcEIsUUFBUVQ7O2tCQUE2Qix1QkFBd0IvaEIsR0FDekQsT0FBTyxVQUFVQSxFQUFHcWhCLFNBRDJCO3VCQUd2RDtTQUVBSTs7a0JBQXlDTCxPQUNyQyxPQUFPLE9BQU85bUIsS0FBTThtQixNQURPO1NBSS9CTzs7a0JBQTJDUCxPQUN2QyxPQUFPLE9BQU85bUIsS0FBTThtQixNQURTO1NBSWpDUTs7a0JBQTJDUixPQUN2QyxPQUFPLE9BQU85bUIsS0FBTThtQixNQURTO1NBSWpDSzs7a0JBQTBDTCxNQUFPQztXQUM3QyxHQUFJRCxVQUFVamxCLFVBQVdpbEI7V0FDekIsR0FBSUEsYUFBYyxPQUFPLGFBQWE5bUIsS0FBTThtQixNQUFPQztXQUNuRDtZQUFNLEVBQUUvbUI7WUFBYyxFQUFFNEY7WUFBYyxJQUFFLE9BQU9BLElBQUk0QztZQUFXO1lBQWF3bEI7V0FDM0UsUUFBU3hsQjtZQUFRLENBQ2J3bEIsUUFBUSxPQUFPcG9CLEVBQUU0QyxJQUNqQitXLE9BQU8sWUFBWXlPLGdCQUFnQkE7V0FIdkMsSUFLSTdwQixLQUFPbkU7V0FDWCxPQUFPbUUsT0FBT29iLEdBVGM7U0FZaEM4SDs7a0JBQTRDUCxNQUFPQztXQUMvQyxHQUFJRCxVQUFVamxCLFVBQVdpbEI7V0FDekIsR0FBSUEsWUFBYSxPQUFPLGFBQWE5bUIsS0FBTThtQixNQUFPQztXQUNsRCxPQUFPLE9BQU8vbUIsV0FIZ0I7U0FNbENzbkIsa0NBQWtDRDtTQUVsQ0M7O1NBQWdDSDs7U0FBOEJFOztvQkFBOEMsT0FBTyxlQUFyQjtTQUU5RkY7O29CQUNJLE9BQU8sU0FBUyxtQkFEVztTQUcvQkEsa0NBQWtDQTtTQUVsQ0UsNENBQ0ksT0FBT3JuQixVQURzQjtTQUdqQ3FuQixvQ0FBb0NBO1NBQ3BDQzs7U0FBaUNBOztvQkFDN0IsT0FBTyxTQUFTLG1CQURpRDtTQUlyRSxTQUFTMEgsaUJBQWlCcHBCO1dBQ3RCLEdBQUksWUFBV0E7WUFBSSxDQUNmLElBQUlGLElBQUtFO2FBQ1QsR0FBSUYsTUFBTSxTQUFTQTtjQUNmLE9BQU9raEI7MkJBQTJCVSxhQUFhLE9BQU81aEI7MkJBQVUyaEIsYUFBYTNoQjthQUNqRixVQUFVdWYsNEJBQTRCcmY7V0FFMUMsSUFBSXpCLEtBQU95QjtXQUNYLEdBQUl6QixLQUFNeUIsSUFBSTtXQURkLElBRUlxcEIsTUFBUTtXQUNaLEdBQUlBO1lBQWtCLFVBQVVoSyw0QkFBNEI7V0FDNUQsR0FBSWdLO1lBQW9CLENBQ3BCLElBQUl4VSxJQUFNd1U7YUFDVixHQUFJeFUsZUFBZ0JBLE1BQU07YUFDMUJBLFFBQU9BO2FBQ1AsR0FBSUEsUUFBUSxTQUFTQSxVQUFTLFVBQVVBO2NBQU07cUJBQVV3Szs0Q0FBNEJ4SzthQUhwRixJQUlTLEtBQUV3VSxTQUNNLGFBQUU7YUFDbkIsR0FBSUM7Y0FBbUIsQ0FDbkJ6VSxPQUFPd1QsY0FBY2lCO2VBQ3JCakI7O2VBQU8sYUFBY2lCOztlQUFnQixXQUFXQTthQUVwRCxHQUFJelU7Y0FBUztxQkFBVXdLOzthQUN2QmdKLFFBQVEsSUFBS2pvQixNQUFNeVU7YUFDbkI3VSxJQUFJcW9CO1dBakJSLElBbUJJa0IsUUFBVSx1QkFBdUJ2cEI7V0FDckMsS0FBS3VwQixRQUFTLFVBQVVsSyw0QkFBNEJyZjtXQUNwRCxHQUFJZ2hCO1lBQXNCLFdBQ1hVLGFBQWEsT0FBT25qQixXQUFheUIsRUFBSUE7V0F0QnBELElBd0JNLEtBQVUsSUFBRUEsU0FBWSxFQUFFMGdCLFNBQWMsSUFBRThHLE1BQU01a0I7V0FDdEQsTUFBTzRrQjtZQUFTLENBQ1osU0FBUSxRQUFRQyxJQUFLRCxNQUNyQkMsT0FBTzdrQixFQUNQLEdBQUk2a0IsUUFBU0EsUUFDYkQsT0FBTzVrQjtXQUVYLEtBQUtJO1dBQ0wsV0FBV3VlLFdBQVd2ZSxFQUFHekUsS0FDN0I7U0FFQSxTQUFTaXJCLGlCQUFpQnhwQjtXQUN0QixHQUFJZ2hCLHFCQUFzQixXQUNYVSxhQUFhLE9BQU8xaEI7V0FFbkMsR0FBSSxVQUFVQTtZQUFJLENBQ2QsR0FBSUEsTUFBTSxTQUFTQSxHQUFJLFVBQVVxZixNQUFNcmY7YUFDdkMsV0FBV3loQixhQUFhemhCO1dBRTVCLE9BQU8saUJBQWlCLGFBQzVCO1NBRUEsU0FBU3FoQixXQUFXcmhCO1dBQ2hCLFVBQVdBLGVBQWdCLE9BQ2hCLGlCQUFpQkE7V0FFNUIsVUFBV0EsZUFBZ0IsT0FDaEIsaUJBQWlCQTtXQUU1QixVQUFXQSxlQUFnQixXQUNaMGhCLGFBQWExaEI7V0FFNUIsT0FBT0EsQ0FDWDtTQUVBLElBQVcsSUFBRnRDLElBQU9BLFNBQVVBO1VBQUssQ0FDM0J1akIsUUFBUXZqQixLQUFLLFdBQVdBLEdBQ3hCLEdBQUlBLE1BQU91akIsVUFBU3ZqQixLQUFLLGFBQVlBO1NBR3pDdWpCLGNBQWNBO1NBQ2RBLGVBQWVBO1NBQ2ZBLG1CQUFtQkE7U0FDbkJBLGNBQWN1RztTQUNkdkcsY0FBY3dHO1NBQ2R4RyxjQUFjeUc7U0FDZHpHLGNBQWMwRztTQUNkMUc7O2tCQUErQm5oQjtXQUFLLE9BQU9BLGFBQWF5aEI7O2tCQUFjemhCLGFBQWEyaEI7O2tCQUFnQjNoQixhQUFhNGhCLFlBQTNGO1NBQ3JCVCxzQkFBc0IyRztTQUV0QjNHOztrQkFBOEIrRyxPQUFRMUYsS0FBTWtHO1dBQ3hDLE9BQU87b0JBQW1CLFdBQVduSCxZQUFhLFdBQVdpQixZQUFha0csV0FEMUQ7U0FJcEIsT0FBT3ZILE9BbjZDRzs7SUNJZCxTQUFTd0ksZUFBZTNwQjtNQUN0QixJQUFJNUIsRUFBSSxtQkFDUixHQUFHLFNBQVMsT0FBT0EsSUFBSyxPQUFPQSxFQUMvQixPQUFPNEIsQ0FDVDtJQXFLQSxTQUFTNHBCLGlCQUFpQnZMLEdBQUl3TDtNQUM1QixPQUFPLGVBQWUsT0FBT3hMLGVBQWV3TCxLQUM5QztJRmxJQSxTQUFTQyxlQUFnQm5tQixJQUFLaVM7TUFDNUIsSUFBSXJOLE1BQVFqSSxNQUFNc1Y7TUFDbEJyTixPQUFLNUU7TUFDTCxJQUFXLElBQUYvRixJQUFPQSxLQUFLZ1ksS0FBTWhZLElBQUsySyxFQUFFM0s7TUFDbEMsT0FBTzJLLENBQ1Q7SWI1Q0EsU0FBU3doQiwwQkFBMEJDLElBQ2pDLE9BQU9BLGNBQ1Q7SUZ1YUEsU0FBU0Msd0JBQXdCanFCLEVBQUc1QjtNQUNoQyxHQUFJNEIsVUFBVTVCLFFBQVMsU0FDdkIsR0FBSTRCLFVBQVU1QixRQUFTLFdBQ3ZCLFFBQ0o7SWZ2VnVCLFNBQW5COHJCLG1CQUErQmxxQixFQUFHNUI7TUFDbEMsUUFBVyxJQUFPLEVBQUU0QixTQUFVcEMsSUFBSWtGLEVBQUdsRixJQUFLLEVBQ3BDQSxLQUFLUSxFQUFFUixFQUZRO0lBNER6QixJQUFJdXNCLHFCQUF1QnZxQjtJQXNERSxTQUF6QndxQix5QkFBcUNwcUI7TUFDckMsbUJBQW1CQSxFQUFHLHFCQUFxQkEsR0FEaEI7SVNnSC9CLFNBQVNxcUIsc0NBQXNDQyxPQUM3QyxRQUNGO0lxQnJMQSxTQUFTQyxvQkFBb0JycUIsRUFBRXFHO01BQzdCLGdEQUNGO0lSdkdBLFNBQVNpa0IscUJBQXdCLFFBQVU7SUZ5RzNDLFNBQVNDLGlCQUFpQnJuQjtNQUN4QixJQUFRLElBQUVBLFNBQ0osTUFBTTlDLE1BQU1GO01BQ2xCdUM7TUFDQSxJQUFTLElBQUQvRSxJQUFJQSxJQUFFd0MsSUFBSXhDLElBQUsrRSxFQUFFL0UsU0FBT3dGLEVBQUV4RjtNQUNsQyxPQUFPK0UsQ0FDVDtJSWdEQSxTQUFTK25CLGFBQWExcUIsRUFBRTVCO01BQ3RCO09BQU0sRUFBRTtPQUNGLEdBQUM7T0FDRCxFQUFFd1k7T0FDRSxNQUFFdFY7TUFDWnJGLE9BQVEwdUI7TUFDUjF1QixPQUFRMHVCLGtCQUNSMXVCLE9BQVEwdUI7TUFDUjF1QjtNQUNBcUYsTUFBSXRCO01BQ0pzQixNQUFJbEQ7TUFDSix1QkFBdUJ3WSxHQUFHNVcsRUFBRXNCLFdBQVdsRDtNQUN2QyxRQUNGO0l4Qm84QzRDLFNBQXhDd3NCLHdDQUFvRHJrQixPQUFRNE0sSUFBS3pSO01BQ2pFLEdBQUk2RSxhQUFjLFNBQ0xwSyxlQUNOLFNBQ01vSztNQUViLE9BQU87ZUFBMkM7aUJBQW1EQSxPQUFRNE0sSUFBSyx3QkFBd0J6UixPQU5oRztJRS8xQzlDLFNBQVNtcEIsaUJBQWlCdnBCLEVBQUUxRCxFQUFFa3RCO01BQzVCLEdBQUlsdEIsV0FBVzBELFFBQVM7TUFDeEIsSUFBTyxVQUFTd3BCLFNBQ1QsVUFBU0E7TUFDaEIsc0JBQXVCeHBCLEVBQUcxRCxNQUFPNlQ7TUFDakMsc0JBQXVCblEsRUFBRzFELE1BQU84VDtNQUNqQyxRQUNGO0lBWUEsU0FBU3FaLGtCQUFrQnpwQixFQUFFMUQsRUFBRWt0QixLQUM3QixPQUFPLGlCQUFpQnhwQixFQUFFMUQsRUFBRWt0QixJQUM5QjtJQWtDQSxTQUFTRSxpQkFBaUIxcEIsRUFBRTFELEVBQUVxdEI7TUFDNUIsR0FBSXJ0QixXQUFXMEQsUUFBUztNQUN4QixJQUFJOEIsRUFBSSxvQkFBb0I2bkI7TUFDNUIsSUFBVSxJQUFGbG9CLElBQU9BLE1BQU9BLElBQUssc0JBQ0Z6QixFQUFHMUQsUUFBUW1GLEVBQUdLLEVBQUVMO01BRXpDLFFBQ0Y7SUZtdEMrQyxTQUEzQ21vQiwyQ0FBdURsckI7TUFDdkQsT0FBTztlQUFrQ0E7ZUFBR0o7ZUFBcUNBO2VBQXlCQTtlQUF5Q0E7ZUFBMkJBO2VBQWtDQSx3QkFEbks7SUE2UlosU0FBakN1ckIsaUNBQTZDaE8sTUFBTzZCO01BQ3BEN0IsUUFBUSwyQ0FBMkNBO01BQ25ENkIsUUFBUSw0QkFBNEJBO01BQ3BDLE9BQU8sNENBQTRDN0IsTUFBTzZCLE1BSHZCO0ljM3VEdkMsU0FBU29NLGlCQUFpQnByQjtNQUN4QixJQUFJNUIsRUFBSSxvQkFBb0I0QjtNQUM1QixPQUFPLHFCQUFxQjVCLEtBQU1BLEtBQU1BLEtBQU1BLEtBQU1BLEtBQU1BLEtBQU1BLEtBQU1BLE1BQ3hFO0laMGNBLFNBQVNpdEIsZ0JBQWdCL3BCLEVBQUcxRCxFQUFHa0YsRUFBR0Q7TUFDaEMsR0FBSUM7T0FBTyxHQUNMbEYsV0FBV2tGLEtBQUt4QixPQUFRQSxZQUEwQndCLEtBQUt4QjtRQUFjLEdBQ25FdUI7U0FBUSxDQUNWdkIsU0FDQUE7O1NBQ0ssQ0FDTEEsTUFBTSxnQkFBaUJ3QixFQUFHLG9CQUFvQkQsSUFDOUN2QixNQUFPd0IsS0FBS3hCOztRQUVULENBQ0wsR0FBSUEsU0FBc0IsNEJBQTRCQTtTQUN0RCxJQUFLd0IsS0FBS2xGLEVBQUdBLElBQUlrRixFQUFHbEYsSUFBSzBELElBQUkxRCxLQUFLaUY7TUFHdEMsUUFDRjtJQUlBLElBQUl5b0IsaUJBQW1CRDtJb0J6bEJ2QixTQUFTRSxnQkFBaUIsUUFBUTtJVW9LbEMsU0FBU0MsZ0JBQWdCbk4sR0FBSXdMO01BQzNCLE9BQU8sZUFBZSxPQUFPeEwsY0FBY3dMLEtBQzdDO0lyQkhBLFNBQVM0QixTQUFTaFksSUFBS2pDLElBQUtwUixJQUFLc3JCO01BQy9CLElBQUkzSSxPQUFVMkk7TUFDZCxJQUFVLElBQUY5dEIsSUFBT0EsSUFBSXdDLElBQUt4QztPQUFLLENBQzNCLElBQUlvQyxHQUFLeVQsU0FBU2pDLE1BQUk1VCxZQUFXbWxCO1FBQ2pDdFAsU0FBU2pDLE1BQUk1VCxLQUFLb0M7UUFDbEIsR0FBSUEsT0FBUSxDQUNWK2lCLFdBQ0EsV0FDSztNQUlULE9BQVFBLGVBQ1Y7SU5NQSxTQUFTNEksWUFBWXpaO01BQ25CLEdBQUc3WCxzQkFBc0JBO09BQTBCLE9BQzFDO01BRVQsc0JBQ0Y7SWV6REEsU0FBU3V4QixnQkFBZ0I1ckIsR0FBSyxTQUFRQSxDQUFHO0lwQmtMYixTQUF4QjZyQix3QkFBb0M3ckI7TUFDcEMsT0FBTyxnQkFBZ0IsbUNBQW1DQSxHQURoQztJaUN2UzlCLFNBQVM4ckIsNEJBQStCLFFBQVU7SWpDb0ZmLFNBQS9CQywrQkFBMkMvckIsR0FDM0MsT0FBSUEsTUFBTTdELGVBR0s2RCxFQUprQjtJQWsrREwsU0FBNUJnc0IsNEJBQXdDaHNCO01BQ3hDO09BQXdCLG9CQUFFQTtPQUNQLGVBQUVBO09BQ0kscUJBQUU3RDtNQUMzQixHQUFJMGYsd0JBQXdCMWYsYUFBYTJmLG1CQUFtQjNmO09BQVcsNkJBQ3BDMGYscUJBQXNCQztNQUV6RDtjQUNJLCtCQUErQkY7Y0FDL0I1YjtjQUNBQTtpQkFDSUE7Y0FDSkE7Y0FDQUE7Y0FDQUE7Y0FDQUE7aUJBQ0lBO2lCQUNBQTtpQkFDQUEsVUFsQnNCO0lBaURULFNBQXJCaXNCLHFCQUFpQ2pzQjtNQUNqQztjQUFXLDRCQUE0QkE7aUJBQVVBLFVBQVdBO2NBQVk7Z0JBQXdDQTtjQUF5REEsNEJBRGxKO0lxQjFoRTNCLFNBQVNrc0Isb0JBQW9CdGY7TUFDM0JBLEtBQUtBO01BQ0xBLElBQUksU0FBVUE7TUFDZEEsS0FBS0E7TUFDTEEsSUFBSSxTQUFVQTtNQUNkQSxLQUFLQTtNQUNMLE9BQU9BLENBQ1Q7SUxpWEEsU0FBU3VmLG9CQUFvQjVhLEdBQUlqQyxHQUFJcFA7TUFDbkMsSUFBSXNSLElBQU0sVUFBVWxDO01BQ3BCLEdBQUdrQyxXQUFXRCxlQUFnQjtNQUQ5QixJQUVJclIsRUFBSSxvQkFBb0JBO01BQzVCLElBQVUsSUFBRnRDLElBQU9BLE1BQU9BLElBQUssT0FBTzRULE1BQUk1VCxFQUFHc0MsTUFBSXRDO01BQzdDLFFBQ0Y7SWhCMG5CNEIsU0FBeEJ3dUIsd0JBQW9DdFI7TUFDcEMsT0FBTyx1QkFBdUJBLFFBQVNBLFFBRGI7SUFxQkQsU0FBekJ1Uix5QkFBcUNyUjtNQUNyQztlQUFXcGI7ZUFDUCx3QkFBd0JvYjtlQUN4Qix3QkFBd0JBO2VBQ3hCLHdCQUF3QkE7ZUFDeEIsd0JBQXdCQTtlQUN4Qix3QkFBd0JBO2VBQ3hCLHdCQUF3QkE7ZUFDeEIsd0JBQXdCQSxVQVJEO0lBdUJBLFNBQTNCc1IsMkJBQXVDaFI7TUFDdkM7ZUFBVzFiO2VBQ1AwYjtlQUNBLHlCQUF5QkE7ZUFDekIsd0NBQXdDQSxTQUpmO0lBNkJPLFNBQXBDaVIsb0NBQWdEcnNCLEVBQUdGO01BQ25ELE9BQU87ZUFBK0NFLEVBQUcsMkJBQTJCRixHQUQ5QztJa0MvbkMxQyxTQUFTd3NCLDZCQUFnQyxRQUFTO0l6QnNHbEQ7S0FBYztNQUFHO1NBQ2YsSUFBTSxFQUFFbnlCLFdBQ0MsYUFDQTtTQUVULEdBQUdvUixhQUNHQSxrQkFDQUE7VUFBMkIsQ0FDL0IsSUFBSWtoQixLQUFPbGhCLGVBRVhpaEIsT0FBT0MsUUFDUHJvQixPQUFPO1NBVlQsSUFhTSxFQUFFLHdCQUF3Qm9vQixNQUN0QixTQUFNbE07U0FDaEIsSUFBVSxJQUFGNWlCLElBQU9BLElBQUkwRyxZQUFhMUc7VUFDOUIsV0FBVyx3QkFBd0IwRyxLQUFLMUc7U0FDMUMsT0FBT2d2QixLQWxCUzs7S0F1Qk8scUJBQUVIO0lBdUIzQixTQUFTSyx5QkFBeUIxcEIsR0FDaEMsT0FBT3lwQixvQkFDVDtJZ0JxRUEsU0FBU0UsZUFBZ0Ivc0IsRUFBRzVCLEdBQUssVUFBUyxpQkFBaUI0QixFQUFFNUIsY0FBZ0I7SXpCeVB0RCxTQUFuQjR1QixtQkFBK0I5c0IsRUFBR3RDO01BQ2xDLElBQUk4akIsTUFBUXhoQixFQUFFdEM7TUFDZCxHQUFJOGpCLFVBQVV2bEI7T0FBVyxNQUNqQjs7O2VBQXdEeUI7Ozs7Z0JBQVdzQztNQUUzRSxZQUFXL0UsOEJBQTZCdW1CLE1BTG5CO0llN1d6QixTQUFTdUwsdUJBQXVCcnZCLEdBQzVCLE9BQVFBLFdBQ1o7SVlpVUEsU0FBU3N2QixxQkFBcUJycUIsRUFBRTNDLEdBQUssUUFBUztJTm5WOUMsU0FBU2l0QixzQkFBc0J2Z0IsRUFBR3RMO01BQ2hDLElBQVEsSUFBRUEsU0FBVTFELEVBQUdzYTtNQUN2QixJQUFLdGEsTUFBT0EsU0FBU3dDLElBQUt4QztPQUFRLENBQ2hDc2E7O1FBQUksYUFBYXRhOztRQUNaLGFBQWFBOzs7O1FBQ2IsYUFBYUE7Ozs7UUFDYixhQUFhQTs7O1FBQ2xCZ1AsSUFBSSxrQkFBa0JBLEVBQUdzTDtNQUUzQkE7TUFDQSxPQUFROVg7ZUFDQThYLElBQUssYUFBYXRhO2VBQ2xCc2EsS0FBSyxhQUFhdGE7ZUFFeEJzYSxLQUFLLGFBQWF0YSxHQUNsQmdQLElBQUksa0JBQWtCQSxFQUFHc0w7O01BRzNCdEwsS0FBS3hNO01BQ0wsT0FBT3dNLENBQ1Q7SUF1Q0EsU0FBU3dnQixxQkFBcUJ4Z0IsRUFBRzFNO01BQy9CLE9BQU8sc0JBQXNCME0sRUFBRyx1QkFBdUIxTSxHQUN6RDtJQXJDQSxTQUFTbXRCLHdCQUF3QnpnQixFQUFHdEw7TUFDbEMsSUFBUSxJQUFFQSxTQUFVMUQsRUFBR3NhO01BQ3ZCLElBQUt0YSxNQUFPQSxTQUFTd0MsSUFBS3hDO09BQVEsQ0FDaENzYSxJQUFJNVcsRUFBRTFELEtBQ0QwRCxFQUFFMUQsY0FDRjBELEVBQUUxRCxlQUNGMEQsRUFBRTFEO1FBQ1BnUCxJQUFJLGtCQUFrQkEsRUFBR3NMO01BRTNCQTtNQUNBLE9BQVE5WDtlQUNBOFgsSUFBSzVXLEVBQUUxRDtlQUNQc2EsS0FBSzVXLEVBQUUxRDtlQUNQc2EsS0FBSzVXLEVBQUUxRCxHQUNiZ1AsSUFBSSxrQkFBa0JBLEVBQUdzTDs7TUFHM0J0TCxLQUFLeE07TUFDTCxPQUFPd00sQ0FDVDtJbkI2cEJBLFNBQVMwZ0Isc0JBQXNCaHNCO01BQzdCLE9BQVFBO2dCQUVOLDZCQUE2QkEsVUFFN0IsT0FBT0E7ZUFFUCxPQUFPQTtTQUVYO0ltQmhxQkEsU0FBU2lzQixvQkFBb0IzZ0IsRUFBRzFNO01BQzlCLElBQUkyRCxRQUFVLHNCQUFzQjNEO01BQ3BDLGNBQVUyRDtlQUNELHNCQUFzQitJLEVBQUcvSTtlQUV6Qix3QkFBd0IrSSxFQUFHL0ksUUFDdEM7SUFjQSxTQUFTMnBCLFVBQVdDLE1BQU9DLE1BQU9DLEtBQU1uZTtNQUN0QyxJQUFJb2UsTUFBT0MsR0FBSUMsR0FBSXZZLEdBQUlzRCxJQUFLak0sRUFBRzFNLEVBQUd0QyxFQUFHd0M7TUFDckNtVixLQUFLbVk7TUFDTCxHQUFJblksVUFBVUEsU0FBVUE7TUFDeEJzRCxNQUFNNFU7TUFDTjdnQixJQUFJK2dCO01BQ0pDLFNBQVNwZTtNQUFNcWU7TUFBUUM7TUFDdkIsTUFBT0QsS0FBS0MsTUFBTWpWO09BQVMsQ0FDekIzWSxJQUFJMHRCLE1BQU1DO1FBQ1YsR0FBSTN0QixLQUFLQTtVQUFjO1lBQ2xCd1ksZ0JBQWdCeFk7O1lBQWtCd1ksZ0JBQWdCeFk7V0FBcUIsQ0FDeEUsSUFBSTZ0QixHQUFLLGdCQUFnQjd0QixvQkFBb0JBO1lBQzdDME0sSUFBSSxrQkFBbUJBLEVBQUdtaEI7WUFDMUJsVjs7U0FHQyxHQUFJM1ksYUFBYUksU0FBU0osVUFBVUE7VUFBUyxPQUN4Q0E7cUJBR04wTSxJQUFJLGtCQUFrQkEsRUFBRzFNLE1BQ3pCMlksTUFDQTtxQkFHQStVLFFBQVFDLE1BQU0zdEIsS0FDZDs7YUFFQSxJQUFJeUQsSUFBUXpELHFCQUF1QkE7YUFDbkMwTSxJQUFJLGtCQUFrQkEsRUFBR2pKO2FBQ3pCLElBQUsvRixNQUFPd0MsTUFBTUYsU0FBVXRDLElBQUl3QyxJQUFLeEM7Y0FBSyxDQUN4QyxHQUFJa3dCLE1BQU12WSxHQUFJLE1BQ2RxWSxNQUFNRSxRQUFRNXRCLEVBQUV0QzthQUVsQjs7VUFFRyxHQUFJLGlCQUFpQnNDO1dBQUksQ0FDOUIwTSxJQUFJLG9CQUFvQkEsRUFBRTFNLEdBQzFCMlk7O1dBQ0ssR0FBSSxrQkFBa0IzWTtZQUFJLENBQy9CME0sSUFBSSxxQkFBcUJBLEVBQUUxTSxHQUMzQjJZOztZQUNLLFVBQVczWTthQUFnQixDQUNoQzBNLElBQUksc0JBQXNCQSxFQUFFMU0sR0FDNUIyWTs7YUFDSyxHQUFJM1ksT0FBT0E7Y0FBTSxDQUV0QjBNLElBQUksa0JBQWtCQSxFQUFHMU0sSUFBRUEsT0FDM0IyWTs7Y0FDSyxHQUFJM1ksUUFBT0EsRUFBRyxDQUVuQjBNLElBQUksb0JBQW9CQSxFQUFFMU0sR0FDMUIyWTtNQUdKak0sSUFBSSxvQkFBb0JBO01BQ3hCLE9BQU9BLGNBQ1Q7SWNsSEEsU0FBU29oQixpQkFBaUIxc0IsR0FDeEIsT0FBTyxnQkFBZ0JBLEVBQ3pCO0lSeEdBLFNBQVMyc0IsZ0JBQWdCdFQsT0FBT3JaO01BQzlCO09BQVMsS0FBRW1aLGlCQUFpQkU7T0FDcEIsSUFBRSx1QkFBdUJyWjtPQUN4QixLQUFFLHNCQUFzQnVZO01BQ2pDLGdCQUFnQmUsWUFBYWYsTUFBUXFVO01BQ3JDdFQsZUFBZXNUO01BQ2YsUUFDRjtJUGlDQSxTQUFTQyxnQkFBZ0I3c0I7TUFDdkIsSUFBTSxFQUFFLG1CQUFtQkEsR0FDckIsRUFBRWpIO01BQ1IsR0FBSW9SLGFBQWFBLG9CQUFvQkE7T0FBd0IsdUJBQ3BDbks7O09BQ2xCLENBR0wsR0FBRyxhQUFhQSxvQkFDZEEsSUFBSSxXQUFXQTtRQUNqQixJQUFJcEIsRUFBSXVMO1FBQ1J2TCxLQUFLQSxXQUFXLFFBQVFvQixHQUU1QjtJQTdCQSxTQUFTOHNCLGdCQUFnQjlzQjtNQUN2QixJQUFNLEVBQUUsbUJBQW1CQSxHQUNyQixFQUFFakg7TUFDUixHQUFJb1IsYUFBYUEsb0JBQW9CQTtPQUF3Qix1QkFDcENuSzs7T0FDbEIsQ0FHTCxHQUFHLGFBQWFBLG9CQUNkQSxJQUFJLFdBQVdBO1FBQ2pCLElBQUlwQixFQUFJdUw7UUFDUnZMLEtBQU1BLFNBQVMsTUFBTW9CLEdBRXpCO0lPckJBLFNBQVMrc0IsdUJBQXVCQyxJQUFJQyxPQUFPam5CLEtBQUtrbkI7TUFDOUMsR0FBR3JwQix5QkFBeUJoSjtPQUFXZ0osMkJBQTJCN0U7TUFDbEVrdUIsUUFBTUEsTUFBTUE7TUFDWixJQUFJQztNQUNKQSxZQUFZbm5CO01BQ1ptbkIsY0FBY0QsYUFBYTtNQUMzQkMsYUFBYUQ7TUFDYkMsY0FBY0Y7TUFDZHBwQixxQkFBcUJtcEIsT0FBT0c7TUFDNUIsS0FBSXRwQixnQ0FBZ0NtcEIsTUFBTW5wQjtPQUN4Q0EsK0JBQStCbXBCO01BQ2pDLE9BQU9BLEdBQ1Q7SUFDQSxTQUFTSSxjQUFlbHpCLEtBQU1nekIsTUFBT0c7TUFDbkMsSUFBSXRyQjtNQUNKLE1BQU1tckI7T0FBTSxDQUNWLE9BQU9BO2lCQUNDbnJCLGFBQWE7aUJBQ2JBLGFBQWE7aUJBQ2JBLGFBQWE7aUJBQ2JBLGFBQWE7aUJBQ2JBLGVBQWU7aUJBQ2ZBLFdBQVk7aUJBQ1pBLGFBQWE7aUJBQ2JBLFdBQVc7aUJBQ1hBLGVBQWU7O1FBRXZCbXJCLFFBQU1BO01BRVIsR0FBR25yQixZQUFZQTtPQUNiO1NBQXFCLHVCQUF1QjdIOzs7TUFDOUMsR0FBRzZILFVBQVVBO09BQ1g7U0FBcUIsdUJBQXVCN0g7OztNQWxCOUM7T0FtQlMsS0FBRSxrQkFBa0JBO09BQ3BCLEtBQUUsaUJBQWlCeUcsVUFBVW9CO09BQzlCLElBQUU4Qiw2QkFBNkJBO01BQ3ZDLE9BQU8sdUJBQXdCbXBCLFFBQU1MLGdCQUFnQjNtQixLQUFLakUsRUFDNUQ7SUFDQTtRQUF5QjRxQixvQkFBcUI1bkIsV0FBVztJQUN6RDtRQUF5QituQixvQkFBcUIvbkIsV0FBVztJQUN6RDtRQUF5QjhuQixvQkFBcUI5bkIsV0FBVztJQThDekQsU0FBU3VvQiwyQkFBNEI3bUI7TUFDbkMsSUFBSStOLEtBQU8zUSxxQkFBcUI0QztNQUNoQyxHQUFHK04sa0JBQW1CLDZCQUE0Qi9OO01BRGxELElBRUk4bUIsT0FBU3Z5QjtNQUNiLEdBQUd5TCxXQUFXO09BQW9CLENBQ2hDLElBQUkrbUIsR0FBSztRQUNURDs7bUJBQ0UsT0FBTyx3QkFBd0IsMEJBRHhCO01BTFg7T0FRSUU7Y0FDR2paO2dCQUNFQTtZQUNKL047OztnQkFHSThtQjtNQUVUcFUsaUJBQWlCc1UsY0FBWUE7TUFDN0IsT0FBT0EsVUFDVDtJcEJqR0EsU0FBU0M7TUFDUCxvQkFBb0I3cEIsNkJBQ3RCO0lMaXVCQSxTQUFTOHBCLHFCQUFxQjN0QixHQUFLLE9BQU9BLENBQUU7SUE1UjVDLFNBQVM0dEIscUJBQXNCOXJCO01BQzdCLE9BQU8sdUJBQXVCLHlCQUF5QkEsSUFBSUEsVUFDN0Q7SWtDdGRBO0tBQUkrckI7TUFBaUI7U0FDbkIsU0FBUy9NLElBQUtwaUIsRUFBRzVCLEdBQUssT0FBUTRCLElBQUk1QixLQUFRO1NBQzFDLFNBQVNneEIsR0FBR3BpQixFQUFFNUosRUFBRVQsRUFBRTNDLEVBQUVzQixFQUFFc0I7V0FDcEJRLElBQUksSUFBSSxJQUFJQSxFQUFHNEosR0FBSSxJQUFJaE4sRUFBRzRDLElBQzFCLE9BQU8sSUFBS1EsS0FBSzlCLElBQU04QixXQUFZOUIsRUFBS3FCLEVBQzFDO1NBQ0EsU0FBUzBzQixHQUFHanNCLEVBQUVULEVBQUVFLEVBQUU1RyxFQUFFK0QsRUFBRXNCLEVBQUVzQixHQUN0QixPQUFPLEdBQUlELElBQUlFLE1BQVFGLElBQUsxRyxFQUFJbUgsRUFBR1QsRUFBRzNDLEVBQUdzQixFQUFHc0IsRUFDOUM7U0FDQSxTQUFTMHNCLEdBQUdsc0IsRUFBRVQsRUFBRUUsRUFBRTVHLEVBQUUrRCxFQUFFc0IsRUFBRXNCLEdBQ3RCLE9BQU8sR0FBSUQsSUFBSTFHLElBQU00RyxNQUFNNUcsRUFBS21ILEVBQUdULEVBQUczQyxFQUFHc0IsRUFBR3NCLEVBQzlDO1NBQ0EsU0FBU21yQixHQUFHM3FCLEVBQUVULEVBQUVFLEVBQUU1RyxFQUFFK0QsRUFBRXNCLEVBQUVzQixHQUFLLE9BQU8sR0FBR0QsSUFBSUUsSUFBSTVHLEVBQUdtSCxFQUFHVCxFQUFHM0MsRUFBR3NCLEVBQUdzQixFQUFJO1NBQ2xFLFNBQVNqRCxHQUFHeUQsRUFBRVQsRUFBRUUsRUFBRTVHLEVBQUUrRCxFQUFFc0IsRUFBRXNCLEdBQUssT0FBTyxHQUFHQyxLQUFLRixNQUFNMUcsR0FBS21ILEVBQUdULEVBQUczQyxFQUFHc0IsRUFBR3NCLEVBQUk7U0FFdkUsU0FBUzJzQixJQUFJcG5CLE9BQVF6SztXQUNuQixJQUFJRSxFQUFJRjtXQUNSeUssT0FBT3ZLLHdCQUF5QkE7V0FDaEMsSUFBS0EsS0FBS0EsZ0JBQWVBLGVBQWdCQTtZQUN2Q3VLLFFBQVF2SztXQUNWdUssUUFBUXZLLGVBQWNGO1dBQ3RCeUssT0FBT3ZLLFVBQVdGO1dBTGxCLElBT0l3YTtXQUVKLElBQUl0YSxNQUFPQSxJQUFJdUssY0FBZXZLO1lBQVMsQ0FDckMsSUFBTSxFQUFFc2EsS0FBUSxFQUFFQSxLQUFRLEVBQUVBLEtBQVEsRUFBRUE7YUFFdEM5VSxJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFDMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFDMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFDMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFFMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFDMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFDMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFDMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFFMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFDMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFDMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFDMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFFMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFDMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFDMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFDMUJ3RixJQUFJLEdBQUdBLEVBQUdULEVBQUdFLEVBQUc1RyxFQUFHa00sT0FBT3ZLO2FBQzFCM0IsSUFBSSxHQUFHQSxFQUFHbUgsRUFBR1QsRUFBR0UsRUFBR3NGLE9BQU92SzthQUMxQmlGLElBQUksR0FBR0EsRUFBRzVHLEVBQUdtSCxFQUFHVCxFQUFHd0YsT0FBT3ZLO2FBQzFCK0UsSUFBSSxHQUFHQSxFQUFHRSxFQUFHNUcsRUFBR21ILEVBQUcrRSxPQUFPdks7YUFFMUJzYSxPQUFPLElBQUk5VSxFQUFHOFU7YUFDZEEsT0FBTyxJQUFJdlYsRUFBR3VWO2FBQ2RBLE9BQU8sSUFBSXJWLEVBQUdxVjthQUNkQSxPQUFPLElBQUlqYyxFQUFHaWM7V0FuRmhCLElBc0ZJdFYsTUFBUXRDO1dBQ1osSUFBVyxJQUFGMUMsSUFBT0EsTUFBT0E7WUFDckIsSUFBVyxJQUFGbUYsSUFBT0EsTUFBT0EsSUFDckJILEVBQUVoRixRQUFRbUYsS0FBTW1WLEVBQUV0YSxVQUFXbUY7V0FDakMsT0FBT0gsQ0FDVDtTQUVBLGdCQUFpQnRCLEVBQUdrUSxJQUFLcFI7V0FHdkIsSUFBUSxPQUNJLFFBQUUsc0JBQXNCa0I7V0FDcEMsVUFBVXVDO1lBQXFCLENBQzdCLElBQUlsQixFQUFJa0I7YUFDUixJQUFXLElBQUZqRyxJQUFPQSxJQUFJd0MsSUFBS3hDO2NBQU0sQ0FDN0IsSUFBSW1GLEVBQUluRixJQUFJNFQ7ZUFDWmhMLElBQUk1STs7ZUFDRixhQUFhbUY7O2VBQU0sYUFBYUE7Ozs7ZUFDL0IsYUFBYUE7Ozs7ZUFBZSxhQUFhQTs7O2FBRTlDLEtBQU9uRixJQUFJd0MsSUFBS3hDO2NBQUs0SSxJQUFJNUksV0FBUyxhQUFhQSxJQUFJNFQsYUFBYzVUOztZQUM1RCxDQUNMLElBQUl3RixFQUFJUzthQUNSLElBQVcsSUFBRmpHLElBQU9BLElBQUl3QyxJQUFLeEM7Y0FBTSxDQUM3QixJQUFJbUYsRUFBSW5GLElBQUk0VDtlQUNaaEwsSUFBSTVJOztlQUFRd0YsRUFBRUw7O2VBQU1LLEVBQUVMOzs7O2VBQWNLLEVBQUVMOzs7O2VBQWVLLEVBQUVMOzs7YUFFekQsS0FBT25GLElBQUl3QyxJQUFLeEMsSUFBSzRJLElBQUk1SSxXQUFTd0YsRUFBRXhGLElBQUk0VCxhQUFjNVQ7V0FFeEQsT0FBTyxxQkFBcUIsSUFBSTRJLElBQUtwRyxLQXRCaEMsQ0E3R1k7O0lBTnJCLFNBQVNvdkIsZ0JBQWdCbHVCLEVBQUdrUSxJQUFLcFI7TUFDL0IsT0FBTyxlQUFlLHFCQUFxQmtCLEdBQUdrUSxJQUFJcFIsSUFDcEQ7SUFkQSxTQUFTcXZCLGNBQWM5VSxPQUFPdmE7TUFDNUIsSUFBUyxLQUFFcWEsaUJBQWlCRSxRQUNmLFNBQUU7TUFDZixHQUFHdmEsUUFBT0EsTUFBTXN2QixXQUFXOVU7TUFDM0IsR0FBR0EsY0FBY3hhLE1BQU1zdkIsU0FBVTtNQUhqQyxJQUlJbHBCLElBQU0sa0JBQWtCcEc7TUFDNUIsZUFBZXdhLFlBQVlwVSxNQUFNcEc7TUFDakMsT0FBTyxnQkFBZ0IscUJBQXFCb0csT0FBT3BHLElBQ3JEO0lUUkEsU0FBU3V2QixlQUFlNW5CLFdBQ2Y1QyxxQkFBcUI0QyxJQUM1QixRQUNGO0lBK1RBLFNBQVM2bkIsY0FBZWpWO01BQ3RCLElBQUlDLEtBQU9ILGlCQUFpQkU7TUFDNUIsS0FBS0MsWUFBYTtNQUNsQixLQUFJQSxlQUFlQSxrQkFBbUI7TUFDdEM7UUFBR0E7O1FBQ0d6VixxQkFBcUJ5Vjs7UUFDckJ6VixxQkFBcUJ5VjtPQUFpQixDQUMxQyxJQUFJMlQsT0FBU3BwQixxQkFBcUJ5VjtRQUNsQyxPQUFPMlQ7aUJBQ0MsT0FBTzVULE9BQU9DLGFBQWEsY0FDMUIsT0FBT0E7TUFHbEJBO01BQ0EsUUFDRjtJQXBMQSxTQUFTaVYsc0JBQXVCbFY7TUFDOUIsSUFBSUMsS0FBT0gsaUJBQWlCRTtNQUM1QixjQUFjQTtNQUNkQztNQUNBO01BQ0EsZUFBZUE7TUFDZixRQUNGO0lPN0lBLFNBQVNrVixZQUFZL25CO01BQ2pCLElBQUlnb0IsR0FBSywyQkFBMkJob0I7TUFDcEMsS0FDSSxPQUFPLGNBQWNnb0IsaUJBRXJCLHNCQUFzQkEsSUFFOUI7SUcvQkEsSUFBSUM7SUF3QkosU0FBU0MsY0FBY2p3QixFQUFHcEM7TUFDeEIsR0FBR0EsU0FBU295Qix1QkFBdUJweUIsS0FBS29DO09BQ3RDO01BQ0YsT0FBUUEsRUFBRWd3Qix1QkFBdUJweUIsT0FBTXpCOztlQUFhNkQsRUFBRWd3Qix1QkFBdUJweUIsRUFDL0U7SUE0Q0EsSUFBSXN5QixrQkFBb0JEO0lMbVB4QixTQUFTRSx5QkFBeUIzTixLQUFNbGhCO01BQ3RDLEdBQUlraEI7T0FBVyxDQUNiQTtRQUNBLElBQU0sSUFDRztRQUNULEdBQUdsaEIsRUFBRWtmLFVBQVcsQ0FBRS9oQixXQUFXK2hCLFNBQ3hCLEdBQUlsZixFQUFFa2YsVUFBVztRQUN0QixHQUFJbGYsRUFBRWtmO1NBQVcsQ0FDZkE7VUFDQSxHQUFJbGYsWUFBWWtmO1dBQUc7O1dBRVosQ0FDTCxJQUFJNFAsR0FBSzl1QixFQUFFa2Y7WUFDWCxHQUFJNFAsYUFBYUE7YUFBVzs7YUFFckIsR0FBSUEsYUFBYUE7Y0FBVzs7Y0FFNUIsR0FBSUEsYUFBYUEsVUFBVztZQUduQyxHQUFHNU4sV0FBWSxDQUNibGhCLElBQUksWUFBWWtmLE9BQ2hCLEdBQUcvaEIsWUFBWTZDLFVBQVVBO01BTWpDLEdBQUlBLFlBQWFBLElBQUk7TUFFckJBLElBQUk7TUFFSixHQUFHQSxZQUFZQSxRQUFTQTtNQUV4QixTQUFTZ25CLE1BQU1wa0I7UUFDYixHQUFHQSxjQUFjQSxXQUFZLE9BQU9BO1FBQ3BDLEdBQUdBLGNBQWNBLFlBQWEsT0FBT0E7UUFDckMsR0FBR0EsY0FBY0EsV0FBWSxPQUFPQSxjQUN0QztNQUNBLElBQUl0RztNQUNKLEdBQUcwRCxFQUFFMUQsVUFBV0E7TUFDaEIsS0FBT0EsSUFBSTBELFNBQVcxRDtPQUFJLENBQ3hCLElBQUlpRixFQUFJLE1BQU0sYUFBYWpGO1FBQzNCLEdBQUdpRixLQUFLMUcsYUFBYTBHLEtBQUsyZjtTQUN4QjtNQUVKLE9BQU8sZUFBZSxPQUFPbGhCLEVBQUdraEIsTUFFbEM7SUFLQSxTQUFTNk4sdUJBQXVCN04sS0FBTWxoQixFQUFHZixJQUFLSDtNQUM1Q2tCLElBQUksdUJBQXVCQTtNQUMzQixHQUFHZixZQUFZSCxPQUFPa0I7T0FBVSxDQUM5QixHQUFJQSxXQUFXZixNQUFNSDtTQUFLOztRQUcxQmtCLElBQUksUUFBUWYsSUFBSUEsTUFBSUg7TUFFdEIsT0FBTyx5QkFBeUJvaUIsS0FBTWxoQixFQUN4QztJaEMzWDZCLFNBQXpCZ3ZCLHlCQUFxQ0M7TUFDckM7T0FBVyxPQUFFLHFCQUFxQkE7T0FDeEIsV0FBTXAxQiw4QkFBNkJ1QztNQUM3QyxJQUFXLElBQUZFLElBQU9BLElBQUlGLE9BQVFFO09BQUssTUFFdkJBLEtBQUssc0JBQXNCMnlCLFlBQWEzeUI7TUFFbEQsT0FBTzJKLEtBUG9CO0lBb1lKLFNBQXZCaXBCLHVCQUFtQ0Q7TUFDbkMsT0FBTztlQUFrQyx5QkFBeUJBLGFBRHpDO0lBbTNCN0I7S0FBSUU7TUFBMkM3d0I7SUt4dEMvQyxTQUFTOHdCLGNBQWU7SWVrRXhCLFNBQVNDLDJCQUEyQkMsSUFBS0M7TUFFdkMsS0FBSUQsZ0JBQWdCQyxTQUFTRDtPQUFlQTs7WUFBbUJ2MkI7TUFDL0QsT0FBT3UyQixHQUNUO0lYMEpBLFNBQVNFLGdCQUFnQkMsT0FDdkIsUUFDRjtJQWlCQSxTQUFTQywyQkFBNkIsUUFBUztJVGloQy9DO0tBQUlDO01BQTJDcnhCO0lnQ2psQi9DLFNBQVNzeEIsbUJBQW1CN1MsR0FBSUM7TUFDOUJELEtBQUssT0FBT0E7TUFDWkMsS0FBSyxPQUFPQTtNQUNaO09BQVEsSUFBRSxXQUFXRCxHQUFHQztPQUNsQixFQUFFRDtPQUNGLEVBQUVDO09BQ0YsRUFBRTtPQUNFLE1BQUU7T0FDTixFQUFFO09BQ0UsTUFBRTtPQUNSdFI7T0FBR3BLO09BQUdNO01BQ1YsR0FBRyxVQUFVLFdBQVk7TUFHekIsUUFBTyxTQUFTO09BQVksQ0FDMUI4SixJQUFJLFNBQVNySztRQUNiTyxJQUFJLFdBQVcsV0FBV1A7UUFDMUJDLElBQUk1QztRQUNKQSxJQUFJLGVBQWUsV0FBV0E7UUFDOUJteEIsUUFBUXZ1QjtRQUNSQSxJQUFJeEU7UUFDSkEsSUFBSSxlQUFlLFdBQVdBO1FBQzlCZ3pCLFFBQVF4dUI7UUFDUlEsSUFBSVQ7UUFDSkEsSUFBSU87TUFFTixPQUFHLEtBQUs7a0JBQ0ksZUFBZSxZQUFZLGVBQWU7a0JBRTFDLGVBQWVFLEdBQUcsZUFBZSt0QixTQUMvQztJakIxV0EsU0FBU0UsMkJBQTJCaGEsT0FBUXpCO01BQ3hDQSxZQUNBLE9BQU8sZUFDWDtJT2pXQSxTQUFTMGIsNEJBQTRCcGYsTUFBUSxRQUFVO0lnQnpDdkQsU0FBU3FmLGVBQWVqd0I7TUFDdEJBLElBQUksdUJBQXVCQTtNQUMzQixJQUFNLEVBQUVBLGFBQ0YsTUFBTWhCLE1BQU13QztNQUNsQixJQUFXLElBQUZsRixJQUFPQSxJQUFJa0YsRUFBR2xGO09BQ3JCd0YsRUFBRXhGOztRQUFNLGlCQUFpQkEsS0FBTSxpQkFBaUJBOzs7OztNQUNsRCxPQUFPd0YsQ0FDVDtJN0JrVEEsU0FBU291QjtNQUNQLCtEQUNGO0lrQnRCQSxTQUFTQyxtQkFBbUI5VyxPQUFPcGE7TUFDakMsSUFBSXFhLEtBQU9ILGlCQUFpQkU7TUFDNUIsR0FBSUMsZUFBZXRlLEtBQU07TUFDekJzZSxjQUFjLG9CQUFvQnJhO01BQ2xDLFFBQ0Y7SUYxRUEsU0FBU214QixjQUFlMXhCLEVBQUc1QixHQUFLLFVBQVMsaUJBQWlCNEIsRUFBRTVCLGNBQWdCO0lWeks1RSxTQUFTdXpCLG9CQUFvQnpmLE1BQ3pCLFdBQVduRSxrQkFDZjtJaUIwREEsU0FBUzZqQixTQUFTdlQsSUFDaEIsT0FBTyxlQUFlLE9BQU9BLFVBQy9CO0laa0pBLFNBQVN3VCwyQkFBMkJ4dUI7TUFDbEM7UUFDRSxJQUFRLElBQUV5USxpQkFDRCxTQUFNeFQsTUFBTUY7UUFDckJrRSxVQUFVaEs7UUFDVixJQUFXLElBQUZzRCxJQUFPQSxJQUFJd0MsSUFBS3hDLElBQUswRyxLQUFLMUcsU0FBT2tXLFVBQVVsVztRQUNwRCxPQUFPLGNBQWN5RixFQUFFaUIsS0FMbEIsQ0FPVDtJQTVNQSxTQUFTd3RCLGFBQ1AsUUFDRjtJbUJoRkE7S0FBaUMsNkJBQUVoYTtLOUIrUHZCO01BQUd6ZDs7T0FDQUE7O09BQ0FBOzs7OztJSmpQZixTQUFTNDNCLGVBQWdCcnZCO01BQ3ZCO09BQU0sTUFBTXBHLEtBQU1vRztPQUNSLE1BQUU7T0FDSyxhQUFFLElBQUtwRyxLQUFLO09BQ3JCLElBQUUsWUFBWTAxQixRQUFRQztPQUN0QixRQUFNMzFCLEtBQUs7T0FDWCxRQUFNQSxLQUFLO09BQ0c7UUFBRSxTQUFTLHdCQUF5QjtNQUMxRDtjQUFnQjtjQUFnQjtjQUFnQjtjQUNuQztjQUFhO2NBQWM7Y0FDM0I7Y0FBWTQxQjtjQUNYLHdCQUF3Qkcsc0JBQ3hDO0llMEdBLFNBQVNDLG1CQUFtQnB2QixHQUMxQixPQUFPLFVBQ1Q7SUE4REEsU0FBU3F2QixrQkFBa0JscUIsRUFBR2xGLEVBQUdpQjtNQUMvQixPQUFPLEVBQUUsd0JBQXdCakIsVUFBVWtGLEVBQUcsbUJBQW1CakUsTUFDbkU7SWlCbkxBLFNBQVNvdUIsaUJBQWtCenZCO01BQ3pCLEdBQUlBLE1BQU87TUFDWCxJQUFJakQ7TUFDSkEsV0FBV2d3Qix1QkFBdUIvc0I7TUFDbEMsT0FBT2pELENBQ1Q7SUFvREEsSUFBSTJ5QixpQkFBbUJEO0l4QjZKdkIsU0FBU0UsY0FBZTV5QixFQUFHNUIsR0FBSyxPQUFPLEtBQUtBLEVBQUk7SUV4RGhELFNBQVN5MEIsc0JBQXNCN3lCLEVBQUc1QjtNQUM5QixXQUFXMmQsT0FBTyxjQUFjL2IsUUFBUzVCLFNBQzdDO0ltQnZIQSxTQUFTMDBCLHVCQUF1QkM7TUFDOUIsR0FBSTtPQUEyQzs7TUFJL0NBO01BQ0FBLG1CQUFrQkE7TUFDbEJBO01BQ0EsUUFDRjtJQUlBLFNBQVNDLGtCQUFrQjNWLFVBQVd6SDtNQUNsQyxHQUFJO09BQThDOztNQUlsRCxJQUFJcWQsY0FBZTVWLHNDQUFxQ3pIO01BQ3hELGFBQWEsdUJBQXdCQTtNQURyQztPQUVJc2Q7UUFBZ0Isc0JBQXNCN1YsZUFBZ0JBLGtCQUFtQnpILE1BQU9xZDtNQUNwRix1QkFBdUI1VjtNQUV2QixPQUFPNlYsYUFDWDtJZHhEQSxTQUFTQyxnQkFBZ0I5eUI7TUFDdkIsSUFBSXdDO01BQ0osTUFBTXhDLE9BQU9BO09BQWMsQ0FDekJBLE1BQU0sb0JBQW9CL0QsS0FBTStELGNBQ2hDd0M7TUFFRixPQUFPeEMsR0FDVDtJTGtEQSxTQUFTK3lCLHlCQUF5QngxQixHQUM5QixXQUFXbVEsT0FBT25RLEVBQ3RCO0lmNjBCc0IsU0FBbEJ5MUIsa0JBQThCNVYsT0FBUTdhLEVBQUdsQjtNQUN6QyxHQUFJK2IsYUFBYyxTQUNMdGhCLGVBQ04sU0FDTXNoQjtNQUViLE9BQU87ZUFBNkJBLE9BQVE3YSxFQUFHLHdCQUF3QmxCLE1BTm5EO0lnQ3YwQnhCLFNBQVM0eEIsU0FBU2pWLEdBQUlDO01BQ3BCQSxLQUFLLE9BQU9BO01BQ1osR0FBSSxVQUFVLFdBQVk7TUFHMUIsT0FBTyxlQUFlLE9BQU9ELFFBQVFDLElBQ3ZDO0lLdkVBLFNBQVNpVixjQUFjdnpCLEVBQUdwQyxFQUFHc0M7TUFDM0IsR0FBR3RDLFNBQVNveUIsdUJBQXVCcHlCLEtBQUtvQztPQUN0QztNQUNGQSxFQUFFZ3dCLHVCQUF1QnB5QixLQUFLc0M7TUFDOUIsUUFDRjtJbkNrS0EsU0FBU3N6QjtNQUNQLDRDQUNGO0lBc0NBLFNBQVNDLGtCQUFrQm55QixFQUFFMUQ7TUFDM0IsR0FBSUEsV0FBVyxzQkFBc0IwRCxPQUFRO01BQzdDO09BQU8sR0FBRSx1QkFBd0JBLEVBQUcxRDtPQUM3QixHQUFFLHVCQUF3QjBELEVBQUcxRDtPQUM3QixHQUFFLHVCQUF3QjBELEVBQUcxRDtPQUM3QixHQUFFLHVCQUF3QjBELEVBQUcxRDtNQUNwQyxPQUFRZ1UsV0FBV0QsV0FBV0QsVUFBVUQsRUFDMUM7SXNDdEtBLFNBQVNpaUIsdUJBQXVCQyxVQUM5QixPQUFPQSxxQkFDVDtJeEMrc0J5QixTQUFyQkMscUJBQWlDOXpCO01BQ2pDO09BQUlPO1FBQU07VUFBZ0MsMkJBQTJCUCxHQUFJRjtNQUN6RSxpQkFBaUJTO01BQ2pCLE9BQU9BLEdBSGdCO0llOW5CM0IsU0FBU3d6QixvQkFBb0I3ekIsRUFBRzVCO01BQzVCLEdBQUksaUJBQWtCO01BSXRCNEIsYUFBYUE7TUFDYjVCLGFBQWFBO01BQ2IsV0FBVzJkLE9BQU8sZ0JBQWdCM2Qsa0JBQ3RDO0lLVUEsU0FBUzAxQixhQUFhendCLEVBQUdrRixFQUFHakU7TUFBUSxPQUFPLFFBQVFpRSxFQUFHLG1CQUFtQmpFLE1BQVE7SVh5RGpGLFNBQVN5dkIsNEJBQStCLHlCQUEwQjtJVDBxQmhDLFNBQTlCQyw4QkFBMENoMEI7TUFDMUMsT0FBTztlQUFpQ0EsRUFBR0osMEJBQTJCQSxrQ0FEdEM7SUF5aUNFLFNBQWxDcTBCLGtDQUE4Q2owQjtNQUM3QixTQUFiZ0ssYUFBeUI5SjtRQUN6QixJQUFNLEVBQUVBLGFBQ0EsUUFBTUksTUFBTTJDO1FBQ3BCLElBQVcsSUFBRnJGLElBQU9BLElBQUlxRixJQUFLckY7U0FBRyxJQUNwQkEsS0FBSyw4QkFBOEJzQyxFQUFFdEM7UUFFN0MsT0FBTywrQkFBK0J5QyxJQU52QjtNQVNuQjtPQUFXLE9BQUUsYUFBYUw7T0FDZixPQUFFLDhCQUE4QkE7T0FDaEMsT0FBRSw4QkFBOEJBO01BQzNDLFlBQVdKLG9DQUFtQ2llLE9BQVFDLE9BQVFDLE9BYjFCO0lBbkRBLFNBQXBDbVcsb0NBQWdEbDBCO01BQzVCLFNBQWhCaWUsZ0JBQTRCQztRQUM1QixPQUFPO2lCQUEwQkE7aUJBQVMzVTtpQkFBNEIzSixrQ0FEcEQ7TUFHdEI7T0FBTyxHQUFFSTtPQUNDO1FBQUUsMkJBQTJCQSxLQUFNSjtPQUN0QyxHQUFFSTtPQUNGLEdBQUVBO09BQ0YsR0FBRSwyQkFBMkJBLEtBQU1KO09BQ2xDLElBQUV1ZTtPQUVFLFlBQU03ZCxNQUFNRjtPQUNaLFlBQU1FLE1BQU1GO01BQ3hCLElBQVcsSUFBRnhDLElBQU9BLElBQUl3QyxJQUFLeEMsSUFBSyxDQUMxQjRnQixRQUFRNWdCLEtBQUt1Z0IsR0FBR3ZnQixNQUNoQjZnQixRQUFRN2dCLEtBQUt1Z0IsR0FBR3ZnQjtNQVhwQixJQWFNLEVBQUUsZ0JBQWdCNGdCLFNBQ2xCLEVBQUUsZ0JBQWdCQztNQUN4QixZQUFXN2UsK0JBQThCa0QsRUFBR0ksRUFBR2tiLE1BQU9DLEdBQUlDLEdBQUlDLEdBbkJ4QjtJQTUyQ2YsU0FBdkI0Vix1QkFBbUNqMEI7TUFDbkMsT0FBTyx3Q0FBd0NBLEVBRHRCO0lBZzJDZSxTQUF4Q2swQix3Q0FBbURwMEIsR0FDbkQsT0FBT0EsQ0FEbUM7SUFxR2QsU0FBNUJxMEIsNEJBQXdDcjBCO01BQ3hDO09BQWEsU0FBRSxrQ0FBa0NBO09BQ3ZDLE1BQUUsb0NBQW9DQTtPQUN0QyxNQUFFLHdDQUF3Q0E7T0FDdkMsU0FBRUE7T0FDSCxRQUFFLHVCQUF1QkE7T0FDakIsZ0JBQUVBO09BQ1IsVUFBRWtMO09BQ1ksNkJBQU10TCx5QkFBd0JzZjtPQUNoQywwQkFBTTVlLE1BQU00ZTtNQUN0QyxJQUFXLElBQUZ0aEIsSUFBT0EsSUFBSXNoQixVQUFXdGhCO09BQUssQ0FDaEM7VUFBNkIsdUJBQXVCc04sZ0JBQWdCdE47UUFDcEV3aEIsc0JBQXNCeGhCOztRQUFTLDhCQUE4QnNOLGdCQUFnQnROO01BRWpGd2hCOztNQUF3QiwrQkFBK0JBO01BQ3ZEO2VBQVd4ZjtlQUE2QmdnQjtlQUFVWjtlQUFPNVQ7ZUFBTzZUO2VBQVVoVTtlQUFTa1U7ZUFBeUJDLHNCQWY5RTtJQTJERyxTQUFqQ2tWLGlDQUE2Q25YLE1BQU82QjtNQUNwRDdCLFFBQVEsMkNBQTJDQTtNQUNuRDZCLFFBQVEsNEJBQTRCQTtNQUNwQyxPQUFPLDRDQUE0QzdCLE1BQU82QixNQUh2QjtJZXArRHZDLFNBQVN1Vix1QkFBdUJ2MEIsRUFBRzVCLEdBQy9CLFdBQVcyUCxPQUFPL04sVUFBVTVCLFFBQ2hDO0lzQjBDQSxTQUFTbzJCLG9CQUFvQngwQixFQUFHcEMsR0FDOUIsT0FBTyxjQUFjb0MsRUFBR3BDLElBQzFCO0lHTUEsU0FBUzYyQixnQkFBZ0JDO01BQ3ZCO09BQUlmOztTQUNPLElBQUlnQixpQkFBa0JDLFNBQzdCLGdCQUFnQkEsUUFERztxQkFHSGxUO2NBQ2RpUyxpQkFBaUJqUyxNQUNqQmlTLDRCQUZJO29CQUlXMXJCO2FBQ2YwckIsaUJBQWlCMXJCO2FBQ2pCMHJCO2FBQ0FBO2FBQ0EsTUFBTTFyQixHQUpEOzs7TUFTWCxPQUFPMHJCLFFBQ1Q7SVI3SEEsU0FBU2tCLG1CQUFtQjcwQixFQUFFNUIsR0FDNUIsSUFBSTAyQixFQUFJOTBCLElBQUU1QixFQUNWLE9BQU8wMkIsTUFBTUEsTUFDZjtJRzhIQSxTQUFTQyxnQkFBZ0IvMEIsR0FDdkIsUUFDRjtJWCtLQSxTQUFTZzFCLGtCQUFrQkM7TUFDekIsSUFBSTN6QixFQUFJO01BQ1I7TUFDQSxpQkFBaUIyekIsU0FBUzN6QixXQUFXMnpCO01BQ3JDLElBQVUsSUFBRnIzQixJQUFPQSxJQUFJcTNCLFVBQVdyM0I7T0FDNUIsaUJBQWlCcTNCLEdBQUdyM0IsTUFBTTBELFdBQVcyekIsR0FBR3IzQjtNQUMxQyxpQkFBaUJxM0IsU0FBUzN6QixXQUFXMnpCO01BQ3JDO01BQ0EsUUFDRjtJRjVUQSxTQUFTQyxxQkFDUCwwQ0FDRjtJRXFlQSxTQUFTQztNQUNQLHFEQUNGO0l4Qnl3QkE7S0FBSUM7TUFBMEN4MUI7SThCcm5DOUMsU0FBU3kxQix5QkFBeUI5c0IsR0FBSyxRQUFVO0luQmxFakQsU0FBUytzQixjQUFjN2hCLElBQUtqQyxLQUMxQixPQUFPaUMsU0FBU2pDLElBQ2xCO0lpQnJCQSxTQUFTK2pCLGdCQUFnQnBWLEdBQUlwYSxHQUFJcWEsR0FBSW5hLEdBQUk3RjtNQUN2QyxHQUFJNkYsTUFBTUY7T0FBSSxJQUNELElBQUZoRCxJQUFPQSxLQUFLM0MsSUFBSzJDLElBQUtxZCxHQUFHbmEsS0FBS2xELEtBQUtvZCxHQUFHcGEsS0FBS2hEOztPQUMvQyxJQUNNLElBQUZBLEVBQUkzQyxJQUFLMkMsT0FBUUEsSUFBS3FkLEdBQUduYSxLQUFLbEQsS0FBS29kLEdBQUdwYSxLQUFLaEQ7TUFFdEQsUUFDRjtJNUIwcEJpQyxTQUE3Qnl5Qiw2QkFBeUMxMUI7TUFDekMsT0FBTztlQUEyQjtpQkFBd0M7bUJBQTJCQSxHQUFJRixvQ0FEMUU7SUk1aUJuQyxTQUFTNjFCO01BQ1AsT0FBTyx1QkFBdUJyekIsaUJBQ2hDO0lKNUc4QixTQUExQnN6QiwwQkFBc0MxMUI7TUFDdEMsT0FBTyx3QkFBd0IscUNBQXFDQSxHQUR4QztJb0JxR2hDLFNBQVMyMUIsc0JBQXNCN3lCO01BQzdCLElBQUlNLEtBQ0osS0FBTU4sUUFBU0EsSUFBSUEsS0FBTSxPQUNoQkEsTUFFVCxPQUFPTSxDQUNUO0lSd1JBO0tBQTRCO0tBYVI7TUFBRTtTQUNwQixTQUFTMHlCLFNBQVl4N0IsZUFBaUI7U0FDdEN3N0I7Ozs7Ozs7O21CQUVrQmxnQixLQUFNOEw7WUFDcEIsSUFBVyxJQUFGOWpCLEVBQUlnWSxTQUFTaFksT0FBT0E7YUFDM0J0RCxXQUFXQSxvQkFBcUJvbkIsU0FBUzlqQixRQUZ2Qzs7bUJBSWEyQyxJQUFLcVYsS0FBTThMO1lBQzVCLElBQUluaEIsSUFBTUE7WUFDVixJQUFXLElBQUYzQyxFQUFJZ1ksU0FBU2hZLE9BQU9BO2FBQzNCdEQsV0FBV2lHLFNBQVVtaEIsU0FBUzlqQixRQUh6Qjs7bUJBS1lnWSxLQUFNMVIsS0FBTXdkO1lBQy9CcG5CLFdBQVdBLG9CQUFvQjRKO1lBQy9CLElBQVcsSUFBRnRHLEVBQUlnWSxTQUFTaFksT0FBT0E7YUFDM0J0RCxXQUFXQSxvQkFBcUJvbkIsU0FBUzlqQixRQUhsQzs7bUJBS1kySTtZQUNyQixHQUFJQTthQUFtQix1QkFBOENBOzthQUNoRSxHQUFJQTtjQUFvQix3QkFBZ0RBOztjQUN4RSx3QkFBZ0RBLE9BSDFDO3lCQUtLLE9BQU9qTSxjQUFyQjs7O1lBRUZBLGlCQUFpQkE7WUFDakJBO1lBQ0E7WUFDQSxjQUFnQkE7WUFDaEIsY0FBZ0JBO1lBQ2hCLGNBQWdCQTtZQUNoQixjQUFnQkE7WUFDaEIsT0FBT0EsVUFSQTtTQVdYLGdCQUFpQjRGLEVBQUdzdUI7V0FDbEJBLFFBQVEsc0JBQXNCQTtXQUU5QjtZQUFlLFdBQUc7WUFDTCxTQUFJO1dBR2pCLEdBQUl3SDtZQUNGOztXQUxGO1lBT1csV0FBTUY7WUFDUDtZQUNXLGlCQUFFQyxXQUFhejVCLFNBQVc0UDtXQUUvQyxTQUFTZ3FCLEtBQUtoMkI7YUFDWixHQUFJNjFCLFdBQVk7YUFDaEIsSUFBSUksZ0JBQWtCLHdCQUF3QmoyQjthQUM5QyxHQUFJaTJCO2NBQWlCLENBQUUsb0JBQW9CQSxpQkFBa0I7O2NBQ3hELENBQUUsdUJBQXVCajJCLEdBQUksYUFDcEM7V0FFQSxTQUFTazJCLFdBQVlsMkI7YUFDbkIsR0FBSUE7Y0FBZSxDQUNqQixHQUFJLEtBQUtBLEdBQUk7ZUFDYjtnQkFBUyxLQUFFQTtnQkFDSCxJQUFFd1ksZ0JBQWdCbGQ7Z0JBQ2I7ZUFDYixLQUFJNjZCO2dCQUNGO2VBQ0YsR0FBR1Q7Z0JBQXlCLENBQzFCO2lCQUNBLElBQVcsSUFBRmg0QixJQUFPQSxJQUFJcEMsWUFBYW9DO2tCQUMvQixlQUFpQixnQkFBZ0JBO2lCQUNuQztpQkFDQSxjQUFjMFgsT0FBUXBWLEVBQUdvMkI7O2dCQUNwQixHQUFHRCxvQkFBb0JsNkI7aUJBQVUsQ0FDdEM7a0JBQ0EsSUFBVyxJQUFGeUIsSUFBT0EsSUFBSXBDLFlBQWFvQzttQkFDL0IsZUFBaUIsZ0JBQWdCQTtrQkFDbkM7a0JBQ0EsSUFBSTI0QixXQUFhO2tCQUNqQixJQUFVLElBQUYzNEIsSUFBT0EsT0FBUUEsSUFBSztrQkFHNUIsY0FBYzBYLE9BQVFwVixFQUFHbzJCO2tCQUN6QixnQkFBZ0JDLGNBQWdCRDtrQkFDaEMsZ0JBQWdCQztrQkFDaEIsZ0JBQWdCQSxrQkFBb0JEOztpQkFDL0IsQ0FDTDtrQkFDQSxJQUFXLElBQUYxNEIsSUFBT0EsSUFBSXBDLFlBQWFvQzttQkFDL0IsZUFBaUIsZ0JBQWdCQTtrQkFDbkM7a0JBQ0EsSUFBSTQ0QixRQUFVO2tCQUNkLGNBQWNsaEIsT0FBUXBWLEVBQUdvMkI7a0JBQ3pCLEdBQUlELG9CQUFvQixlQUFlRzttQkFDckM7MkVBQW9FaDdCO2VBRXhFOFosdUJBQXdCZ2hCO2VBQ3hCaGhCLHVCQUF3QmdoQjs7Y0FFckIsR0FBSXAyQixhQUFhSSxTQUFTSixVQUFVQTtlQUFTLENBQ2hELEdBQUlBO2lCQUFhO2dCQUdqQixHQUFJQSxnQkFBZ0IsS0FBS0EsR0FBSTtnQkFDN0IsR0FBSUEsYUFBYUE7aUJBQ2Ysc0JBQW1EQSxRQUFTQTs7aUJBRTVELDBCQUFtREEscUJBQXFCQTtnQkFDMUVvVixrQkFBa0JwVjtnQkFDbEJvVixrQkFBa0JwVjtnQkFDbEIsR0FBSUEsYUFBYyxXQUFZQTs7ZUFDekIsR0FBSSxpQkFBaUJBO2dCQUFJLENBQzlCLEtBQUssaUJBQWlCO2tCQUE4Qjs7aUJBR3BELEdBQUksS0FBS0EsR0FBSTtpQkFDYixJQUFJRSxJQUFNLHFCQUFxQkY7aUJBQy9CLEdBQUlFO2tCQUNGLHNCQUFvREE7O2tCQUNqRCxHQUFJQTttQkFDUCx5QkFBZ0RBOzttQkFFaEQsMEJBQW1EQTtpQkFDckQsSUFBVyxJQUFGeEMsSUFBTUEsSUFBSXdDLElBQUl4QztrQkFDckIsZUFBaUIsc0JBQXNCc0MsRUFBRXRDO2lCQUMzQzBYLHdCQUF5QmxWO2lCQUN6QmtWLHdCQUF5QmxWOztnQkFDcEIsR0FBSSxrQkFBa0JGO2lCQUFJLENBQy9CLElBQUlFLElBQU0sc0JBQXNCRjtrQkFDaEMsR0FBSUU7bUJBQ0Ysc0JBQW9EQTs7bUJBQ2pELEdBQUlBO29CQUNQLHlCQUFnREE7O29CQUVoRCwwQkFBbURBO2tCQUNyRCxJQUFXLElBQUZ4QyxJQUFNQSxJQUFJd0MsSUFBSXhDO21CQUNyQixlQUFpQix1QkFBdUJzQyxFQUFFdEM7a0JBQzVDMFgsd0JBQXlCbFY7a0JBQ3pCa1Ysd0JBQXlCbFY7O2lCQUNwQixHQUNERixNQUFNQTtrQkFBSyxDQUNiLElBQUl1MkIsaUJBQW1CdjJCO21CQVN2Qjt3REFBK0N1MkI7O2tCQUs1QyxHQUFJdjJCLFVBQVVBO21CQUFVLHNCQUNzQkE7O21CQUM1QyxHQUNEQSxtQkFBa0JBO29CQUNwQix5QkFBNkNBOztvQkFDMUMsR0FBSUEsb0JBQW1CQTtxQkFDMUIsMEJBQStDQTs7cUJBRS9DLDBCQUErQ0EsRUFHdkQ7V0FDQSxXQUFZQTtXQUNaLE1BQU9vWjtZQUFrQixDQUN2QixJQUFNLEVBQUUsWUFDRixFQUFFO2FBQ1IsR0FBSTFiLFFBQVFzQyxTQUFVLFdBQVlBLEVBQUd0QzthQUNyQyxXQUFZc0MsRUFBRXRDO1dBRWhCLEdBQUlxNEI7WUFBa0IzZ0IscUJBQXFCMmdCO1dBQzNDO1dBQ0EsT0FBTzNnQixZQTFJRixDQW5DYTs7SUFtTHRCLFNBQVNvaEIsNEJBQTZCeDJCLEVBQUdzdUI7TUFDdkMsT0FBTyxxQkFBc0IsZ0JBQWlCdHVCLEVBQUdzdUIsT0FDbkQ7SVJqY0EsU0FBU21JLHFCQUFxQm43QjtNQUM1QixxQkFBc0JBLDJCQUN4QjtJSmlrRUEsU0FBU283QjtNQUNMO2FBQVVyWDtrRkFDZDtJSy9zRUEsU0FBU3NYLFlBQVlDO01BQ25CLEdBQUc7T0FBcUIsQ0FDdEIsSUFBSUMsSUFBTSxlQUNWLE9BQU8sV0FBV0Q7O09BQ2IsUUFHVDtJTXJEQSxTQUFTRSxNQUFNaDNCO01BQ2IxRixpQkFBZ0JELHVCQUFzQjJGO01BR3RDMUYsY0FBY0Esb0JBQ2hCO0lBRUEwOEI7SUFrWUEsU0FBU0MsZ0JBQWdCNWYsT0FBUTlCO01BQy9CLElBQVEsSUFBRSxpQkFDRixRQUFNeWhCLE1BQU01MkI7TUFDcEIsSUFBVSxJQUFGeEMsSUFBT0EsSUFBSXdDLElBQUt4QyxJQUFJLFNBQ2pCQSxLQUFLO01BRWhCMlgsUUFBUW5WO01BQ1IsT0FBT3FULEdBQ1Q7SUExWkEsU0FBU3lqQjtNQUNQeGU7O21CQUNrQnVlLDBCQUNGOWMsbUJBQ0x6RyxjQUViO0lYdXhCeUIsU0FBckJ5akIscUJBQWlDcjNCO01BQ2pDLElBQUlPLElBQU0sZ0NBQWdDUDtNQUMxQyxPQUFPLDJCQUEyQk8sSUFGWDtJZ0J0WDNCLFNBQVMrMkIsY0FBYzdsQixHQUFJakMsSUFDekIsT0FBTyxPQUFPLFVBQVVBLElBQzFCO0lFN1hBLFNBQVMrbkIsc0JBQXNCQyxLQUFNQyxTQUFVQyxLQUFNQyxTQUFVQztNQUM3RCxJQUFXLElBQUY5NUIsSUFBT0EsSUFBSTg1QixNQUFPOTVCO09BQUssQ0FDOUI7U0FBTSxFQUFFLGNBQWMwNUIsS0FBS0MsV0FBVzM1QjtTQUNoQyxFQUFFLGNBQWM0NUIsS0FBS0MsV0FBVzc1QjtRQUN0QyxHQUFJd0YsSUFBSVQsRUFBRztRQUNYLEdBQUlTLElBQUlULEVBQUc7TUFFYixRQUNGO0lNeWNBLFNBQVNnMUIsdUJBQXVCdjBCLEVBQUVULEVBQUVFLEVBQUU1RztNQUNwQyx1REFDRjtJVDVkQSxTQUFTMjdCLG9CQUFvQjUzQixFQUFHNUIsR0FDNUIsV0FBVzJQLE9BQU8vTixVQUFVNUIsUUFDaEM7SWRxTkEsU0FBU3k1QixvQkFBcUI3M0IsRUFBRzVCO01BQy9CLEdBQUlBLE9BQVFBLFFBQVFBLEVBQ3BCNEIsSUFBSSxTQUFTQSxHQUNiLE9BQVE1QixRQUFTNEIsRUFBR0EsQ0FDdEI7SURzWnVCLFNBQW5CODNCLG1CQUErQjkzQjtNQUMvQixJQUFJSyxJQUFNLDhCQUE4Qkw7TUFDeEMsaUJBQWlCSztNQUNqQixPQUFPQSxHQUhjO0lxQzdpQnpCLFNBQVMwM0Isa0JBQWtCLzNCLEVBQUdwQyxFQUFHc0MsR0FDL0IsT0FBTyxjQUFjRixFQUFHcEMsS0FBT3NDLEdBQ2pDO0lyQ3RDNkIsU0FBekI4M0IseUJBQXFDaDRCLEVBQUdwQztNQUN4QyxPQUFPLGdCQUFnQixvQ0FBb0NvQyxFQUFHcEMsR0FEbkM7SUFrcUJaLFNBQWZxNkIsZUFBMkJqNEIsRUFBRzVCO01BQzlCLElBQUlpQyxJQUFNLDBCQUEwQkwsRUFBRzVCLEdBQ3ZDLGlCQUFpQmlDLEtBQ2pCLE9BQU9BLEdBSFU7SUVyTXJCLFNBQVM2M0IscUJBQXFCcHlCLEdBQUlFO01BQy9CRixZQUFhLDZCQUE2QkE7TUFDMUNFLFlBQWEsNkJBQTZCQTtNQUMzQyxPQUFRRixRQUFRRSxRQUNsQjtJQXFPQSxTQUFTbXlCLHNCQUFzQnJ5QixHQUFJRSxJQUNqQyxPQUFPLHFCQUFxQkYsR0FBR0UsR0FDakM7SUEzTkEsU0FBU295Qix5QkFBeUJ0eUIsR0FBSUU7TUFDcEMsT0FBTyxzQkFBc0JBLEdBQUdGLEdBQ2xDO0lzQnhZQSxTQUFTdXlCLGlCQUNQLElBQUkvMkIsRUFBSSxvQkFDUixPQUFPQSxRQUNUO0l4QmlNQSxJQUFJZzNCLHNCQUF3QjE0QjtJMkJoRDVCLFNBQVMyNEIsZUFBZTVkLFFBQVMsT0FBT0YsaUJBQWlCRSxjQUFjO0lkakZ2RSxTQUFTNmQsZUFBZ0J4NEIsRUFBRzVCLEdBQUssT0FBTyxNQUFNQSxFQUFJO0lFbEdsRCxTQUFTcTZCLHlCQUF5Qjc2QjtNQUM5QixPQUFPO2VBQTJCQSxtQkFBcUJBLDRCQUMzRDtJQWhFQSxTQUFTODZCLG9CQUFvQjE0QixFQUFHNUI7TUFFNUIsSUFBUyxLQUFFLHlCQUF5QjRCLEdBQzNCLEtBQUUseUJBQXlCNUI7TUFDcEMsV0FBVzJQLE9BQVEsb0JBQW9CLGVBQWU0cUIsS0FBTUMsT0FDaEU7SWZvNERzQyxTQUFsQ0Msa0NBQThDNzRCO01BQzdCLFNBQWJnSyxhQUF5QjlKO1FBQ3pCO1NBQU0sRUFBRSwrQkFBK0JBLEVBQUdOO1NBQ2xDO1FBQ1IsSUFBVyxJQUFGaEMsSUFBT0EsSUFBSXdGLFdBQVl4RjtTQUFHLFNBRXRCLDhCQUE4QndGLEVBQUV4RjtRQUU3QyxPQUFPeUMsR0FQUTtNQVVuQjtPQUFXLE9BQUUsYUFBYUw7T0FDZixPQUFFLDhCQUE4QkE7T0FDaEMsT0FBRSw4QkFBOEJBO01BQzNDO01BQ0EsVUFBVzZkLE9BQVFDLE9BQVFDLE9BZlM7SUE3Q0EsU0FBcEMrYSxvQ0FBZ0Q5NEI7TUFDNUIsU0FBaEJpZSxnQkFBNEJDO1FBQzVCLE9BQU87aUJBQTBCQTtpQkFBU3RlO2lCQUF3QkM7dUJBRGhEO01BR3RCO09BQU0sRUFBRSxnQkFBZ0JHO09BQ2xCLEVBQUUsZ0JBQWdCQTtPQUNkLE1BQUUsMkJBQTJCQTtPQUNoQyxHQUFFQTtPQUNGLEdBQUVBO09BQ0YsR0FBRSwyQkFBMkJBO01BQ3BDO01BTkEsSUFPSUksSUFBTTBDO01BQ1YsR0FBSTFDLFFBQVE4QyxTQUFVLFVBQVlxYztNQVJsQyxJQVNJcEIsT0FBUzdkLE1BQU1GO01BQ25CK2Q7TUFDQSxJQUFXLElBQUZ2Z0IsSUFBT0EsSUFBSXdDLElBQUt4QztPQUFLLENBQzFCLElBQUk0aEIsVUFBWWxmO1FBQ2hCa2Y7UUFDQUEsV0FBVzFjLEVBQUVsRjtRQUNiNGhCLFdBQVd0YyxFQUFFdEY7UUFDYnVnQixHQUFHdmdCLEtBQUs0aEI7TUFFWixVQUFXckIsR0FBSUMsTUFBT0MsR0FBSUMsR0FBSUMsR0F0QlE7SUE5M0NmLFNBQXZCd2EsdUJBQW1DNzRCO01BRW5DLE9BQU8sd0NBQXdDQSxLQUZ0QjtJQWcyQ2UsU0FBeEM4NEIsd0NBQW1EaDVCLEdBQ25ELE9BQU9BLENBRG1DO0lBbUhkLFNBQTVCaTVCLDRCQUF3Q2o1QjtNQUN4QztPQUFhLFNBQUUsa0NBQWtDQTtPQUN2QyxNQUFFLG9DQUFvQ0E7T0FDdEMsTUFBRSx3Q0FBd0NBO09BQ3pDLE9BQUUsd0NBQXdDQTtPQUN4QyxTQUFFQTtPQUNILFFBQUUsdUJBQXVCQTtPQUNULHdCQUFFQTtPQUNKO1FBQUU7VUFBK0JBLHdCQUF5Qko7T0FDdEUsVUFBRXdmO09BQ0ksb0JBQU05ZSxNQUFNNGU7TUFDaENoVTtNQUNBLElBQVcsSUFBRnROLElBQU9BLElBQUlzaEIsVUFBV3RoQjtPQUFLLENBQ2hDLElBQUl5QyxRQUFVQztRQUNkRDtRQUNBQSxTQUFTLHVCQUF1Qiw0QkFBNEJ6QztRQUM1RHlDLFNBQVMsOEJBQThCK2Usc0JBQXNCeGhCO1FBQzdEc04sZ0JBQWdCdE4sS0FBS3lDO01BRXpCLFVBQVd1ZixTQUFVWixNQUFPNVQsTUFBTzZULFNBQVVoVSxRQUFTQyxnQkFuQnhCO0lBd0JHLFNBQWpDaXVCO01BQTZDaGMsTUFBT2ljLGFBQWNsdUIsZ0JBQWlCbXVCO01BQ25GLElBQUluaEIsT0FBUXRZLHlCQUF3Qnc1QjtNQUNwQyxJQUFXLElBQUZ4N0IsSUFBT0EsSUFBSXc3QixvQkFBcUJ4N0I7T0FBSyxPQUNuQyx1QkFBdUJ3N0IsYUFBYXg3QjtNQUUvQ3c3QixlQUFlbGhCO01BQ2ZoTixrQkFBa0IsdUJBQXVCQTtNQUN6Q211Qjs7TUFBVztRQUEwQkEsU0FBVTl2QiwyQkFBNEIzSjtNQU4zRTtPQU9RO1FBQUU7VUFBNEN1ZCxNQUFPaWMsYUFBY2x1QixnQkFBaUJtdUI7T0FDbEYsTUFBRSw0QkFBNEJoNUI7TUFDeEMsT0FBTzJlLEtBVjRCO0lhL3lEdkMsU0FBU3NhLG1CQUFtQnQ1QixHQUFLLFNBQVEsVUFBWTtJc0J0SHJELFNBQVN1NUIsNkJBQTZCL1csS0FBTWdYO01BQzFDLElBQVEsSUFBRSw2QkFDRixLQUFHQyxJQUFLalgsS0FBTWlYLElBQUtBLEtBQ25CLElBQUVBO01BQ1YsUUFBUSxtQkFBbUJEO09BQVcsQ0FDcENFLFNBQVMsZUFBZUEsT0FBUUE7UUFDaENBLFNBQVMsZUFBZUEsT0FBUUE7UUFDaENBLFNBQVMsZUFBZUEsT0FBUUE7UUFDaENyNUIsTUFBTSxlQUFlQSxJQUFLcTVCLElBQUksZ0JBQWdCRjtRQUM5Q0EsV0FBVyxnQ0FBZ0NBO01BRTdDLE9BQU9uNUIsR0FDVDtJMUI0R0EsU0FBU3M1QiwyQkFBOEIsU0FBVztJTXVGbEQsU0FBU0MseUJBQXlCaDhCO01BQzlCQSxJQUFJQSxRQUNKLE9BQU8sMkJBQTJCQSxLQUFNQSxLQUFNQSxTQUNsRDtJaUIzUUEsU0FBU2k4QixTQUFTeGIsR0FBSUM7TUFDcEIsT0FBTyxlQUFlLE9BQU9ELGFBQWEsT0FBT0MsS0FDbkQ7SUEwdkJBLFNBQVN3YixjQUFjaEY7TUFDckJBLElBQUksT0FBT0E7TUFDWCxJQUFTLEtBQUUsVUFDSCxJQUFFO01BQ1YsR0FBSSxLQUFLaUYsTUFBTyxvQkFDTTtNQUh0QixJQUtJbjhCO01BQ0osSUFBS0EsUUFBUSxTQUFTbThCLE1BQU9uOEIsSUFBSyxJQUM1QixNQUFNO01BRVosR0FBR0EsTUFBTUEsT0FBTSxvQkFBb0I7TUFDbkMsT0FBT0EsS0FDVDtJQUtBLFNBQVNvOEIsYUFBYTNiLEdBQUlDO01BQ3hCLEdBQUcsT0FBT0Qsb0JBQW9CLE9BQU9DO09BQWtCLG9CQUNqQztNQUV0QjtTQUFJRCxPQUFPQSxXQUFXQyxPQUFPQTs7U0FBYSxPQUFPRCxvQkFBb0IsT0FBT0M7T0FBbUI7TUFHL0YsT0FBTyxjQUFjLE9BQU9ELFFBQVEsT0FBT0MsS0FDN0M7SUExVkEsU0FBUzJiLFNBQVM1YixHQUFJdFk7TUFDcEJBLEtBQUssT0FBT0E7TUFDWixHQUFJLE1BQU07T0FBWTtNQUd0QixPQUFPLGVBQWUsT0FBT3NZLFFBQVF0WSxJQUN2QztJaEI1TEEsU0FBU20wQixlQUFleGtCLEtBQU1nQixPQUFReWpCO01BQ3BDO09BQVMsS0FBRSxtQkFBbUJBO09BQ3JCLEtBQUUsc0JBQXNCemtCLEtBQU0saUJBQWlCUztNQUN4RCxPQUFPLHNCQUFzQlQsS0FBTWdCLE9BQVFQLEtBQU1MLEtBQ25EO0lFalVBLFNBQVNza0IsZ0JBQWdCQyxFQUFFemtCLE1BQ3pCLE9BQU8sdUJBQXlCQSxNQUNsQztJaEJvTkEsU0FBUzBrQixnQkFBaUJoNUIsRUFBRzFEO01BQzNCLEdBQUlBLFdBQVcsc0JBQXNCMEQsR0FBSTtNQUN6QyxPQUFPLHVCQUF3QkEsRUFBRzFELEVBQ3BDO0l1Q25NQTtLQUFJMjhCO01BQVc7U0FDYjtVQUFvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VBV1I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBVVosU0FBU0csZUFBZTczQjtXQUN0QixPQUFRMjNCLGdCQUFtQjMzQixZQUFhQSxVQUMxQztTQUVBLFNBQVM4M0IsVUFBVXI1QixFQUFFMUQ7V0FDbkIsT0FBUSxnQkFBZ0IwRCxFQUFHMUQsWUFBYUEsVUFDMUM7U0FFQSxTQUFTZzlCLGNBQWMvakIsR0FBSXZWLEVBQUdmLElBQUtzNkI7V0FFakM7WUFBa0IsS0FBRSxtQkFBbUJoa0I7WUFDckIsTUFBRSxtQkFBbUJBO1lBQ3JCLFVBQUUsdUJBQXVCQTtZQUN6QixVQUFFQTtZQUNGLGFBQUVBO1lBQ0YsV0FBRUE7WUFFZCxFQUFFLHFCQUFxQnZWO1lBRXRCO1lBQ0U7WUFDQztZQUNDLFdBQU1oQixNQUFNMjZCO1lBQ1AsZ0JBQU0zNkIsTUFBTTQ2QjtXQUU1QixJQUFVLElBQUZ0OUIsSUFBT0EsSUFBSTA5QixjQUFlMTlCLElBQUksT0FDN0JBO1dBRVQwOUIsa0JBQWtCLzZCO1dBRUosU0FBVmk3QjthQUNGLE1BQU9saUI7Y0FBYyxDQUNuQixJQUFJbWlCLEtBQU87ZUFDWCxHQUFJQTtnQkFBVyxjQUNDQSxrQkFBa0JBOztnQkFFN0IsR0FBR0EsU0FBVSxDQUNoQkwsS0FBS0ssWUFDTGw3QixNQUFNazdCLGFBQ047YUFHSkosV0FaYztXQWVQLFNBQUxLLEtBQWdCRCxNQUFRLFdBQVdBLEtBQTVCO1dBRUEsU0FBUEU7YUFDRkwsZ0JBQWdCLzZCO2FBQ2hCLElBQUlzQixXQUFhdkIsVUFBVWc3QjthQUMzQno1QjthQUNBLElBQVUsSUFBRmpFLElBQU9BLElBQUkwOUIsY0FBZTE5QjtjQUFJLENBQ3BDLElBQUk2TixFQUFJNnZCLE9BQU8xOUI7ZUFDZixHQUFHNk4sZUFBZUEsVUFBVyxVQUNqQkE7ZUFFWjVKLFdBQVNqRSxTQUFVNk47ZUFDbkI1SixXQUFTakUsYUFBYzZOO2FBRXpCLE9BQU81SixNQVpJO1dBZUksU0FBYis1QjthQUNGLEdBQUdmLFFBQVMsT0FBTyxjQUNkLFdBRlk7V0FNbkIsUUFBUVE7WUFBTSxDQUNaO2NBQU8sR0FBRVAsS0FBS007Y0FDTCxLQUFFTixLQUFLTTtjQUNQLEtBQUVVO2NBQ0wsRUFBRXg2QixFQUFFZjtjQUNOeTdCO2FBRUpaO2FBRUEsT0FBUVM7b0JBQ0hwQjtnQkFDSCxHQUFHbDZCLFFBQVFlLFNBQVUsQ0FBQyxlQUFpQjtnQkFDdkMsR0FBSXVCLE1BQU1rNUIsS0FBTXg3QixXQUNYO2dCQUNMO29CQUNHazZCO2dCQUNILEdBQUdsNkIsUUFBUWUsU0FBVSxDQUFDLGVBQWlCO2dCQUN2QyxHQUFJLHFCQUFxQnVCLE9BQU9rNUIsS0FBTXg3QixXQUNqQztnQkFDTDtvQkFDR2s2QjtnQkFDSDtzQkFBYSxJQUFFLHVCQUF1Qk0sTUFBTWdCLE9BQVU7a0JBQUtuK0I7O2tCQUFJK1k7a0JBQVkvWTtpQkFBSyxDQUM5RSxHQUFHMkMsUUFBUWUsU0FBVSxDQUFDLGVBQWlCO2tCQUN2QyxHQUFJdUIsTUFBTSxlQUFlakY7bUJBQ3ZCaUYsSUFBSXZCLElBQUlmOzttQkFDTCxDQUFFLFlBQWE7Z0JBRXRCO29CQUNHazZCO2dCQUNIO3NCQUFhLElBQUUsdUJBQXVCTSxNQUFNZ0IsT0FBVTtrQkFBS24rQjs7a0JBQUkrWTtrQkFBWS9ZO2lCQUFLLENBQzlFLEdBQUcyQyxRQUFRZSxTQUFVLENBQUMsZUFBaUI7a0JBQ3ZDLEdBQUkscUJBQXFCdUIsT0FBTyxlQUFlakY7bUJBQzdDaUYsSUFBSXZCLElBQUlmOzttQkFDTCxDQUFFLFlBQWE7Z0JBRXRCO29CQUNHazZCO2dCQUNILEdBQUdsNkIsUUFBUWUsU0FBVSxDQUFDLGVBQWlCO2dCQUN2QyxHQUFJLFVBQVV5NUIsTUFBTWdCLE1BQU9sNUIsR0FBSXRDLFdBQzFCO2dCQUNMO29CQUNHazZCO2dCQUNILEdBQUdsNkIsV0FBV2UsRUFBRWYsZUFBeUIsWUFDekM7b0JBQ0drNkI7Z0JBQ0gsR0FBR2w2QixNQUFNZSxZQUFZQSxFQUFFZixXQUFxQixZQUM1QztvQkFDR2s2QjtnQkFDSCxHQUFHbDZCO2lCQUFVLENBQ1gsR0FBR0EsUUFBUWUsU0FBVSxDQUFDLGVBQWlCO2tCQUN2QyxHQUFHLGVBQWVBLE1BQU87a0JBQ3pCOztpQkFFRyxHQUFJZixRQUFRZTtrQkFBVSxDQUN6QixHQUFHLGVBQWVBLEVBQUVmLFVBQVcsTUFDL0I7O2tCQUVHLENBQ0gsR0FBRyxlQUFlZSxFQUFFZixhQUFhLGVBQWVlLEVBQUVmO29CQUFPO21CQUN6RDtnQkFFRjtvQkFDR2s2QjtnQkFDSHVCLFFBQVFWLE9BQU9TO2dCQUNmLGdCQUFpQkMseUJBRUdBO2dCQUNwQkEsY0FBY3o3QjtnQkFDZDtvQkFDR2s2QjtnQkFDSHVCLFFBQVFWLE9BQU9TO2dCQUNmLGdCQUFrQkMsdUJBRUVBO2dCQUNwQkEsWUFBWXo3QjtnQkFDWjtvQkFDR2s2QjtnQkFDSHVCLFFBQVFWLE9BQU9TO2dCQUNmLEdBQUdDLG1CQUFtQkEsY0FBZSxDQUFDLFlBQWM7Z0JBQ3BELElBQVcsSUFBRnArQixFQUFJbytCLFlBQWFwK0IsSUFBSW8rQixVQUFXcCtCO2lCQUFJLENBQzNDLEdBQUcyQyxRQUFRZSxTQUFVLENBQUMsZUFBaUI7a0JBQ3ZDLEdBQUdBLEVBQUUxRCxNQUFNMEQsRUFBRWYsS0FBTSxDQUFDLFlBQWM7a0JBQ2xDQTtnQkFFRjtvQkFDR2s2QixrQkFDSCxHQUFJLFVBQVVNLE1BQU1nQixNQUFPbDVCLEdBQUl0QyxNQUMvQjtvQkFDR2s2QjtnQkFDSCxNQUFPLFVBQVVNLE1BQU1nQixNQUFPbDVCLEdBQzVCQSxJQUFJdkIsSUFBSWYsS0FDVjtvQkFDR2s2QjtnQkFDSCxHQUFHbDZCLFFBQVFlLFNBQVUsQ0FBQyxlQUFpQjtnQkFDdkMsR0FBSSxVQUFVeTVCLE1BQU1nQixNQUFPbDVCO2lCQUFJLEdBQzFCLElBQ0d2QixJQUFJZixXQUNELFVBQVV3NkIsTUFBTWdCLE1BQU9sNUI7O2lCQUU3QjtnQkFDTDtvQkFDRzQzQixlQUNILE9BQU87b0JBQ0pBLGFBQ0hXLEtBQUtBLEtBQUtVLEtBQ1Y7b0JBQ0dyQixpQkFDSCxjQUFnQlcsS0FBS1UsU0FBV3Y3QixPQUNoQztvQkFDR2s2QjtnQkFDSDs2QkFBaUJjLGlCQUNFUSxXQUNDUixZQUFZUTtnQkFDaENSLFlBQVlRLFFBQVF4N0I7Z0JBQ3BCO29CQUNHazZCO2dCQUNILEdBQUljLFlBQVlRLFVBQVV4N0IsSUFBSyxZQUMvQjt1QkFDTyxVQUFVZ2Y7V0FHckIsUUFDRjtTQUVBLE9BQU9xYixhQXROTTs7SUEwT2YsU0FBU3FCLG1CQUFtQnBsQixHQUFJdlYsRUFBR2Y7TUFDakMsR0FBR0EsV0FBV0EsTUFBTSxzQkFBc0JlO09BQ3hDO01BQ0YsTUFBT2YsU0FBVSxDQUNmLElBQUlGLElBQU0sU0FBU3dXLEdBQUl2VixFQUFHZixPQUMxQixHQUFJRixJQUFLLE9BQU9BLElBQ2hCRTtNQUdGLFVBQ0Y7SURuTEEsU0FBUzI3QixjQUFjdkk7TUFDckIsS0FBS0EseUJBQXlCQSxpQkFBa0I7TUFHaEQsVUFBV0EsZUFDYjtJUjZDQSxTQUFTd0ksWUFBWTlkLEdBQUlDO01BQ3ZCLE9BQU8sZUFBZSxPQUFPRCxRQUFRLE9BQU9DLEtBQzlDO0loQ2dxQnFDLFNBQWpDOGQsaUNBQTZDcDhCLEVBQUc1QjtNQUNoRCxJQUFJaUMsSUFBTSw0Q0FBNENMLEVBQUc1QjtNQUN6RCxpQkFBaUJpQztNQUNqQixPQUFPQSxHQUg0QjtJUXR5QnZDLFNBQVNnOEIsbUJBQW1CekwsSUFBSzBMO01BSy9CLElBQUlyMEIsSUFBTTJvQjtNQUNWLEdBQUkzb0IsZUFBZTVOO09BQWtCLE1BQzdCNE47O09BQ0QsTUFDQyxNQUFNcTBCLGdCQUVoQjtJZ0I2Y0EsU0FBU0MsdUJBQXVCLFFBQVE7SVJ0QnhDLFNBQVNDLG9CQUFvQmpyQixHQUFJakMsR0FBSXBQO01BQ25DLElBQUlzUixJQUFNLFVBQVVsQztNQUNwQixHQUFHa0MsV0FBV0QsZUFBZ0I7TUFDOUIsT0FBT0MsUUFBUXRSO01BQ2YsT0FBT3NSLFFBQVF0UjtNQUNmLE9BQU9zUixRQUFRdFI7TUFDZixPQUFPc1IsUUFBUXRSO01BQ2YsUUFDRjtJZi9NQSxTQUFTdThCLG1CQUFtQno4QixHQUMxQixHQUFJQSxPQUFRQSxRQUFRQSxFQUNwQixPQUFRQSxTQUNWO0l1Qi9IQSxTQUFTMDhCLHlCQUF5QmxoQztNQUNoQyxJQUFJOEYsRUFBSTtNQUNSQSxVQUFVOUY7TUFEVixJQUVJbWhDLE9BQVMsd0JBQXdCbmhDO01BQ3JDLEdBQUc4RixZQUFhLFlBQVlxN0I7TUFDNUIsUUFDRjtJQWtLQSxTQUFTQyx1QkFBdUIxa0I7TUFDOUIsSUFBSTVXLEVBQUk7TUFDUkEsZUFBZTRXO01BQ2Y1VyxzQkFBc0I0VztNQUN0QixRQUNGO0lBdUVBLFNBQVMya0Isc0JBQXNCam5CO01BQzdCLElBQUl0VSxFQUFJO01BQ1JBLGNBQWNzVTtNQUNkdFUsaUJBQWlCQSxzQkFBc0Isd0JBQXdCQTtNQUMvRCxRQUNGO0lBZkEsU0FBU3c3QixpQkFBaUJ6NUI7TUFDeEIsSUFBSS9CLEVBQUk7TUFDUkEsU0FBUytCO01BQ1QvQixpQkFBaUJBLHNCQUFzQix3QkFBd0JBO01BQy9ELFFBQ0Y7SUFsTUEsU0FBU3k3QixrQkFBa0JwUztNQUN6QixJQUFJcnBCLEVBQUk7TUFDUixTQUFTYixRQUFRZjtRQUNmLElBQUltYSxTQUFXO1FBQ2YsTUFBT0EsZUFBZ0JBLFlBQVlBO1FBQ25DLE9BQU9BLEdBQ1Q7TUFDQSxJQUNFLEVBQUc4USxtQkFDSCxFQUFHQSxrQkFDSCxFQUFHQTtNQUNMcnBCLFVBQVFxcEI7TUFKUixJQUtJcVMsWUFBYyxRQUFROTVCLEtBQUssUUFBUXVJLEtBQUssUUFBUTlJO01BQ3BEckIsc0JBQXdCMDdCO01BQ3hCMTdCLHdCQUF3QjA3QjtNQUN4QixRQUNGO0lBNEJBLFNBQVNDLGVBQWVqOUIsRUFBRTVCO01BQ3hCLElBQUlrRCxFQUFJLG9CQUNSQSxNQUFJdEIsRUFDSnNCLE1BQUlsRCxFQUNKLFFBQ0Y7SUFwRkEsU0FBUzgrQixzQkFBc0JobEIsRUFBRXRMO01BQy9CLElBQUl0TCxFQUFJO01BQ1JBLFVBQVU0VztNQUNWNVcsV0FBV3NMO01BQ1h0TCxpQkFBaUI0VztNQUNqQjVXLGtCQUFrQnNMO01BQ2xCLFFBQ0Y7SUFsRUEsU0FBU3V3QjtNQUNQLGVBQWVsaEIsZ0JBQWdCQTtNQUMvQixzQkFBc0JBLG9CQUFvQkE7TUFDMUMsdUJBQXVCQTtNQUN2QixzQkFBc0JBO01BQ3RCLGlCQUFpQkE7TUFDakIsa0JBQWtCQTtNQUNsQix5QkFBeUJBO01BRXpCQSw2Q0FDRjtJUjZ3QkEsU0FBU21oQiw0QkFBNEJDO01BQ25DLElBQU0sRUFBRWhqQyxXQUNKcWI7TUFDSixHQUFJMm5CLGNBQWM1eEI7T0FBZ0JpSzs7T0FDN0IsR0FBSTJuQixjQUFjNXhCO1FBQWdCaUs7O1FBQ2xDLEdBQUkybkIsY0FBYzV4QjtTQUFhaUs7O1NBQy9CLEdBQUkybkIsY0FBYzV4QjtVQUFjaUs7O1VBQ2hDLEdBQUkybkIsY0FBYzV4QjtXQUFjaUs7O1dBQ2hDLEdBQUkybkIsY0FBYzV4QjtZQUFlaUs7O1lBQ2pDLEdBQUkybkIsY0FBYzV4QjthQUFjaUs7O2FBQ2hDLEdBQUkybkIsY0FBYzV4QjtjQUFlaUs7O2NBQ2pDOztNQUNMLE9BQU9BLElBQ1Q7SUFLQSxTQUFTNG5CLHlCQUF5QkQ7TUFDaEMsSUFBSTNuQixLQUFPLDRCQUE0QjJuQjtNQUN2QyxPQUFPLHNCQUFzQjNuQixRQUFVMm5CLFdBQVlBLEdBQ3JEO0lXbGVBLFNBQVNFLGlCQUFpQjVpQixPQUFPcGE7TUFDL0IsY0FBY29hLFFBQ2RGLGlCQUFpQkUsaUJBQWlCcGEsSUFDbEMsUUFDRjtJUGxZQSxTQUFTaTlCLGVBQWVqMUIsR0FBSyxjQUFjQSxDQUFHO0lvQjJHOUMsU0FBU2sxQixvQkFBb0I5SixVQUMzQixPQUFPQSxnQkFDVDtJTDNGQSxTQUFTK0osd0JBQXdCMTlCO01BQy9CLEdBQUlBLFFBQVM7TUFDYixJQUFJaUQ7TUFDSixJQUFNakQsc0JBQXVCLENBQUVpRCxJQUFJQSxPQUFRakQsSUFBSUE7TUFDL0MsSUFBTUEsc0JBQXVCLENBQUVpRCxJQUFJQSxNQUFRakQsSUFBSUE7TUFDL0MsSUFBTUEsc0JBQXVCLENBQUVpRCxJQUFJQSxNQUFRakQsSUFBSUE7TUFDL0MsSUFBTUEsc0JBQXVCLENBQUVpRCxJQUFJQSxNQUFRakQsSUFBSUE7TUFDL0MsT0FBT2lELEtBQUtqRCxNQUNkO0lBUUEsU0FBUzI5Qiw0QkFBNEIzOUIsR0FBSyxPQUFPLHdCQUF3QkEsRUFBSTtJT2xFN0UsSUFBSTQ5QixtQ0FGQUM7SUFtQkosU0FBU0MsaUNBQWtDQyxRQUFTQztNQUNsRHZqQixpQkFBaUJzakIsV0FBV0Y7TUFDNUJwakIsaUJBQWlCdWpCLFdBQVdKO01BQzVCLFFBQ0Y7SXRCa1NBLFNBQVNLLGtDQUFrQzU2QjtNQUN6QztRQUNFLElBQVEsSUFBRXlRLGlCQUNELFNBQU14VCxNQUFNRjtRQUNyQmtFLFVBQVVoSztRQUNWLElBQVcsSUFBRnNELElBQU9BLElBQUl3QyxJQUFLeEMsSUFBSzBHLEtBQUsxRyxTQUFPa1csVUFBVWxXO1FBQ3BELE9BQU8sUUFBUXRCLEtBQU1nSSxLQUxoQixDQU1UO0lVL09BLFNBQVM0NUIsc0JBQXVCdjdCLEVBQUV6QyxHQUNoQ3lDLFdBQ0FBLE9BQUt6QyxFQUNMLFFBQ0Y7SW5CN0NBLFNBQVNpK0IsV0FBV3ZvQjtNQUNsQixJQUFJbU0sUUFBVWlWLE1BQU1waEI7TUFDcEIsSUFBVSxJQUFGaFksSUFBT0EsSUFBSWdZLEtBQU1oWSxJQUFLLFNBQ25CQTtNQUVYLE9BQU9ta0IsR0FDVDtJcUIrWUEsU0FBU3FjLGNBQWMvZixJQUNyQixPQUFHQSxPQUFPQSxXQUVaO0laNVRBLFNBQVNnZ0Isa0JBQWtCcitCLEdBQUssV0FBU0EsQ0FBRztJSVA1QyxTQUFTcytCO01BQ1AsSUFBSWg5QixFQUFJO01BQ1JBO01BQ0FBO01BQ0EsUUFDRjtJZTlIQSxJQUFJaTlCLDJCQUE2QmhyQjtJckNtZWpDLFNBQVNpckIsbUJBQW1CcCtCO01BQzFCLEdBQUdBLFFBQVM7TUFDWixXQUFXc0QsUUFBUXRELFdBQVdBLElBQ2hDO0lGcmNzQyxTQUFsQ3ErQixrQ0FBOENuOUI7TUFDOUMsT0FBTztlQUE2Qyx3QkFBd0JBLEdBRHhDO0ltQ3pCeEMsU0FBU285Qix3QkFBd0IxK0I7TUFDL0IsSUFBTSxLQUNGNUI7TUFDSkEsSUFBSTRCO01BQVEsR0FBSTVCLE9BQVEsQ0FBRTZFLElBQUlBLE9BQU9qRCxJQUFJNUI7TUFDekNBLElBQUk0QjtNQUFRLEdBQUk1QixPQUFRLENBQUU2RSxJQUFJQSxNQUFPakQsSUFBSTVCO01BQ3pDQSxJQUFJNEI7TUFBUSxHQUFJNUIsT0FBUSxDQUFFNkUsSUFBSUEsTUFBT2pELElBQUk1QjtNQUN6Q0EsSUFBSTRCO01BQVEsR0FBSTVCLE9BQVEsQ0FBRTZFLElBQUlBLE1BQU9qRCxJQUFJNUI7TUFDekNBLElBQUk0QjtNQUFRLEdBQUk1QixPQUFRLE9BQU82RTtNQUMvQixPQUFPQSxJQUFJakQsQ0FDYjtJQVFBLFNBQVMyK0IsNEJBQTRCMytCLEdBQUssT0FBTyx3QkFBd0JBLEVBQUk7SW5DbUc3RSxJQUFJNCtCLGtCQUFvQmgvQjtJa0N0SHhCLFNBQVNpL0IsMkJBQTJCQyxLQUFLN2hDO01BQ3ZDO09BQU0sTUFBTVQsS0FBS3NpQztPQUNKLFNBQUUsdUJBQXVCN2hDO09BQzFCLFFBQUUsMkJBQTJCOGhDLFNBQVU5aUM7TUFDbkQsT0FBTyx1QkFBdUIraUMsUUFDaEM7SUppREEsU0FBU0MsYUFBY2ovQjtNQUNyQixJQUFNLEVBQUVBLFNBQ0YsTUFBTU0sTUFBTXdDO01BQ2xCLElBQVUsSUFBRmxGLElBQU9BLElBQUlrRixFQUFHbEYsSUFBTXdGLEVBQUV4RixLQUFLb0MsRUFBRXBDO01BQ3JDLE9BQU93RixDQUNUO0lPaEJBLFNBQVM4N0IsbUJBQW1CbC9CLEVBQUdwQztNQUM3QixHQUFHQSxTQUFTb3lCLHVCQUF1QnB5QixLQUFLb0M7T0FDdEM7TUFDRixJQUFJNUIsRUFBSSxjQUFjNEIsRUFBR3BDO01BQ3pCLEdBQUlRLFFBQVMsT0FBT0E7TUFEcEIsSUFFSTAyQixFQUFJMTJCO01BQ1IsR0FBSTAyQixhQUFheDBCLE1BQU8sVUFBVyxhQUFhdzBCO01BQ2hELE9BQU8xMkIsQ0FDVDtJcENrT0EsU0FBUytnQyxpQkFBa0JuL0IsR0FBSyxPQUFPLFdBQVdBLEVBQUk7STBCZ0Z0RCxTQUFTby9CLHFCQUFxQnprQixPQUFPeFMsT0FBTzVCLE9BQU9uRztNQUNqRCxJQUFJd2EsS0FBT0gsaUJBQWlCRTtNQUM1QixLQUFLQztPQUFhO01BRGxCLElBRUlyVDtNQUNKLEdBQUdoQixlQUFlLHFCQUFxQjRCLFdBQVcvSDtPQUNoRG1ILFFBQVFZOztPQUNMLENBQ0haLFFBQVEsa0JBQWtCbkg7UUFDMUIsZ0JBQWdCK0gsT0FBTzVCLE9BQU9nQixRQUFRbkg7TUFQeEM7T0FTVyxPQUFFLHFCQUFxQm1IO09BQ3JCLFNBQUUsdUJBQXVCODNCO09BQy9CLEdBQUU7TUFDVCxHQUFHRTtPQUNEM2tCLGVBQWEwa0I7O09BQ1YsQ0FDSDFrQixlQUFhLGtCQUFrQjJrQjtRQUMvQixjQUFlNWtCO1FBQ2ZDLGVBQWUsZ0JBQWdCMmtCO01BRWpDLFFBQ0Y7SUFJQSxTQUFTQyxlQUFlN2tCLE9BQU94UyxPQUFPNUIsT0FBT25HO01BQzNDLE9BQU87ZUFBcUJ1YSxPQUFPLHFCQUFxQnhTLFFBQVE1QixPQUFPbkcsSUFDekU7STNCeXRDNkMsU0FBekNxL0IseUNBQXFEaGlCLE9BQVE3YSxFQUFHbEI7TUFDaEUsR0FBSStiLGFBQWMsU0FDTHRoQixlQUNOLFNBQ01zaEI7TUFFYixPQUFPO2VBQW9EQTtlQUFRLDJDQUEyQzdhO2VBQUksd0JBQXdCbEIsTUFOL0Y7SW9CcGpEL0MsU0FBU2crQix1QkFBdUJyOEIsRUFBRWlCO01BQ2hDLGtCQUFrQmpCLFdBQVdpQixLQUMvQjtJTDhXQSxTQUFTcTdCLDRCQUE0QnRvQixPQUFRekI7TUFDekNBLFlBQ0EsT0FBTyxnQkFDWDtJRS9aQSxTQUFTZ3FCLHdCQUF3Qmh6QixFQUFHb2Q7TUFDbEMsT0FBTyx3QkFBd0JwZCxFQUFFb2QsUUFDbkM7SUNxREEsSUFBSTZWLDRCQUE4QkQ7SVBvRWxDLFNBQVNFLFNBQVNyc0IsSUFBS2pDLElBQUtwUixJQUFLc3JCO01BQy9CLElBQUluSixNQUFRbUo7TUFDWixJQUFVLElBQUY5dEIsSUFBT0EsSUFBSXdDLElBQUt4QztPQUFLLENBQzNCLElBQUlvQyxHQUFLeVQsU0FBU2pDLE1BQUk1VCxZQUFZMmtCO1FBQ2xDOU8sU0FBU2pDLE1BQUk1VCxLQUFNb0M7UUFDbkIsR0FBR0EsS0FBTUEsUUFBVSxDQUNqQnVpQixVQUNBLFdBQ0s7TUFJVCxPQUFPQSxLQUNUO0lxQnNSQSxTQUFTd2QsVUFBVTFoQixJQUNqQixPQUFPLE9BQU9BLFlBQVlxQyxZQUM1QjtJTC9NQSxTQUFTc2YsMkJBQTJCcmxCLE9BQU90WDtNQUN6Q29YLGlCQUFpQkUsaUJBQWlCdFgsRUFDbEMsUUFDRjtJM0IrdkJrQyxTQUE5QjQ4Qiw4QkFBMEM5MEIsSUFBSyswQjtNQUMvQztPQUFJNy9CO1FBQU07VUFBeUM4SyxJQUFLLHdDQUF3QyswQjtNQUNoRyxPQUFPLDZCQUE2QjcvQixJQUZKO0lnQ3pScEMsU0FBUzgvQixlQUFlOWhCO01BTXRCQSxLQUFLLE9BQU9BO01BQ1osSUFBUSxJQUFFLFVBQ0YsSUFBRTtNQUVWLEdBQUksTUFBTW9iLFFBQVEsVUFBVUEsS0FBTTtNQUlsQyxHQUFJLE9BQU9BLFlBQVlBLEtBQU0sS0FDdEIsT0FBTzJHLFVBQ1AsS0FDQSxPQUFPM0c7TUFHZDtPQUFhLEdBQ1A7UUFBd0IsT0FDbkIsZUFBZXBiOztRQUNqQixLQUNBLE9BQU8raEIsSUFHbEI7SVo3WUEsU0FBU0MsYUFBYS8rQjtNQUNwQjtNQUNBLE9BQU8sS0FBSyx3QkFBd0JBLEdBQUk7SXBCdUMxQyxJQUFJZy9CLG9CQUFzQjFnQztJUy9EMUIsU0FBUzJnQyxpQ0FBa0NqVztNQUN6QyxPQUFPL2IscUJBQ1Q7SVRrM0RzQixTQUFsQml5QixrQkFBOEJDLFNBQVVDLGVBQWdCMWhCO01BQ3hELE9BQU87ZUFBcUI7aUJBQ3hCO21CQUEwQnloQixTQUFVek07aUJBQ3BDLDJDQUEyQzBNO2lCQUMzQyw0QkFBNEIxaEIsUUFKWjtJWWppRHhCLFNBQVMyaEIsMkJBQTRCemdDLEVBQUdzdUI7TUFDdEMsT0FBTyxvQkFBcUIsZ0JBQWlCdHVCLEVBQUdzdUIsT0FDbEQ7SVVybEJBLFNBQVNvUyxxQkFBcUIxdUIsTUFBUSxRQUFVO0l0QjZzQ2hEO0tBQUkydUI7TUFBMkNqaEM7SXFCM3VDL0MsU0FBU2toQyxxQkFBc0JyVCxNQUFPQyxNQUFPbGU7TUFDM0MsSUFBSXV4QjtNQUNKLFNBQVNDLFNBQVV4eEI7UUFDakJrZTtRQUNBLEdBQUlELGFBQWFDLFVBQVc7UUFDNUIsR0FBSWxlLGVBQWVsUCxTQUFTa1AsWUFBWUE7U0FBVyxPQUN6Q0E7b0JBR05pZSxRQUNBc1QsWUFBYUEsb0JBQW9CdnhCLFdBQ2pDO29CQUdBa2UsUUFBUyxTQUFTbGUsS0FBTTs7WUFFeEJpZTtZQUNBc1QsWUFBYUEsaUJBQWlCdnhCO1lBQzlCLElBQVcsSUFBRjVSLEVBQUk0UixlQUFnQjVSLE1BQU9BLElBQUssU0FBVTRSLElBQUk1Ujs7U0FFcEQsR0FBSSxpQkFBaUI0UjtVQUFNLENBQ2hDaWU7V0FDQSxJQUFJNXBCLFFBQVUsc0JBQXNCMkw7V0FDcEMsVUFBVTNMO1lBQXNCLFFBQzFCLEVBQUVBLFFBQVcsRUFBRWxCLFNBQVksSUFBSy9FLElBQUlrRixFQUFHbEY7YUFDekNtakMsWUFBYUEsaUJBQWlCLGFBQWFuakM7O1lBQ3hDLFFBQ00sRUFBRWlHLFFBQVcsRUFBRVQsU0FBWSxJQUFLeEYsSUFBSWtGLEVBQUdsRjthQUNoRG1qQyxZQUFhQSxpQkFBaUIzOUIsRUFBRXhGOztVQUUvQixHQUFJLGtCQUFrQjRSO1dBQU0sQ0FDakMsSUFBSXl4QixRQUFVLHVCQUF1Qnp4QjtZQUNyQyxRQUFXLEVBQUV5eEIsUUFBVyxFQUFFQSxlQUFrQixJQUFLcmpDLElBQUlrRixFQUFHbEY7YUFDdERtakMsWUFBYUEsaUJBQWlCLGFBQWFuakM7O1dBQ3hDLFVBQVc0UjtZQUFrQixRQUN2QixFQUFFQSxJQUFPLEVBQUVBLFdBQWMsSUFBSzVSLElBQUlrRixFQUFHbEY7YUFDOUNtakMsWUFBYUEsaUJBQWlCLGFBQWFuakM7O1lBQ3hDLEdBQUk0UixTQUFTQTthQUFRLENBRTFCaWUsUUFDQXNULFlBQWFBLG9CQUFvQnZ4Qjs7YUFDNUIsR0FBSUEsVUFBU0E7Y0FBSyxDQUV2QmllO2VBQ0EsSUFBSWpOLEVBQUksb0JBQXFCLHlCQUEwQmhSO2VBQ3ZELElBQVcsSUFBRjVSLElBQU9BLE9BQVFBLElBQUttakMsWUFBYUEsaUJBQWlCdmdCLEVBQUU1aUI7O2NBQ3hELEdBQUc0UixPQUFPQTtlQUFpQjtpQkFDN0JrSixnQkFBZ0JsSjs7aUJBQW9Ca0osZ0JBQWdCbEo7Z0JBQXVCLENBQzVFLElBQUk1QyxFQUFJLGdCQUFnQjRDLHNCQUFzQkE7aUJBQzlDdXhCLFlBQWFBLG9CQUFvQm4wQixNQUd2QztNQUNBLFNBQVU0QztNQUNWLE9BQU91eEIsc0JBQ1Q7SXJCeXFCc0IsU0FBbEJHLGtCQUE4QmxoQztNQUM5QixJQUFJSyxJQUFNLDZCQUE2Qkw7TUFDdkMsaUJBQWlCSztNQUNqQixPQUFPQSxHQUhhO0lnQ3RyQnhCLFNBQVM4Z0MsU0FBUzlpQixHQUFJQztNQUNwQkEsS0FBSyxPQUFPQTtNQUNaLEdBQUcsVUFBVSxXQUFZO01BQ3pCLE9BQU8sZUFBZSxPQUFPRCxXQUFXLE9BQU9DLEtBQ2pEO0lBd3hCQSxTQUFTOGlCLGNBQWMvaUIsR0FBSUMsSUFDekIsT0FBTyxTQUFTRCxHQUFJQyxHQUN0QjtJcEJqTkEsU0FBUytpQiw0QkFBNkIvL0IsRUFBR2tRLElBQUtwUixJQUFLRixFQUFHc3VCO01BQ3BELElBQUk1ckIsRUFBSSxnQkFBaUIxQyxFQUFHc3VCO01BQzVCLEdBQUk1ckIsV0FBV3hDLElBQUs7TUFDcEIsZ0JBQWdCd0MsSUFBTXRCLEVBQUdrUSxJQUFLNU87TUFDOUIsUUFDRjtJWm9JbUIsU0FBZjArQixlQUEyQjFqQztNQUMzQixJQUFJeUMsSUFBTSwwQkFBMEJ6QyxHQUNwQyxpQkFBaUJ5QyxLQUNqQixPQUFPQSxHQUhVO0lBaTBCdUIsU0FBeENraEMsd0NBQW9EaDdCLE9BQVE0TSxJQUFLelI7TUFDakUsR0FBSTZFLGFBQWMsU0FDTHBLLGVBQ04sU0FDTW9LO01BRWIsT0FBTztlQUEyQztpQkFBbURBLE9BQVE0TSxJQUFLLHdCQUF3QnpSLE9BTmhHO0lJbDBDOUMsU0FBUzgvQix3QkFBd0JobUMsS0FBS3FJO01BQ3BDLEdBQUd4SjtPQUNELDRCQUE0Qm1CLEtBQUtxSTs7T0FDOUIsQ0FDSCxLQUFJeEosdUJBQXdCQTtRQUM1QixrQ0FBa0NtQixhQUFhcUk7TUFFakQsUUFDRjtJRjRrQkEsU0FBUzQ5QixrQkFBa0JuZ0MsR0FDekIsT0FBTyx3QkFBd0JBLEVBQ2pDO0lGa1YwQyxTQUF0Q29nQztNQUFrREMsa0JBQW1CQztNQUNyRSxPQUFPO2VBQXdCO2lCQUFpREQsa0JBQW1CQyxhQUQzRDtJMkNqckM1QyxJQUFJQyw4QkFBZ0N6bEI7SWYwRnBDLFNBQVMwbEIsZUFBZ0IxaEMsSUFBSzJoQztNQUM1QixHQUFJM2hDLFFBQVM7TUFDYixJQUFRLElBQUVBLFlBQ0osTUFBTUUsTUFBTUY7TUFDbEJ1QztNQUNBLElBQVcsSUFBRi9FLElBQU9BLElBQUl3QyxJQUFLeEMsSUFBSytFLEVBQUUvRSxLQUFLbWtDO01BQ3JDLE9BQU9wL0IsQ0FDVDtJRGlTQSxTQUFTcS9CLG9CQUFxQnJuQixPQUFPOVg7TUFDbkMsSUFBSXZCLEVBQUksdUJBQXVCLG9CQUFvQnVCO01BQ25ELGVBQWU4WCxPQUFPclo7TUFDdEIsUUFDRjtJRzNYQSxTQUFTMmdDLGtCQUFtQmppQyxHQUFLLFVBQVNBLGFBQWFNLE1BQVE7SWxCc0cvRCxTQUFTNGhDLG9CQUFxQjkrQjtNQUM1QixPQUFPLHlCQUEwQixvQkFBcUJBLEdBQ3hEO0laeTRCcUIsU0FBakIrK0IsaUJBQTZCNTdCLE9BQVE3RTtNQUNyQyxHQUFJNkUsYUFBYyxTQUNMcEssZUFDTixTQUNNb0s7TUFFYjtPQUFJbEc7UUFBTSw0QkFBNEJrRyxPQUFRLHdCQUF3QjdFO01BQ3RFLE9BQUlyQixPQUNXQSxNQVJJO0lBbU9tQixTQUF0QytoQztNQUFrRFQsa0JBQW1CQztNQUNyRSxPQUFPO2VBQXdCO2lCQUFpREQsa0JBQW1CQyxhQUQzRDtJOEJ0bUM1QyxTQUFTUyx1QkFBdUI5NUIsRUFBRTNLLEVBQUVzQyxHQUFLLE9BQU9xSSxFQUFFM0ssU0FBT3NDLENBQUU7SVAxRDNELFNBQVNvaUMsdUJBQXVCai9CLEVBQUdrL0I7TUFDakMsR0FBSWwvQixZQUFhay9CLFlBQVk7TUFDN0IsSUFBSW5pQyxJQUFNbWlDO01BRVYsR0FBSWwvQixpQkFBaUJBLGNBQWNBLG9CQUFxQmpEO01BQ3hELEdBQUlpRCxZQUFhLENBQ2YsR0FBSUEsWUFBYWpELFNBQ2pCLEdBQUlpRCxhQUFjakQ7TUFMcEIsSUFRSStIO01BQ0osR0FBSTlFLG9CQUFvQkE7T0FDdEIsSUFBVyxJQUFGekYsRUFBSXdDLElBQUt4QyxJQUFJeUYsUUFBU3pGLElBQUt1SztNQUN0QyxHQUFJOUU7T0FBYyxHQUNaQTtRQUFZOEU7O1FBQ1gsR0FBSTlFLG1CQUFvQjhFLFVBQVU5RTtNQUV6QyxHQUFJQSxlQUFlQSxZQUFhOEU7TUFDaEMsR0FBSTlFLGVBQWVBLGFBQWM4RTtNQUNqQyxHQUFJOUUsb0JBQW9CQTtPQUN0QixJQUFXLElBQUZ6RixFQUFJd0MsSUFBS3hDLElBQUl5RixRQUFTekYsSUFBS3VLO01BQ3RDQSxVQUFVbzZCO01BQ1YsR0FBSWwvQixpQkFDRixJQUFXLElBQUZ6RixFQUFJd0MsSUFBS3hDLElBQUl5RixRQUFTekYsSUFBS3VLO01BQ3RDLE9BQU8sdUJBQXVCQSxPQUNoQztJdkJ5RjBCLFNBQXRCcTZCLHNCQUFrQ3hpQyxFQUFHNUI7TUFDckMsbUJBQW1CNEIsRUFBRyxrQkFBa0JBLEVBQUc1QixHQURuQjtJQ3JCNUIsU0FBU3FrQyxpQkFBaUJ6aUMsR0FDeEIsT0FBTyxXQUFXQSxFQUNwQjtJK0J3ckJBLFNBQVMwaUMsb0JBQW9CcHRCLE9BQVFwVixFQUFHcVY7TUFDdENyVixJQUFJLE9BQU9BO01BQ1gsSUFBSThsQixLQUFPLFVBQVU7TUFDckIsZUFBZ0JBO01BRGhCLElBRVUsTUFBRUEsa0JBQ0osSUFBRTJjO01BQ1YsZ0JBQWlCdmlDO01BQ2pCLElBQVUsSUFBRnhDLEVBQUkra0MsVUFBVy9rQyxPQUFRQTtPQUFLLENBQ2xDLGVBQWlCb29CLFdBQVdwb0I7UUFDNUIsZUFBaUJvb0IsV0FBV3BvQjtRQUM1QixlQUFpQm9vQixXQUFXcG9CO1FBQzVCLGVBQWlCb29CLFdBQVdwb0I7TUFFOUIyWCxtQkFBb0JuVjtNQUNwQm1WLG1CQUFvQm5WLGtCQUN0QjtJaENuWWdDLFNBQTVCd2lDLDRCQUF3QzFpQyxFQUFHRixHQUMzQyxPQUFPQSxFQUR1QjtJdUM5ZWxDO0tBQWlDLDZCQUFFNlg7S3ZDeXpCUix1QkFBRWpZO0l5QjNrQjdCLFNBQVNtakMsV0FBWS9pQyxFQUFHNUIsR0FBSyxVQUFTLGlCQUFpQjRCLEVBQUU1QixjQUFnQjtJRXBCekUsU0FBUzRrQyxxQkFBc0Jwb0I7TUFDN0IsSUFBUSxJQUFFLGNBQ0UsUUFBRSxzQkFBc0JmO01BQ3BDLEdBQUlvcEIsYUFBY3JvQixjQUFjdGU7TUFDaEMsZ0JBQWdCLG1CQUFvQnVkLE1BQVFvcEI7TUFDNUMsT0FBT0EsT0FDVDtJQS9EQSxJQUFJQyx5QkFBMkJ4b0I7SWhCZ00vQixTQUFTeW9CLFlBQVl4M0IsS0FBTUMsS0FBTUMsS0FBTUMsS0FBTUMsS0FBTXEzQjtNQUNqRCxJQUFNLEVBQUUsZUFBZXozQixLQUFNQyxLQUFNQyxNQUM3QixFQUFFLGVBQWVDLEtBQU1DLEtBQU1xM0I7TUFDbkMsR0FBR2hnQyxJQUFJVCxFQUFHO01BQ1YsR0FBR1MsSUFBSVQsRUFBRztNQUNWLElBQVUsSUFBRi9FLEVBQUlpTyxTQUFVak8sT0FBUUE7T0FBSyxDQUNqQyxHQUFLK04sVUFBVUMsT0FBS2hPLFdBQWFrTyxVQUFVQyxPQUFLbk8sU0FBVztRQUMzRCxHQUFLK04sVUFBVUMsT0FBS2hPLFdBQWFrTyxVQUFVQyxPQUFLbk8sU0FBVztNQUU3RCxRQUNGO0lTaFZBLFNBQVN5bEMsZUFBZTk2QixFQUFFbEYsVUFBWWtGLEVBQUVsRixHQUFJLFFBQVE7SU5NcEQsU0FBU2lnQyx5QkFBMEJoaUM7TUFDakMsSUFBTSxJQUFTLElBQUUsc0JBQXNCQSxHQUFTLFFBQVc7TUFDM0QsR0FBSWxCO09BQVMsT0FDSCx1QkFBdUJrQixFQUFFMUQ7aUJBQ3hCQSxJQUFLYSxXQUFXLGNBQ2hCYixJQUFLYSxTQUFVO01BRzFCLEdBQUliLFFBQVF3QyxPQUFPLHVCQUF1QmtCLEVBQUcxRDtPQUMzQyxPQUFRLHVCQUF1QjBELEVBQUcxRDs7aUJBQ2Y0a0IsVUFBVzVrQixPQUFROztpQkFDbkI0a0IsU0FBVzVrQixPQUFROztpQkFDbkI0a0IsU0FBVzVrQixPQUFROztpQkFDbkJBLE9BQVE7O01BRTdCLFFBQVFBLEVBQUdhLEtBQU0rakIsS0FDbkI7SUFhQSxTQUFTK2dCLG1CQUFvQmppQztNQUMzQjtPQUFNLEVBQUUseUJBQTBCQTtPQUM1QixFQUFFNEI7T0FBVyxLQUFFQTtPQUFXLEtBQUVBO09BQzFCLElBQUUsc0JBQXNCNUI7T0FDbEI7T0FDUixFQUFHMUQsSUFBSXdDLElBQUssdUJBQXVCa0IsRUFBRzFEO09BQ3RDLEVBQUUsaUJBQWlCaUY7TUFDekIsR0FBSTVHLFNBQVNBLEtBQUt1bUIsS0FBTTtNQU54QixJQU9JbmlCLElBQU1wRTtNQUNWLElBQUsyQixJQUFJQSxJQUFFd0MsSUFBSXhDO09BQUssQ0FDbEJpRixJQUFJLHVCQUF1QnZCLEVBQUcxRDtRQUM5QixHQUFJaUYsUUFBUztRQUNiNUcsSUFBSSxpQkFBaUI0RztRQUNyQixHQUFJNUcsU0FBU0EsS0FBS3VtQixLQUFNO1FBQ3hCbmlCLE1BQU1taUIsT0FBT25pQixNQUFNcEU7UUFDbkIsR0FBSW9FLE1BQU1takMsVUFBVztNQUV2QixHQUFJNWxDLEtBQUt3QyxJQUFLO01BSWRDLE1BQU01QixPQUFPNEI7TUFDYixHQUFLbWlCLGVBQWlCbmlCLFlBQVlBLElBRWhDO01BQ0YsT0FBT0EsT0FDVDtJVnVCQSxTQUFTb2pDO01BQ1AsSUFBSUM7TUFDSixJQUFVLElBQUY5bEMsSUFBT0EsSUFBSW9MLHdCQUF5QnBMO09BQUksQ0FDOUMsSUFBSTBJLElBQU1vOUI7UUFDVkEsVUFBVyx1QkFBdUIxNkIsaUJBQWlCcEwsU0FBVTBJO01BRS9ELE9BQU9vOUIsSUFDVDtJSmc3QmtDLFNBQTlCQyw4QkFBMEN4NEIsSUFBSyswQjtNQUMvQztPQUFJNy9CO1FBQU07VUFBeUM4SyxJQUFLLHdDQUF3QyswQjtNQUNoRyxPQUFPLDhCQUE4QjcvQixJQUZMO0lZcGhDcEM7S0FBSXVqQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SWtCZ0hKLFNBQVNDLG1CQUFtQnQ3QixFQUFFM0ssR0FBSyxPQUFPMkssRUFBRTNLLE1BQUs7SVYrTGpELFNBQVNrbUMsZUFBZ0I5akMsRUFBRzVCLEdBQUssVUFBUzRCLEtBQUs1QixFQUFJO0lSeEduRCxTQUFTMmxDLDZCQUE2QjFzQixPQUFRN0Y7TUFDNUM7T0FBVyxPQUFFO09BQ0UsV0FBRTtPQUNELFlBQUU7T0FDTCxTQUFFO09BQ0YsU0FBRTtPQUNMO09BQ1csaUJBQUcweUIsbUJBQW9CNW5DO09BQzVCO01BQ2hCLFNBQVNnb0M7UUFDUCxJQUFJcGdDLEtBQU87UUFDWCxHQUFJQTtTQUF1QyxHQUNyQ0E7VUFBeUMsQ0FDM0MsSUFBUSxJQUFFQSxXQUNELEtBQUdBLGdCQUNOLEdBQUdQO1dBQ1QsR0FBSWlTLFVBQVcsT0FBTzFWO1dBQ3RCLEdBQUkrMUIsaUJBQWtCQSxpQkFBaUJvTyxpQkFBaUJua0M7V0FDeEQsV0FBV0EsRUFBRzBWO1dBQ2QsT0FBTzFWOztVQUVQLE9BQVFnRTs7U0FDTCxHQUNEQTtVQUEwQyxDQUM1QyxJQUFRLElBQUVBLFlBQ0osRUFBRSxlQUFnQjlEO1dBQ3hCLEdBQUk2MUIsaUJBQWtCQSxpQkFBaUJvTyxpQkFBaUJua0M7V0FDeEQsT0FBT0E7O1VBQ0YsT0FDRWdFO3NCQUVMLE9BQU87c0JBRVAsT0FBTztzQkFFUCxPQUFPO3NCQUVQLGdEQUNBOzthQUVBLElBQUlxQyxPQUFTO2FBQ2IsT0FBTzB2QixpQkFBaUJvTyxjQUFjOTlCOzthQUV0QyxJQUFJQSxPQUFTO2FBQ2IsT0FBTzB2QixpQkFBaUJvTyxjQUFjOTlCOzthQUV0QyxJQUFJQSxPQUFTO2FBQ2IsT0FBTzB2QixpQkFBaUJvTyxjQUFjOTlCOzthQUV0QztjQUFXLE9BQUU7Y0FDTCxJQUFFZytCO2NBQ0QsS0FBRUE7Y0FDTCxHQUFHNWdDO2FBQ1QsR0FBSWlTLFVBQVcsT0FBTzFWO2FBQ3RCLEdBQUkrMUIsaUJBQWtCQSxpQkFBaUJvTyxpQkFBaUJua0M7YUFDeEQsV0FBV0EsRUFBRzBWO2FBQ2QsT0FBTzFWOzthQUVQLG1EQUNBOzthQUVBLElBQVEsSUFBRSxnQkFDSixFQUFFLGVBQWdCRTthQUN4QixHQUFJNjFCLGlCQUFrQkEsaUJBQWlCb08saUJBQWlCbmtDO2FBQ3hELE9BQU9BOzthQUVQLElBQVEsSUFBRSxpQkFDSixFQUFFLGVBQWdCRTthQUN4QixHQUFJNjFCLGlCQUFrQkEsaUJBQWlCb08saUJBQWlCbmtDO2FBQ3hELE9BQU9BOzthQUVQLElBQUkwQyxNQUFRdEM7YUFDWixJQUFXLElBQUYxQyxJQUFNQSxNQUFNQSxJQUFLZ0YsTUFBTWhGLEtBQUs7YUFEckMsSUFFSXNDLEVBQUksb0JBQXFCMEM7YUFDN0IsR0FBSXF6QixpQkFBa0JBLGlCQUFpQm9PLGlCQUFpQm5rQzthQUN4RCxPQUFPQTs7YUFFUCxJQUFJMEMsTUFBUXRDO2FBQ1osSUFBVyxJQUFGMUMsSUFBTUEsTUFBTUEsSUFBS2dGLEVBQUVoRixLQUFLO2FBRGpDLElBRUlzQyxFQUFJLG9CQUFxQjBDO2FBQzdCLEdBQUlxekIsaUJBQWtCQSxpQkFBaUJvTyxpQkFBaUJua0M7YUFDeEQsT0FBT0E7O2FBRVAsSUFBUSxJQUFFLGdCQUNKLE1BQU1JLE1BQU1GO2FBQ2xCRjthQUZBLElBR0kwQyxNQUFRdEM7YUFDWixHQUFJMjFCLGlCQUFrQkEsaUJBQWlCb08saUJBQWlCbmtDO2FBQ3hELElBQVcsSUFBRnRDLElBQU1BLEtBQUt3QyxJQUFJeEM7Y0FBSyxDQUMzQixJQUFXLElBQUZtRixJQUFNQSxNQUFNQSxJQUFLSCxNQUFNRyxLQUFLO2VBQ3JDN0MsRUFBRXRDLEtBQUssb0JBQXFCZ0Y7YUFFOUIsT0FBTzFDOzthQUVQLElBQVEsSUFBRSxnQkFDSixNQUFNSSxNQUFNRjthQUNsQkY7YUFGQSxJQUdJMEMsTUFBUXRDO2FBQ1osR0FBSTIxQixpQkFBa0JBLGlCQUFpQm9PLGlCQUFpQm5rQzthQUN4RCxJQUFXLElBQUZ0QyxJQUFNQSxLQUFLd0MsSUFBSXhDO2NBQUssQ0FDM0IsSUFBVyxJQUFGbUYsSUFBTUEsTUFBTUEsSUFBS0gsRUFBRUcsS0FBSztlQUNqQzdDLEVBQUd0QyxLQUFLLG9CQUFxQmdGO2FBRS9CLE9BQU8xQzs7YUFFUCxJQUFRLElBQUUsaUJBQ0osTUFBTUksTUFBTUY7YUFDbEJGO2FBQ0EsR0FBSSsxQixpQkFBa0JBLGlCQUFpQm9PLGlCQUFpQm5rQzthQUh4RCxJQUlJMEMsTUFBUXRDO2FBQ1osSUFBVyxJQUFGMUMsSUFBTUEsS0FBS3dDLElBQUl4QztjQUFLLENBQzNCLElBQVcsSUFBRm1GLElBQU1BLE1BQU1BLElBQUtILE1BQU1HLEtBQUs7ZUFDckM3QyxFQUFFdEMsS0FBSyxvQkFBcUJnRjthQUU5QixPQUFPMUM7O2FBRVAsSUFBUSxJQUFFLGlCQUNKLE1BQU1JLE1BQU1GO2FBQ2xCRjthQUZBLElBR0kwQyxNQUFRdEM7YUFDWixJQUFXLElBQUYxQyxJQUFNQSxLQUFLd0MsSUFBSXhDO2NBQUssQ0FDM0IsSUFBVyxJQUFGbUYsSUFBTUEsTUFBTUEsSUFBS0gsRUFBRUcsS0FBSztlQUNqQzdDLEVBQUd0QyxLQUFLLG9CQUFxQmdGO2FBRS9CLE9BQU8xQzs7c0JBR1AsMkNBQ0E7Ozs7YUFJQSxJQUFJMkMsRUFBSzthQUNULE9BQVFBLElBQUksc0JBQXdCdkIsS0FBSyxvQkFBcUJ1QjthQUQ5RCxJQUVRLElBQUU2VixnQkFBZ0JwWCxHQUN0QmtqQzthQUNKLEtBQUluTztjQUNGO2FBQ0YsT0FBT255Qjt5QkFFTDs7Z0JBRUEsS0FBSW15QjtpQkFDRjs7Z0JBQ0ZtTyxnQkFBZ0JuTztnQkFDaEI7O2dCQUVBbU8sZ0JBQWdCO2dCQUVoQjtnQkFBa0I7Z0JBQ2xCOzthQWxCRixJQW9CWSxRQUFFbnRCLFNBQ0wsU0FDSCxFQUFFLGdCQUFnQkEsT0FBUXpCO2FBQ2hDLEdBQUc0dUIsaUJBQWlCcm9DO2NBQVUsR0FDekJxb0MsaUJBQWlCNXVCO2VBQ2xCOzthQUVKLEdBQUlxZ0IsaUJBQWtCQSxpQkFBaUJvTyxpQkFBaUJua0M7YUFDeEQsT0FBT0E7b0JBRVAsaURBSVI7TUFDQSxJQUFJRyxJQUFNO01BQ1YsTUFBT2laO09BQWtCLENBQ3ZCLElBQVMsS0FBRSxZQUNMLEVBQUUsWUFDRixFQUFFcFo7UUFDUixHQUFJakUsSUFBSTJaLEtBQU0sV0FBVzFWLEVBQUcwVjtRQUM1QjFWLEVBQUVqRSxLQUFLO01BRVQsVUFBV3VWLGdCQUFlQSxTQUFTNkY7TUFDbkMsT0FBT2hYLEdBQ1Q7SUs5WEEsU0FBU29rQyx5QkFBeUJ6YSxJQUNoQyxPQUFPQSxPQUNUO0lGZUEsU0FBUzBhLDBCQUEwQjFrQztNQUMvQixJQUFJNUIsRUFBSSwwQkFBMEI0QixHQUNsQyxPQUFRNUIsZ0JBQ1o7SWlCc2JBLFNBQVN1bUMsb0JBQW9CdG1CLElBQzNCLE9BQU8sY0FBY0EsR0FDdkI7SVJqTkEsU0FBU3VtQixnQkFBZ0JDLElBQUlDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUc5a0IsR0FBR0M7TUFDMUMsTUFBTUQsS0FBR0MsR0FBSUE7TUFDYkQ7TUFDQUM7TUFDQTtPQUFRO09BQUkra0I7T0FBS0M7T0FBS0M7T0FBVUM7T0FDdEI7T0FDRixLQUFLbGxCLEtBQUtELE1BQU1waUIsWUFBWWtuQyxLQUFHRCxXQUFVTztPQUN2QyxPQUFHbmxCLEtBQUtELE1BQU1waUIsVUFBVThhO09BQzVCLEVBQUVzSCxLQUFLcGlCO01BQ2IsSUFBVSxJQUFEZ0YsSUFBSUEsS0FBRzhWLElBQUk5VjtPQUFJLENBQ3RCb2lDOztRQUFPTDs7UUFBTUc7O1FBQUssU0FBU3JuQzs7UUFBTSxTQUFTc25DLE1BQU1ubkM7O1FBQVlpbkM7O1FBQUssU0FBU3BuQzs7UUFBTSxTQUFTc25DLE1BQU1ubkM7UUFDL0ZvbkMsT0FBTztRQUNQQzs7UUFBT0w7O1FBQU1DOztRQUFLLFNBQVNwbkM7O1FBQU0sU0FBU3NuQyxNQUFNbm5DOztRQUFZa25DOztRQUFLLFNBQVNybkM7O1FBQU0sU0FBU3NuQyxNQUFNbm5DO1FBQy9GcW5DLE9BQU87UUFDUCxHQUFJcmlDO1NBQU0sV0FDR29pQyxLQUFNQzs7U0FDWixHQUFJQyxhQUFXRixRQUFRRyxhQUFXRixLQUFLLFdBQ2pDRCxLQUFNQztRQUVuQkMsWUFBVUY7UUFDVkcsWUFBVUY7UUFDVnhuQyxLQUFJd2dCO01BRU4sUUFDRjtJQTRDQSxTQUFTb25CLGlCQUFpQnhsQyxFQUFFNUIsRUFBRTZtQyxHQUFHRCxHQUFHN2tCLEdBQUdDO01BQ3JDLElBQUk5ZSxFQUFJO01BQ1I7TUFDQSxnQkFBZ0JBLFVBQVV0QixFQUFFc0IsV0FBV2xELEVBQUU2bUMsR0FBR0QsR0FBRzdrQixHQUFHQztNQUNsRDtNQUNBLFFBQ0Y7SVg3RkEsU0FBU3FsQixlQUFnQnpsQyxFQUFHNUIsR0FBSyxPQUFPLE1BQU1BLEVBQUc7SUVyRGpELFNBQVNzbkMsdUJBQXVCMWxDLEVBQUc1QjtNQUMvQixXQUFXMmQsT0FBTyxlQUFlL2IsUUFBUzVCLFNBQzlDO0lBMUdBLFNBQVN1bkMsdUJBQXVCL25DLEdBQzVCLFdBQVdtUSxPQUFPblEsRUFDdEI7SWY0SEEsSUFBSWdvQyxzQkFBd0JobUM7SUF1ZUYsU0FBdEJpbUMsc0JBQWtDL2xDO01BQ2xDO09BQUlPO1FBQU07VUFBaUMsMkJBQTJCUCxHQUFJRjtNQUMxRSxpQkFBaUJTO01BQ2pCLE9BQU9BLEdBSGlCO0lZOVM1QixTQUFTeWxDLHVCQUF3QnhrQyxFQUFHa1E7TUFDbEMsU0FBU3UwQixNQUFNemtDLEVBQUUxRDtRQUNmLE9BQVEsc0JBQXNCMEQsRUFBRzFEOzs7O2VBQzlCLHNCQUFzQjBELEVBQUcxRDs7OztlQUN6QixzQkFBc0IwRCxFQUFHMUQ7Ozs7ZUFDMUIsc0JBQXNCMEQsRUFBRzFELE1BQzdCO01BQ0EsR0FBSSxNQUFNMEQsRUFBR2tRO09BQ1g7TUFDRixPQUFRLE1BQU1sUSxFQUFHa1EsUUFDbkI7SUF2V0EsU0FBU3cwQixlQUFnQjFrQyxFQUFHMUQ7TUFBS3RELFNBQVMsdUJBQXVCZ0gsR0FBSWhILFNBQVNzRCxDQUFHO0lBQ2pGb29DOzt1QkFDdUIsT0FBTyxrQkFBa0IxckMsU0FBdkM7dUJBQ2MsT0FBTyxrQkFBa0JBLHFCQUF2Qzs7O09BRUwsSUFBTSxFQUFFQSxPQUFVLEVBQUVBO09BQ3BCQSxTQUFTc0Q7T0FDVCxPQUFRLGFBQWFBLFVBQVcsYUFBYUEsTUFIdkM7OztPQU1OLElBQU0sRUFBRXRELE9BQVUsRUFBRUE7T0FDcEJBLFNBQVNzRDtPQUNULE9BQVEsYUFBYUEsaUJBQWtCLGFBQWFBLE1BSDlDOzs7T0FNTixJQUFNLEVBQUV0RCxPQUFVLEVBQUVBO09BQ3BCQSxTQUFTc0Q7T0FDVCxRQUFTLGFBQWFBOzs7O2VBQWEsYUFBYUE7Ozs7ZUFDdkMsYUFBYUE7Ozs7ZUFBYSxhQUFhQTs7ZUFKMUM7OztPQU9OLElBQU0sRUFBRXRELE9BQVUsRUFBRUE7T0FDcEJBLFNBQVNzRDtPQUNULE9BQVEsYUFBYUE7Ozs7Y0FBYSxhQUFhQTs7OztjQUM1QyxhQUFhQTs7OztjQUFhLGFBQWFBLE1BSnBDOztjQU1Vd0M7T0FDaEIsSUFBSXhDLEVBQUl0RDtPQUNSQSxTQUFTc0QsSUFBSXdDO09BQ2IsT0FBTyx1QkFBdUIsaUJBQWlCeEMsRUFBR0EsSUFBSXdDLEtBSGhEO0lBK0RWLFNBQVM2bEMsNEJBQTRCM2tDLEVBQUVrUTtNQUNyQztPQUFJNkY7O1NBQWEydUI7VUFBZ0IscUJBQXFCMWtDLFVBQVdrUSxnQkFBY0EsSUFBSUE7TUFDbkYsT0FBTyw2QkFBNkI2RixPQUFRN0YsSUFDOUM7SWU0R0EsU0FBUzAwQixpQkFBa0J2ckI7TUFDekIsSUFBUyxLQUFFRixpQkFBaUJFLFFBRXBCLElBQUU7TUFDVixlQUFlQyxZQUFZcFU7TUFIM0IsSUFNUSxJQUFFLHVCQUF3QkEsWUFFMUIsSUFBRSxrQkFBa0JwRztNQUM1QixlQUFld2EsWUFBWXBVLE1BQU1wRztNQVRqQyxJQVdXLFdBQ0gsSUFBRSw0QkFBNEJvRyxJQUFLRDtNQUMzQ3FVLGNBQWNBLGNBQWNyVTtNQUM1QixPQUFPbEcsR0FDVDtJWHNFQSxTQUFTOGxDLGFBQWE1MEIsSUFDcEIsT0FBT0EsT0FDVDtJMEJ2VEEsU0FBUzYwQix3QkFBd0J4ckI7TUFDL0IsSUFBSTZULEtBQU9oVSxpQkFBaUJHLE1BQzVCLE9BQU82VCxXQUNUO0l0QitKQSxTQUFTNFgsaUJBQWlCaGpDLEVBQUdEO01BQzNCLE9BQVFBO2VBQ0EsT0FBTztlQUNQLE9BQU8sRUFBR0E7ZUFDVixPQUFPLEVBQUdBLEtBQUtBO2VBQ2YsT0FBTyxFQUFHQSxLQUFLQSxLQUFLQTtlQUNwQixPQUFPLEVBQUdBLEtBQUtBLEtBQUtBLEtBQUtBO2VBQ3pCLE9BQU8sRUFBR0EsS0FBS0EsS0FBS0EsS0FBS0EsS0FBS0E7ZUFDOUIsT0FBTyxFQUFHQSxLQUFLQSxLQUFLQSxLQUFLQSxLQUFLQSxLQUFLQTtlQUNuQyxPQUFPLEVBQUdBLEtBQUtBLEtBQUtBLEtBQUtBLEtBQUtBLEtBQUtBLEtBQUtBOztNQUVoRCxPQUFPLFFBQVE5RyxLQUFNLG1CQUFtQjhHLEdBQzFDO0lFM0lBLFNBQVNrakMsb0JBQW9CQyxNQUFRLFFBQVU7SVQ4Sy9DLFNBQVNDLHVCQUF1QnhtQyxHQUFLLFNBQVEsU0FBVztJQXFEeEQsU0FBU3ltQyxrQkFBbUJ6cUMsSUFBS2dFO01BQy9CLElBQUlxRCxFQUFJLGtCQUFrQnJIO01BQzFCLEdBQUlxSCxnQkFBZ0IsdUJBQXVCckQ7T0FBSSxDQUM3Q3FELGFBQWFyRCxJQUFJLGVBQWVBO01BRmxDO09BSVc7T0FDRCxNQUFFLG9CQUFvQnFEO09BQ3RCO01BQ1Y7T0FBRyxDQUNELElBQUltZCxFQUFJLFVBQVVrbUI7UUFDbEIxbUMsSUFBSXdnQjtRQUNKclksU0FBUyxhQUFhLG9CQUFvQnFZLGNBQWNyWTs7VUFDL0MsbUJBQW1Cbkk7TUFDOUIsR0FBSXFEO09BQWEsQ0FDZkE7UUFDQSxJQUFJSixFQUFJSSxTQUFTOEU7UUFDakIsR0FBSWxGLE1BQU9rRixTQUFTLGdCQUFpQmxGLFNBQVVrRjtNQUVqRCxPQUFPLHVCQUF1QjlFLEVBQUc4RSxPQUNuQztJWDRpQkEsU0FBU3krQixnQkFBaUJ0bEMsR0FBSyxPQUFPLHVCQUF1QkEsRUFBRztJYXZoQmhFLFNBQVN1bEMsMEJBQTBCanBDO01BQy9CLE9BQU8sa0JBQWtCLHNCQUF1QkEsUUFDcEQ7SVN3SkEsU0FBU2twQyxtQkFBbUJDO01BQzFCO3NFQUNGO0lUbkZBLFNBQVNDLDBCQUEwQjF4QixPQUFRcFYsRUFBRzBWO01BQzFDLGdCQUFpQjFWLFNBQ2pCMFYsWUFDQUEsV0FDSjtJZjR5REEsU0FBU3F4Qix1Q0FDTCxVQUNKO0lpQzNxRUEsU0FBU0Msd0JBQTJCLFFBQVU7STVCZDlDLFNBQVNDLFlBQWF2a0M7TUFDcEI7T0FBTSxNQUFNcEcsS0FBTW9HO09BQ1IsTUFBRTtPQUNLLGFBQUUsSUFBS3BHLEtBQUssU0FBUztPQUM5QixJQUFFLFlBQVkwMUIsUUFBUUM7TUFDOUI7Y0FBZ0I7Y0FBbUI7Y0FBbUI7Y0FDekM7Y0FBZ0I7Y0FBaUI7Y0FDakM7Y0FBZUM7d0JBRTlCO0lMMFN1QixTQUFuQmdWLG1CQUErQnBuQztNQUMvQixPQUFPLCtCQUErQiw4QkFBOEJBLEdBRC9DO0lLeFR6QixTQUFTcW5DLFlBQ1AsT0FBTyxXQUFXLG9CQUNwQjtJc0I0RkEsU0FBU0M7TUFDUCxJQUFJeGtDO01BQ0osSUFBVSxJQUFGRCxJQUFPQSxJQUFJNFgsd0JBQXlCNVg7T0FBSTtTQUMzQzRYLGlCQUFpQjVYOztTQUFNNFgsaUJBQWlCNVg7O1NBQWE0WCxpQkFBaUI1WDtRQUN2RUMsT0FBSzJYLGlCQUFpQjVYLE1BQU1DO01BRWhDLE9BQU9BLENBQ1Q7SXZCcU1BLFNBQVN5a0MsaUJBQWlCL3JDLEtBQUtxSTtNQUM3QixJQUFJNUIsS0FBTyxrQkFBa0J6RztNQUM3QixLQUFLeUcscUJBQXNCO01BQzNCLHFCQUFxQkEsVUFBVTRCO01BQy9CLFFBQ0Y7SUFLQSxTQUFTMmpDLGlCQUFpQmhzQyxLQUFLcUk7TUFDN0I7T0FBUyxLQUFFLHVCQUF1QnJJO09BQ3RCLFFBQUUsdUJBQXVCcUk7TUFDckMsT0FBTyxpQkFBaUJySSxLQUFNcUksUUFDaEM7STRCbU1BLFNBQVM0akMsVUFBVXBwQjtNQUNqQixJQUFNLEVBQUUsT0FBT0EsWUFBWSxnQkFDbkI7TUFDUixJQUFXLElBQUZ6Z0IsSUFBT0EsSUFBSXdGLGVBQWdCeEY7T0FBSyxNQUNqQyxrQkFBa0I4cEMsSUFBS3RrQyxRQUFReEY7TUFFdkMsR0FBR3dGLHdCQUF5QixNQUNwQixrQkFBa0Jza0M7TUFFMUIsR0FBR3RrQyxhQUFhLE1BQ1Jza0M7TUFFUixPQUFPQSxPQUNUO0lqQjFWQSxTQUFTQyx1QkFBdUIzbkMsRUFBRzVCO01BQy9CLFdBQVcyZCxPQUFPLGVBQWUvYixRQUFTNUIsU0FDOUM7STBCNEZBLFNBQVN3cEMsZ0JBQWdCL3dCLEdBQUd2VixFQUFFZjtNQUM1QixHQUFHQSxXQUFXQSxNQUFNLHNCQUFzQmU7T0FDeEM7TUFDRixJQUFJakIsSUFBTSxTQUFTd1csR0FBSXZWLEVBQUdmO01BQzFCLE9BQUlGLElBQVlBLE9BRWxCO0k3Qm5NQSxTQUFTd25DLGdCQUFpQjdkLEdBQUlwc0IsR0FBS3RELFNBQVMwdkIsR0FBSTF2QixTQUFTc0QsQ0FBRztJQUM1RGlxQzs7dUJBQ3VCLE9BQU8sY0FBY3Z0QyxPQUFPQSxTQUExQzt1QkFDYyxPQUFPLGNBQWNBLE9BQU9BLHFCQUExQzs7O09BRUwsSUFBTSxFQUFFQSxPQUFVLEVBQUVBO09BQ3BCQSxTQUFTc0Q7T0FDVCxPQUFRLGNBQWMwRCxFQUFFMUQsVUFBVyxjQUFjMEQsRUFBRTFELE1BSDdDOzs7T0FNTixJQUFNLEVBQUV0RCxPQUFVLEVBQUVBO09BQ3BCQSxTQUFTc0Q7T0FDVCxPQUFRLGNBQWMwRCxFQUFFMUQsaUJBQWtCLGNBQWMwRCxFQUFFMUQsTUFIcEQ7OztPQU1OLElBQU0sRUFBRXRELE9BQVUsRUFBRUE7T0FDcEJBLFNBQVNzRDtPQUNULFFBQVMsY0FBYzBELEVBQUUxRDs7OztlQUFlLGNBQWMwRCxFQUFFMUQ7Ozs7ZUFDL0MsY0FBYzBELEVBQUUxRDs7OztlQUFjLGNBQWMwRCxFQUFFMUQ7O2VBSmpEOzs7T0FPTixJQUFNLEVBQUV0RCxPQUFVLEVBQUVBO09BQ3BCQSxTQUFTc0Q7T0FDVCxPQUFRLGNBQWMwRCxFQUFFMUQ7Ozs7Y0FBZSxjQUFjMEQsRUFBRTFEOzs7O2NBQ3BELGNBQWMwRCxFQUFFMUQ7Ozs7Y0FBYyxjQUFjMEQsRUFBRTFELE1BSjNDOztjQU1Vd0M7T0FDaEIsSUFBTSxFQUFFOUYsT0FDQSxRQUFNZ0csTUFBTUY7T0FDcEIsSUFBVSxJQUFGMkMsSUFBT0EsSUFBSTNDLElBQUsyQyxJQUFJLElBQ3RCQSxLQUFLLGNBQWN6SSxPQUFRc0QsSUFBRW1GO09BRW5DekksU0FBU3NELElBQUl3QztPQUNiLE9BQU8scUJBQXFCMmhCLElBUHRCO0lJMlFWLFNBQVMrbEIsb0JBQW9CdjJCLEdBQUkzVDtNQUMvQixJQUFJNFQsSUFBTSxVQUFVLG1CQUFtQjVULElBQ3ZDLE9BQU8sT0FBTzRULElBQ2hCO0loQjJKZ0MsU0FBNUJ1MkIsNEJBQXdDN25DLEVBQUdGLEdBQzNDLE9BQU9BLEVBRHVCO0ltQy9mbEMsU0FBU2dvQyxzQkFBc0Job0MsR0FBSyxPQUFPLHdCQUF3QkEsRUFBSTtJbkNpTnZFLElBQUlpb0Msd0JBQTBCcm9DO0lpQjdMOUIsU0FBU3NvQyw2QkFBNkI5MUIsSUFBS0MsS0FBTWlLLElBQUsvSixLQUFNblM7TUFDMUQsU0FBU2dTO09BQ1A7TUFDRixTQUFTa0s7T0FDUDtNQUNGLEdBQUdsYyxTQUFVO01BQ2IsSUFBUyxLQUFFLFdBQVdpUyxNQUNiLEtBQUUsV0FBV0U7TUFDdEIsR0FBRzNHLE9BQU94TCxNQUFNZ1MsZ0JBQWdCO01BR2hDLEdBQUdyRyxPQUFPM0wsTUFBTWtjLGdCQUFnQjtNQUxoQyxJQVFJOUosTUFBUSxrQkFBa0I1RyxLQUFLQSxPQUFLeEw7TUFDeEMsYUFBYW9TLE1BQU1EO01BQ25CLFFBQ0Y7STBCekRBLElBQUk0MUIsaUNBQW1DRDtJWDZqQnZDLFNBQVNFLFVBQVV0VCxFQUFHbDNCO01BQ3BCLElBQVMsS0FBRSxVQUNILElBQUU7TUFDVmszQixJQUFJLE9BQU9BO01BRVgsR0FBSWwzQixlQUFlLEtBQUttOEI7T0FBTztNQUkvQixHQUFJLFNBQVNBLFNBQVMsU0FBU04sS0FBTSxPQUM1QixlQUFlM0U7TUFUeEIsSUFZVSxNQUFFaUYsS0FDSixJQUFFakYsRUFDRixJQUFFeDRCLEtBRUYsSUFBRTtNQUVWLE1BQU8sVUFBVStyQztPQUNqQixDQUNFLElBQVEsSUFBRSxVQUFVQSxZQUFZakksS0FDekIsR0FBRSxRQUFReGlDO1FBQ2pCLEdBQUksVUFBVWszQjtTQUFJLE9BQ1QsZUFBZXlUOztTQUNqQixHQUFJLE1BQU16VCxHQUFJLENBQ25Cbk0sUUFBUSxXQUNSMmYsTUFBTUMsU0FDRCxNQUNDO01BR1YsT0FBTyxlQUFlRCxJQUN4QjtJQWlMQSxTQUFTRyxjQUFjM1Q7TUFDckJBLElBQUksT0FBT0E7TUFDWCxJQUFJaUYsS0FBTztNQUNYLEdBQUksS0FBS0E7T0FBTztNQURoQjtPQUlTLEtBQUUsT0FBTyxVQUFVakY7T0FDcEIsSUFBRSxjQUFjN3lCO09BQ2YsS0FBRSxXQUFXeTNCO01BQ3RCLFVBQVcsZUFBZXozQixNQUFPLGVBQWV5bUMsTUFDbEQ7SUt0d0JBLElBQUlDO0lBOEdKLFNBQVNDLHdCQUF3QjVvQztNQUMvQixPQUFHQSxFQUFFMm9DLDJCQUEyQnhzQzs7a0JBR25CLGFBQWE2RCxFQUFFMm9DLHdCQUM5QjtJZmhHQSxTQUFTRSxtQkFBbUJDLEtBQUtDLFdBQVdDLFNBQzFDLFFBQ0Y7SXRCNnNDQTtLQUFJQztNQUF1Q3JwQztJaUMzdEMzQyxTQUFTc3BDLCtCQUFpQyxRQUFTO0lqQ3U4QlIsU0FBdkNDLHVDQUFtRGgrQixJQUFLbEIsTUFBT2kyQjtNQUMvRDtPQUFlLFdBQUUsdUJBQXVCQTtPQUN6QjtRQUFFO1VBQWtELzBCLElBQUtsQixNQUFPbS9CO01BQy9FLE9BQU87ZUFBMEJDO2VBQVl6cEM7ZUFBdUJDO3FCQUgzQjtJV3QxQjdDLFNBQVN5cEMsUUFBUTM5QixLQUFNQyxLQUFNQyxLQUFNQyxLQUFNQyxLQUFNcTNCLEtBQU0xWDtNQUNuRCxJQUFJbkosTUFBUW1KO01BQ1osSUFBVSxJQUFGOXRCLElBQU9BLElBQUl3bEMsS0FBTXhsQztPQUFLLENBQzVCO1NBQUlvQztXQUFLMkwsVUFBVUMsT0FBS2hPLGFBQWFrTyxVQUFVQyxPQUFLbk8sWUFBWTJrQjtRQUNoRTVXLFVBQVVDLE9BQUtoTyxLQUFLb0M7UUFDcEIsR0FBR0EsS0FBTUEsUUFBVSxlQUVaO01BSVQsT0FBTyxTQUFTMkwsS0FBTUMsT0FBS3czQixLQUFNdjNCLE9BQUt1M0IsS0FBTTdnQixNQUM5QztJQTFIQSxTQUFTZ25CLGFBQWF6bUMsR0FDcEIsV0FBV2swQixNQUFNbDBCLEVBQ25CO0lBd0tBLFNBQVMwbUMsZUFBZTc5QixLQUFNQyxLQUFNQyxLQUFNQyxLQUFNQyxLQUFNcTNCLEtBQU1xRyxLQUFNQztNQUNoRSxJQUFVLFFBQ0osRUFBR0QsVUFBVUM7TUFDbkIsSUFBVSxJQUFGOXJDLElBQU9BLElBQUl3bEMsS0FBTXhsQztPQUFLLENBQzVCO1NBQU87V0FBRytOLFVBQVVDLE9BQUtoTzs7V0FBYWtPLFVBQVVDLE9BQUtuTzs7V0FBYXdGOztVQUFrQm1mO1NBQzdFLElBQUd6VyxVQUFVQyxPQUFLbk8sYUFBYXdGO1FBQ3RDbWYsUUFBUSxXQUFXcW5CO1FBRm5CLElBR0lDLEdBQUtGLEtBQU1DO1FBQ2ZqK0IsVUFBVUMsT0FBS2hPLEtBQUtpc0M7UUFDcEJ0bkIsU0FBUyxXQUFXc25CO01BR3RCLE9BQUd6RyxPQUFPdjNCLFFBQVEwVztlQUNUO2lCQUFRNVcsS0FBTUMsT0FBS3czQixLQUFNdjNCLE9BQUt1M0IsS0FBTSxjQUFjN2dCO2VBRWxEQSxLQUVYO0lBTUEsU0FBU3VuQixTQUFTbitCLEtBQU1DLEtBQU1DLEtBQU1DLEtBQU1DLEtBQU1xM0IsS0FBTXFHLEtBQU1DLEtBQU1LO01BQ2hFLElBQUl4bkI7TUFDSixJQUFVLElBQUYza0IsSUFBT0EsSUFBSW1zQyxLQUFNbnNDO09BQUs7O09BQ25CLGVBQWUrTixLQUFNQyxPQUFLaE8sRUFBR2lPLE9BQUtqTyxFQUFHa08sS0FBTUMsS0FBTXEzQixLQUFNcUcsS0FBTUMsT0FBSzlyQztNQUU3RSxPQUFPMmtCLEtBQ1Q7SUFNQSxTQUFTeW5CLFdBQVdyK0IsS0FBTUMsS0FBTUMsS0FBTUMsS0FBTUMsS0FBTXEzQjtNQUNoRCxJQUFJN2dCO01BQ0pBLFNBQVMsUUFBUTVXLEtBQU1DLEtBQU1DLEtBQU1GLEtBQU1DLEtBQU1DO01BQy9DMFcsU0FBUyxTQUFTNVcsS0FBTUMsS0FBTUMsS0FBTUMsS0FBTUMsS0FBTXEzQixLQUFNdDNCLEtBQU1DLEtBQU1xM0I7TUFDbEUsT0FBTzdnQixLQUNUO0lTNUdBLFNBQVMwbkIsbUJBQW1CanFDLEdBQUssT0FBT0EsQ0FBRztJRXhIM0MsU0FBU2txQyxlQUNQLDBDQUNGO0l0QnN0RUEsU0FBU0MsMEJBQTBCdnNDO01BRS9CLFdBQVdtZSxPQUFPLG9CQUFvQm5lLEdBQzFDO0lBajlEQSxJQUFJd3NDLGtCQUFvQnhxQztJUzdHeEIsU0FBU3lxQyxxQkFBcUIxekIsS0FDNUI4VixZQUFZOVYsSUFDWixRQUNGO0lxQnBGQSxJQUFJMnpCO0lBQ0osU0FBU0MsdUJBQXdCLzZCLElBQUs3TCxJQUFLNm1DO01BQ3pDLElBQVUsTUFBRWg3QixPQUNKLElBQUU4NkIsa0JBQWtCRTtNQUM1QixHQUFJaDVCLFFBQVFyVjtPQUFXLElBRVYsSUFBRnlCLEVBQUkwc0MseUJBQTBCMXNDLElBQUk0c0MsUUFBUzVzQztRQUNsRDBzQyxrQkFBa0Ixc0M7O09BQ2YsR0FBSTZzQyxNQUFNajVCLFNBQVM3TixJQUFLLE9BQ3RCOG1DLE1BQU1qNUI7TUFQZixJQVNPLEtBQVEsR0FBRWk1QixpQkFBa0JoK0I7TUFDbkMsTUFBT2krQixLQUFLaCtCO09BQUksQ0FDZEQsS0FBT2krQixLQUFHaCtCLFlBQ1YsR0FBSS9JLE1BQU04bUMsTUFBTWgrQixRQUFPQyxLQUFLRCxZQUN2QmkrQixLQUFLaitCO01BRVo2OUIsa0JBQWtCRSxXQUFXRTtNQUU3QixPQUFRL21DLE9BQU84bUMsTUFBTUMsUUFBUUQsTUFBTUMsS0FDckM7STlCOHNCZ0MsU0FBNUJDLDRCQUF3QzdxQztNQUN4QyxPQUFPO2VBQTJCO2lCQUF1QzttQkFBMkJBLEdBQUlGLG1DQUQxRTtJNkJweUJsQyxTQUFTZ3JDLDZCQUE2Qmo0QixRQUFTRCxJQUFLRyxRQUFTRCxJQUFLeFM7TUFDaEUsT0FBTyxnQ0FBZ0NzUyxJQUFLQyxRQUFTQyxJQUFLQyxRQUFTelMsSUFDckU7SUgwQkEsU0FBU3lxQztNQUNQO09BQU0sRUFBRXh3QyxtQkFBbUJBO09BQ3JCOzs7Ozs7Ozs7Ozs7Ozs7TUFFTixTQUFTZ0osSUFBTTtNQUNmLElBQVcsSUFBRnpGLElBQU9BLElBQUl3SixTQUFVeEosSUFBSyxLQUFLaUYsRUFBRXVFLEVBQUV4SixJQUFLaUYsRUFBRXVFLEVBQUV4SixNQUFJeUY7TUFDekQsT0FBT1IsQ0FDVDtJakJtRUEsU0FBU2lvQyx1QkFBdUJ0dkMsTUFDOUIsT0FBTyxnQkFBaUJBLEtBQzFCO0lReEdBLFNBQVN1dkMseUJBQXlCeDVCO01BQ2hDO09BQUk4ckI7O1VBQVNoakM7VUFBc0JrWCxVQUFXQSxjQUFlQSxZQUFZQTtNQUN6RSxPQUFPLDRCQUE4QjhyQixXQUFZQSxHQUNuRDtJaEJvUUEsU0FBUzJOLGlCQUFrQmhyQyxHQUFLLE9BQU8sV0FBV0EsRUFBSTtJK0JrUXRELFNBQVNpckMsYUFBYTVzQjtNQUNwQixJQUFNLEVBQUVxQyxZQUNFLE1BQUUsWUFDSCxLQUFFQTtNQUNYLElBQVUsSUFBRjlpQixJQUFPQSxJQUFJLHNCQUFzQnlnQixJQUFLemdCO09BQUksQ0FDaEQsSUFBSTNCLEVBQUksdUJBQXVCb2lCLEdBQUd6Z0I7UUFDbENzRixJQUFJLE9BQU9zZixlQUFldm1CLE9BQU9pSDtRQUNqQ3NmLE9BQU8sT0FBT0EsZUFBZTBvQjtNQUUvQixPQUFPLGVBQWVob0MsRUFDeEI7STNCcGNBLFNBQVNpb0MsVUFBVTN2QztNQUNqQixJQUFJeUcsS0FBTyxrQkFBa0J6RztNQUM3QixLQUFLeUcsaUJBQWtCO01BR3ZCLE9BQU8saUJBQWlCQSxlQUMxQjtJQUlBLElBQUltcEMsYUFBZUQ7SWVpTG5CLFNBQVNFLHFDQUFxQ2hvQztNQUM1QztRQUNFLElBQVEsSUFBRXlRLGlCQUNELFNBQU14VCxNQUFNRjtRQUNyQixJQUFXLElBQUZ4QyxJQUFPQSxJQUFJd0MsSUFBS3hDLElBQUswRyxLQUFLMUcsS0FBS2tXLFVBQVVsVztRQUNsRCxPQUFPLGNBQWN5RixHQUFHL0ksS0FBS2dLLE1BSnhCLENBTVQ7SW5CbEJBLFNBQVNnbkMsZ0JBQWlCdHJDLEdBQUssT0FBTyxVQUFVQSxFQUFJO0lEeWlDakIsU0FBL0J1ckMsK0JBQTJDaGxDLE9BQVE0TSxJQUFLelI7TUFDeEQsR0FBSTZFLGFBQWMsU0FDTHBLLGVBQ04sU0FDTW9LO01BRWIsT0FBTztlQUEwQ0EsT0FBUTRNLElBQUssd0JBQXdCelIsTUFOckQ7SUN0bkNyQyxTQUFTOHBDLGlCQUFrQnhyQyxFQUFFK1U7TUFDM0JBO01BQ0EsR0FBSUE7T0FBWSxDQUNkQTtRQUNBL1UsS0FBSztRQUNMLEdBQUkrVSxXQUFZLENBQ2RBLFlBQ0EvVSxLQUFLO01BR1QsR0FBSStVLGFBQWEsQ0FDZkEsWUFDQS9VLEtBQUs7TUFFUEEsS0FBSyxXQUFZK1U7TUFDakIsT0FBTy9VLENBQ1Q7SStCMHBCQSxTQUFTeXJDLHNCQUFzQnAwQixPQUFROUI7TUFDckMsSUFBSW0yQjtNQUNKLE9BQU87ZUFDQ0EsY0FBZTtlQUNmQSxlQUFnQjtnQkFDZjtNQUpULElBTVEsSUFBRSxpQkFDSixFQUFFO01BQ1IsSUFBVSxJQUFGOXRDLElBQU9BLElBQUl3QyxRQUFTeEM7T0FBSSxDQUM5QixJQUFJUSxFQUFJLE9BQU87UUFDZkEsSUFBSSxNQUFPO1FBQ1hBLElBQUksTUFBTztRQUNYQSxJQUFJLE1BQVE7UUFDWjRCLElBQUksWUFBWXBDLFlBQVlvQztNQUU5QixHQUFHMHJDLE9BQVExckMsSUFBSTtNQUNmdVYsUUFBUW5WO01BQ1IsT0FBTyxlQUFlSixFQUN4QjtJQ2oyQkEsU0FBUzJyQyw2QkFBZ0MsVUFBWTtJL0JrZ0JyRCxTQUFTQyxvQkFBb0I5bEMsR0FBSUU7TUFDOUJGLFlBQWEsNkJBQTZCQTtNQUMxQ0UsWUFBYSw2QkFBNkJBO01BQzNDLE9BQVFGLE9BQU9FLFFBQ2pCO0lBb09BLFNBQVM2bEMscUJBQXFCL2xDLEdBQUlFLElBQ2hDLE9BQU8sb0JBQW9CRixHQUFHRSxHQUNoQztJRmhkQSxJQUFJOGxDLHFCQUF1QmxzQztJOEJ2UjNCLFNBQVNtc0MsaUJBQWtCL3JDLEVBQUcyRCxLQUFPM0QsT0FBTzJELElBQUssUUFBVTtJZm9UM0QsU0FBU3FvQyx5QkFBeUJoc0M7TUFDOUIsSUFBSTVCLEVBQUksMEJBQTBCNEIsR0FDbEMsT0FBUUEsY0FDWjtJQ3VJQSxTQUFTaXNDLGNBQWMxNkIsR0FBSWpDLEdBQUl2SixHQUFJRSxHQUFJL0Y7TUFDckMsT0FBTyxXQUFXb1AsR0FBR3ZKLEdBQUdFLEtBQU0vRixHQUM5QixRQUNGO0lIMU5BLFNBQVNnc0Msb0JBQXFCbHNDO01BQzVCLEdBQUlBLE1BQU9BLElBQUksVUFBVUE7TUFDekI7Y0FBV3VNO2VBQ1R2TTtlQUNBLFdBQVdBLElBQUlxTTtlQUNmLFdBQVdyTSxJQUFJcU0sb0JBQW9CQSw0QkFDdkM7SVNuTkEsU0FBUzgvQixzQkFBc0JscEMsR0FBSyxRQUFVO0lQNUI5QyxTQUFTbXBDLG9CQUFvQnBzQyxFQUFHNUIsR0FDNUIsV0FBVzJQLE9BQU8vTixVQUFVNUIsUUFDaEM7STRCcENBLElBQUlpdUMsOEJBQWdDbDZCO0kzQzhyQ08sU0FBdkNtNkI7TUFDQSxPQUFPO2VBQWlCLG9EQURpQjtJVzNuQzdDLFNBQVNDLHFCQUFxQjk0QixJQUFLakMsSUFBSzhXO01BQ3RDN1UsU0FBU2pDLE9BQU84VyxNQUNoQixRQUNGO0lBR0EsU0FBU2trQixxQkFBcUIvNEIsSUFBS2pDLEtBQ2pDLE9BQU9pQyxTQUFTakMsSUFDbEI7SVQrU0EsU0FBU2k3QixrQkFBa0JuckMsRUFBRTFELEVBQUVxdEIsS0FDN0IsT0FBTyxpQkFBaUIzcEIsRUFBRTFELEVBQUVxdEIsSUFDOUI7SWFwVkEsU0FBU3loQixvQkFBb0Ixc0MsRUFBRzVCLEdBQzVCLFdBQVcyUCxPQUFPL04sVUFBVTVCLFFBQ2hDO0lTa1BBLFNBQVN1dUMsaUJBQWlCM3NDLEVBQUU1QixFQUFFNm1DLEdBQUdELEdBQUc3a0IsR0FBR0M7TUFDckMsSUFBSTllLEVBQUk7TUFDUjtNQUNBLGdCQUFnQkEsVUFBVXRCLEVBQUVzQixXQUFXbEQsRUFBRTZtQyxHQUFHRCxHQUFHN2tCLEdBQUdDO01BQ2xEO01BQ0EsUUFDRjtJcEJqQ0EsU0FBU3dzQixpQkFBaUJDLElBQUtuM0IsS0FBTWdCLE9BQVFvMkIsT0FBUTMyQixLQUFNNVY7TUFFekQsaURBQ0Y7SUFJQSxTQUFTd3NDLDBCQUEwQnBnQixLQUFLcWdCO01BQ3RDLE9BQU8saUJBQWlCcmdCLFFBQVFBLFFBQVFBLFFBQVFBLFFBQVFBLFFBQVFBLFFBQ2xFO0lDMUhBLFNBQVNzZ0IsYUFBYXhrQyxPQUFRaUssSUFBS0U7TUFDakMsSUFBYSxTQUFFLGtCQUFrQkYsS0FDcEIsU0FBRSxrQkFBa0JFO01BQ2pDLEdBQUdzNkIsbUJBQW1CQztPQUNwQjtNQUNGLEtBQUtEO09BQXlCO01BRzlCLE9BQU8sd0JBQXdCemtDLE9BQVF5a0MsY0FBZUMsbUJBQ3hEO0lMNCtEc0IsU0FBbEJDLGtCQUE4QjNNLFNBQVVDLGVBQWdCMWhCO01BQ3hELE9BQU87ZUFBcUI7aUJBQ3hCO21CQUEwQnloQixTQUFVOWlCO2lCQUNwQywyQ0FBMkMraUI7aUJBQzNDLDRCQUE0QjFoQixRQUpaO0lBb0l4QixTQUFTcXVCO01BQ0w7YUFBVTl0Qjt5RUFDZDtJZ0J2L0NBLFNBQVMrdEIsb0JBQW9CQyxNQUFPQyxNQUFPQyxNQUFPLzNCLEtBQU1nQixPQUFRUDtNQUM5RCxHQUFHcTNCLFNBQVMsNkJBQTZCOTNCO09BQVc7O01BR3BELE9BQU8sc0JBQXNCQSxLQUFNZ0IsT0FBUVAsS0FBTW8zQixNQUNuRDtJaEJyUXVCLFNBQW5CRyxtQkFBK0J4dEMsRUFBR3RDO01BQ2xDLElBQUk4akIsTUFBUXhoQixFQUFFdEM7TUFDZCxHQUFJOGpCLFVBQVV2bEI7T0FBVyxNQUNqQjs7O2VBQXdEeUI7Ozs7Z0JBQVdzQztNQUUzRSxZQUFXL0UsOEJBQTZCdW1CLE1BTG5CO0ltQzdkekIsU0FBU2lzQixzQkFBc0IzdEMsR0FBSyxPQUFPLHdCQUF3QkEsRUFBSTtJakJoQ3ZFLFNBQVM0dEMscUNBQXFDbDdCLElBQUtDLFFBQVNDLElBQUtDLFFBQVN6UztNQUN4RSxPQUFPLGlDQUFpQ3NTLElBQUlDLFFBQVFDLElBQUlDLFFBQVF6UyxJQUNsRTtJTW9UQSxTQUFTeXRDLGlCQUFpQmgwQjtNQUN4QixJQUFNLEVBQUUsb0JBQ0YsRUFBRSxzQkFBc0JBLEtBQ3ZCLEdBQUV6UztNQUNULG1CQUFtQnlTLElBQUl2WSxJQUFJQSxXQUFXQTtNQUN0Q0EsT0FBT3dzQztNQUNQLFFBQ0Y7SUFZQSxTQUFTQyxvQkFBb0JsMEI7TUFDM0IsaUJBQWlCLHdCQUF3QkEsTUFDekMsUUFDRjtJeEJ5SDBCLFNBQXRCbTBCLHdCQUNBLFVBRHdCO0lZalc1QixTQUFTQyw2QkFBNkIzc0MsRUFBRWtRO01BQ3RDLElBQUk2RixXQUFhMnVCLGVBQWdCMWtDLFNBQVVrUSxnQkFBY0EsSUFBSUE7TUFDN0QsT0FBTyw2QkFBNkI2RixPQUFRN0YsSUFDOUM7SUg4TEEsU0FBUzA4QixvQ0FBb0NDLFVBQzNDLFFBQ0Y7SVQrVzBCLFNBQXRCQyxzQkFBa0N0dUM7TUFDbEMsSUFBSU8sSUFBTSxpQ0FBaUNQO01BQzNDLE9BQU8sMkJBQTJCTyxJQUZWO0lBa1VMLFNBQW5CZ3VDLG1CQUErQnp3QztNQUMvQixPQUFPLGlCQUFpQiw4QkFBOEJBLEdBRGpDO0kyQnhrQnpCLFNBQVMwd0MsZ0JBQWdCM3pCO01BQ3ZCLGNBQWNBLFFBQ2QsT0FBT0YsaUJBQWlCRSxjQUMxQjtJTzdhQSxJQUFJNHpCLDZCQUErQmhaO0l6QnFUbkMsU0FBU2laLHVCQUF1QmxrQixPQUM5QixRQUNGO0lXMkJBLFNBQVNta0IsZUFBZ0JyckM7TUFDdkIsSUFBSW1GO01BQ0osSUFBVyxJQUFGM0ssSUFBT0EsSUFBSXdGLFNBQVV4RjtPQUFLLENBQ2pDLElBQUk0aUIsRUFBSXBkLEVBQUV4RixHQUNWMkssRUFBRSx3QkFBd0JpWSxTQUFTQTtNQUVyQyxPQUFPalksQ0FDVDtJTFZBLFNBQVNtbUMsd0JBQXdCcDVCLE9BQVFwVixFQUFHcVk7TUFDeEMsbUJBQW1CakQsT0FBUXBWLFFBQVNxWSxNQUN4QztJZHRCQSxTQUFTbzJCLGVBQWUzdUMsRUFBRzVCLEVBQUcwMkI7TUFDNUI7T0FBVSxNQUFFO09BQ0UsVUFBRTtPQUNKLFFBQUU7T0FDUjtPQUNBLEVBQUUsYUFBYWlhO09BQ2YsRUFBRSxhQUFhQTtNQUVyQixTQUFTRyxTQUFVOXJDLEVBQUdUO1FBQ3BCO1NBQU8sR0FBRWlzQyxRQUFReHJDO1NBQ1QsSUFBRStyQyxNQUFNQSxLQUFLL3JDO1NBQ2IsSUFBRUEsSUFBSWdzQztTQUNQLEdBQUVSLFFBQVFqc0M7U0FDVCxJQUFFMnNDLE1BQU1BLEtBQUszc0M7U0FDYixJQUFFQSxJQUFJNHNDO1NBQ1IsRUFBRW5zQyxJQUFJVDtTQUNOLEVBQUl5c0MsTUFBTUcsTUFBTS91QixJQUFLNHVCLE1BQU1JLE1BQU1ILE1BQU1FLE1BQU9GLE1BQU1HO1FBQzFELFVBQ0todkIsSUFDQXJhLEVBRVA7TUFFQSxTQUFTaWMsSUFBS2hmLEVBQUdUO1FBQ2YsSUFBTSxFQUFFUyxJQUFJVCxFQUNOLEVBQUVyQixJQUFJOEIsRUFDTixFQUFHQSxLQUFLOUIsSUFBSXBCLE1BQU95QyxJQUFJekMsR0FDN0IsVUFDS29CLElBQ0E2RSxFQUVQO01BRUEsU0FBU3NwQyxPQUFRenZDLEVBQUc1QjtRQUNsQixPQUFPNEIsV0FBVzVCLFdBQVd3d0MsUUFBUTV1QyxLQUFLNHVDLFFBQVE1dUMsSUFBSUEsT0FBT0E7aUJBQUlBLFVBQVVBLGtCQUFvQjVCLGlCQUFtQjB3QztpQkFBVzl1QyxDQUMvSDtNQUVBO1FBQUlBOzs7O1FBQVdBOztRQUFNQTs7UUFBS0E7Ozs7O1FBQWdCQTs7Ozs7UUFDdEM1Qjs7OztRQUFXQTs7UUFBTUE7O1FBQUtBOzs7OztRQUFnQkE7Ozs7T0FBYyxPQUMvQzRCLElBQUk1QixJQUFJMDJCO01BRWpCLEdBQUlBLFFBQVMsT0FDSjkwQixJQUFJNUI7TUFFYixHQUFJMDJCLE1BQU1BLEtBQUtBLG1CQUFnQkEsZ0JBQWMsT0FDcENBO01BR1QsSUFBSTRhO01BQ0osTUFBTyxTQUFTMXZDLEtBQUtndkMsRUFBRyxDQUN0QlUsU0FBU1YsRUFDVGh2QyxLQUFLaXZDO01BRVAsTUFBTyxTQUFTN3dDLEtBQUs0d0MsRUFBRyxDQUN0QlUsU0FBU1YsRUFDVDV3QyxLQUFLNndDO01BRVAsR0FBSVMsZ0JBQWlCLE9BQ1oxdkMsSUFBSTVCLElBQUlzeEM7TUFFakIsTUFBTyxTQUFTMXZDLEtBQUtpdkMsRUFBRyxDQUN0QlMsU0FBU1QsRUFDVGp2QyxLQUFLZ3ZDO01BRVAsTUFBTyxTQUFTNXdDLEtBQUs2d0MsRUFBRyxDQUN0QlMsU0FBU1QsRUFDVDd3QyxLQUFLNHdDO01BRVAsR0FBSVUsWUFBYSxPQUNSNWE7TUFyQlQsSUF3Qk8sR0FBRTkwQixFQUNGLEdBQUU1QixFQUNGLEdBQUUwMkIsSUFBSTRhO01BRWIsR0FBSSxTQUFTRyxNQUFNLFNBQVNGLEtBQUtDLFVBQVVkLFFBQVMsT0FDM0NoYTtNQUVULEdBQUksU0FBUythLE1BQU0sU0FBU0YsS0FBS0MsTUFBTWQsY0FBY0E7T0FBYSxNQUMxRGhhLGlCQUFtQitaO01BaEMzQjtPQW1DTyxHQUFFLFNBQVNjLEdBQUlDO09BQ2hCLEVBQUUsSUFBSUUsS0FBTUQ7T0FDWixFQUFFLElBQUlDLEtBQU14dUM7T0FDWixFQUFFLElBQUlBLElBQUt5dUM7T0FFWCxFQUFFbnlDLE1BQU0sT0FBT0EsSUFBS215QztNQUMxQixHQUFJMXNDLFFBQVMsT0FDSkE7TUExQ1QsSUE2Q0l5ckIsR0FBS3pyQixJQUFJcXNDO01BQ2IsR0FBSSxTQUFTNWdCLE1BQU0rZixVQUFXLE9BQ3JCL2Y7TUFJVCxPQUFPQSxLQUFLLE9BQU96ckIsSUFBSXlyQixLQUFLNGdCLE1BQU85eEMsT0FBTzh4QyxLQUM1QztJRDlaNkIsU0FBekJNLHlCQUFxQ0M7TUFDckMsSUFBVyxPQUFFQSxrQkFDRyxZQUFFLGtCQUFrQnZ5QztNQUNwQyxJQUFXLElBQUZFLElBQU9BLElBQUlGLE9BQVFFO09BQUssc0JBRVAyeUIsWUFBYTN5QixFQUFHcXlDLFdBQVdyeUM7TUFFckQsT0FBTzJ5QixXQVBvQjtJQTh0Q1ksU0FBdkMyZjtNQUFtRHZPLGtCQUFtQkM7TUFDdEU7T0FBSXFPO1FBQWE7VUFBa0R0TyxrQkFBbUJDO01BQ3RGLE9BQU8seUJBQXlCcU8sV0FGUztJa0NudEM3QyxTQUFTRSw2QkFBZ0MsUUFBUztJaEMrTWxELFNBQVNDLGtCQUFrQjl1QyxFQUFFMUQ7TUFDM0IsR0FBSUEsV0FBVyxzQkFBc0IwRCxPQUFRO01BQzdDLElBQU8sR0FBRSx1QkFBd0JBLEVBQUcxRCxHQUM3QixHQUFFLHVCQUF3QjBELEVBQUcxRDtNQUNwQyxPQUFROFQsVUFBVUQsRUFDcEI7SUZvbENBO0tBQUk0K0I7TUFBMkN6d0M7SXFDcHFDL0MsU0FBUzB3QyxxQkFBcUJ0d0MsRUFBRzhWO01BQy9COVYsRUFBRTJvQyx5QkFBeUJ4c0MsVUFDM0IsUUFDRjtJQTlFQSxTQUFTbzBDLGVBQWVwd0IsR0FBSXBhLEdBQUlxYSxHQUFJbmEsR0FBSTdGO01BRXRDO1FBQWdCK2YsR0FBSTZQLHVCQUF1QmpxQixPQUMzQnFhLEdBQUk0UCx1QkFBdUIvcEIsT0FDM0I3RjtNQUNoQixRQUNGO0lBUUEsSUFBSW93QyxtQkFBcUJEO0lyQzhsQ2tCLFNBQXZDRTtNQUFtRDlPLGtCQUFtQkM7TUFDdEU7T0FBSXFPO1FBQWE7VUFBa0R0TyxrQkFBbUJDO01BQ3RGLE9BQU8seUJBQXlCcU8sV0FGUztJU2ovQjdDLElBQUlTLGtCQUFvQixJQUFLbDBDO0lBQzdCLFNBQVNtMEM7TUFDUCxJQUFJQyxJQUFNLElBQUtwMEMsaUJBQ2YsT0FBT28wQyxjQUFjRixpQkFDdkI7SUFJQSxTQUFTRywrQkFBK0JsdUMsR0FDdEMsT0FBTyxlQUNUO0lUdzhEcUIsU0FBakJtdUM7TUFDQSxPQUFPLHFCQUFxQiw4QkFEVDtJbUNqcEV2QixTQUFTQyw4QkFBOEIvd0MsR0FDckMsUUFDRjtJbkN1dkVBLFNBQVNneEM7TUFDTDthQUFVenhCO2lGQUNkO0lBM3NFQSxJQUFJMHhCLHdCQUEwQnJ4QztJZ0JnekI5QixTQUFTc3hDLHVCQUF1QjMvQixJQUM5QixPQUFPQSxPQUNUO0lmMW9CQSxTQUFTNC9CLGlCQUFrQm54QztNQUN6QixHQUFLQSxZQUFZLFNBQVNBLEdBQUksVUFBV0E7TUFDekMsSUFBSWdwQixJQUFNaHBCO01BQ1YsR0FBSWdwQixJQUFLaHBCLE1BQU1BO01BRGYsSUFFSStVLElBQU0sZ0JBQWdCLGdCQUFnQi9VO01BQzFDQSxLQUFLLGFBQVkrVTtNQUNqQixNQUFPL1UsUUFBUyxDQUNkQSxPQUNBK1U7TUFFRixNQUFPL1UsT0FBUSxDQUNiQSxTQUNBK1U7TUFFRixHQUFJaVUsSUFBS2hwQixNQUFNQTtNQUNmLFVBQVdBLEVBQUcrVSxJQUNoQjtJaUN4TUEsU0FBU3E4QixxQ0FBcUNweEM7TUFDNUMsVUFBU0EsYUFBYU0sTUFDeEI7SWpCNkNBLFNBQVMrd0MsZ0NBQWdDaDFCLEtBQU1oSyxLQUFNaUssSUFBSy9KLEtBQU1uUztNQUM5RCxTQUFTa2M7T0FDUDs7TUFDRixHQUFHbGMsU0FBVTtNQUNiLElBQUkyTCxLQUFPLFdBQVd3RztNQUN0QixHQUFHRixPQUFPalMsTUFBTSxxQkFBcUJpYyxNQUFPO01BRzVDLEdBQUd0USxPQUFPM0wsTUFBTWtjLGdCQUFpQjtNQUpqQyxJQU9JOUosTUFBUSxvQkFBb0I2SixZQUFZaEssS0FBS0EsT0FBT2pTO01BQ3hELGFBQWFvUyxNQUFNekc7TUFDbkIsUUFDRjtJQ2hGQSxTQUFTdWxDLG9DQUFvQzUrQixJQUFLQyxRQUFTQyxJQUFLQyxRQUFTelM7TUFDdkUsT0FBTyxnQ0FBZ0NzUyxJQUFJQyxRQUFRQyxJQUFJQyxRQUFRelMsSUFDakU7SWN3R0EsU0FBU214QyxVQUFVbHpCLElBQ2pCLE9BQU8sZUFBZSxPQUFPQSxXQUMvQjtJQTZsQkEsU0FBU216QixhQUFhbnpCLEdBQUk5ZCxJQUFLSDtNQUM3QmllLEtBQUssT0FBT0E7TUFDWixPQUFPO2VBQWUsY0FBYzlkLFNBQVMsY0FBY0gsa0JBQzdEO0lBL2pCQSxTQUFTcXhDLFlBQVlwekIsSUFDbkIsT0FBTyxlQUFlLE9BQU9BLFVBQy9CO0loQ3lOQSxJQUFJcXpCLGtCQUFvQjl4QztJQTlOSSxTQUF4Qit4Qyx3QkFBb0MzeEM7TUFDcEMsT0FBTyxnQkFBZ0IsbUNBQW1DQSxHQURoQztJQWcrREwsU0FBckI0eEMscUJBQWlDNXhDLEVBQUdHLE1BQU93YjtNQUMzQztjQUFXeGI7ZUFDUCw0QkFBNEJILEtBQU0yYjtlQUNsQzNiO2VBQ0FBO2VBQ0Esd0NBQXdDQTtlQUN4Q0EsS0FObUI7SUFnQ0YsU0FBckI2eEMscUJBQWlDN3hDO01BQ2pDLE9BQU87ZUFBcUI7aUJBQ3hCO21CQUFxQkEsRUFBR0oseUJBQTBCQSxpQ0FGL0I7SXNCMWxFM0IsU0FBU2t5QyxvQkFBb0I1L0IsTUFBUSxRQUFVO0lia0MvQyxTQUFTNi9CLG9CQUFvQi84QixFQUFFOVU7TUFDN0IsS0FBSTdGLDJCQUNGQTtNQUNGQSwyQkFBMkIyYSxLQUFLOVU7TUFDaEMsUUFDRjtJTzZOQSxTQUFTOHhDLHNCQUFzQnpnQyxHQUFJbUY7TUFDakMsR0FBR25GLGFBQWFtRixPQUFRLE9BQU9uRjtNQUMvQixJQUFJMGdDO01BQ0osSUFBVSxJQUFGcjBDLElBQU9BLElBQUkyVCxlQUFnQjNUO09BQUtxMEMsU0FBU3IwQyxLQUFLMlQsUUFBUUEsaUJBQWlCM1Q7TUFDL0UsT0FBTyxzQkFBc0IyVCxRQUFTbUYsT0FBUXU3QixTQUFVMWdDLFFBQzFEO0lrQnpTQSxTQUFTMmdDLGdDQUFtQyxRQUFTO0lsQ2txRXJELFNBQVNDLHVDQUNMLFVBQ0o7SUtua0VBLFNBQVNDLFdBQVc1MkMsS0FBTTYyQztNQUN4QixJQUFJcHdDLEtBQU8sa0JBQWtCekc7TUFDN0IsS0FBS3lHLGtCQUFtQjtNQUd4QixPQUFPLGtCQUFrQkEsVUFBV293QyxVQUN0QztJbUJvR0EsU0FBU0Msb0JBQ1AsSUFBSWh4QyxFQUFJLG9CQUNSLE9BQU9BLEdBQ1Q7SVYvTkEsU0FBU2l4QyxnQkFBZ0J2MkMsSUFBSzRCO01BQzVCLEdBQUksdUJBQXVCNUI7T0FBYyxPQUFPLDRCQUEwQjRCO01BQzFFLElBQUl5RixFQUFJLGtCQUFrQnJIO01BQzFCLEdBQUk0QixNQUFPLEdBQU15RixhQUFjLENBQUVBLGFBQWF6RixNQUFLQSxPQUFVQTtNQUQ3RCxJQUVJMEQsRUFBSSxXQUFXK0I7TUFDbkIsR0FBSUE7T0FBYSxDQUNmQTtRQUNBLElBQUlKLEVBQUlJLFNBQVMvQjtRQUNqQixHQUFJMkIsTUFBTzNCLElBQUksZ0JBQWlCMkIsU0FBVTNCO01BRTVDLE9BQU8sdUJBQXVCK0IsRUFBRy9CLEVBQ25DO0lnQjJDQSxTQUFTa3hDLGtCQUFtQnh5QyxFQUFHc0I7TUFDN0IsR0FBSUEsVUFBUUEsUUFBUXRCLFNBQ2xCO01BQ0YsR0FBSUEsWUFBWXNCLE1BQU90QixXQUFXc0I7TUFDbEMsUUFDRjtJOUIyOEJvQyxTQUFoQ214QyxnQ0FBNEM3dkMsRUFBRzh2QyxZQUFhOTBDO01BQzVELElBQUl5QyxJQUFNLDJDQUEyQ3VDLEVBQUc4dkMsWUFBYTkwQztNQUNyRSxPQUFPLDhCQUE4QnlDLElBRkg7SVNqd0J0QyxTQUFTc3lDLHFCQUFxQnJvQixPQUM1QixPQUFPLDBCQUNUO0ltQmpQQSxTQUFTc29CLGtCQUFrQjl2QztNQUN6QixJQUFJTTtNQUNKLE1BQU9OO09BQVMsQ0FDZCxJQUFJSCxFQUFJRyxLQUNSLElBQVcsSUFBRmxGLElBQU9BLElBQUkrRSxTQUFVL0UsSUFBSyxPQUFPK0UsRUFBRS9FLElBQzVDa0YsSUFBSUE7TUFFTixPQUFPTSxDQUNUO0lKbEJBLFNBQVN5dkMsa0JBQWtCaE87TUFDekI1b0IsZ0JBQWM0b0IsSUFDZCxxQkFDQSxRQUNGO0lBaUVBLFNBQVNpTyxxQkFBcUJDLE9BQU83NkIsRUFBRXRMO01BQ3JDLElBQUlvbUMsUUFBVTtNQUNkLGdCQUNXQTtxQkFDQUQ7OztvQkFHRDc2QjtxQkFDQ3RMOzttQkFFRjs7O29CQUdDLDJCQUVaO0lBekVBLFNBQVNxbUMsbUJBQW1CeGtCO01BQzFCLElBQU0sRUFBRXAwQixXQUNDLEtBQUUsd0JBQXdCbzBCO01BQ25DLFNBQVNsMEIsSUFBSWlCO1FBQ1gsSUFBSTZFLElBQU0sdUJBQXFCN0U7UUFDL0IsR0FBRzZFLElBQUssT0FBT0EsTUFDakI7TUFDQSxJQUFJNnlDO01BQ0osTUFBS3prQixZQUFXLFdBQVdBO01BRDNCLElBRUkvbEIsT0FBUztNQUNiLEtBQUlBLE9BQVFBO01BSFosSUFJSXlxQyxPQUFTO01BQ2IsS0FBSUEsT0FBUTtNQUxaLElBT0lqN0IsRUFBSTtNQUNSQSxJQUFJQSxFQUFFLFNBQVNBO01BQ2Ysc0JBQW9CQTtNQVRwQixJQVdJdEwsRUFBSTtNQUNSQSxJQUFJQSxFQUFFLFNBQVNBO01BQ2YsdUJBQXFCQTtNQWJyQixJQWVJd21DLElBQU0scUJBQXFCMXFDLE9BQU87TUFDdEMsS0FBSTBxQyxJQUFLO01BaEJULElBaUJRLElBQUVBLGFBQ0MsT0FBRTtNQUNiTCxlQUFlNzZCO01BQ2Y2NkIsZ0JBQWdCbm1DO01BcEJoQixJQXFCSWk0QixJQUFNLHFCQUFxQmtPLE9BQU83NkIsRUFBRXRMO01BQ3hDaTRCLHlCQUEwQnlPLE9BQ3hCRCxZQUFZQyxLQURFO01BR2hCLGtCQUFrQnpPO01BekJsQixJQTBCSTBPLEtBQU9GO01BQ1hFO01BQ0EsaUJBQWlCUjtNQUNqQixRQUNGO0l4QmtvQkEsSUFBSVMsd0JBQTBCNXpDO0lxQ2xrQjlCLFNBQVM2ekMsbUJBQW1CenpDLEVBQUc4VjtNQUM3QjlWLEVBQUUyb0MseUJBQXlCN3lCLEtBQzNCLFFBQ0Y7SVRoQ0EsU0FBUzQ5QixxQkFBcUJ0ekM7TUFDNUIsR0FBSUEsUUFBUztNQUNiLElBQVEsSUFBRUEsWUFDSixNQUFNRSxNQUFNRjtNQUNsQnVDO01BQ0EsSUFBVyxJQUFGL0UsSUFBT0EsSUFBSXdDLElBQUt4QyxJQUFLK0UsRUFBRS9FO01BQ2hDLE9BQU8rRSxDQUNUO0k1QjFGK0IsU0FBM0JneEMsMkJBQXVDcnlDLEVBQUdsQixJQUFLb2lCO01BQy9DLE9BQU87ZUFBc0Msd0JBQXdCbGhCLEdBQUlsQixJQUFLb2lCLEtBRGpEO0lBNEJqQyxJQUFJb3hCLHNCQUF3QmgwQztJc0JYNUIsU0FBU2kwQyxrQkFBa0IzaEMsTUFDekIsUUFDRjtJR21NQSxTQUFTNGhDLGtCQUFtQjl6QyxFQUFHNUI7TUFBSyxVQUFTLGlCQUFpQjRCLEVBQUU1QixjQUFnQjtJekIrRGhGLElBQUkyMUMscUJBQXVCbjBDO0lBc0RFLFNBQXpCbzBDLHlCQUFxQ2gwQztNQUNyQyxtQkFBbUJBLEVBQUcscUJBQXFCQSxHQURoQjtJZ0NxRS9CLFNBQVNpMEMsYUFBYTUxQjtNQUNwQkEsS0FBSyxPQUFPQTtNQUNaLElBQU0sSUFDUyxXQUFFcUM7TUFDakIsTUFBTyxlQUFlckMsSUFBSyxDQUN6QnBiLE9BQ0FpeEMsYUFBYTtNQUVmLE9BQU9qeEMsQ0FDVDtJQ2phQSxTQUFTa3hDLG1DQUFzQyxVQUFZO0loQ3NQM0QsU0FBU0MsaUJBQWlCcDBDLEdBQUssT0FBTyxXQUFXQSxFQUFJO0lEMDhEckQsU0FBU3EwQyxvQ0FBb0NDLGFBQWNDO01BRXZEO09BQXFCO1FBQUU7VUFBK0MsdUJBQXVCQTtPQUMzRSxjQUFFLHVCQUF1QkM7TUFFM0MsK0JBQWdDcHhDLEVBQUd4RixHQUMvQjIyQyxVQUFVMzJDLEtBQUt3RixDQURHLEVBRzFCO0k4QnZvRUEsU0FBU3N4Qyx1QkFBd0J4MEMsR0FBSyxZQUFhQSxFQUFJO0lqQnNLdkQsU0FBU3kwQyx1QkFBd0IzMEMsRUFBR3NCLEdBQUssT0FBTyxjQUFjQSxFQUFHO0lFaERqRSxTQUFTc3pDLG9CQUFvQjUwQyxFQUFHNUI7TUFDNUIsV0FBVzJkLE9BQU8sZUFBZS9iLFFBQVM1QixTQUM5QztJaUJtTUEsU0FBU3kyQyxhQUFheDJCLEdBQUlDLElBQ3hCLE9BQU8sT0FBT0QsWUFBWSxPQUFPQyxJQUNuQztJQWhZQSxTQUFTdzJCLFVBQVU1aUM7TUFDakJ3Rzs7aUJBQ2dCZ3FCO21CQUNFK0k7WUFDUGhFO2VBQ0dvTjtNQUVkLFFBQVM7SXZCUVgsU0FBU0UsMEJBQTBCbmtCO01BQ2pDLE9BQU9BLHFDQUlMLGlCQUVBLFNBRUo7SUFJQSxTQUFTb2tCLHNCQUFzQnBrQjtNQUM3QixJQUFJMXRCO01BQ0osR0FBRzB0QjtPQUFhLENBQ2QxdEIsS0FBSzB0QjtRQUNMO1VBQUdBOzs7O1VBQW1CQTs7OztVQUFrQiwwQkFBMEJBO1NBRWhFLElBQVcsT0FBRUEsT0FDSDs7U0FFVixJQUFVLFFBQ0MsT0FBRUE7UUFFZjF0QjtRQUNBLElBQVUsSUFBRnRGLEVBQUkrcUIsTUFBTy9xQixJQUFJcTNDLGNBQWVyM0M7U0FBSyxDQUN6QyxHQUFHQSxJQUFJK3FCLE1BQU96bEI7VUFDZCxJQUFJaEQsRUFBSSswQyxPQUFPcjNDO1VBQ2YsVUFBVXNDO1dBQ1JnRCxLQUFJOztXQUNELEdBQUdoRCxhQUFhd0Q7WUFBUSxXQUNqQjs7WUFFUCxVQUFVeEQ7YUFBYyxXQUNqQjs7YUFFUGdEO1FBRVBBOztPQUNLLEdBQUkwdEIsY0FBYyxLQUNsQkE7TUFFUCxPQUFPMXRCLENBQ1Q7SWVzQ0EsU0FBU2d5QyxxQkFBcUJDO01BQzVCLEdBQUdBLDJCQUNELE9BQU9BLDBCQUNYO0l4QnFwQ21DLFNBQS9CQywrQkFBMkM3dUMsT0FBUTRNLElBQUt6UjtNQUN4RCxHQUFJNkUsYUFBYyxTQUNMcEssZUFDTixTQUNNb0s7TUFFYixPQUFPO2VBQTBDQSxPQUFRNE0sSUFBSyx3QkFBd0J6UixNQU5yRDtJQXRvQ3JDLElBQUkyekMscUJBQXVCejFDO0k2QnpGM0IsU0FBUzAxQyw4QkFBK0IzaUMsUUFBU0QsSUFBS0csUUFBU0QsSUFBS3hTO01BQ2xFLE9BQU8saUNBQWlDc1MsSUFBSUMsUUFBU0MsSUFBS0MsUUFBUXpTLElBQ3BFO0lJZkEsU0FBU20xQztNQUNQOytEQUNGO0lqQ2dHQSxJQUFJQyxrQkFBb0I1MUM7SUFnRUUsU0FBdEI2MUMsc0JBQWtDejFDLEVBQUc1QjtNQUNyQyxtQkFBbUI0QixFQUFHLGtCQUFrQkEsRUFBRzVCLEdBRG5CO0lPOUs1QixTQUFTczNDLHlCQUEwQi94QyxLQUFPLE9BQU9BLEdBQUs7SVF5VHRELFNBQVNneUMsMEJBQTBCdCtCLE9BQVF6QjtNQUN2QyxXQUFXbUcsT0FBTyxxQkFBcUIxRSxPQUFRekIsTUFDbkQ7SWlCMkhBLFNBQVNnZ0MsZ0JBQWdCdjNCO01BQ3ZCQSxLQUFLLE9BQU9BO01BQ1osT0FBSSxXQUFXOzs7O2NBQXVDLFdBQVc7Ozs7Z0JBSW5FO0lBeE5BLFNBQVN3M0IsY0FBY3gzQjtNQUNyQkEsS0FBSyxPQUFPQTtNQUNaLEtBQUksZ0JBQWdCQTtPQUFLLG9CQUNIO01BRXRCO09BQVMsS0FBRTtPQUNKLEdBQUUsT0FBT3kzQjtPQUNULEdBQUUsc0JBQXNCQTtPQUN6QixFQUFFLHdCQUF3QnRwQyxHQUFJRTtNQUNwQyxPQUFPMU0sQ0FDVDtJQWlsQkEsU0FBUysxQyxVQUFVMTNCO01BRWpCLE9BQU8sT0FBT0EsWUFBWSw0QkFDNUI7SUNyMEJBLFNBQVMyM0Isd0JBQTJCLFFBQVU7SWhDNEs5QyxTQUFTQyxnQkFBaUJqMkM7TUFDeEIsR0FBSSxTQUFVQTtPQUFJLENBQ2hCLElBQUlncEIsUUFBU2hwQjtRQUNiQSxJQUFJLFNBQVNBO1FBRGIsSUFFTSxFQUFFLFdBQVlBLEdBQ2QsRUFBRUEsSUFBSXBDO1FBQ1osR0FBSW9yQixJQUFLLENBQUVwckIsTUFBS0EsRUFBR3lGLE1BQUtBO1FBQ3hCLFVBQVdBLEVBQUd6RjtNQUVoQixHQUFJLE1BQU9vQyxHQUFJLFVBQVdpVyxJQUFLQTtNQUMvQixjQUFhalcsRUFBR0EsRUFDbEI7SXFCaExBLFNBQVNrMkMsY0FDUCwwQkFDRjtJckJzTkEsU0FBU0MsbUJBQW9CbjJDLEVBQUc1QjtNQUM5QixHQUFJNEIsTUFBTTVCLEVBQUc7TUFDYixHQUFJNEIsSUFBSTVCLEVBQUc7TUFDWCxHQUFJNEIsSUFBSTVCLEVBQUc7TUFDWCxHQUFJNEIsTUFBTUEsRUFBRztNQUNiLEdBQUk1QixNQUFNQSxFQUFHO01BQ2IsUUFDRjtJRHN0Qm1DLFNBQS9CZzRDLCtCQUEyQ3h6QyxFQUFHOHZDLFlBQWEyRDtNQUMzRDtPQUFJaDJDO1FBQU07VUFBMEN1QyxFQUFHOHZDLFlBQWEsdUJBQXVCMkQ7TUFDM0YsT0FBTyw2QkFBNkJoMkMsSUFGSDtJbUIzN0JyQyxTQUFTaTJDLGtCQUFrQkMsT0FBUUMsSUFBS0MsSUFBSzkvQjtNQUUzQztPQUFZO09BUUg7T0FDSztPQUNKO09BQ1E7T0FDUDtPQUVJO09BQ087T0FDSjtPQUNBO09BQ1U7T0FDSjtPQUVSO09BQ0E7T0FDUztPQUNGO09BQ0w7T0FDQTtPQUNBO09BQ0w7T0FDTTtPQUNGO09BQ0w7T0FDSztPQUNHO09BQ1Q7T0FDRztPQUNFO09BR0s7T0FDQTtPQUNUO09BQ0E7T0FDRztPQUNEO09BQ0M7T0FDQTtPQUNBO09BQ0c7T0FDSjtPQUNBO01BS2QsS0FBSzQvQjtPQUFjLENBQ2pCQSxnQkFBZ0IsZUFBZ0JBLE9BQU9rQztRQUN2Q2xDLGdCQUFnQixlQUFnQkEsT0FBT29DO1FBQ3ZDcEMsZUFBZ0IsZUFBZ0JBLE9BQU95QztRQUN2Q3pDLGdCQUFnQixlQUFnQkEsT0FBT3FDO1FBQ3ZDckMsZUFBZ0IsZUFBZ0JBLE9BQU93QztRQUN2Q3hDLGFBQWdCLGVBQWdCQSxPQUFPaUM7UUFDdkNqQyxhQUFnQixlQUFnQkEsT0FBT2dDO1FBQ3ZDaEMsZ0JBQWdCLGVBQWdCQSxPQUFPc0M7UUFDdkN0QyxlQUFnQixlQUFnQkEsT0FBT21DO01BaEV6QztPQW1FUTtPQUFLejFDO09BQUdnMkM7T0FBSUM7T0FBSUM7T0FHakIsR0FBRTNDLElBQUkwQjtPQUNILE1BQUUxQixJQUFJMkI7T0FDSixRQUFFM0IsSUFBSTRCO01BRWxCO01BQUs7T0FBUyxPQUNMM0I7Z0JBRUx0QixVQUNBa0U7O1VBSUFwMkMsSUFBSXN6QyxjQUFjcEI7VUFDbEIsR0FBSWx5QyxPQUFRLENBQUV3ekMsTUFBTUssT0FBUTtVQUM1QixHQUFJTixJQUFJbUIsb0JBQXFCLENBQUVsQixNQUFNRyxVQUFXO1VBQ2hEdjJDLE1BQU0wMkM7VUFDTjs7VUFJQSxHQUFJcGdDLGVBQWVyVztXQUFPLENBQ3hCazJDLElBQUltQixpQkFBaUJwQixPQUFPK0Isa0JBQWtCM2hDO1lBQzlDNi9CLElBQUlvQixZQUFZamhDOztXQUNYLENBQ0w2L0IsSUFBSW1CLGlCQUFpQnBCLE9BQU84QixrQkFBa0IxaEM7WUFDOUM2L0IsSUFBSW9COztVQUtOcUIsS0FBSzFDLGNBQWNwQjtVQUNuQitELEtBQUtELEtBQUt6QyxJQUFJbUI7VUFDZDtZQUFJc0I7Ozs7WUFBV0M7Ozs7WUFBV0E7O1lBQU0zQyxPQUFPdUM7O1lBQ25DdkMsYUFBYTJDOztZQUFPMUMsSUFBSW1CO1dBQWdCLENBQzFDbEIsTUFBTS94QixNQUFPO1VBRWZ1MEIsS0FBSzFDLGNBQWNwQjtVQUNuQitELEtBQUtELEtBQUt6QyxJQUFJbUI7VUFDZDtZQUFJc0I7Ozs7WUFBV0M7Ozs7WUFBV0E7O1lBQU0zQyxPQUFPdUM7O1lBQ25DdkMsYUFBYTJDOztZQUFPMUMsSUFBSW1CO1dBQWdCLENBQzFDMTBDLElBQUlzekMsYUFBYTJDLElBQ2pCekMsTUFBTUssT0FBUTtVQUVoQixHQUFJdUMsYUFBYyxDQUNoQmg1QyxNQUFNKzJDLG9CQUNOOztVQUtGLEdBQUlpQztXQUFhLENBQ2ZBO1lBQ0E7YUFBUyxDQUNQRixTQUFTM0MsSUFBSWEsYUFBYStCO2NBQzFCSCxLQUFLMUMsY0FBYzRDO2NBQ25CRCxLQUFLRCxLQUFLdkM7Y0FDVjtnQkFBSXVDOzs7O2dCQUFXQzs7OztnQkFBV0E7O2dCQUFNM0MsT0FBT3VDOztnQkFDbkN2QyxhQUFhMkM7O2dCQUFPeEM7ZUFBUyxDQUMvQkQsTUFBTUksY0FBZTs7ZUFDaEIsQ0FDTCxHQUFJdUMsTUFBTTVDLElBQUlrQixlQUFnQixPQUFPVixrQkFFckNvQzs7V0FHQyxDQUNMLEdBQUk1QyxJQUFJbUIsb0JBQXFCLE9BQU9YO1lBRXBDUixJQUFJbUI7WUFDSmxCLE1BQU1FO1lBQU07Z0JBSWRILElBQUltQixxQkFDSixHQUFJMEIsWUFBYUE7O1VBR2pCbEUsUUFBUW9CLGFBQWEyQztVQUNyQkU7VUFDQSxHQUFJQSxNQUFNNUMsSUFBSWlCLGVBQWdCLENBQzVCcDNDLE1BQU00MkMsY0FDTjs7VUFLRlQsSUFBSWEsYUFBYStCLFVBQVVqRTtVQUMzQnFCLElBQUljLGFBQWE4QixVQUFVNUMsSUFBSW9CO1VBQy9CcEIsSUFBSWUsc0JBQXNCNkIsVUFBVTVDLElBQUlxQjtVQUN4Q3JCLElBQUlnQixvQkFBb0I0QixVQUFVNUMsSUFBSXNCO1VBQ3RDckIsTUFBTUU7VUFDTjs7VUFHQSxJQUFJdnZDLEVBQUltdkMsV0FBV3R6QztVQUNuQnV6QyxJQUFJdUIsV0FBV3FCO1VBQ2Y1QyxJQUFJeUIsbUJBQW1CaDFDO1VBQ3ZCdXpDLElBQUl3QixnQkFBZ0I1d0M7VUFDcEJneUMsS0FBS0EsS0FBS2h5QztVQUNWQSxJQUFJbXZDLFdBQVd0ekM7VUFDZmsyQyxTQUFTM0MsSUFBSWEsYUFBYStCO1VBQzFCSCxLQUFLMUMsY0FBY252QztVQUNuQjh4QyxLQUFLRCxLQUFLRTtVQUNWO1lBQUlGOzs7O1lBQVdDOzs7O1lBQVdBOztZQUFNM0MsT0FBT3VDOztZQUNuQ3ZDLGFBQWEyQzs7WUFBT0M7V0FDdEJoRSxRQUFRb0IsYUFBYTJDOztXQUVyQi9ELFFBQVFvQixhQUFhbnZDO1VBQ3ZCLEdBQUlneUMsTUFBTTVDLElBQUlpQixlQUFnQixDQUM1QnAzQyxNQUFNNjJDLGNBQ047Z0JBS0Y3MkMsTUFBTTgyQyx3QkFDTjs7VUFHQVgsSUFBSWEsYUFBYStCLFVBQVVqRTtVQUMzQnFCLElBQUljLGFBQWE4QixVQUFVemlDO1VBQzNCLElBQUkyaUMsSUFBTTlDLElBQUl1QjtVQUNkdkIsSUFBSWdCLG9CQUFvQjRCLFVBQVU1QyxJQUFJZ0Isb0JBQW9COEI7VUFDMUQsR0FBSUYsS0FBS0U7V0FBSyxJQUVSL0Isc0JBQXNCNkI7O1dBQVU1QyxJQUFJZ0Isb0JBQW9COEI7VUFFOUQ3QyxNQUFNRTtVQUFNO2lCQUdaLE9BQU9LO01BSVhSLElBQUkwQixVQUFVa0I7TUFDZDVDLElBQUkyQixhQUFhaEQ7TUFDakJxQixJQUFJNEIsZUFBZWlCO01BQ25CLE9BQU9oNUMsR0FDVDtJbkJrbkRxQyxTQUFqQ2s1QztNQUE2Q3A4QixNQUFPaWMsYUFBY2x1QixnQkFBaUJtdUI7TUFDbkYsSUFBSW5oQixPQUFRdFkseUJBQXdCdzVCO01BQ3BDLElBQVcsSUFBRng3QixJQUFPQSxJQUFJdzdCLG9CQUFxQng3QjtPQUFLLE9BQ25DLHVCQUF1Qnc3QixhQUFheDdCO01BRS9DdzdCLGVBQWVsaEI7TUFDZmhOLGtCQUFrQix1QkFBdUJBO01BQ3pDbXVCOztNQUFXO1FBQTBCQSxTQUFVOXZCLDJCQUE0QjNKO01BTjNFO09BT1E7UUFBRTtVQUE0Q3VkLE1BQU9pYyxhQUFjbHVCLGdCQUFpQm11QjtPQUNsRixNQUFFLDRCQUE0Qmg1QjtNQUN4QyxPQUFPMmUsS0FWNEI7SUFrYXZDLFNBQVN3NkI7TUFDTDthQUFVajZCO3VGQUNkO0lBbmlDd0MsU0FBcENrNkIsb0NBQWdEdjVDO01BQ2hELE9BQU8sK0NBQStDQSxFQURoQjtJQWoxQjFDO0tBQUl3NUM7TUFBdUM5NUM7SUErWHRCLFNBQWpCKzVDLGlCQUE2QjM1QyxFQUFHNUI7TUFDaEMsSUFBSWlDLElBQU0sNEJBQTRCTCxFQUFHNUI7TUFDekMsaUJBQWlCaUM7TUFDakIsT0FBT0EsR0FIWTtJZ0N2dUJ2QixTQUFTdTVDLHdCQUF3QjFuQyxNQUFRLFFBQVM7STVCME5sRCxTQUFTMm5DLGVBQWVyK0MsS0FBTTYyQztNQUM1QixJQUFJcHdDLEtBQU8sa0JBQWtCekc7TUFDN0Isa0JBQWtCeUcsVUFBVW93QztNQUM1QixRQUNGO0ljaFBBLFNBQVN5SCxvQkFBb0JoMEMsR0FBSUMsR0FBSUMsR0FBSUMsR0FBSTdGO01BQzNDLE9BQU8sNkJBQTZCMEYsR0FBR0MsR0FBR0MsR0FBR0MsR0FBRzdGLElBQ2xEO0loQmlnQkEsU0FBUzI1QyxpQkFBaUJqMEMsR0FBSUU7TUFDNUIsR0FBR0YsT0FBT0UsR0FBSTtNQUNiRixZQUFhLDZCQUE2QkE7TUFDMUNFLFlBQWEsNkJBQTZCQTtNQUMzQyxPQUFRRixRQUFRRSxRQUNsQjtJQThPQSxTQUFTZzBDLGtCQUFrQmwwQyxHQUFJRSxJQUM3QixPQUFPLGlCQUFpQkYsR0FBR0UsR0FDN0I7SUE1T0EsU0FBU2kwQyxxQkFBcUJuMEMsR0FBSUUsSUFBTSxXQUFTLGtCQUFrQkYsR0FBSUUsR0FBSztJRnRYckQsU0FBbkJrMEMsbUJBQStCbDZDO01BQy9CLE9BQU8sK0JBQStCLDhCQUE4QkEsR0FEL0M7SW1DcEt6QixTQUFTbTZDLDJCQUEyQmo2QztNQUNsQ0EsSUFBSUEsS0FBTUE7TUFDVkEsS0FBS0EsbUJBQW9CQTtNQUN6QixRQUFTQSxLQUFLQSx3Q0FDaEI7SS9CZ1VBLFNBQVNrNkMsdUJBQXdCNStDO01BQy9CO09BQVMsWUFBVUEsaUJBQWtCLHVCQUF1QkEsTUFBTUE7T0FDekQsS0FBRSxrQkFBa0JBO01BQzdCLEdBQUcsbUJBQW1CeUc7T0FBWSxDQUNoQztTQUFTLEtBQUUsaUJBQWlCQTtTQUNuQixJQUFFO1NBQ0YsSUFBRSxrQkFBa0I3QjtRQUM3QixZQUFZb0csTUFBTXBHO1FBQ2xCLE9BQU8scUJBQXFCb0c7TUFFOUIsd0JBQXdCLHVCQUF1QmhMLE1BQ2pEO0lnQnJNQSxTQUFTNitDLGlCQUFpQnI2QyxHQUFLLE9BQU9BLENBQUc7SXBCd0Z6QyxJQUFJczZDLGtCQUFvQjE2QztJQXBESSxTQUF4QjI2Qyx3QkFBb0N2NkM7TUFDcEMsT0FBTyx3QkFBd0IsbUNBQW1DQSxHQUR4QztJd0IwQzlCLFNBQVN3NkMsb0JBQW9CeDZDLEVBQUU1QjtNQUM3QjtPQUFNLEVBQUU7T0FDRixHQUFDLHVCQUF1QjRCLEVBQUVzQixXQUFXbEQ7T0FDckMsRUFBRXdZO01BQ1IsUUFBUTNhLGVBQWVBLGFBQWFBLElBQ3RDO0lnQjNFQSxTQUFTdytDLG9CQUFvQkM7TUFDM0I7T0FBSS9tQjs7U0FDTztxQkFDU2pTO2NBQ2RpUyxpQkFBaUJqUztjQUNqQmlTO2NBQ0EsT0FBT2pTLEtBSEg7b0JBS1d6WjthQUNmMHJCLGlCQUFpQjFyQjthQUNqQjByQjthQUNBQTthQUNBLE1BQU0xckIsR0FKRDs7O01BU1gsT0FBTzByQixRQUNUO0lwQzBFQSxTQUFTZ25CLGdCQUFnQnB5QyxFQUFFdEY7TUFDekIsSUFBVyxPQUFFLGtCQUFrQnNGLEdBQ3BCLE9BQUUsa0JBQWtCdEY7TUFDL0IsR0FBRzIzQyxpQkFBaUJDO09BQ2xCOztNQUNGLEtBQUlEO09BQ0Y7TUFDRixxQkFBcUJBLFlBQWFDLFlBQ3BDO0lKNUJBLElBQUlDLG9CQUFzQmw3QztJZTRNMUIsU0FBU203Qyw0QkFBNEIxakMsT0FBUXpCO01BQ3pDQSxZQUNBLFdBQVc3SCxPQUFPLGlCQUN0QjtJZnRYQSxJQUFJaXRDLG9CQUFzQnA3QztJZWdHMUIsU0FBU3E3QywwQkFBMEJyOUM7TUFDaEMsT0FBTyxnQkFBZ0IsbUJBQzFCO0lZZ0ZBLFNBQVNzOUMseUJBQTBCdmdDO01BQ2pDLElBQUlDLEtBQU9ILGlCQUFpQkU7TUFDNUIsR0FBSUMsZUFBZXRlLEtBQU07TUFDekIsR0FBSSxzQkFBc0JzZSxZQUFhO01BQ3ZDLHFCQUFzQkEsS0FDeEI7SUErRkEsU0FBU3VnQyx3QkFBd0J4Z0M7TUFDL0IsSUFBSUMsS0FBT0gsaUJBQWlCRTtNQUM1Qix5QkFBeUJBO01BRHpCLElBRU0sRUFBRUMsWUFDQSxJQUFFO01BQ1YsR0FBRzRGLEtBQUtwZ0IsSUFBSztNQUNiO09BQVksQ0FDVixHQUFHb2dCLEtBQUtwZ0IsSUFBSyxVQUFVb2dCLElBQUk1RjtRQUMzQixHQUFHLG1CQUFtQjRGLFNBQVUsT0FBT0EsSUFBSTVGO1FBQzNDNEYsSUFFSjtJTGxWQSxTQUFTNDZCLGdCQUFpQixRQUFRO0l0QjZ1QmYsU0FBZkMsZUFBMkJyN0MsRUFBRzVCO01BQzlCLElBQUlpQyxJQUFNLDBCQUEwQkwsRUFBRzVCLEdBQ3ZDLGlCQUFpQmlDLEtBQ2pCLE9BQU9BLEdBSFU7SWdCclpyQixTQUFTaTdDLGlCQUFpQi9wQyxJQUN4QixPQUFPQSxjQUNUO0k0QmxTQSxTQUFTZ3FDLDZCQUE2Qm5wQyxJQUFLb3BDLFFBQVNsL0IsSUFBS20vQixRQUFTcjdDO01BQ2hFLElBQVcsSUFBRnhDLElBQU9BLElBQUl3QyxJQUFLeEM7T0FBSyxDQUM1QjtTQUFJaUY7VUFBSTtZQUFpQixjQUFjdVAsSUFBS29wQyxVQUFVNTlDLEdBQUksY0FBYzBlLElBQUttL0IsVUFBVTc5QztRQUN2RixHQUFJaUYsT0FBUSxPQUFPQTtNQUVyQixRQUNGO0l4QjRCQSxTQUFTNjRDLG9CQUFvQnYxQztNQUMzQixHQUFHQSxhQUFhN0YsTUFBTyxPQUFPNkY7TUFFOUI7UUFBRzlMOztRQUNHOEwsYUFBYTlMOztRQUNiOEw7O1FBQ0E7T0FDSixPQUFPLHlCQUF5QmhCO01BRWxDO1FBQUc5Szs7UUFDRzhMLGFBQWE5TDs7UUFDYjhMOztRQUNBO09BQ0osT0FBTyx5QkFBeUJoQjtNQUVsQyxHQUFHZ0IsYUFBYTlMLG9CQUFvQjtPQUNsQyxVQUFVLDRCQUE0QjhMO01BRXhDLFVBQVVoQix5QkFBeUIsd0JBQXlCLE9BQU9nQixJQUNyRTtJaEJtTEEsU0FBU3cxQztNQUNQLElBQUlsMEIsSUFBSXB0QjtNQUNSLEdBQUdvdEI7T0FBSSxJQUNLLElBQUY3cEIsSUFBT0EsSUFBSTZwQixXQUFZN3BCO1FBQUksaUJBQ2hCNnBCLElBQUk3cEIsUUFBUTZwQixJQUFJN3BCO01BR3JDdkQsOEJBQThCbXRDO01BQzlCbnRDO01BQ0EsUUFDRjtJbUNsU0EsSUFBSXVoRCw4QkFBZ0N4dUI7SW5DcUtwQyxTQUFTeXVCLGVBQWVDO01BQ3RCLElBQUk3NUMsS0FBTyxrQkFBa0I2NUM7TUFDN0IsR0FBRyxtQkFBbUI3NUM7T0FBWSxDQUNoQyxHQUFHQTtTQUFXRyxtQkFBbUIsb0JBQW9CSCxZQUFZQTs7U0FDNURHLG1CQUFtQkg7UUFDeEI7O09BRUcsd0JBQ3FCLHVCQUF1QjY1QyxLQUVuRDtJSnEzQndDLFNBQXBDQyxvQ0FBZ0Q1d0MsSUFBS2xCLE1BQU9pMkI7TUFDNUQ7T0FBZTtRQUFFO1VBQTBCajJCLE1BQU9WLDJCQUE0QjNKO09BQy9ELFdBQUUsdUJBQXVCc2dDO09BQ2pDO1FBQUU7VUFBK0MvMEIsSUFBS2srQixXQUFZRDtNQUN6RSxPQUFPL2hDLEVBSitCO0lBM3lCMUMsSUFBSTIwQyx3QkFBMEJwOEM7SWdDdk45QixTQUFTcThDLFNBQVM1OUIsR0FBSUM7TUFDcEIsT0FBTyxlQUFlLE9BQU9ELFFBQVEsT0FBT0MsS0FDOUM7SUE0QkEsU0FBUzQ5QixVQUFVNzlCLEdBQUlDO01BQ3JCLElBQVcsT0FBRSxVQUFVRCxJQUNaLE9BQUUsVUFBVUM7TUFDdkIsR0FBSTY5QixTQUFTQztPQUF3RCxLQUM5RCxPQUFPLzlCLFFBQVEsT0FBT0MsWUFBWTtRQUFZLE9BQzFDLFNBQVMsU0FBU0QsR0FBSUMsSUFBSztNQUd0QyxPQUFPLFNBQVNELEdBQUlDLEdBQ3RCO0loQjRZQSxTQUFTKzlCLGNBQWM5cUMsR0FBSWpDLEdBQUlwUCxHQUM3QixPQUFPLFVBQVVvUCxJQUFLcFAsR0FDdEIsUUFDRjtJNEJoYkEsU0FBU284Qyw0QkFBNEI1cEMsSUFBSzZwQyxRQUFTM3BDLElBQUs0cEMsUUFBU3A4QztNQUMvRCxJQUFXLElBQUZ4QyxJQUFPQSxJQUFJd0MsSUFBS3hDO09BQUssY0FDZGdWLElBQUs0cEMsVUFBVTUrQyxFQUFHLHVCQUF1QjhVLElBQUs2cEMsVUFBVTMrQyxHQUUxRTtJNUMwK0JtQyxTQUEvQjYrQywrQkFBMkM3NUMsRUFBRzh2QyxZQUFhZ0s7TUFDM0Q7T0FBSXI4QztRQUFNO1VBQTBDdUMsRUFBRzh2QyxZQUFhLHVCQUF1QmdLO01BQzNGLE9BQU8sOEJBQThCcjhDLElBRko7SUFueUJWLFNBQXZCczhDLHVCQUFtQ3BzQjtNQUNuQyxPQUFPO2VBQWtDLHlCQUF5QkEsYUFEekM7SVdhN0IsU0FBU3FzQixXQUFXeDVDLEVBQUdULEVBQUdFO01BQ3hCO09BQU0sRUFBRU8sYUFBYVQ7T0FDZixFQUFFLFdBQVczQyxJQUFFNkM7T0FDZixFQUFHN0MsSUFBSTZDO09BQ1AsRUFBRWl5QixLQUFLbnlCO01BQ2IsUUFBUXZFLElBQUksV0FBVzhaLElBQUVyVixHQUFJcVYsSUFBSXJWLEVBQ25DO0lBS0EsU0FBU2c2QyxjQUFjQyxLQUFNQyxLQUFNQyxLQUFNQyxLQUFNdHhDLEtBQU1DLEtBQU14TCxJQUFLMEwsS0FBTUM7TUFDcEUsSUFBSW14QyxJQUFPdnhDLFVBQVVDLE9BQUt4TDtNQUcxQixJQUFVLElBQUZ4QyxFQUFJd0MsUUFBT3hDLE9BQVFBO09BQUssQ0FDOUIsSUFBSW9DLEVBQUksV0FBV2s5QyxJQUFNdnhDLFVBQVVDLE9BQUtoTyxTQUFZa08sVUFBVUM7UUFDOUQrd0MsVUFBVUMsT0FBS24vQyxLQUFLb0M7UUFDcEJrOUMsTUFBTWw5QztNQUVSZzlDLFVBQVVDLFFBQVFDO01BQ2xCLFFBQ0Y7SUFqTUEsU0FBU0MsK0JBQStCMXBDLElBQUtqQztNQUMzQyxJQUFNLEVBQUVpQyxTQUFTakMsS0FDWDtNQUNOLEdBQUdwTyxlQUFnQixDQUFFVCxRQUFRUztNQUM3QixHQUFHQSxXQUFnQixDQUFFVCxPQUFRUztNQUM3QixHQUFHQSxTQUFnQixDQUFFVCxPQUFRUztNQUM3QixHQUFHQSxPQUFnQixDQUFFVCxPQUFRUztNQUM3QixHQUFHQSxNQUFnQixDQUFFVCxPQUFRUztNQUM3QixHQUFHQSxNQUFnQjtNQUNuQixZQUFZVCxDQUNkO0lBZ0pBLFNBQVN5NkMsZUFBZXp4QyxLQUFNQyxLQUFNQyxLQUFNQyxLQUFNQyxLQUFNQztNQUNwRCxHQUFHQSxXQUFZLENBQ2JGLFVBQVVDLFVBQ1Y7TUFFRixJQUFJRTtNQUNKLElBQVUsSUFBRnJPLElBQU9BLElBQUlpTyxLQUFNak87T0FBSyxDQUM1QixJQUFJd0YsRUFBS3VJLFVBQVVDLE9BQUtoTztRQUN4QitOLFVBQVVDLE9BQUtoTyxLQUFNd0YsS0FBSzRJLFFBQVNDO1FBQ25DQSxPQUFPN0ksV0FBWTRJO01BRXJCRixVQUFVQyxRQUFRRTtNQUNsQixRQUNGO0lBck5BLFNBQVNveEMsZ0JBQWdCNXBDLElBQUtqQyxJQUFLcFI7TUFDakMsSUFBVSxJQUFGeEMsSUFBT0EsSUFBSXdDLElBQUt4QyxJQUFLLFNBQ2xCNFQsTUFBSTVULE9BRWYsUUFDRjtJQW9JQSxTQUFTMC9DLFFBQVEzeEMsS0FBTUMsS0FBTUMsS0FBTUMsS0FBTUMsS0FBTXEzQixLQUFNMVg7TUFDbkQsSUFBSTNJLE9BQVUySTtNQUNkLElBQVUsSUFBRjl0QixJQUFPQSxJQUFJd2xDLEtBQU14bEM7T0FBSyxDQUM1QjtTQUFJb0M7V0FBSzJMLFVBQVVDLE9BQUtoTyxhQUFha08sVUFBVUMsT0FBS25PLFlBQVltbEI7UUFDaEVwWCxVQUFVQyxPQUFLaE8sS0FBS29DO1FBQ3BCLEdBQUlBLE9BQVEsZ0JBRUw7TUFJVCxPQUFPLFNBQVMyTCxLQUFNQyxPQUFLdzNCLEtBQU12M0IsT0FBS3UzQixLQUFPcmdCLGdCQUMvQztJQWlHQSxTQUFTdzZCLFFBQVE1eEMsS0FBTUMsS0FBTUMsS0FBTUMsS0FBTUMsS0FBTXEzQjtNQUM3QyxHQUFHQTtPQUFXLENBQ1osY0FBY3ozQixLQUFNQyxTQUFRRCxLQUFNQyxLQUFNRCxLQUFNQyxLQUFNQyxLQUFNQyxLQUFNQztRQUNoRTtNQUdGLElBQUl6SyxFQUFJLCtCQUErQndLLEtBQU1DLE9BQUtxM0I7TUFDbEQsZUFBZXQzQixLQUFNQyxLQUFNcTNCLEtBQU0sb0JBQXNCOWhDO01BQ3ZELGVBQWVxSyxLQUFNQyxLQUFNQyxLQUFNLG9CQUFzQnZLO01BRnZELElBSU0sR0FBR3dLLFVBQVVDLE9BQUtxM0IscUJBQ2xCLEVBQUUsV0FBV0E7TUFDbkIsSUFBVyxJQUFGeGxDLEVBQUlpTyxTQUFVak8sS0FBS3dsQyxLQUFNeGxDO09BQUssQ0FFckM7U0FBSTQvQztVQUFNdmhEO1lBQW1CMFAsVUFBVUMsT0FBS2hPO1lBQVk7ZUFBWStOLFVBQVVDLE9BQUtoTyxTQUFZK04sVUFBVUMsT0FBS2hPLGFBQVkzQjs7UUFDMUgsZ0JBQWdCbUgsSUFBTWdnQztRQUN0QixlQUFlaGdDLElBQU1nZ0MsU0FBUXQzQixLQUFNQyxLQUFNcTNCLEtBQU0sY0FBY29hO1FBQzdELFFBQVE3eEMsS0FBTUMsT0FBS2hPLElBQUV3bEMsS0FBTUEsU0FBUWhnQyxJQUFNZ2dDO1FBRXpDO1VBQU96M0IsVUFBVUMsT0FBS2hPOzs7O1VBQVcsWUFBWStOLEtBQU1DLE9BQUtoTyxJQUFFd2xDLEtBQU1BLEtBQU10M0IsS0FBTUMsS0FBTXEzQjs7O1NBQVksQ0FDNUZvYSxNQUFNQTtVQUNOLFFBQVE3eEMsS0FBTUMsT0FBS2hPLElBQUV3bEMsS0FBTUEsU0FBUXQzQixLQUFNQyxLQUFNcTNCO1FBR2pEejNCLFVBQVVDLE9BQUtoTyxLQUFLNC9DO01BR3RCLGdCQUFnQjd4QyxLQUFNQyxLQUFNdzNCLEtBQU0sb0JBQXNCOWhDO01BQ3hELGdCQUFnQndLLEtBQU1DLEtBQU1xM0IsS0FBTSxvQkFBc0I5aEM7TUFDeEQsUUFDRjtJS21MQSxTQUFTbThDLGFBQWEvcUMsSUFBS0U7TUFDekIsR0FBSUEsbUJBQW1CRjtPQUNyQjtNQUNGLElBQVcsSUFBRjlVLElBQU9BLElBQUlnVixnQkFBaUJoVjtPQUNuQyxHQUFJZ1YsU0FBU2hWLE1BQU04VSxTQUFTOVU7UUFDMUI7TUFDSixhQUFhOFU7TUFDYixRQUNGO0lMcFpBLFNBQVNnckMsYUFBYWpxQyxJQUFLakMsS0FDekIsR0FBSWlDLFNBQVNqQyxVQUFXLFNBQ3hCLFFBQ0Y7SUk2VEEsU0FBU21zQyxxQkFBcUJ6OUMsR0FDMUIsT0FBT0EsT0FDWDtJR2hYQSxTQUFTMDlDLGVBQWU1ekIsR0FBSTZ6QixJQUFLdDlDLElBQUtIO01BQ3BDLE1BQU1BLFFBQVEsQ0FDWixHQUFHLGNBQWM0cEIsR0FBR3pwQixRQUFRczlDLElBQUssT0FBT3Q5QyxJQUN4Q0EsTUFDQUg7TUFFRixVQUNGO0loQjBxQkEsU0FBUzA5Qyx1QkFBd0J4OEMsRUFBRzFELEVBQUdpRjtNQUNyQyxPQUFPLHNCQUFzQnZCLEVBQUUxRCxFQUFFaUYsRUFDbkM7SXlCNWlCQSxTQUFTazdDLHdCQUF3QnBqQztNQUMvQixJQUFJQyxLQUFPSCxpQkFBaUJFO01BQzVCLE9BQU8sb0JBQW9CLG1CQUM3QjtJM0I4RkEsSUFBSXFqQyxrQkFBb0JwK0M7SWdDbkZ4QixTQUFTcStDLGNBQWNoekI7TUFDckIsSUFBSWpDO01BQ0osR0FBRyxtQkFBbUJpQyxJQUFLO09BQW1DLENBQzVEakMsV0FDQWlDLE1BQU0sZUFBZUE7TUFIdkI7T0FLTyxHQUFFLGdCQUFnQkE7T0FDbEIsR0FBRSxnQkFBZ0JBO09BQ25CLEVBQUUsT0FBT3plLFFBQVEsT0FBT0U7TUFDOUIsR0FBR3NjLElBQUssSUFBTTtNQUNkLE9BQU8sZUFBZWhwQixFQUN4QjtJakJWQSxTQUFTaytDLHVCQUF1QnRnRDtNQUM1QixXQUFXbWUsT0FBTyxvQkFBb0JuZSxHQUMxQztJaUJqTEEsU0FBU3VnRCxTQUFTOS9CLElBQ2hCLE9BQU8sZUFBZSxPQUFPQSxhQUMvQjtJaEIyaEJBLFNBQVMrL0IsZ0JBQWdCN3NDLEdBQUk4c0M7TUFDM0JBLE9BQU8sbUJBQW1CQTtNQUMxQixJQUFZLFdBQ0MsU0FBRUE7TUFFZixHQUFJL21DLGdCQUFnQkE7T0FBYztNQUhsQyxJQU1JVztNQUNKLElBQVcsSUFBRnJhLElBQU9BLElBQUkwWixTQUFVMVo7T0FBSyxDQUNqQzBnRCxRQUFRMWdELEtBQUt5Z0QsS0FBS3pnRDtRQUNsQixHQUFJMGdELFFBQVExZ0Q7U0FDVjtRQUNGcWEsV0FBV0EsV0FBV3FtQyxRQUFRMWdEO01BWGhDLElBY0lnWSxLQUFPLGlCQUFpQnJFO01BRTVCLEdBQUkwRyxZQUFZckM7T0FDZDtNQUNGLE9BQU8sc0JBQXNCckUsUUFBU0EsVUFBVytzQyxRQUFTL3NDLFFBQzVEO0kwQmhsQkEsU0FBU2d0QyxrQ0FBbUNDLFFBQVN6Z0IsUUFBU0M7TUFDNURKLHFDQUFxQ25qQixpQkFBaUJ1akI7TUFDdERILHFDQUFxQ3BqQixpQkFBaUJzakI7TUFDdEQsSUFBSXhQLE9BQVM5VCxpQkFBaUIrakM7TUFDOUIvakMsaUJBQWlCc2pCLFdBQVd4UDtNQUM1QjlULGlCQUFpQnVqQixXQUFXelA7TUFDNUIsUUFDRjtJWnlHQSxTQUFTa3dCLGVBQWdCOTdDLEdBQ3ZCQSxPQUFLbWQsa0JBQ0wsT0FBT25kLENBQ1Q7SUVtRUEsU0FBUys3QyxZQUFZOWdELEdBQ25CLE9BQU9BLEtBQ1Q7SUFLQSxTQUFTK2dELGNBQWNDLEtBQ3JCLE9BQU8sWUFBWUEsSUFDckI7SXpCN0tBLFNBQVNDLG9CQUFxQmw3QyxJQUFLZ1QsS0FBTyxTQUFVaFQsSUFBS2dULElBQU07SWtCK00vRCxTQUFTbW9DLGFBQWMxN0MsRUFBR1QsR0FBSyxPQUFPLGlCQUFrQlMsRUFBR1QsT0FBVTtJekJ3SzFDLFNBQXZCbzhDLHVCQUFtQy8rQztNQUNuQyxJQUFJSyxJQUFNLGtDQUFrQ0w7TUFDNUMsT0FBTyx5QkFBeUIsa0NBQWtDQSxHQUZ6QztJQXNQVCxTQUFoQmcvQyxnQkFBNEJoL0MsRUFBRzVCO01BQy9CLElBQUlpQyxJQUFNLDJCQUEyQkwsRUFBRzVCO01BQ3hDLGlCQUFpQmlDO01BQ2pCLE9BQU9BLEdBSFc7SWlCcm1CdEIsU0FBUzQrQyxzQkFBc0JuNUMsR0FBSXVNLEtBQU1yTSxHQUFJdU0sS0FBTW5TO01BQ2pELElBQVcsSUFBRnhDLElBQU9BLElBQUl3QyxJQUFLeEM7T0FBSyxDQUM1QixJQUFNLEVBQUUsY0FBY2tJLEdBQUd1TSxPQUFPelUsR0FDMUIsRUFBRSxjQUFjb0ksR0FBR3VNLE9BQU8zVTtRQUNoQyxHQUFJd0YsSUFBSVQsRUFBRztRQUNYLEdBQUlTLElBQUlULEVBQUc7TUFFYixRQUNGO0lnQlpBLFNBQVN1OEMsNEJBQThCLFFBQVU7SVQrSGpELFNBQVNDO01BQ1AsSUFBSTc5QyxFQUFJO01BQ1JBLGlCQUFpQkE7TUFDakJBLGtCQUFrQkE7TUFFbEIsUUFDRjtJeEJzTDBCLFNBQXRCODlDLHNCQUFrQ3AvQyxFQUFHNUI7TUFDckMsbUJBQW1CNEIsRUFBRyxrQkFBa0JBLEVBQUc1QixHQURuQjtJV3lDNUIsU0FBU2loRCxlQUFlMXpDLEtBQU1DLEtBQU1FLEtBQU1DO01BQ3hDSixVQUFVQyxTQUFTRSxVQUFVQyxNQUM3QixRQUNGO0lJdEdBLFNBQVN1ekMsb0JBQW9CdC9DLEVBQUc1QjtNQUM1QixHQUFJLGlCQUFrQjtNQUl0QjRCLGFBQWFBO01BQ2I1QixhQUFhQTtNQUNiLFdBQVcyZCxPQUFPLGdCQUFnQjNkLGlCQUN0QztJaUJuSkEsU0FBU21oRCxXQUFXbGhDLEdBQUlDO01BQ3RCLE9BQU8sZUFBZSxPQUFPRCxPQUFPLE9BQU9DLEtBQzdDO0lBZ1RBLFNBQVNraEMsZ0JBQWdCbmhDLElBQ3ZCLE9BQU8sY0FBY0EsR0FDdkI7SU0xYUEsU0FBU29oQyxnQkFBZ0JDLElBQUtDLFlBQWFDO01BQ3pDO09BQWU7T0FDSTtPQUNEO09BQ0Q7T0FDQTtPQUNHO09BQ0E7T0FDUDtPQUNHO09BQ0E7T0FDRjtPQUNBO01BRWQsS0FBS0Y7T0FBaUIsQ0FDcEJBLGVBQWtCLGVBQWdCQSxJQUFJVTtRQUN0Q1Ysa0JBQWtCLGVBQWdCQSxJQUFJVztRQUN0Q1gsZ0JBQWtCLGVBQWdCQSxJQUFJYztRQUN0Q2QsZ0JBQWtCLGVBQWdCQSxJQUFJYTtRQUN0Q2Isa0JBQWtCLGVBQWdCQSxJQUFJWTtNQWxCeEMsSUFxQkl6OUMsRUFBUyxNQUFFODhDLFlBRUosT0FBRSxvQkFBb0JDLE9BQU9DO01BRXhDLEdBQUkxSztPQUFZLENBRWR5SyxPQUFPSyxnQkFBZ0JMLE9BQU9HLGlCQUFpQkgsT0FBT0k7UUFDdERKLE9BQU9NOztPQUNGLFVBRUkvSztNQUVYO09BQVEsQ0FFTixJQUFJM3lCLEtBQU9rOUIsYUFBYXZLO1FBQ3hCLEdBQUkzeUIsU0FBVSxTQUFRQTtRQUR0QixJQUdJaStCLFFBQVVmLGdCQUFnQnZLO1FBQzlCLEdBQUlzTDtTQUFjLENBQ2hCYixPQUFPSyxnQkFBZ0JMLE9BQU9JO1VBQzlCSixPQUFPTSxtQkFBbUJPO1FBRzVCLEdBQUliLE9BQU9JLGlCQUFpQkosT0FBT0U7U0FBZ0IsR0FDN0NGLE9BQU9PLHNCQUNULFNBQVFoTCxlQUVSdHlDOztTQUNDLENBRUhBLElBQUlzRixPQUFPeTNDLE9BQU9JLGVBQ2xCSixPQUFPSTtRQUdULEdBQUlOLGNBQWNsOUIsT0FBTzNmLE1BQU1zeUM7U0FDN0JBLFFBQVF1SyxjQUFjbDlCLE9BQU8zZjs7U0FFN0JzeUMsUUFBUXVLLGdCQUFnQnZLO1FBRTFCLEdBQUlBO1NBQVcsQ0FDYnlLLE9BQU9JLGdCQUFnQkosT0FBT0s7VUFDOUIsR0FBSUwsT0FBT007V0FDVDs7V0FFQSxPQUFPTixPQUFPTTs7U0FDYixHQUlDcjlDLFNBQVUrOEMsT0FBT08scUJBRzNCO0lsQ2tHQSxTQUFTTyxxQkFBc0JsbEQ7TUFDN0IsSUFBSXlHLEtBQU8sa0JBQWtCekcsTUFDN0IsT0FBTyxtQkFBbUJ5RyxVQUM1QjtJNkJoS0EsU0FBUzArQztNQUNQLGdEQUNGO0lMM0JBLFNBQVNDLGVBQWdCeDlDLEVBQUd4RixFQUFHd0M7TUFDN0IsSUFBSWdnQixPQUFTOWYsTUFBTUY7TUFDbkJnZ0I7TUFDQSxRQUFXLEtBQU8sR0FBRXhpQixNQUFLcUksTUFBTTdGLElBQUs2RixLQUFLRixLQUFNLEdBQzFDRSxNQUFJN0MsRUFBRTJDO01BRVgsT0FBT3FhLEVBQ1Q7SUo0SUEsU0FBU3lnQyxpQkFDUCxJQUFJdi9DLEVBQUksb0JBQ1IsT0FBT0EsT0FDVDtJeEI3Q0EsSUFBSXcvQyxtQkFBcUJsaEQ7SUF3T0MsU0FBdEJtaEQsc0JBQWtDL2dELEVBQUc1QjtNQUNyQyxtQkFBbUI0QixFQUFHLGtCQUFrQkEsRUFBRzVCLEdBRG5CO0lBelQ1QixJQUFJNGlELDBCQUE0QnBoRDtJU2tOaEMsU0FBU3FoRCwrQkFBa0MsT0FBT2p2Qix1QkFBNkI7SVJ3Qi9FLFNBQVNrdkIsZ0JBQWlCbGhELEdBQUssT0FBTyxVQUFVQSxFQUFJO0lEM0dwRCxJQUFJbWhELHFCQUF1QnZoRDtJcUN6RzNCLFNBQVN3aEQsZ0JBQWdCcGhELEVBQUdwQztNQUMxQixPQUFHb0MsRUFBRWd3Qix1QkFBdUJweUI7O2NBQUt6Qjs7Y0FBYTZELEVBQUVnd0IsdUJBQXVCcHlCOzs7O2dCQUl6RTtJQStCQSxJQUFJeWpELG9CQUFzQkQ7SWJnUzFCLFNBQVNFLGtCQUFrQkM7TUFDekI7T0FBTSxFQUFFO09BQ0YsRUFBRSxzQkFBc0Isd0JBQXdCQTtNQUN0RCxVQUFVcnBDLEVBQUU1VyxZQUNkO0ljelJBLFNBQVNrZ0QsaUJBQWlCbGdELEVBQUcxRCxFQUFHNmpELElBQUtDO01BQ25DO09BQVMsQ0FDUCxJQUFJOXVDLElBQU0sYUFBYWhWO1FBQUlBO1FBQzNCLEdBQUlnVixZQUFhO1FBRGpCLElBRUlGLElBQU0sYUFBYTlVO1FBQUlBO1FBQzNCLEdBQUk4VTtTQUNGK3VDLElBQUs3dUMsV0FBVzh1Qzs7U0FFaEJELElBQUs3dUMsV0FBVzZ1QyxJQUFLL3VDLFNBRTNCO0lBRUEsU0FBU2l2QyxpQkFBaUJyZ0QsRUFBRzFELEVBQUc2akQ7TUFDOUI7T0FBUyxDQUNQLElBQUk3dUMsSUFBTSxhQUFhaFY7UUFBSUE7UUFDM0IsR0FBSWdWLFlBQWE7UUFEakIsSUFFSUYsSUFBTSxhQUFhOVU7UUFBSUE7UUFDM0IsR0FBSThVLFlBQ0YrdUMsSUFBSzd1QyxvQkFFTDZ1QyxJQUFLN3VDLFdBQVc2dUMsSUFBSy91QyxTQUUzQjtJQUVBLFNBQVNrdkMsb0JBQW9CbEMsSUFBS0MsWUFBYUM7TUFDN0M7T0FBZTtPQUNJO09BQ0Q7T0FDRDtPQUNBO09BQ0c7T0FDQTtPQUNSO09BQ0M7T0FDRztPQUNBO09BQ0Y7T0FDQTtPQUNJO09BQ0c7T0FDQTtPQUNGO09BQ0E7T0FDTjtNQUViLEtBQUtGO09BQWlCLENBQ3BCQSxlQUFrQixlQUFnQkEsSUFBSVU7UUFDdENWLGtCQUFrQixlQUFnQkEsSUFBSVc7UUFDdENYLGdCQUFrQixlQUFnQkEsSUFBSWM7UUFDdENkLGdCQUFrQixlQUFnQkEsSUFBSWE7UUFDdENiLGtCQUFrQixlQUFnQkEsSUFBSVk7TUFFeEMsS0FBS1o7T0FBc0IsQ0FDekJBLG9CQUF1QixlQUFnQkEsSUFBSW9DO1FBQzNDcEMsdUJBQXVCLGVBQWdCQSxJQUFJcUM7UUFDM0NyQyxxQkFBdUIsZUFBZ0JBLElBQUl3QztRQUMzQ3hDLHFCQUF1QixlQUFnQkEsSUFBSXVDO1FBQzNDdkMsdUJBQXVCLGVBQWdCQSxJQUFJc0M7TUFFN0MsR0FBSXRDLGdCQUFnQnBqRDtPQUFNb2pELGVBQWUsdUJBQXVCQSxJQUFJeUM7TUFsQ3BFLElBb0NJdC9DLEVBQVMsTUFBRTg4QyxZQUVKLE9BQUUsb0JBQW9CQyxPQUFPQztNQUV4QyxHQUFJMUs7T0FBWSxDQUVkeUssT0FBT0ssZ0JBQWdCTCxPQUFPRyxpQkFBaUJILE9BQU9JO1FBQ3RESixPQUFPTTs7T0FDRixVQUVJL0s7TUFFWDtPQUFRLENBRU4sSUFBSTN5QixLQUFPazlCLGFBQWF2SztRQUN4QixHQUFJM3lCO1NBQVUsQ0FDWixJQUFJNC9CLE9BQVMxQyxrQkFBa0J2SztVQUMvQixpQkFBaUJ1SyxhQUFjMEMsT0FBUXhDLE9BQU9pQztVQUM5QyxTQUFRci9CO1FBSlYsSUFPSWkrQixRQUFVZixnQkFBZ0J2SztRQUM5QixHQUFJc0w7U0FBYyxDQUNoQixJQUFJMkIsT0FBUzFDLHFCQUFxQnZLO1VBQ2xDLGlCQUFpQnVLLGFBQWMwQyxPQUFReEMsT0FBT2lDO1VBQzlDakMsT0FBT0ssZ0JBQWdCTCxPQUFPSTtVQUM5QkosT0FBT00sbUJBQW1CTztRQUc1QixHQUFJYixPQUFPSSxpQkFBaUJKLE9BQU9FO1NBQWdCLEdBQzdDRixPQUFPTyxzQkFDVCxTQUFRaEwsZUFFUnR5Qzs7U0FDQyxDQUVIQSxJQUFJc0YsT0FBT3kzQyxPQUFPSSxlQUNsQkosT0FBT0k7UUF2QlQsSUEwQklxQyxPQUFTbE47UUFDYixHQUFJdUssY0FBY2w5QixPQUFPM2YsTUFBTXN5QztTQUM3QkEsUUFBUXVLLGNBQWNsOUIsT0FBTzNmOztTQUU3QnN5QyxRQUFRdUssZ0JBQWdCdks7UUFFMUIsR0FBSUE7U0FBVyxDQUNieUssT0FBT0ksZ0JBQWdCSixPQUFPSztVQUM5QixHQUFJTCxPQUFPTTtXQUNUOztXQUVBLE9BQU9OLE9BQU9NOztTQUNiLENBRUgsSUFBYyxVQUFFUixrQkFBa0IyQyxRQUFTRDtVQUMzQyxHQUFJMUMsbUJBQW1CNEMsWUFBWXovQyxNQUFNdy9DO1dBQ3ZDRCxTQUFTMUMsbUJBQW1CNEMsWUFBWXovQzs7V0FFeEN1L0MsU0FBUzFDLHFCQUFxQjJDO1VBQ2hDLEdBQUlEO1dBQ0Y7YUFDRDFDLGFBQWMwQyxPQUFReEMsT0FBT2lDLFNBQVVqQyxPQUFPSTtVQUkvQyxHQUFJbjlDLFNBQVUrOEMsT0FBT08sc0JBRzNCO0l2QjJIQSxTQUFTb0Msb0JBQW9CcndDLE1BQ3pCLFFBQ0o7SWR2RkEsU0FBU3N3QyxpQkFBa0J4aUQsR0FBSyxPQUFPLFdBQVdBLEVBQUk7SURxMkNMLFNBQTdDeWlELDZDQUF5RHppRDtNQUN6RCxPQUFPO2VBQTJDO2lCQUF3RCwyQ0FBMkNBLElBRHRHO0kyQnB0Q25ELFNBQVMwaUQsb0JBQW9CL25DLE9BQU9wYTtNQUNsQyxjQUFjb2E7TUFDZEYsaUJBQWlCRSxpQkFBaUIsb0JBQW9CcGE7TUFDdEQsUUFDRjtJaEI1REEsU0FBU29pRCxpQkFBaUJoM0MsS0FBS0c7TUFDN0IsT0FBTyxZQUFZSCxPQUFPQSxpQkFBaUJHLE9BQU9BLGlCQUNwRDtJVzdWQSxTQUFTODJDLFlBQVl2b0MsVUFDbkIsUUFDRjtJUHFHQSxTQUFTd29DLDJCQUEyQjdpRCxFQUFHNUIsR0FDbkMsV0FBVzJQLE9BQU8vTixXQUFXNUIsRUFDakM7SUtwR0EsU0FBUzBrRCxZQUFZdjZDLEVBQUVsRixHQUFLLE9BQU9rRixFQUFFbEYsRUFBSTtJRWxCekMsU0FBUzAvQyxxQkFBc0IsUUFBUTtJT3VCdkMsU0FBU0MsbUNBQW1DcndDLFFBQVFELElBQUtHLFFBQVNELElBQUt4UztNQUNyRSxHQUFHQSxTQUFVO01BQ2IsaUJBQWtCc1MsSUFBS0M7TUFDdkIsaUJBQWtCRCxJQUFLQyxVQUFVdlM7TUFDakMsMkJBQTJCd1MsSUFBS0M7TUFDaEMsMkJBQTJCRCxJQUFLQyxVQUFVelM7TUFFMUN1UyxVQUFVQTtNQUNWO09BQVk7YUFBTXhYLGdDQUErQixVQUFVd1gsUUFBUUEsVUFBVXZTO09BQzNELG1CQUFNakYsOEJBQTZCOG5EO09BQzVDLEtBQUUsa0JBQWtCcHdDLFFBQVNBLFVBQVd6UztNQUNqRCxTQUFTOGlEO01BQ1QsUUFDRjtJTXNEQSxTQUFTQywyQkFBMkIzZ0MsS0FBTWdYO01BQ3hDLElBQVEsTUFDQSxLQUFHQyxJQUFLalgsS0FBTWlYLElBQUtBLEtBQ25CLElBQUVBO01BQ1YsUUFBUUQ7T0FBYSxDQUNuQkUsU0FBVUEsU0FBU0E7UUFDbkJBLFNBQVVBLFNBQVNBO1FBQ25CQSxTQUFVQSxTQUFTQTtRQUNuQnI1QixNQUFPQSxNQUFNcTVCLElBQUlGO1FBQ2pCQSxXQUFXQTtNQUViLE9BQU9uNUIsR0FDVDtJeEJJQSxTQUFTK2lELGNBQWMzdkMsSUFBS2pDLEtBQzFCLEdBQUdpQyxTQUFTakMsVUFBVyxTQUN2QixRQUNGO0lTN0ZBLFNBQVM2eEMsWUFBWTk2QyxFQUFFbEYsRUFBRW5ELEdBQUtxSSxFQUFFbEYsS0FBR25ELEVBQUUsUUFBUTtJcEI0SmpCLFNBQXhCb2pELHdCQUFvQ3RqRDtNQUNwQyxPQUFPLG1DQUFtQyx3QkFBd0JBLEdBRHhDO0lBMmtCUixTQUFsQnVqRCxrQkFBOEJ2akQ7TUFDOUIsSUFBSUssSUFBTSw2QkFBNkJMO01BQ3ZDLGlCQUFpQks7TUFDakIsT0FBT0EsR0FIYTtJQTY4Q3hCLFNBQVNtakQsb0NBQW9DbFAsYUFBY21QO01BRXZEO09BQXFCO1FBQUU7VUFBK0MsdUJBQXVCQTtPQUMzRSxjQUFFLHVCQUF1QmpQO01BRTNDLCtCQUFnQ3B4QyxFQUFHeEYsR0FDL0I2bEQsVUFBVTdsRCxLQUFLd0YsQ0FERyxFQUcxQjtJZ0MzOERBLFNBQVN1Z0QsYUFBYTd1QixFQUFFdjBCO01BQ3RCdTBCLElBQUksT0FBT0EsR0FDWCxPQUFRLGFBQWF2MEIsU0FBUywyQkFDaEM7SUVsUEEsU0FBU3FqRCx3Q0FBMkMsUUFBUztJTnVEN0QsU0FBU0MsZUFBZ0IzbUMsTUFBT0M7TUFDOUIsR0FBS0EsYUFBZUEsU0FBU0QsaUJBQW1CO01BQ2hELE9BQU9BLE1BQU1DLFVBQ2Y7STVCZ3BFQSxJQUFJMm1DLGVBQWlCbGtEO0lDcjlEckIsU0FBU21rRCxnQkFBZ0IvakQsR0FBSyxPQUFPLFVBQVVBLEVBQUk7SUQrMUNMLFNBQTFDZ2tELDBDQUFzREM7TUFDdEQsT0FBTztlQUF1QyxxREFBcURBLFdBRHZEO0k2QjFqRGhELFNBQVNDLDZCQUE4QnZ4QyxRQUFTRCxJQUFLRyxRQUFTRCxJQUFLeFM7TUFDakUsT0FBTyxpQ0FBaUNzUyxJQUFJQyxRQUFTQyxJQUFLQyxRQUFRelMsSUFDcEU7SWhCNEtBLFNBQVMrakQsZUFBZ0Jua0QsRUFBRzVCLEdBQUssT0FBTyxNQUFNQSxFQUFHO0lnQnhLakQsU0FBU2dtRCx1QkFBd0J6eEMsUUFBU0QsSUFBS0csUUFBU0QsSUFBS3hTO01BRzNELEdBQUdzUyxlQUNEQSxNQUFNLHlCQUF5QkE7TUFDakMsR0FBR0UsZUFDREEsTUFBTSx5QkFBeUJBO01BQ2pDLE9BQU8sNkJBQTZCRixJQUFJQyxRQUFRQyxJQUFJQyxRQUFRelMsSUFDOUQ7SWhCc0xBLFNBQVNpa0Qsc0JBQXVCcmtELEVBQUdzQixHQUFLLE9BQU8sYUFBYUEsRUFBRztJSlYvRCxTQUFTZ2pELDBCQUE2QixTQUFXO0lUMHRCYixTQUFoQ0MsZ0NBQTRDM2hELEVBQUc4dkMsWUFBYTkwQztNQUM1RCxJQUFJeUMsSUFBTSwyQ0FBMkN1QyxFQUFHOHZDLFlBQWE5MEM7TUFDckUsT0FBTyw2QkFBNkJ5QyxJQUZGO0lnQnhtQnRDLFNBQVNta0QsWUFBWWp6QyxHQUFJM1Q7TUFDdkIsR0FBSUEsU0FBU0EsS0FBSzJULGVBQ2hCO01BQ0YsT0FBT0EsUUFBUTNULEVBQ2pCO0lBSUEsU0FBUzZtRCxjQUFjbHpDLElBQ3JCLE9BQU8sWUFBWUEsS0FDckI7SWdCOFpBLFNBQVNtekMsVUFBVXJtQztNQUNqQixJQUFNLEVBQUUsT0FBT0EsSUFDTixLQUFFO01BQ1gsR0FBSSxLQUFLMGI7T0FBTztNQUdoQixPQUFPLFVBQVVqRixJQUNuQjtJaEM4TXdDLFNBQXBDNnZCLG9DQUFnRHg1QyxJQUFLbEIsTUFBT2kyQjtNQUM1RDtPQUFlO1FBQUU7VUFBMEJqMkIsTUFBT1YsMkJBQTRCM0o7T0FDL0QsV0FBRSx1QkFBdUJzZ0M7T0FDakM7UUFBRTtVQUErQy8wQixJQUFLaytCLFdBQVlEO01BQ3pFLE9BQU8vaEMsRUFKK0I7SUVqSTFDLFNBQVN1OUMsdUJBQXVCdGpELEdBQUssT0FBTyx1QkFBdUJBLEVBQUc7SXNDMXZCdEUsU0FBU3VqRCxtQkFBbUJseEI7TUFDMUIsS0FBS0E7T0FBdUIsTUFDcEI7TUFFUixHQUFJQSxpQkFBa0IsTUFDZEE7TUFFUixPQUFPQSxjQUNUO0lSd2tCQSxTQUFTbXhCLGtCQUFrQmh3QixFQUFHbDNCLEdBQzVCLE9BQUksT0FBT2szQixtQkFBbUJsM0IsTUFLaEM7STNCanBCQSxTQUFTbW5ELFlBQVlDO01BQ25CO09BQU0sRUFBRSxJQUFLeG9ELEtBQUt3b0QsYUFBV0EsTUFBTUEsTUFBTUEsTUFBTUEsTUFBTUE7T0FDL0MsRUFBRSxXQUFXL29EO09BQ1gsSUFBRSxlQUFlMkc7TUFDekIsVUFBZUEsRUFBRXFpRCxJQUNuQjtJTDJDQSxJQUFJQywwQkFBNEJ0bEQ7SUE4K0JoQyxTQUFTdWxELCtCQUErQmg2QyxJQUFLODRDO01BQ3pDLE9BQU8sMENBQTBDOTRDLElBQUs4NEMsVUFDMUQ7SUUveUJBLFNBQVNtQixpQkFBaUI5akQsRUFBRTFEO01BQzFCLEdBQUlBLFdBQVcwRCxRQUFTO01BQ3hCLElBQUk4QixNQUFROUM7TUFDWixJQUFVLElBQUZ5QyxJQUFPQSxNQUFPQSxJQUFJLE1BQ2xCQSxLQUFLLHNCQUF1QnpCLEVBQUcxRCxJQUFJbUY7TUFFM0MsT0FBTyxvQkFBb0JLLEVBQzdCO0lGcUdBLElBQUlpaUQsd0JBQTBCemxEO0lBK0lKLFNBQXRCMGxELHNCQUFrQ3BsRCxHQUNsQyxPQUFPQSxZQURpQjtJSXRUNUIsU0FBU3FsRCxnQkFBZ0IvcEQ7TUFDdkIsSUFBUyxLQUFFLGtCQUFrQkEsTUFDdEIsR0FBRSxtQkFBbUJ5RztNQUM1QixHQUFHb0YsUUFBUyx3QkFBd0IsdUJBQXVCN0w7TUFDM0QsUUFDRjtJSCtDQSxTQUFTZ3FELGlCQUFrQnhsRCxFQUFHNUIsR0FBSyxPQUFPLFdBQVc0QixFQUFHNUIsRUFBSTtJRHdnQ3hCLFNBQWhDcW5ELGdDQUE0Q2hvQyxPQUFRN2EsRUFBR2xCO01BQ3ZELEdBQUkrYixhQUFjLFNBQ0x0aEIsZUFDTixTQUNNc2hCO01BRWIsT0FBTztlQUEyQ0EsT0FBUTdhLEVBQUcsd0JBQXdCbEIsTUFObkQ7SUEzK0JoQixTQUFsQmdrRCxrQkFBOEIxbEQ7TUFDOUIsT0FBTywrQkFBK0IsNkJBQTZCQSxHQUQvQztJQTRMRSxTQUF0QjJsRCxzQkFBa0N6bEQsR0FDbEMsT0FBT0EsWUFEaUI7SWdDOVA1QixTQUFTMGxELFlBQVl2bkM7TUFDbkIsR0FBSUEsT0FBT0EsUUFBUyxPQUFPQTtNQUMzQixvQkFBb0Isa0NBQ3RCO0lZN01BLFNBQVN3bkMsMEJBQTBCbnpDLElBQUs2cEMsUUFBUzNwQyxJQUFLNHBDLFFBQVNwOEM7TUFDN0QsSUFBVyxJQUFGeEMsSUFBT0EsSUFBSXdDLElBQUt4QztPQUFLLHVCQUNMZ1YsSUFBSzRwQyxVQUFVNStDLEVBQUcsY0FBYzhVLElBQUs2cEMsVUFBVTMrQyxHQUUxRTtJM0NxUkEsU0FBU2tvRCxnQkFBZ0I5bEQsR0FDdkIsV0FBVyxlQUFlQSxFQUM1QjtJMEJqQ0EsU0FBUytsRCxrQkFBbUJwckM7TUFDMUIsSUFBUyxLQUFFRixpQkFBaUJFLFFBQ25CLEtBQUVDO01BQ1gsTUFBUUEsbUJBQW9CO09BQWUsQ0FDekMsSUFBSTlYLEVBQUkscUJBQXFCOFgsTUFDN0IsR0FBSTlYLE9BQVE7TUFKZDtPQU1NLEVBQUU4WDtPQUNGO1FBQUUsY0FBY3JTOzs7O1FBQ2QsY0FBY0E7Ozs7UUFDZCxjQUFjQTs7OztRQUNkLGNBQWNBO01BQ3RCcVM7TUFDQSxPQUFPMVgsQ0FDVDtJM0J0SnNCLFNBQWxCOGlELGtCQUE4QmhtRDtNQUM5QixPQUFPLCtCQUErQiw2QkFBNkJBLEdBRC9DO0lDdVZ4QixTQUFTaW1ELHFCQUFxQjNrRDtNQUM1QixJQUFJakI7TUFDSmlCLElBQUksdUJBQXVCQTtNQUMzQmpCLFFBQU9pQjtNQUNQLEdBQUtBLGdCQUFrQmpCLFFBQVFBLElBQU0sT0FBT0E7TUFDNUNpQixJQUFJO01BQ0pqQixRQUFPaUI7TUFDUCxHQUFNQSxnQkFBa0JqQixRQUFRQSxPQUFTLG1CQUFtQmlCLEdBQUksT0FBT2pCO01BTnZFLElBT0krRyxFQUFJLCtEQUErRDlGO01BRXZFLEdBQUc4RjtPQUFFLENBQ0g7U0FBTyxHQUFFO1NBQ0ksU0FBRSxTQUFTQSxPQUFPQSxPQUFPOCtDO1NBQ3pCLFVBQUc5K0MsZ0JBQVk4K0M7UUFDNUI3bEQsTUFBTThsRCxXQUFXLFdBQVkzc0I7UUFDN0IsT0FBT241QjtNQUVULEdBQUcseUJBQXlCaUIsR0FBSSxPQUFPb1Q7TUFDdkMsR0FBRyx1QkFBdUJwVCxHQUFJLFNBQVFvVDtNQUN0QyxnQ0FDRjtJUXZSQSxTQUFTMHhDLDRCQUErQixRQUFVO0lBOUNsRCxTQUFTQyx3QkFBd0I1UDtNQUMvQixJQUFJQSxJQUFNLHdCQUF3QkE7TUFDbEM7ZUFBV3p1Qzs7OztRQUNKOztRQUNBO09BQW1DO1NBQ25DLGtDQUFrQ3l1Qyx1QkFBeUI7YUFDekR0d0MsR0FBSTs7T0FFUixVQUNQO0l5QnZLQSxTQUFTbWdELDZCQUFnQyxRQUFTO0lSb0RsRCxTQUFTQywyQkFBMkIzMUI7TUFDbEMsR0FBR0EsYUFBYyxPQUFTQSxhQUMxQixPQUFPdDBCLElBQ1Q7SVg1QkEsU0FBU2txRCx1QkFBdUJ4bUQsRUFBRzVCLEdBQy9CLFdBQVcyUCxPQUFPL04sVUFBVTVCLFFBQ2hDO0lpQjhEQSxTQUFTcW9ELFVBQVVwb0MsSUFDakIsT0FBTyxlQUFlLE9BQU9BLFdBQy9CO0kzQkZBLFNBQVNxb0MsV0FBV2xyRDtNQUNsQixJQUFJeUcsS0FBTyxrQkFBa0J6RztNQUM3QixLQUFLeUcsa0JBQW1CO01BR3hCLE9BQU8sa0JBQWtCQSxlQUMzQjtJQUlBLElBQUkwa0QsY0FBZ0JEO0lXd1RwQixTQUFTRSxvQkFBb0JyMUMsR0FBSTNULEVBQUdzQztNQUNsQyxPQUFPLFVBQVUsbUJBQW1CdEMsSUFBS3NDLEdBQ3pDLFFBQ0Y7SWhCMm5Eb0MsU0FBaEMybUQ7TUFDQSxPQUFPO2VBQTRCLDZDQUREO0lDajZEdEMsU0FBU0MscUJBQXNCOW1ELEVBQUU1QjtNQUMvQixHQUFHLE1BQU00QixNQUFNLE1BQU01QixHQUFJLE9BQU82WDtNQUNoQyxHQUFHalcsS0FBRzVCLEVBQUcsT0FBT0E7TUFDaEIsR0FBRzRCLE9BQUssT0FDSDVCLFFBQ08sbUJBRUQ7TUFFWCxJQUFTLEtBQUUseUJBQXlCNEIsR0FDNUIsSUFBRTtNQUNWLEdBQUtBLElBQUU1QixLQUFPNEI7T0FDWmdtQixPQUFPLGVBQWVBLEtBQU15VDs7T0FFNUJ6VCxPQUFPLGVBQWVBLEtBQU15VDtNQUM5QixPQUFPLHlCQUF5QnpULEtBQ2xDO0ljZ0NBLFNBQVMrZ0Msb0JBQW9CNzBDO01BQ3pCLElBQUlsUyxFQUFJO01BQ1JBLE9BQU9BO01BQ1AsV0FBVytiLE9BQU8vYixFQUN0QjtJQWdCQSxTQUFTZ25ELHlCQUF5QnBwRDtNQUM5QixXQUFXbWUsT0FBTywyQkFBMkJuZSxLQUFNQSxLQUFNQSxZQUM3RDtJaUI0TUEsU0FBU3FwRCxTQUFTNW9DLEdBQUlDO01BQ3BCLE9BQU8sZUFBZSxXQUFXLE9BQU9ELElBQUssT0FBT0MsV0FDdEQ7SWhDcEwyQixTQUF2QjRvQyx1QkFBbUNsbkQ7TUFDbkMsSUFBSUssSUFBTSxrQ0FBa0NMO01BQzVDLE9BQU8seUJBQXlCLGtDQUFrQ0EsR0FGekM7SWU5TjdCLFNBQVNtbkQscUJBQXFCajFDLE1BQzFCLFFBQ0o7SWIwMEJBLFNBQVNrMUMsb0JBQW9COWxELEdBQzNCLE9BQU8sd0JBQXdCQSxFQUNqQztJY2pXQSxTQUFTK2xELFlBQVk5MUMsR0FBSUMsSUFBS3BSO01BQzVCLElBQUlrbkQsWUFDSTtNQUNSLEdBQUkvMUM7T0FBZ0IsQ0FDbEIsSUFBVyxJQUFGM1QsSUFBT0EsSUFBSTJULGVBQWdCM1QsSUFDbEM4N0IsTUFBTUEsTUFBTW5vQixRQUFRM1Q7UUFDdEIwcEQ7O09BQ0ssQ0FDTCxJQUFXLElBQUYxcEQsSUFBT0EsSUFBSzJULG1CQUFxQjNULElBQ3hDODdCLE1BQU1BLE1BQU1ub0IsUUFBUTNUO1FBQ3RCMHBELGNBQWMvMUM7UUFDZEMsTUFBTUE7TUFFUixHQUFJQSxXQUFXcFIsV0FBWW9SLE1BQU1wUixNQUFPbVIsUUFBUSsxQztPQUFhO01BWjdELElBZUlyVjtNQUNKLElBQVcsSUFBRnIwQyxJQUFPQSxJQUFJMlQsZUFBZ0IzVCxJQUNsQ3EwQyxTQUFTcjBDLEtBQUsyVCxRQUFRM1Q7TUFDeEJxMEMsU0FBU3FWLGVBQWVsbkQ7TUFDeEJzNUIsT0FBTyw2QkFBNkJub0I7TUFuQnBDLElBb0JJMGhCLFNBQVcsaUJBQWlCemhCLE1BQU1rb0IsS0FBTWxvQixNQUFNcFIsT0FBT3M1QjtNQUN6RCxPQUFPLHNCQUFzQm5vQixRQUFTQSxVQUFXMGdDLFNBQVVoZixTQUM3RDtJaEIwdUJBO0tBQUlzMEI7TUFBMkMzbkQ7SXNCaHdDL0MsU0FBUzRuRCxxQkFBc0IsUUFBUTtJcEI0VXZDLFNBQVNDLGlCQUFpQm5tRCxFQUFFMUQsRUFBRWdoRDtNQUM1QixHQUFJaGhELFdBQVcwRCxRQUFTO01BQ3hCO09BQU8sVUFBU3M5QztPQUNULFVBQVNBO09BQ1QsVUFBU0E7T0FDVCxVQUFTQTtNQUNoQixzQkFBdUJ0OUMsRUFBRzFELE1BQU82VDtNQUNqQyxzQkFBdUJuUSxFQUFHMUQsTUFBTzhUO01BQ2pDLHNCQUF1QnBRLEVBQUcxRCxNQUFPK1Q7TUFDakMsc0JBQXVCclEsRUFBRzFELE1BQU9nVTtNQUNqQyxRQUNGO0k4QjVPQSxTQUFTODFDLGFBQWFycEMsR0FBSUMsSUFDeEIsVUFBVyxTQUFTRCxHQUFHQyxJQUFLLFNBQVNELEdBQUlDLElBQzNDO0l2Qm9JQSxTQUFTcXBDLDZCQUFnQyxPQUFPMzFCLHFCQUEyQjtJZWQzRSxTQUFTNDFCLG9CQUNQLElBQUl0bUQsRUFBSSxvQkFDUixPQUFPQSxHQUNUO0lTdE1BLFNBQVN1bUQsMkJBQTJCajNCLElBQUswZSxJQUFNLFFBQVM7SWpDOHNFeEQsU0FBU3dZO01BQ0w7YUFBVXZvQzsyRUFDZDtJd0JqZ0VBLFNBQVN3b0MsZUFBZS9uRCxFQUFFNUI7TUFDeEIsSUFBSWtELEVBQUk7TUFDUjtNQUNBLGlCQUFpQkEsSUFBSUEsV0FBV0E7TUFDaEMsaUJBQWlCdEIsRUFBRXNCLFdBQVdsRDtNQUM5QjtNQUNBa0QsTUFBSXRCO01BQ0pzQixNQUFJbEQ7TUFDSixRQUNGO0lSc0hBLFNBQVM0cEQsY0FBY3oyQyxJQUNyQixPQUFPLFlBQVlBLEtBQ3JCO0lSMVZBLFNBQVMwMkMsOEJBQThCaGdEO01BR3JDLFNBQVNpZ0QsYUFBYWpnRDtRQUNwQixHQUFJQSxlQUFlc1g7U0FBTyxNQUFNdFg7O1NBQzNCLEdBQUksY0FBY0EsS0FBTSxZQUNmaWdELGFBRWhCO01BQ0EsYUFBYWpnRDtNQUViLFlBQVlBO01BRVosU0FBU2tnRCxnQkFBZ0JsZ0QsSUFBS3kvQjtRQUM1QixJQUFJN3RCLElBQU0xZDtRQUNWLFVBQVc4TDtTQUFrQixNQUNyQkE7O1NBQ0QsR0FBSUEsT0FBT0EsbUJBQW1CQTtVQUFvQyxNQUNqRUE7O1VBQ0QsR0FBSSxjQUFjQTtXQUFNLHFCQUNQOUIsR0FDcEIsZ0JBQWdCQSxFQUFHdWhDLElBRFQ7UUFJZCxLQUFLN3RCLElBQUssT0FBTzZ0QjtRQUNqQixHQUFJQSxlQUFldnJDO1NBQVd1ckMsYUFBYTd0Qjs7U0FDdEM2dEIsYUFBYUEsb0JBQW9CN3RCO1FBQ3RDLE9BQU82dEIsVUFDVDtNQUNBLElBQUk3dEIsSUFBTSxnQkFBZ0I1UjtNQUMxQixHQUFJNFIsUUFBUTFkLFVBQVcsTUFBTSx3QkFBd0IwZDtNQUVyRCxZQUFZNVI7TUFDWixNQUFNLDBEQUNSO0lSZ25Cb0IsU0FBaEJtZ0QsZ0JBQTRCeHFEO01BQzVCLElBQUl5QyxJQUFNLDJCQUEyQnpDLEdBQ3JDLGlCQUFpQnlDLEtBQ2pCLE9BQU9BLEdBSFc7SXFDamhCdEIsU0FBU2dvRCxxQkFBcUJyb0Q7TUFDNUIsT0FBR0EsRUFBRTJvQywyQkFBMkJ4c0MsYUFJbEM7SW5Dd0VBLFNBQVNtc0QsaUJBQWlCaG5ELEVBQUUxRDtNQUMxQixHQUFJQSxXQUFXMEQsUUFBUztNQUN4QixJQUFPLEdBQUUsc0JBQXVCQSxFQUFHMUQsR0FDNUIsR0FBRSxzQkFBdUIwRCxFQUFHMUQ7TUFDbkMsT0FBUThULFVBQVVELEVBQ3BCO0lGeWpDcUMsU0FBakM4MkM7TUFBNkN0MUMsTUFBT0MsY0FBZWhJLGdCQUFpQmlJO01BQ3BGLE9BQU87ZUFBaUI7aUJBQTRDRixNQUFPQyxjQUFlaEksZ0JBQWlCaUksS0FEeEU7STJCN3NDdkMsU0FBU3ExQywyQkFDUCxRQUNGO0kxQjhLQSxTQUFTQyxnQkFBZ0J6b0QsR0FBSyxPQUFPLFdBQVlBLEVBQUk7SURqRnJEO0tBQXdCLG9CQUFFSjtLQTlDSixrQkFBRUE7SUE4REUsU0FBdEJncEQsc0JBQWtDNW9ELEVBQUc1QjtNQUNyQyxtQkFBbUI0QixFQUFHLGtCQUFrQkEsRUFBRzVCLEdBRG5CO0lrQnBLNUIsU0FBU3lxRCxzQkFBc0J4ckMsVUFBV3lyQyxNQUFPcHhCLE1BQU9xeEI7TUFDdEQsSUFBVyxJQUFGbnJELElBQU9BLElBQUk4NUIsTUFBTzk1QixJQUFLLGNBQ2hCeWYsVUFBV3lyQyxRQUFRbHJELEVBQUdtckQsT0FFeEM7SWxCb3hDQTtLQUE2QztNQUFFbnBEO0tBdHNDaEIsMkJBQUVBO0lxQ0lqQyxTQUFTc3BELG1CQUFtQmxwRDtNQUMxQixPQUFHQSxFQUFFMm9DLDJCQUEyQnhzQzs7a0JBR25CNkQsRUFBRTJvQyx1QkFDakI7SVgvREEsU0FBU3dnQiwyQkFBMkJqM0M7TUFDbEMsSUFBSXpHLEVBQUlwUjtNQUNSLFVBQVVvUjtPQUNSLEtBQU0sWUFBV0EsMEJBQTBCdEY7TUFFN0MsVUFBVXNGO09BQWlDLENBQ3pDLEtBQU0sWUFBV0EseUNBQTBDdEY7UUFDM0QsS0FBTSxZQUFXc0YseUNBQTBDdEY7UUFDM0QsS0FBTSxZQUFXc0YsNENBQTZDdEY7TUFFaEUsK0NBQ0Y7SUMwWEEsU0FBU2lqRCxvQkFBb0J2bUQsR0FBSyxRQUFTO0kzQm9zQlosU0FBM0J3bUQsMkJBQXVDL3RDO01BRXZDO2VBQVcxYjtlQUNQMGI7ZUFDQSx5QkFBeUJBO2VBQ3pCLHdDQUF3Q0EsU0FMZjtJQWtFTyxTQUFwQ2d1QyxvQ0FBZ0RwcEQsRUFBR0Y7TUFDbkQsT0FBTztlQUErQ0UsRUFBRywyQkFBMkJGLEdBRDlDO0lBOWV2QixTQUFmdXBEO01BQ0EsSUFBSWxwRCxJQUFNLDRCQUNWLGlCQUFpQkEsS0FDakIsT0FBT0EsR0FIVTtJbUM5ckJyQixTQUFTbXBELHdCQUF3QnhwRDtNQUMvQixJQUFNLEtBQ0Y1QjtNQUNKQSxJQUFJLGdDQUFnQzRCO01BQ3BDLEtBQUssbUJBQW1CNUIsR0FBSSxDQUFFNkUsSUFBSUEsT0FBT2pELElBQUk1QjtNQUM3Q0EsSUFBSSxnQ0FBZ0M0QjtNQUNwQyxLQUFLLG1CQUFtQjVCLEdBQUksQ0FBRTZFLElBQUlBLE9BQU9qRCxJQUFJNUI7TUFDN0NBLElBQUksZ0NBQWdDNEI7TUFDcEMsS0FBSyxtQkFBbUI1QixHQUFJLENBQUU2RSxJQUFJQSxNQUFPakQsSUFBSTVCO01BQzdDQSxJQUFJLGdDQUFnQzRCO01BQ3BDLEtBQUssbUJBQW1CNUIsR0FBSSxDQUFFNkUsSUFBSUEsTUFBT2pELElBQUk1QjtNQUM3Q0EsSUFBSSxnQ0FBZ0M0QjtNQUNwQyxLQUFLLG1CQUFtQjVCLEdBQUksQ0FBRTZFLElBQUlBLE1BQU9qRCxJQUFJNUI7TUFDN0NBLElBQUksZ0NBQWdDNEI7TUFDcEMsS0FBSyxtQkFBbUI1QixHQUFJLE9BQU82RTtNQUNuQyxPQUFPQSxJQUFJLG9CQUFvQmpELEVBQ2pDO0lQcEJBLFNBQVN5cEQsa0JBQWtCdHBDLEdBQUlDO01BQzdCLElBQU8sR0FBRUQsVUFBYyxHQUFFQyxVQUNuQixFQUFFMkQsS0FBR0MsT0FDTCxNQUFNMWpCLE1BQU13QztNQUNsQk07TUFIQSxJQUlNLElBQU07TUFDWixLQUFLeEYsSUFBRW1tQixHQUFHbm1CLElBQUt3RixFQUFFeEYsS0FBR3VpQixHQUFHdmlCO01BQ3ZCLEtBQUtBLElBQUVrRixFQUFFbEYsSUFBSW1GLElBQUtLLEVBQUV4RixLQUFHd2lCLEdBQUdyZDtNQUMxQixPQUFPSyxDQUNUO0k1QnVxQkE7S0FBMEIsc0JBQUV4RDtLQTdqQk4sa0JBQUVBO0lnQzdGeEIsU0FBU2dxRCxTQUFTdnJDLEdBQUlDO01BQ3BCLE9BQU8sZUFBZSxPQUFPRCxhQUFhLE9BQU9DLEtBQ25EO0lBbUNBLFNBQVN1ckMsVUFBVXhyQyxHQUFJQztNQUNyQixJQUFXLE9BQUUsVUFBVUQsSUFDWixPQUFFLFVBQVVDO01BQ3ZCLEdBQUk2OUIsU0FBU0M7T0FBd0QsS0FDOUQsT0FBTy85QixRQUFRLE9BQU9DLFlBQVk7UUFBWSxPQUMxQyxTQUFTLFNBQVNELEdBQUlDLElBQUs7TUFHdEMsT0FBTyxTQUFTRCxHQUFJQyxHQUN0QjtJaEM2NUJzQixTQUFsQndyQyxrQkFBOEJyc0MsT0FBUTdhLEVBQUdsQjtNQUN6QyxHQUFJK2IsYUFBYyxTQUNMdGhCLGVBQ04sU0FDTXNoQjtNQUViLE9BQU87ZUFBNkJBLE9BQVE3YSxFQUFHLHdCQUF3QmxCLE1BTm5EO0lnQzNleEIsU0FBU3FvRCxhQUFhMXJDO01BQ3BCQSxLQUFLLE9BQU9BO01BQ1osSUFBSWhlO01BQ0osUUFBTyxVQUFVO09BQVcsQ0FDMUJBLE9BQU8sb0JBQW9CLE9BQU87UUFDbENnZSxLQUFLLFVBQVU7TUFFakIsTUFBTWhlLG9CQUFvQixPQUNqQjtNQUVULE9BQU8sdUJBQXVCQSxJQUNoQztJU3JQQSxTQUFTMnBELG9CQUFvQkMsS0FBSzN1QixPQUFPNHVCO01BQ3ZDO09BQVMsS0FBRSx1QkFBdUJEO09BQzFCLElBQUVBO09BQ0QsS0FBRSx1QkFBdUJDO09BQzFCO09BQ0Y7T0FDRkM7T0FDQXhoQztPQUFPMGY7T0FBS3hsQztNQUNoQixNQUFNSSxJQUFJN0M7T0FBSSxDQUNaK3BELE1BQU0sWUFBWWxuRDtRQUNsQixHQUFHa25EO1NBQVksT0FDTkE7O1NBRUosQ0FDSCxHQUFHbG5ELEtBQUs3QztXQUFLO1VBQ2IrcEQsTUFBTSxZQUFZbG5EO1VBQ2xCLE9BQU9rbkQ7c0JBRUw5cEQsT0FBTzhwRCxJQUNQOzs7Ozs7Ozs7OzthQUdBdG5ELE1BQUtzbkQ7YUFDTCxHQUFJdG5ELFNBQU95NEI7Y0FDVDthQUNGM1MsUUFBUSxlQUFlMlMsT0FBT3o0QjthQUM5QndsQyxNQUFNLGVBQWUvTSxPQUFRejRCO2FBQzdCLEdBQUk4bEI7Y0FDRjthQUNGdG9CLE9BQUssV0FBV3NvQixNQUFNMGY7YUFDdEI7b0JBRUFob0MsY0FBZ0I4cEQ7TUFJdEIsT0FBTyx1QkFBdUI5cEQsSUFBTTtJckJLdEMsU0FBUytwRCxrQkFBbUI5b0Q7TUFDMUI7TUFDQSxPQUFPLEtBQUssd0JBQXdCQSxHQUFJO0lUM1IxQyxTQUFTK29ELFNBQVMxK0MsS0FBTUMsS0FBTUUsS0FBTUMsS0FBTTNMO01BQ3hDLElBQVUsSUFBRnhDLElBQU9BLElBQUl3QyxJQUFLeEMsSUFBSyxVQUNqQmdPLE9BQUtoTyxLQUFLa08sVUFBVUMsT0FBS25PO01BRXJDLFFBQ0Y7SUxaQSxTQUFTMHNELDBCQUEwQjdsRCxHQUFHdkU7TUFDcENxRSxrQkFBa0IsdUJBQXVCRSxPQUFPdkUsRUFDaEQsUUFDRjtJTjZMQTtLQUFJcXFEO01BQWlDM3FEO0lheUVyQyxTQUFTNHFELHFCQUFxQmxwRDtNQUM1QjtPQUFNLEVBQUUseUJBQTBCQTtPQUM1QixFQUFFNEI7T0FBVyxLQUFFQTtPQUFXLEtBQUVBO09BQ3ZCLE9BQUUsb0JBQW9Cc2Y7T0FDbkI7UUFDVixJQUFJalcsMkNBQTZDaytDO09BQy9DLEVBQUUsdUJBQXVCbnBELEVBQUcxRDtPQUM1QixFQUFFLGlCQUFpQmlGO01BQ3pCLEdBQUk1RyxTQUFTQSxLQUFLdW1CLEtBQU07TUFQeEIsSUFRSW5pQixJQUFNLG9CQUFvQnBFO01BQzlCO09BQVMsQ0FDUDJCO1FBQ0FpRixJQUFJLHVCQUF1QnZCLEVBQUcxRDtRQUM5QixHQUFJaUYsUUFBUztRQUNiNUcsSUFBSSxpQkFBaUI0RztRQUNyQixHQUFJNUcsU0FBU0EsS0FBS3VtQixLQUFNO1FBRXhCLEdBQUksZUFBZWdoQixVQUFXbmpDLEtBQU07UUFDcENwRSxJQUFJLG9CQUFvQkE7UUFDeEJvRSxNQUFNLGVBQWUsZUFBZW9xRCxPQUFRcHFELEtBQU1wRTtRQUVsRCxHQUFJLGVBQWVvRSxJQUFLcEUsR0FBSTtNQUU5QixHQUFJMkIsS0FBSyxzQkFBc0IwRCxHQUFJO01BQ25DLEdBQUlraEIsY0FBYyxtQkFBbUJqVyxvQkFBdUJsTTtPQUMxRDtNQUNGLEdBQUk1QixTQUFVNEIsTUFBTSxlQUFlQTtNQUNuQyxPQUFPQSxHQUNUO0kyQnpRQSxTQUFTcXFELGtCQUFrQi8yQixTQUFVZzNCO01BQ25DLGlDQUNFLEtBQUtoM0IsZUFEZSxFQUd4QjtJQ21LQSxTQUFTaTNCLGtCQUFrQi96QyxHQUFJdlYsRUFBR2Y7TUFDaEMsR0FBR0EsV0FBV0EsTUFBTSxzQkFBc0JlO09BQ3hDO01BQ0YsTUFBT2YsT0FBTyxzQkFBc0JlO09BQUksQ0FDdEMsSUFBSWpCLElBQU0sU0FBU3dXLEdBQUl2VixFQUFHZixPQUMxQixHQUFJRixJQUFLLE9BQU9BLElBQ2hCRTtNQUdGLFVBQ0Y7SWQrQ0EsU0FBU3NxRCxnQkFBZ0Jsd0MsT0FBT3BhO01BQzlCLElBQUlxYSxLQUFPSCxpQkFBaUJFO01BQzVCLEdBQUlDLGVBQWV0ZSxLQUFNO01BQ3pCc2UsY0FBY3JhO01BQ2QsUUFDRjtJdkJsR0EsU0FBU3VxRCx3QkFBd0J0dkQ7TUFDL0I7T0FBUyxLQUFFLGtCQUFrQkE7T0FDdkIsRUFBRSxvQkFBb0J5RztPQUN0QixNQUFNM0IsTUFBTThDO01BQ2xCTjtNQUNBLElBQVMsSUFBRGxGLElBQUlBLElBQUV3RixTQUFTeEYsSUFDckJrRixFQUFFbEYsU0FBTyx1QkFBdUJ3RixFQUFFeEY7TUFDcEMsT0FBT2tGLENBQ1Q7SUtpQ0EsU0FBU2lvRCw4QkFBaUMsT0FBTy80QixzQkFBNEI7SWtCcUI3RSxTQUFTZzVCLG1CQUFvQnJ3QztNQUMzQixJQUFJQyxLQUFPSCxpQkFBaUJFO01BQzVCLHlCQUF5QkE7TUFDekIsR0FBSUMsZUFBZSxtQkFDakI7TUFIRixJQUlJdmEsSUFBTSxtQkFBbUJ1YTtNQUM3QkE7TUFDQSxPQUFPdmEsR0FDVDtJUHhHQSxTQUFTNHFELFlBQVlqckQ7TUFDbkIsSUFBSUEsRUFBSSx3QkFBd0JBO01BRWhDLEtBQUk7T0FBbUU7OztTQUNqQ0E7OztNQUd0QyxPQUFPLEtBQUtBLEVBQ2Q7SUxxSUEsU0FBU2tyRCx1QkFBdUJ0dEQsR0FDNUIsT0FBTyxvQkFBb0JBLFFBQy9CO0lmaTZCeUMsU0FBckN1dEQscUNBQWlEanJELEVBQUdGLEVBQUc1QjtNQUN2RCxPQUFPO2VBQWdEOEIsRUFBRyx3QkFBd0JGLEdBQUksd0JBQXdCNUIsR0FEdkU7SXFDMW1DM0MsU0FBU2d0RCxvQkFBb0IxNEMsSUFBS0U7TUFDaENBLElBQUkrMUIseUJBQXlCajJCLElBQUlpMkIsdUJBQ2pDLFFBQ0Y7SUh0RkEsU0FBUzBpQixnQ0FBbUMsUUFBUztJNUI0Q3JELFNBQVNDLGtCQUFrQnpvRCxHQUFLLFVBQVNBLFVBQVVBLFFBQVU7SW1DOE03RCxTQUFTMG9ELGlCQUFpQjEwQyxHQUFHdlYsRUFBRWY7TUFDN0IsR0FBR0EsV0FBV0EsTUFBTSxzQkFBc0JlO09BQ3hDO01BQ0YsSUFBSWpCLElBQU0sU0FBU3dXLEdBQUl2VixFQUFHZjtNQUMxQixPQUFJRixJQUFZQSxPQUVsQjtJaEM5RUEsU0FBU21yRDtNQUNQLEdBQUdueEQ7T0FBbUIsVUFDVkE7UUFBaUQsQ0FFekQsSUFBSStJLE9BQVEvSTtTQUNaLGtDQUFrQytJO1NBQ2xDLFVBQVVBOztRQUNMLEdBQUcvSTtTQUE2QyxDQUVyRDtXQUFTLEtBQUU7V0FDTCxPQUFNQSx3QkFBdUJveEQ7VUFDbkMsVUFBVXJvRDtNQUdkLElBQVEsSUFBRSxJQUFLNUcsaUJBQ1QsRUFBRW8wQyxtQkFBZTtNQUN2QixVQUFVNXdDLEVBQ1o7SWEvTEEsU0FBUzByRCwyQ0FBOEMsUUFBVTtJTndZakUsU0FBU0MsY0FBY3A2QyxHQUFJakMsR0FBSXZKLElBQzdCLE9BQU8sT0FBTyxXQUFXdUosR0FBR3ZKLEtBQzlCO0lYM1hBLFNBQVM2bEQsY0FBYzVyRCxHQUFJLE9BQU9BLENBQUU7SVcyWXBDLFNBQVM2ckQsb0JBQW9CdDZDLEdBQUlqQyxHQUFJcFA7TUFDbkMsSUFBSXNSLElBQU0sVUFBVWxDO01BQ3BCLEdBQUdrQyxXQUFXRCxlQUFnQjtNQUM5QixPQUFPQyxRQUFRdFI7TUFDZixPQUFPc1IsUUFBUXRSO01BQ2YsUUFDRjtJaEIzWDZCLFNBQXpCNHJELHlCQUFxQzlyRDtNQUNyQyxPQUFPLHlCQUF5QixvQ0FBb0NBLEdBRHpDO0lrQ3ZEL0IsU0FBUytyRCw2QkFBZ0MsUUFBUztJbEI2Z0JsRCxTQUFTQyxjQUFjejZDLEdBQUk4c0M7TUFDekJBLE9BQU8sbUJBQW1CQTtNQUMxQixJQUFhLFNBQUVBLFlBQ0wsU0FDRyxZQUNUN3NDO01BRUosR0FBSXk2QyxXQUFXMTZDO09BQ2I7TUFHRixHQUFJQTtPQUFnQixDQUNsQixJQUFXLElBQUYzVCxJQUFPQSxJQUFJcXVELFNBQVVydUQsSUFDNUJ1ZixNQUFNdmYsS0FBS3lnRCxLQUFLemdEO1FBQ2xCLEtBQU9BLElBQUkyVCxlQUFnQjNULElBQ3pCdWYsTUFBTXZmO1FBQ1JzdUQsV0FBVyxjQUFjRDs7T0FDcEIsQ0FDTCxJQUFXLElBQUZydUQsSUFBT0EsSUFBSXF1RCxTQUFVcnVEO1NBQzVCdWYsTUFBTTVMLGlCQUFpQjA2QyxXQUFXcnVELEtBQUt5Z0QsS0FBS3pnRDtRQUM5QyxJQUFXLElBQUZBLElBQU9BLElBQUkyVCxpQkFBaUIwNkMsU0FBVXJ1RCxJQUM3Q3VmLE1BQU12ZjtRQUNSc3VELFdBQVcsZ0JBQWlCMzZDLGlCQUFpQjA2QztNQUUvQ3o2QyxNQUFNLFVBQVUyTDtNQXRCaEI7T0F1QlMsS0FBRSxpQkFBaUIrdUM7T0FDUCxpQkFBRSw2QkFBNkIzNkM7T0FDdkM7UUFBRTtVQUFpQkMsTUFBTTJGLGtCQUFtQjNGLE1BQU1vRSxRQUFRdUI7TUFDdkUsT0FBTyxzQkFBc0I1RixRQUFTQSxVQUFXMjZDLFNBQVVqNUIsU0FDN0Q7SWdCblhBLFNBQVNrNUIsa0JBQWtCcjNCLEdBQ3pCLE9BQU8sWUFBWUEsRUFDckI7SUEyWkEsU0FBU3MzQixZQUFZaHBELEVBQUdIO01BR3RCRyxJQUFJLE9BQU9BO01BQ1hILElBQUksT0FBT0E7TUFDWCxJQUFTLEtBQUUsVUFDSCxJQUFFO01BQ1YsR0FBRyxlQUFldzJCLEtBQ2hCO01BQ0YsR0FBSSxTQUFTTSxTQUFTLGVBQWVOLEtBQU0sT0FDbENyMkI7TUFFVCxHQUFJLFNBQVMyMkIsU0FBUyxTQUFTQSxNQUFPO01BUHRDO09BVU0sRUFBRSxtQkFBbUIzMkIsRUFBR0g7T0FDeEIsRUFBRSxPQUFPakQ7T0FDUCxJQUFFLE9BQU9vRCxZQUFZRixPQUFPRDtNQUNwQyxHQUFHLE9BQU84MkIsTUFBT3RTLE1BQU0sUUFBUTtNQUMvQixHQUFHLEtBQUtzUyxNQUFPNzJCLElBQUksTUFBTTtNQUN6QixHQUFHLFdBQVd1MkIsS0FBTSxPQUNYLGVBQWV2MkI7TUFFeEIsd0JBQ0Y7SUFsS0EsU0FBU21wRCxVQUFVaHVDLEdBQUlDLEdBQUlndUM7TUFDekIsSUFBUyxLQUFFLFVBQ0gsSUFBRTtNQUNWanVDLEtBQUssT0FBT0E7TUFDWkMsS0FBSyxPQUFPQTtNQUNaZ3VDLEtBQUssT0FBT0E7TUFDWixHQUFHLFVBQVV2eUIsTUFBTztNQUNwQixHQUFHLGdCQUFnQk4sS0FBTTtNQUN6QixHQUFHLFVBQVVNLE1BQU87TUFDcEIsR0FBRztPQUFVLENBQ1gsSUFBUSxJQUFFLE9BQU8sWUFBWTFiLEdBQUlpdUMsS0FDM0IsRUFBRSxXQUFXLFlBQWFBO1FBQ2hDLEdBQUcsS0FBS3Z5QixNQUFPNzJCLElBQUksTUFBTTtRQUN6QixPQUFPLGVBQWVBOztPQUNqQixDQUNMLElBQUlBLEVBQUksT0FBT21iLFdBQVdDLEdBQUlndUM7UUFDOUIsR0FBRyxLQUFLdnlCLE1BQU83MkIsSUFBSSxNQUFNO1FBQ3pCLE9BQU8sZUFBZUEsR0FFMUI7SUFpRUEsU0FBU3NwRCxjQUFjbnVDLEdBQUlDLEdBQUlndUM7TUFDN0JBLEtBQUssT0FBT0E7TUFFWixJQUFJN3lCLElBQU07TUFDVixHQUFJLE9BQU9uYixPQUFPbWI7T0FBTTtNQUd4QixLQUFLLE9BQU82eUIsUUFBUTd5QixZQUFZQTtPQUFNO01BR3RDLE9BQU8sVUFBVXBiLEdBQUlDLEdBQUlndUMsR0FDM0I7SVp4aUJBLFNBQVNHLGtCQUFtQnBwRCxHQUFLLE9BQU8sR0FBSztJY2xCN0MsSUFBSXFwRCwyQkFBNkJuM0I7SXZCdVZqQyxTQUFTbzNCLG1CQUFtQmhoRCxLQUFNQyxLQUFNRSxLQUFNQztNQUM1QyxHQUFHSixVQUFVQyxRQUFRRSxVQUFVQyxNQUFPO01BQ3RDLEdBQUdKLFVBQVVDLFFBQVFFLFVBQVVDLE1BQU87TUFDdEMsUUFDRjtJZ0JoSEEsU0FBUzZnRCxjQUFlanlDLE9BQVFyWixFQUFHMUQsRUFBR2tGO01BQ3BDLElBQVMsS0FBRTJYLGlCQUFpQkUsUUFDckIsR0FBRSxxQkFBcUJDO01BQzlCLEdBQUlvSixXQUFXcEosZUFBZXRlLEtBQU0wbkIsS0FBSyxxQkFBcUJwSjtNQUM5RCxHQUFJb0osS0FBS2xoQixFQUFHQSxJQUFJa2hCO01BQ2hCLGVBQWVwSixZQUFhdFosRUFBRzFELEVBQUdrRjtNQUNsQzhYLGVBQWU5WDtNQUNmLE9BQU9BLENBQ1Q7STNCaTBCMkMsU0FBdkMrcEQsdUNBQW1EMWhELElBQUtsQixNQUFPaTJCO01BQy9EO09BQWUsV0FBRSx1QkFBdUJBO09BQ3pCO1FBQUU7VUFBa0QvMEIsSUFBS2xCLE1BQU9tL0I7TUFDL0UsT0FBTztlQUEwQkM7ZUFBWXpwQztlQUF3QkM7cUJBSDVCO0l3QnpsQjdDLFNBQVNpdEQsd0JBQXdCLFFBQVE7SXhCOUZ6QyxJQUFJQyx3QkFBMEJudEQ7SVMvSDlCLFNBQVNvdEQ7TUFDUCxVQUFXLHNDQUNiO0lBVUEsU0FBU0M7TUFDUCxVQUFXLHVCQUF1Qmo3QixjQUNwQztJVHlxQnFCLFNBQWpCazdCLGlCQUE2QjNtRCxPQUFRN0U7TUFDckMsR0FBSTZFLGFBQWMsU0FDTHBLLGVBQ04sU0FDTW9LO01BRWI7T0FBSWxHO1FBQU0sNEJBQTRCa0csT0FBUSx3QkFBd0I3RTtNQUN0RSxPQUFJckIsT0FDV0EsTUFSSTtJd0M1NEJ2QixTQUFTOHNELGNBQWN4NUIsU0FBVWczQjtNQUMvQjtPQUFJeUM7O1NBQ08sc0JBQ0R6QztzQkFDVTBDLGlCQUNkLE9BQU9BLHVCQURIO3FCQUdVM3JDO2NBQ2QwckMsb0JBQW9CMXJDO2NBQ3BCMHJDO2NBQ0EsT0FBTzFyQyxLQUhIO29CQUtXelo7YUFDZm1sRCxvQkFBb0JubEQ7YUFDcEJtbEQ7YUFDQUE7YUFDQSxNQUFNbmxELEdBSkQ7OztNQVNYLE9BQU9tbEQsV0FDVDtJeENlNkIsU0FBekJFLHlCQUFxQy84QjtNQUNyQyxPQUFPO2VBQW9DLHlCQUF5QkEsYUFEekM7SUMwTS9CLFNBQVNnOUIsaUJBQWtCdnRELEdBQUssT0FBTyxXQUFXQSxFQUFJO0lEbWhDdEQ7S0FBSXd0RDtNQUF1QzV0RDtJa0NoeEMzQyxTQUFTNnRELG1DQUFzQyxRQUFTO0lqQlh4RCxTQUFTQywwQkFBMEJDO01BQ2pDLElBQUl0d0IsUUFBU2hqQyx1QkFBc0JzekQ7TUFDbkMsT0FBTyw0QkFBOEJ0d0IsV0FBWUEsR0FDbkQ7SUhtRkEsU0FBU3V3QixTQUFTNXRELEVBQUU1QixHQUNsQixHQUFJQSxPQUFRLHlCQUNaLE9BQU80QixJQUFFNUIsQ0FDWDtJRWxGQSxTQUFTeXZELGVBQ1AsUUFDRjtJaEJzUEEsSUFBSUMsMkJBQTZCbHVEO0l3QnNKakMsU0FBU211RCxtQkFBbUJuM0M7TUFDMUIsSUFBSWQ7TUFDSixJQUFTLElBQURsWSxJQUFLQSxJQUFFZ1osVUFBVWhaO09BQUksQ0FDM0JrWSxLQUFLbFk7UUFDTCxJQUFTLElBQURtRixJQUFLQSxJQUFFNlQsU0FBUzdUO1NBQUksQ0FDMUI7V0FBTSxFQUFFbkYsS0FBR2daLGdCQUFlN1Q7V0FDcEIsRUFBRTZULFFBQVFyTztXQUNWLEVBQUVxTyxRQUFRck87V0FDVixFQUFFcU8sUUFBUXJPO1VBQ2hCdU4sS0FBS2xZLE9BQUttRixVQUFRRyxZQUFZdUksVUFBVTlJO01BRzVDLE9BQU9tVCxJQUNUO0lTaGFBLFNBQVNrNEMsK0JBQWtDLFFBQVU7SWxCb2FyRCxTQUFTQyx3QkFBd0JqdUQsRUFBRzVCO01BQ2hDNEIsYUFBYUE7TUFDYjVCLGFBQWFBO01BQ2IsT0FBTyxpQkFBaUJBLFFBQzVCO0lkcEJBLFNBQVM4dkQsa0JBQW1CbHlELElBQUtnRTtNQUMvQixTQUFTbXVELFFBQVFudUQsRUFBRW91RDtRQUNqQixHQUFJLFNBQVNwdUQ7U0FBVSxPQUNkLFVBQVVvdUQ7O1NBQ1osQ0FDTCxJQUFJam9ELEVBQUksU0FBUztVQUNqQixHQUFJQTtXQUFRLENBQ1ZBO1lBQ0FuRyxLQUFLLFlBQVltRztZQUNqQm5HLEtBQUssSUFBS00sTUFBTTZGO1lBQ2hCLEdBQUdpb0QsT0FBUSxJQUNMcHVELFVBQVUsSUFBS00sTUFBTTh0RDtZQUUzQixPQUFPcHVEOztXQUVKLE9BQU8sVUFBVW91RCxJQUUxQjtNQUNBLElBQUk5c0QsRUFBSyxFQUFFLGtCQUFrQnRGLEtBQ3BCLEtBQUdxSCxhQUFjQTtNQUMxQixHQUFJckQsU0FBVUEsY0FBWUEsT0FBTTBVLFNBQVcsQ0FBRXJSLGFBQWFyRCxNQUFLQTtNQUMvRCxHQUFJLE1BQU1BO09BQUksQ0FBRXNCLFVBQVcrQjs7T0FDdEIsS0FBSyxTQUFTckQ7UUFBSSxDQUFFc0IsVUFBVytCOztRQUVsQyxPQUFRQTs7V0FFTixJQUFNLEVBQUUsZ0JBQWdCZ3JELE1BRWxCLEVBQUUvc0Q7V0FDUixHQUFJLFNBQVMxRDtZQUNYMEQsSUFBSSxVQUFZMUQsZUFBZSxRQUFTQTtXQUMxQzttQkFFQTBELElBQUksUUFBUXRCLEVBQUdxdUQsTUFBTzs7V0FFdEJBLE9BQU9BLEtBQUtBO1dBQ1ovc0QsSUFBSSxnQkFBZ0Irc0Q7V0FDcEIsSUFBTSxFQUFFLGVBQ0EsTUFBRyxRQUFRdHJEO1dBQ25CLEdBQUlnUyxhQUFZL1UsYUFBYSxzQkFBc0JxdUQ7WUFBTSxDQUV2RCxJQUFJendELEVBQUltRjthQUFPLE1BQU8sU0FBU25GLFVBQVdBO2FBQzFDLEdBQUksU0FBU0EsVUFBV0E7YUFDeEIwRCxJQUFJLFVBQVcxRCxTQUFTLFFBQVFtRjthQUNoQ25GLElBQUkwRDthQUNKLEdBQUksU0FBUzFEO2NBQ1gwRCxJQUFJLFVBQVkxRCxlQUFlLFFBQVNBO2FBQzFDOztZQUNLLENBQ0wsSUFBSTRpQixFQUFJNnRDO2FBQ1IsR0FBSXQ1QztjQUFTLENBQUV5TCxLQUFLekwsUUFBU3pULElBQUksVUFBVWtmOztjQUN0QyxNQUFPbGYsSUFBSSxVQUFVa2YsR0FBSWxmLFdBQVcrc0QsU0FBVTd0QzthQUNuRCxHQUFJQTtjQUFHLENBRUwsSUFBSTVpQixFQUFJMEQ7ZUFBYyxNQUFPLFNBQVMxRCxVQUFXQTtlQUNqRCxHQUFJLFNBQVNBLFVBQVdBO2VBQ3hCMEQsSUFBSSxVQUFXMUQ7V0FHbkI7O01BRUosT0FBTyx1QkFBdUJ5RixFQUFHL0IsRUFDbkM7SUduVkEsU0FBU2d0RCxvQkFBb0I5eUQsS0FBSzZIO01BQ2hDLElBQVMsS0FBRSxlQUFlN0gsTUFDakIsS0FBRSxvQkFBb0I7TUFDL0IsNEJBQTRCQSxnQkFBZ0JvTCxhQUFhcEwsS0FBSzZIO01BQzlELFFBQ0Y7STRCaVFBLFNBQVNrckQsV0FBV2x3QyxHQUFJQyxJQUN0QixPQUFPLE9BQU9ELFdBQVcsT0FBT0MsSUFDbEM7STlCaUtBLFNBQVNrd0Msd0JBQXdCMW9ELEdBQUlFO01BQ25DLE9BQU8scUJBQXFCQSxHQUFJRixHQUNsQztJWTdkQSxTQUFTMm9ELFNBQVN6dUQsRUFBRTVCO01BQ2xCLEdBQUlBLE9BQVEseUJBQ1osT0FBUTRCLElBQUU1QixLQUNaO0lrQjRqQkEsU0FBU3N3RCxvQkFBb0I1NUI7TUFDM0JBLElBQUksT0FBT0E7TUFDWCxHQUFJLEtBQUssV0FBWTtNQUdyQixJQUFJN3lCLEtBQU8sT0FBTyxVQUFVNnlCO01BQzVCLE9BQUksY0FBYzd5QixTQUFTNnlCLE1BTTdCO0l2QjVnQkEsU0FBUzY1QixrQkFBbUJ2ckQsR0FDMUIsVUFBV3FwQixhQUFjQSxVQUMzQjtJZXlTQSxTQUFTbWlDLHFCQUFxQjV1RCxFQUFFNUI7TUFDOUIsSUFBSWtELEVBQUksb0JBQ1IsT0FBTywwQkFBMEJ0QixFQUFFNUIsRUFDckM7SWE5V0EsSUFBSXl3RCx1QkFBeUIzdkI7SVo2SjdCLFNBQVM0dkIsY0FBZTl1RCxFQUFHNUIsR0FBSyxVQUFTLGlCQUFpQjRCLEVBQUU1QixhQUFlO0lPbUIzRSxTQUFTMndELGtCQUFrQjF3QyxJQUFNLE9BQU8sWUFBWUEsR0FBSTtJWTdNeEQsU0FBUzJ3QywwQkFBMEJ6OUMsR0FBSTA5QyxPQUFRcDFDLElBQUtxMUMsUUFBUzl1RDtNQUMzRCxJQUFXLElBQUZ4QyxJQUFPQSxJQUFJd0MsSUFBS3hDO09BQUssQ0FDNUI7U0FBSWlGO1VBQUk7WUFBaUIsY0FBYzBPLEdBQUkwOUMsU0FBU3J4RDtZQUFJLHVCQUF1QmljLElBQUtxMUMsVUFBVXR4RDtRQUM5RixHQUFJaUYsT0FBUSxPQUFPQTtNQUVyQixRQUNGO0l0Q1JBLFNBQVNzc0QscUJBQXNCbHNELEVBQUcvQyxFQUFHa3ZEO01BQ25DLEdBQUdBLFlBQVkvMEQ7T0FDYjRJLElBQUkseUJBQXlCbXNEO01BQy9CanFELGlCQUFpQmxDLFNBQVMvQztNQUMxQixHQUFHa3ZELFNBQVVqcUQsaUJBQWlCaXFELFlBQVlsdkQsQ0FDNUM7STRCZEEsU0FBU212RCw2QkFBNkI3b0QsSUFBS2dMLElBQUtwUixJQUFLQztNQUNqRCxJQUFJa0gsTUFBUSxrQkFBa0JuSDtNQUM5QixvQ0FBb0NvRyxJQUFLZ0wsSUFBS2pLLFFBQVVuSDtNQUR4RCxJQUVJa3ZELEtBQU8sZ0JBQWdCLHFCQUFxQi9uRCxTQUFXbkg7TUFDM0QsaUJBQWlCa3ZELE9BQVNqdkQ7TUFDMUIsUUFDSjtJbEN3MkJ1QixTQUFuQmt2RCxtQkFBK0IzeEQ7TUFDL0IsT0FBTyxpQkFBaUIsOEJBQThCQSxHQURqQztJNEIzeUJ6QixTQUFTNHhELHVCQUF1QnB2RDtNQUM5QixHQUFJQSxRQUFTO01BQ2IsSUFBUSxJQUFFQSxZQUNKLE1BQU1FLE1BQU1GO01BQ2xCdUM7TUFDQSxJQUFXLElBQUYvRSxJQUFPQSxJQUFJd0MsSUFBS3hDLElBQUsrRSxFQUFFL0U7TUFDaEMsT0FBTytFLENBQ1Q7SU56REEsU0FBUzhzRCxzQkFBc0J4c0QsR0FBSyxRQUFVO0l0QjJuQlIsU0FBbEN5c0Qsa0NBQThDMXZELEVBQUc1QjtNQUNqRCxJQUFJaUMsSUFBTSw2Q0FBNkNMLEVBQUc1QjtNQUMxRCxpQkFBaUJpQztNQUNqQixPQUFPQSxHQUg2QjtJQW1sRHhDLFNBQVNzdkQ7TUFDTDthQUFVcHdDOzRFQUNkO0l3Q3B3RUEsU0FBU3F3QyxhQUFhajhCLFNBQVVnM0I7TUFDOUI7T0FBSXlDOztTQUNPLHNCQUNEekM7cUJBQ1VqcEM7Y0FDZDByQyxvQkFBb0IxckM7Y0FDcEIwckM7Y0FDQSxPQUFPMXJDLEtBSEg7b0JBS1d6WjthQUNmbWxELG9CQUFvQm5sRDthQUNwQm1sRDthQUNBQTthQUNBLE1BQU1ubEQsR0FKRDs7O01BU1gsT0FBT21sRCxXQUNUO0lwQjBMQSxTQUFTeUMsaUJBQWlCaHRELEVBQUdPO01BQzNCLE9BQVFBO2VBQ0EsV0FBV1A7ZUFDWCxXQUFXQSxFQUFHTztlQUNkLFdBQVdQLEVBQUdPLEtBQUtBO2VBQ25CLFdBQVdQLEVBQUdPLEtBQUtBLEtBQUtBO2VBQ3hCLFdBQVdQLEVBQUdPLEtBQUtBLEtBQUtBLEtBQUtBO2VBQzdCLFdBQVdQLEVBQUdPLEtBQUtBLEtBQUtBLEtBQUtBLEtBQUtBO2VBQ2xDLFdBQVdQLEVBQUdPLEtBQUtBLEtBQUtBLEtBQUtBLEtBQUtBLEtBQUtBO2VBQ3ZDLFdBQVdQLEVBQUdPLEtBQUtBLEtBQUtBLEtBQUtBLEtBQUtBLEtBQUtBLEtBQUtBOztNQUVwRCxTQUFTNk0sSUFBTSxPQUFPLFFBQVEzVixLQUFNOEksRUFBSTtNQUN4QzZNLGNBQWNwTjtNQUNkLFdBQVdvTixHQUNiO0lMeURBLFNBQVM2L0MsMkJBQTJCOXZELEVBQUc1QjtNQUNuQyxXQUFXMmQsT0FBTyxzQkFBc0IvYixRQUFTNUIsR0FDckQ7SWZtZXNCLFNBQWxCMnhEO01BQ0EsSUFBSTF2RCxJQUFNLCtCQUNWLGlCQUFpQkEsS0FDakIsT0FBT0EsR0FIYTtJV2huQnhCLFNBQVMydkQsZUFBZXY4QyxJQUFLakMsSUFBS3BSO01BQ2hDLElBQVUsSUFBRnhDLElBQU9BLElBQUl3QyxJQUFLeEM7T0FBSyxTQUNsQjRULE1BQUk1VCxvQkFBbUI2VixTQUFTakMsTUFBSTVULFNBRWpEO0lYdUlBLElBQUlxeUQsa0JBQW9CcndEO0lnQ2hKeEIsU0FBU3N3RCxZQUFZN3hDLEdBQUlDO01BQ3ZCLE9BQU8sZUFBZSxPQUFPRCxRQUFRLE9BQU9DLEtBQzlDO0loQzBIQTtLQUF1QixtQkFBRTFlO0swQjFQTDtJQUNwQixTQUFTeXdELG9CQUFxQi91RDtNQUM1QixLQUFLLHlCQUF5QkEsR0FBSSxPQUFPQTtNQUN6QyxPQUFPLFVBQVU4dUQ7Z0JBQ05BO2VBQ0FBLDhCQUNiO0lWNFVBLFNBQVNFLGNBQWMvK0MsSUFDckIsT0FBTyxZQUFZQSxLQUNyQjtJZ0JtYkEsU0FBU2cvQyxvQkFBb0J6N0I7TUFDM0JBLElBQUksT0FBT0E7TUFDWCxJQUFTLEtBQUUsVUFDSCxJQUFFO01BQ1YsR0FBSSxTQUFTaUYsTUFBTztNQUZwQixJQU1JbjhCO01BQ0prM0IsSUFBSSxNQUFNO01BQ1YsSUFBS2wzQixRQUFRLFNBQVM4aUIsYUFBYzlpQixJQUFLLElBQ25DO01BRU4sT0FBT0EsQ0FDVDtJWnBpQkEsU0FBUzR5RCw2QkFBNkJDLE1BQU9wdEQ7TUFDM0M7UUFDRSxJQUFJSixFQUFJNlE7UUFDUixHQUFHN1EsS0FBS3d0RCxTQUFTcHRELFlBQVlvdEQsTUFBTyxPQUFPLFFBQVFuMEQsS0FBTXdYO1FBRHpELElBRVMsU0FBTXhULE1BQU1td0QsT0FDYixJQUFFLFNBQVMzOEMsaUJBQWtCMjhDO1FBQ3JDLElBQVcsSUFBRjd5RCxJQUFPQSxJQUFJd0MsSUFBS3hDLElBQUswRyxLQUFLMUcsS0FBS2tXLFVBQVVsVztRQUNsRCxPQUFPLGNBQWN5RixFQUFHaUIsS0FObkIsQ0FRVDtJRXJOQSxTQUFTb3NELG9CQUFvQngrQyxNQUFRLFFBQVU7SXRCNmxCekIsU0FBbEJ5K0Msa0JBQThCM3dELEVBQUc1QjtNQUNqQyxJQUFJaUMsSUFBTSw2QkFBNkJMLEVBQUc1QjtNQUMxQyxpQkFBaUJpQztNQUNqQixPQUFPQSxHQUhhO0lXelN4QixTQUFTdXdELGVBQWVqbEQsS0FBTUMsS0FBTUUsS0FBTUM7TUFDeENKLFVBQVVDLFNBQVNFLFVBQVVDLE1BQzdCLFFBQ0Y7SUVwSEEsU0FBUzhrRCxlQUFnQjd3RCxFQUFHNUIsR0FBSyxPQUFPLE1BQU1BLEVBQUc7SVI5RmpELFNBQVMweUQsY0FBY3QxRDtNQUNyQixJQUFJeUcsS0FBTyxrQkFBa0J6RztNQUM3QixLQUFLeUc7T0FBc0I7TUFHM0IsT0FBTyxxQkFBcUJBLGVBQzlCO0lTeERBLFNBQVM4dUQsaUJBQWlCL3dEO01BQ3hCLFFBQVVBOzs7O2NBQ0FBOzs7O2NBQ0FBOzs7O2NBQ0FBOztlQUNaO0lUMUVBLFNBQVNneEQsY0FBZTtJZWhCeEIsU0FBU0MsbUJBQW1CMW9ELEVBQUUxRixHQUFLLE9BQVEwRixhQUFhMUYsS0FBWTtJQXFOcEUsU0FBU3F1RCxzQkFBc0I3dEQ7TUFDN0I7UUFDRSxJQUFJakQsSUFBTTBUO1FBQ1YsR0FBRzFUO1NBQVEsQ0FDVCxJQUFJa0UsU0FBV2hFLE1BQU1GO1VBQ3JCLElBQVcsSUFBRnhDLElBQU9BLElBQUl3QyxJQUFLeEMsSUFBSzBHLEtBQUsxRyxLQUFLa1csVUFBVWxXO1VBQ2xELE9BQU8sY0FBY3lGLEVBQUdpQjs7U0FDbkIsT0FDRSxjQUFjakIsR0FBSWxILFdBUHRCLENBVVQ7SUw3SEEsU0FBU2cxRCw0QkFBNEJueEQsRUFBRzVCO01BQ3BDLFdBQVcyUCxPQUFPL04sWUFBWTVCLEVBQ2xDO0lkeUpBLFNBQVNnekQsZ0JBQWlCcHhELEdBQUssT0FBTyxVQUFVQSxFQUFJO0ljMEVwRCxTQUFTcXhELG1CQUFtQm4vQyxNQUN4QixRQUNKO0lTUkEsU0FBU28vQyxrQkFBa0J6dUQ7TUFDekIsaUJBQWlCLG9CQUFvQkEsSUFDckMsUUFDRjtJcEJ2TUEsU0FBUzB1RCxhQUFhLzFEO01BQ3BCO09BQVMsS0FBRSxlQUFlQTtPQUNqQixLQUFFLG9CQUFvQjtPQUN2QjtNQUNSLElBQVUsSUFBRm9DLElBQU9BLElBQUlvTCx3QkFBeUJwTDtPQUMxQyxHQUFHb0wsaUJBQWlCcEwsV0FBV3BDLEtBQU04eUIsTUFBTTF3QjtNQUM3QyxHQUFHMHdCLFVBQVUsd0JBQXdCQTtNQUNyQyxRQUNGO0lKNkhBLElBQUlrakMscUJBQXVCNXhEO0lBMnhEYSxTQUFwQzZ4RCxvQ0FBZ0R6eUM7TUFDaEQsT0FBTztlQUE0QjtpQkFBK0MsNEJBQTRCQSxRQUR4RTtJZWhyRDFDLFNBQVMweUMscUJBQXFCeC9DLE1BQzFCLFFBQ0o7SVkzRUEsU0FBU3kvQyxrQkFBa0JoM0M7TUFBUyxPQUFPLG9CQUFvQkYsaUJBQWlCRSxlQUFlO0lIb0gvRixTQUFTaTNDLG1CQUFtQmg3QyxHQUFHNVcsRUFBRTVCO01BQy9CLElBQUlrRCxFQUFJO01BQ1IsS0FBSXNWO09BQVUsQ0FDWixJQUFJbThCLE9BQVM7UUFDYkEsZUFBZXp4QztRQUNmeXhDLGdCQUFnQnp4QztRQUNoQixxQ0FBcUNzVjtRQUhyQyxJQUlJaTdDLFdBQVl4M0Q7UUFDaEJ3M0Q7OztVQUNFLG9CQUFvQkEsTUFBTTd4RCxFQUFFc0IsV0FBV3NWLFlBQVl4WTtVQUNuRHdZLFdBQVdpN0MsS0FGRTtRQUlmQSxZQUFZOztPQUNQLG9CQUNlajdDLFNBQVM1VyxFQUFFc0IsV0FBV3NWLFlBQVl4WTtNQUV4RCxRQUNGO0l0QnZKQSxTQUFTMHpELGdCQUFpQnh3RCxFQUFHMUQsRUFBR2lGO01BQzlCLEdBQUlqRixXQUFXMEQsSUFBSztNQUNwQixPQUFPLHVCQUF3QkEsRUFBRzFELEVBQUdpRixFQUN2QztJRW5EQSxTQUFTa3ZELGVBQWV2MkQ7TUFDdEIsSUFBSXlHLEtBQU8sa0JBQWtCekcsTUFDN0Isa0JBQWtCeUcsV0FDbEIsUUFDRjtJK0I3TEEsU0FBUyt2RCx3QkFBd0JoeUQ7TUFDL0IsR0FBSSxtQkFBbUJBLEdBQUk7TUFDM0IsSUFBSWlEO01BQ0osU0FBU2d2RCxRQUFTanlELEdBQVEsT0FBTyxtQkFBbUJBLEVBQUk7TUFDeEQsU0FBU2t5RCxLQUFNbHlELEVBQUU1QixHQUFTLE9BQU8sZUFBZTRCLEVBQUc1QixFQUFJO01BQ3ZELFNBQVMrekQsWUFBWW55RCxHQUFLLE9BQU8sMkJBQTJCQSxNQUFRO01BQ3BFO1FBQUksUUFBUSxLQUFLQSxFQUFHO09BQTBELENBQzVFaUQsSUFBSUEsT0FBUWpELElBQUksZ0NBQWdDQTtNQUVsRCxHQUFJLFFBQVEsS0FBS0EsRUFBRztPQUF5QixDQUMzQ2lELElBQUlBLE9BQVFqRCxJQUFJLGdDQUFnQ0E7TUFFbEQsR0FBSSxRQUFRLEtBQUtBLEVBQUc7T0FBeUIsQ0FDM0NpRCxJQUFJQSxNQUFRakQsSUFBSSxnQ0FBZ0NBO01BRWxELEdBQUksUUFBUSxLQUFLQSxFQUFHO09BQXlCLENBQzNDaUQsSUFBSUEsTUFBUWpELElBQUksZ0NBQWdDQTtNQUVsRCxHQUFJLFFBQVEsS0FBS0EsRUFBRztPQUF5QixDQUMzQ2lELElBQUlBLE1BQVFqRCxJQUFJLGdDQUFnQ0E7TUFFbEQsT0FBT2lELElBQUssb0JBQW9CLGVBQWVqRCxFQUFHLHVCQUNwRDtJcEJvQkEsU0FBU295RCxvQkFBb0JweUQsRUFBRzVCO01BQzVCLEdBQUlBLGFBQWM7TUFHbEIsV0FBVzJQLE9BQU8vTixVQUFVNUIsUUFDaEM7SWJzYUEsU0FBU2kwRCxvQkFBb0J2c0QsR0FBSUUsSUFBTSxXQUFTLGlCQUFpQkYsR0FBSUUsR0FBSztJT2pRMUUsU0FBU3NzRCx3QkFBd0Job0MsT0FDL0IsT0FBTywwQkFDVDtJVCs0QzhDLFNBQTFDaW9DLDBDQUFzRHRPO01BQ3RELE9BQU87ZUFBdUMscURBQXFEQSxXQUR2RDtJZTkzQ2hELFNBQVN1Tyw0QkFBNEJ4eUQsRUFBRzVCO01BQ3BDLFdBQVcyZCxPQUFPLGdDQUFnQy9iLFFBQVM1QixHQUMvRDtJUzRMQSxTQUFTcTBEO01BQ1Asc0RBQ0Y7SXhCdTRDb0MsU0FBaENDO01BQ0EsT0FBTztlQUE0Qiw2Q0FERDtJdUMxMkR0QyxTQUFTQyxpQ0FBaUNobEM7TUFDeEMsSUFBSS9nQixFQUFJLG9CQUFvQitnQixNQUM1QixPQUFPL2dCLGNBQ1Q7SXhCc1NBLFNBQVNnbUQsb0JBQW9CNXlELEVBQUc1QjtNQUM1QixXQUFXMmQsT0FBTyxlQUFlL2IsUUFBUzVCLFNBQzlDO0lmcWhDb0MsU0FBaEN5MEQsZ0NBQTRDcDFDLE9BQVE3YSxFQUFHbEI7TUFDdkQsR0FBSStiLGFBQWMsU0FDTHRoQixlQUNOLFNBQ01zaEI7TUFFYixPQUFPO2VBQTJDQSxPQUFRN2EsRUFBRyx3QkFBd0JsQixNQU5uRDtJYzl0Q3RDLFNBQVNveEQsYUFBYTl5RCxHQUNwQixRQUFXQSxvQkFDQUEsZ0JBQ2I7SWFvREEsU0FBUyt5RCx3QkFBd0JwNEMsT0FBTzVUO01BQ3RDLElBQVMsS0FBRTBULGlCQUFpQkUsUUFDbkIsS0FBRXhWLHFCQUFxQnlWO01BQ2hDOUUsb0JBQW1CL087TUFDbkIrTyxvQkFBb0IvTztNQUNwQixRQUNGO0lMeElBLFNBQVNpc0Qsc0JBQXlCLFFBQVU7SUU2TjVDLFNBQVNDLGtCQUFrQmp6RCxFQUFFNUIsRUFBRThaLEVBQUV0TDtNQUMvQixJQUFJdEwsRUFBSTtNQUNSLHFCQUFxQnRCLEVBQUVzQixXQUFXbEQsRUFBRThaLElBQUd0TDtNQUN2QyxRQUNGO0l4QnZDQSxJQUFJc21ELHFCQUF1QnR6RDtJMkJ5TDNCLFNBQVN1ekQsa0JBQW1CeDRDLE9BQU96YSxFQUFFc3VCO01BQ25DLElBQUlsdEIsRUFBSSw0QkFBNEJwQixFQUFHc3VCO01BQ3ZDLGVBQWU3VCxPQUFPclosSUFBSSxzQkFBc0JBO01BQ2hELFFBQ0Y7STNCc3hCeUMsU0FBckM4eEQscUNBQWlEbHpELEVBQUdGLEVBQUc1QjtNQUN2RCxPQUFPO2VBQWdEOEIsRUFBRyx3QkFBd0JGLEdBQUksd0JBQXdCNUIsR0FEdkU7SWdCOXZCM0MsU0FBU2kxRCxjQUFjOWhELEdBQUlqQyxHQUFJdkosR0FBSUUsSUFDakMsT0FBTyxPQUFPLFdBQVdxSixHQUFHdkosR0FBR0UsS0FDakM7SWhCeUYwQixTQUF0QnF0RCx3QkFDQSxVQUR3QjtJQXRKNUIsSUFBSUMscUJBQXVCM3pEO0lnQ3BJM0IsU0FBUzR6RCxjQUFjbjFDLElBQU0sT0FBTyxZQUFZQSxHQUFJO0loQ2c0Q1AsU0FBekNvMUM7TUFDQSxJQUFJcHpELElBQU07TUFDVixPQUFPLDJDQUEyQ0EsSUFGUDtJd0MvaUQvQyxTQUFTcXpELGNBQWMvL0IsU0FBVWczQjtNQUMvQixpQ0FFSSxLQUFLaDNCLGVBREQ7bUJBR0MsRUFDWDtJQTNFQSxTQUFTZ2dDLGFBQWFoSjtNQUNwQjtPQUFJaDNCOztTQUNPLHVCQUNEZzNCO3FCQUNVanBDO2NBQ2RpUyxpQkFBaUJqUztjQUNqQmlTO2NBQ0EsT0FBT2pTLEtBSEg7b0JBS1d6WjthQUNmMHJCLGlCQUFpQjFyQjthQUNqQjByQjthQUNBQTthQUNBLE1BQU0xckIsR0FKRDs7O01BU1gsT0FBTzByQixRQUNUO0luQ2dMQSxTQUFTaWdDLGNBQWMxaEQsTUFDckIsc0JBQ0Y7SUx1a0VBLFNBQVMyaEQ7TUFDTDthQUFVdDBDO3lFQUNkO0lBL1oyQyxTQUF2Q3UwQyx1Q0FBbURDLFFBQVNDO01BQzVERDs7TUFBVTtRQUEwQkEsUUFBUzdvQztNQUM3QzhvQyxTQUFTLDBCQUEwQkEsT0FBUWwxQztNQUMzQyxPQUFPLGtEQUFrRGkxQyxRQUFTQyxPQUh6QjtJOEJsMUQ3QyxTQUFTQyxhQUFjajBEO01BQ3JCLEdBQUtBLGFBQWFNLFNBQVVOLFFBQVNBO09BQ25DLE9BQU9BOztPQUNKLEdBQUksaUJBQWlCQTtRQUN4Qjs7UUFDRyxHQUFJLGtCQUFrQkE7U0FDekI7O1NBQ0csR0FBS0EsYUFBYWswRCxtQkFBb0JsMEQ7VUFDekM7O1VBQ0csR0FBSUEsS0FBS0EsY0FDWixnQkFFQSxXQUNKO0k1QnFOQSxTQUFTbTBELGlCQUFpQjd5RCxFQUFFMUQ7TUFDMUIsR0FBSUEsV0FBVzBELFFBQVM7TUFDeEI7T0FBTyxHQUFFLHNCQUF1QkEsRUFBRzFEO09BQzVCLEdBQUUsc0JBQXVCMEQsRUFBRzFEO09BQzVCLEdBQUUsc0JBQXVCMEQsRUFBRzFEO09BQzVCLEdBQUUsc0JBQXVCMEQsRUFBRzFEO01BQ25DLE9BQVFnVSxXQUFXRCxXQUFXRCxVQUFVRCxFQUMxQztJZ0M5T0EsU0FBUzJpRCxtQ0FBc0MsUUFBUztJaENvUHhELFNBQVNDLGtCQUFrQi95RCxFQUFFMUQ7TUFDM0IsR0FBSUEsV0FBVyxzQkFBc0IwRCxPQUFRO01BQzdDLElBQUk4QixNQUFROUM7TUFDWixJQUFVLElBQUZ5QyxJQUFPQSxNQUFPQSxJQUFJLE1BQ2xCQSxLQUFLLHVCQUF3QnpCLEVBQUcxRCxJQUFJbUY7TUFFNUMsT0FBTyxvQkFBb0JLLEVBQzdCO0lrQnZKQSxTQUFTa3hELGtDQUFrQzFqQztNQUN6QyxHQUFHQSxhQUFjLFVBQWFBLGNBQzlCLFFBQ0Y7SU93VEEsU0FBUzJqQyxtQkFBbUI1NUM7TUFDMUIsY0FBY0E7TUFDZCxPQUFPLG9CQUFxQkYsaUJBQWlCRSxlQUMvQztJS3ZOQSxTQUFTNjVDLGNBQWNDO01BQ3JCLEdBQUdBLE1BQU0vL0MsWUFBWSsvQyxRQUFPLy9DLFlBQVkrL0MsTUFBTUE7T0FDNUMsb0JBQW9CO01BQ3RCLE9BQU8sZUFBZSxPQUFPQSxPQUFLLFVBQVVBLElBQUksV0FBV0EsS0FDN0Q7SVI4UkEsU0FBU0Msd0JBQXdCdHhEO01BQy9CLHdEQUNGO0l4Qm9xQndDLFNBQXBDdXhELG9DQUFnRHowRDtNQUNoRCxPQUFPLCtDQUErQ0EsRUFEaEI7STRCN21DMUMsU0FBUzAwRCxxQkFBcUJ6MEMsR0FBSXBhLEdBQUlxYSxHQUFJbmEsR0FBSTdGO01BQzVDLEdBQUk2RixNQUFNRjtPQUFJLElBQ0QsSUFBRmhELElBQU9BLEtBQUszQyxJQUFLMkMsSUFBS3FkLEdBQUduYSxLQUFLbEQsS0FBS29kLEdBQUdwYSxLQUFLaEQ7O09BQy9DLElBQ00sSUFBRkEsRUFBSTNDLElBQUsyQyxPQUFRQSxJQUFLcWQsR0FBR25hLEtBQUtsRCxLQUFLb2QsR0FBR3BhLEtBQUtoRDtNQUV0RCxRQUNGO0k1QjhtRXFCLFNBQWpCOHhEO01BQ0EsT0FBTyxxQkFBcUIsOEJBRFQ7SXdDdGtFdkIsU0FBU0MsZ0JBQWdCcHpDO01BQ3ZCLGdCQUNXLGdCQUFnQkE7b0JBQ2xCQTs7Z0NBSVg7SUxvQkEsU0FBU3F6QyxpQkFBaUI5NEQsR0FDeEIsT0FBTyxnQkFBZ0JBLEVBQ3pCO0lmd0VBLFNBQVMrNEQsWUFBWW55RCxFQUFHTztNQUN0QixPQUFRQTtlQUNBLFdBQVdQO2VBQ1gsV0FBV0EsRUFBR087ZUFDZCxXQUFXUCxFQUFHTyxLQUFLQTtlQUNuQixXQUFXUCxFQUFHTyxLQUFLQSxLQUFLQTtlQUN4QixXQUFXUCxFQUFHTyxLQUFLQSxLQUFLQSxLQUFLQTtlQUM3QixXQUFXUCxFQUFHTyxLQUFLQSxLQUFLQSxLQUFLQSxLQUFLQTtlQUNsQyxXQUFXUCxFQUFHTyxLQUFLQSxLQUFLQSxLQUFLQSxLQUFLQSxLQUFLQTtlQUN2QyxXQUFXUCxFQUFHTyxLQUFLQSxLQUFLQSxLQUFLQSxLQUFLQSxLQUFLQSxLQUFLQTs7TUFFcEQsU0FBUzZNLElBQU0sT0FBTyxRQUFRM1YsS0FBTSxtQkFBbUI4SSxHQUFLO01BQzVENk0sY0FBY3BOO01BQ2QsV0FBV29OLEdBQ2I7SXBCY0E7S0FBSWdsRDtNQUF1Q3IxRDtJRWtvQjNDLFNBQVNzMUQsa0JBQW1CNXpELEdBQzFCLE9BQU8sd0JBQXdCQSxFQUNqQztJRnBpQjRCLFNBQXhCNnpELHdCQUFvQ24xRDtNQUNwQyxPQUFPLG1DQUFtQyx3QkFBd0JBLEdBRHhDO0lXdE45QixTQUFTbzFELGFBQWEzaEQsSUFBS2pDLEtBQ3pCLEdBQUdpQyxTQUFTakMsU0FBVSxTQUN0QixRQUNGO0lnQlZBLFNBQVM2akQsNEJBQTZCdHREO01BQ3BDLElBQUkrTixLQUFPM1EscUJBQXFCNEM7TUFDaEMsR0FBRytOLGtCQUFtQiw2QkFBNEIvTjtNQURsRDtPQUVJZ25CO2NBQ0dqWjtnQkFDRUE7WUFDSi9OOzs7O01BS0wwUyxpQkFBaUJzVSxjQUFZQTtNQUM3QixPQUFPQSxVQUNUO0laNk5BLFNBQVN1bUMscUJBQXFCcDFELEdBQzFCLE9BQU8sZ0JBQWdCQSxRQUMzQjtJZDFEQSxTQUFTcTFELGdCQUFpQnYxRCxHQUFLLE9BQU8sVUFBVUEsRUFBSTtJcUIzT3BELFNBQVN3MUQsb0JBQW9CdGpELE1BQVEsUUFBVTtJWWxDL0MsU0FBU3VqRCw0QkFBK0IsUUFBUztJVW9CakQsU0FBU0MsOEJBQThCaGpELElBQUs2cEMsUUFBUzNwQyxJQUFLNHBDLFFBQVNwOEM7TUFDakUsSUFBVyxJQUFGeEMsSUFBT0EsSUFBSXdDLElBQUt4QztPQUFLLGNBQ2RnVixJQUFLNHBDLFVBQVU1K0MsRUFBRyxjQUFjOFUsSUFBSzZwQyxVQUFVMytDLEdBRWpFO0k1Q3drQm9CLFNBQWhCKzNEO01BQ0EsSUFBSXQxRCxJQUFNLDZCQUNWLGlCQUFpQkEsS0FDakIsT0FBT0EsR0FIVztJNkNubkJ0QixJQUFJdTFELFdBQWE7SUFDakIsU0FBU0M7TUFDTCxJQUFPLEdBQUUsV0FFRSxPQUFFLG9CQUFvQkM7TUFDakMsT0FBTyxlQUFlQyxPQUFPSCxXQUNqQztJbENrWEEsU0FBU0ksY0FBY3JxRCxLQUFNQyxLQUFNRSxLQUFNQztNQUN2Q0osVUFBVUMsU0FBU0UsVUFBVUMsTUFDN0IsUUFDRjtJYW9GQSxTQUFTa3FELG1CQUFtQnIvQyxHQUFHNVcsRUFBRTVCO01BQy9CO09BQU0sRUFBRTtPQUNBO1FBQUUsdUJBQXVCNEIsRUFBRXNCLFdBQVdzVixZQUFZeFksRUFBRXdZLFNBQVNBO01BQ3JFLElBQVcsSUFBRmhaLElBQU9BLElBQUlzNEQsZ0JBQWlCdDREO09BQUssQ0FDeENnWixRQUFRaFosS0FBS3M0RCxTQUFTdDREO1FBQ3RCZ1osUUFBUWhaLFNBQU9zNEQsU0FBU3Q0RDtRQUN4QmdaLFFBQVFoWixTQUFPczRELFNBQVN0NEQ7UUFDeEJnWixRQUFRaFosU0FBT3M0RCxTQUFTdDREO01BRTFCLFFBQ0Y7SUE2QkEsU0FBU3U0RCxrQkFBa0IveUQ7TUFDekIsa0RBQ0Y7SXhCNWNBO0tBQUlnekQ7TUFBaUN4MkQ7STBCMUJyQyxTQUFTeTJEO01BQ1AsSUFBSUMsR0FDQWo4RCxxQkFBcUJBO01BQ3pCLE9BQU8sNkJBQTRCLHdCQUNyQztJVjRUQSxTQUFTazhELGVBQWVobEQsSUFDdEIsT0FBT0EsU0FDVDtJRHBVQSxTQUFTaWxELHlCQUF5QjU0RCxHQUM5QixPQUFRQSxXQUNaO0lrQk1BLFNBQVM2NEQsNkJBQWdDLFVBQVk7SUwrQ3JELFNBQVNDLGVBQWdCeDVDLE1BQU9DLE1BQU93NUM7TUFDckMsR0FBS3g1QyxhQUFlQSxTQUFTRCxpQkFBbUI7TUFDaERBLE1BQU1DLGFBQVN3NUM7TUFBUSxRQUN6QjtJMUIwZUEsU0FBU0Msd0JBQXdCOXdELEdBQUlFO01BQ25DLE9BQU8scUJBQXFCQSxHQUFHRixHQUNqQztJOEI0RUEsU0FBUyt3RCxtQkFBbUIvaEM7TUFJMUJBLElBQUksT0FBT0E7TUFDWCxJQUFTLEtBQUUsVUFDSCxJQUFFO01BRVYsR0FBSSxTQUFTaUYsU0FBUyxTQUFTTixRQUFRLFNBQVMsY0FBZTtNQUgvRCxJQU1JcTlCLE1BQVEsYUFBYTtNQUN6QixJQUFXLElBQUZuMEQsSUFBT0EsS0FBS20wRCxNQUFPbjBEO09BQUssQ0FDL0IsR0FBRyxLQUFLbzNCLFNBQVNwM0IsV0FBWTtRQUM3QixJQUFPLEdBQUUsUUFDSCxFQUFFLE9BQU8sVUFBVW8wRCxHQUFJcDBEO1FBQzdCLEdBQUcsS0FBS28zQixNQUFPdlosSUFBSTtRQUZuQixJQUdJdGQsRUFBSSxPQUFPLFNBQVNzZCxFQUFHN2Q7UUFDM0IsR0FBSSxTQUFTTyxHQUFJO01BSW5CLFFBQ0Y7SXJCM2xCQSxTQUFTOHpELGNBQWN2akQsSUFBS2pDLElBQUs4VyxPQUMvQjdVLFNBQVNqQyxPQUFPOFcsTUFDaEIsUUFDRjtJZ0IyWEEsU0FBUzJ1QyxtQkFBb0J0OEMsT0FBTy9jO01BQ2xDO09BQVEsS0FBSUEsZUFBZUEsZUFBZUEsY0FBYUE7T0FDakQsRUFBRSxxQkFBcUJta0I7TUFDN0IsZUFBZXBILE9BQU9yWjtNQUN0QixRQUNGO0kzQml1QndDLFNBQXBDNDFELG9DQUFnRGgzRCxFQUFHdEM7TUFDbkQsT0FBTztlQUF3QiwrQ0FBK0NzQyxFQUFHdEMsR0FEM0M7SWV4bUMxQyxTQUFTdTVELHNCQUFzQm4zRCxFQUFHNUIsR0FDOUIsV0FBVzJQLE9BQU8vTixVQUFVNUIsUUFDaEM7SWVSQSxTQUFTZzVELGtCQUFrQnp6RCxJQUFJM0Q7TUFDN0IsSUFBTSxFQUFFQSxTQUNGLE1BQU1NLE1BQU13QztNQUNsQk0sT0FBT087TUFDUCxJQUFVLElBQUYvRixJQUFPQSxJQUFJa0YsRUFBR2xGLElBQU13RixFQUFFeEYsS0FBS29DLEVBQUVwQztNQUNyQyxPQUFPd0YsQ0FDVDtJSGlJQSxTQUFTaTBELHFCQUFxQjE4QztNQUM1QixJQUFJQyxLQUFPSCxpQkFBaUJFLFFBQzVCLE9BQU8sa0JBQ1Q7STFCbEhBLFNBQVMyOEMsd0JBQXlCdDNELEVBQUdxdUQsS0FBTWtKO01BQ3pDLEtBQUssU0FBU3YzRDtPQUFJLENBQ2hCLEdBQUksTUFBTUEsR0FBSSxPQUFPO1FBQ3JCLE9BQU8sd0JBQTBCQTtNQUVuQyxJQUFJdkIsS0FBUXVCLGNBQVVBLE9BQU0wVSxXQUFhMVU7TUFDekMsR0FBR3ZCLEtBQU11QixNQUFLQTtNQURkLElBRUkrVTtNQUNKLEdBQUkvVTtPQUFROztPQUNQLEdBQUlBO1FBQU8sTUFDUEEsU0FBUytVLGFBQWMsQ0FBRS9VLE9BQVErVTs7UUFDbkMsTUFDRS9VLE9BQVEsQ0FBRUEsT0FBUStVO01BUDNCLElBU2EsU0FBRUEsZUFDRjtNQUNiLEdBQUl0VztPQUFNZzVEOztPQUNMLE9BQ0lGO2lCQUNZRSxlQUFnQjtpQkFDaEJBLGVBQWdCO2lCQUMxQjtNQUdYLEdBQUlwSixhQUFhQTtPQUFXLENBRTFCLElBQUlxSixJQUFNLFdBQVdySixVQUNyQnJ1RCxJQUFJLFdBQVdBLElBQUkwM0QsT0FBT0E7TUF0QjVCLElBd0JJQyxNQUFRO01BQ1osR0FBR3RKO09BQVUsQ0FDWCxJQUFJLy9CLElBQU07UUFDVixHQUFHQTtTQUFPLGVBQ08sZ0JBQWdCKy9COztTQUU1QixDQUNILElBQUl6NEMsS0FBTzBZLFVBQU0rL0I7VUFDakIsR0FBR3NKLGVBQWUvaEQ7V0FDaEIraEQsU0FBUyxnQkFBZ0IvaEQsT0FBTytoRDs7V0FFaENBLFFBQVEsZUFBZS9oRDtNQUc3QixPQUFPO2VBQXlCNmhELGtCQUFrQkUsY0FBY0gsV0FBVyxpQkFDN0U7SUR1ckNBO0tBQUlJO01BQTBDaDREO0lBMStCbEIsU0FBeEJpNEQsd0JBQW9DNzNEO01BQ3BDLE9BQU8sd0JBQXdCLG1DQUFtQ0EsR0FEeEM7SW9CMUI5QixTQUFTODNELGtDQUFrQ3JILE1BQU9wdEQ7TUFDaEQ7UUFDRSxJQUFTLFNBQU0vQyxNQUFNbXdELFdBQ2IsSUFBRSxTQUFTMzhDLGlCQUFrQjI4QztRQUNyQ25zRCxVQUFVaEs7UUFDVixJQUFXLElBQUZzRCxJQUFPQSxJQUFJd0MsSUFBS3hDLElBQUswRyxLQUFLMUcsU0FBT2tXLFVBQVVsVztRQUNwRCxPQUFPLGNBQWN5RixFQUFHaUIsS0FMbkIsQ0FPVDtJWS9CQSxTQUFTeXpELFlBQVkvN0QsSUFBS3FpQjtNQUN4QkEsS0FBSyxPQUFPQTtNQUNaO09BQVEsSUFBRSx1QkFBdUJyaUI7T0FFeEI7T0FDRDtPQUNFO09BQ0Y7T0FDQTtPQUNDO09BQ0Q7T0FDQTtPQUNFO01BQ1YsTUFBTUEsSUFBSXN5QixZQUFhQTtNQUN2QixNQUFPQTtPQUFPLEdBQ1R0eUIsSUFBSXN5QjtRQUFhNHBDOztRQUNmLEdBQUlsOEQsSUFBSXN5QjtTQUFhNnBDOztTQUNyQixHQUFJbjhELElBQUlzeUI7VUFBYXd0Qjs7VUFDckIsR0FBSTkvQyxJQUFJc3lCLGVBQWV0eUIsSUFBSXN5QixZQUFhN3ZCLE9BQU96QyxJQUFJc3lCLFVBQ25EO01BRVAsR0FBRyxNQUFNLFdBQVcsQ0FBQzd2QixXQUFXNGYsS0FBSztNQUNyQyxLQUFLcmlCLElBQUlzeUIsZUFBYXR5QixJQUFJc3lCLFlBQVdBO09BQ25DMnBDLGFBQVNBLFVBQVVqOEQsSUFBSXN5QjtNQUN6QixPQUFPdHlCLElBQUlzeUI7OztpQkFDbUI7aUJBQ3BCOUwsU0FBVSxHQUFHMDFDLElBQUtFLGNBQWU7aUJBQ2pDNTFDLFNBQVUsR0FBRzAxQyxJQUFLRSxjQUFlO2lCQUNqQzUxQyxVQUFXLEdBQUcwMUMsSUFBS0UsY0FBZTtpQkFDbEM1MUMsVUFBVyxHQUFHMDFDLElBQUtFLGNBQWVKLFFBQVM7Z0JBRW5ELHVDQUF1Q2g4RDtNQUV6QyxHQUFJOC9DLElBQUtxYztNQS9CVCxJQWdDSTkzRCxJQUFNLFlBQVltaUI7TUFDdEIsR0FBSXcxQyxVQUFXLE1BQ1A7TUFsQ1IsSUFvQ0lwaUQsS0FBT3ZWO01BQ1gsR0FBSTgzRDtPQUFZLEdBQ1hyYztRQUFLLENBQ056N0MsTUFBTTVCLE9BQU8yNUQsU0FBUy8zRCxJQUN0QixLQUFLQSxhQUFXNDNELE9BQVE1M0QsTUFBTUEsTUFBTTgzRDs7UUFDL0IsQ0FDTDkzRCxNQUFNNUIsT0FBTzI1RCxTQUFTLzNELElBQ3RCLEtBQUtBLGFBQVc0M0QsT0FBUTUzRCxNQUFNODNELE1BQU05M0Q7O09BRWpDLENBQ0wsSUFBSWc0RCxJQUFNNTVELE9BQU8yNUQ7UUFDakIsS0FBSy8zRCxhQUFXZzRELGFBQVdKLE9BQVE1M0QsTUFBTTgzRCxNQUFNOTNEO1FBQy9DQSxNQUFNZzRELE1BQU1oNEQ7TUFFZCxPQUFPLHVCQUF1QkEsSUFDaEM7SWhDNjJEeUIsU0FBckJpNEQscUJBQWlDdDREO01BQ2pDLE9BQU87ZUFDSDtpQkFDSTttQkFBcUJBLEVBQUdKLHlCQUEwQkEsaUNBSG5DO0lTbGhFM0IsU0FBUzI0RCxjQUFlbjFELEdBQ3RCLE9BQU9xcEIsU0FDVDtJQXlIQSxTQUFTK3JDLDhCQUE4QixRQUFRO0lPK00vQyxTQUFTQyxhQUFhbG5ELEdBQUlyUixHQUN4QixRQUFRQSxHQUNSLFFBQ0Y7SWdCOVRBLFNBQVN3NEQsdUJBQXVCcjZDLEdBQUlDO01BQ2xDLE9BQU8sU0FBUyxPQUFPRCxJQUFLLGNBQWNDLElBQzVDO0k5QmlMQSxTQUFTcTZDLGtCQUFrQnIzRCxFQUFFMUQsRUFBRWdoRCxLQUM3QixPQUFPLGlCQUFpQnQ5QyxFQUFFMUQsRUFBRWdoRCxJQUM5QjtJYVlBLFNBQVNnYSx1QkFBdUIxbUQ7TUFDNUJ3Rzs7bUJBQ2UyWTtNQUVmM1k7O21CQUNlaW5CO01BRWZqbkI7O2lCQUNhc3VCO21CQUNFK1Q7O1lBRVA0QztlQUNHMXpCO01BQ1h2Ujs7aUJBQ2FnMkI7bUJBQ0VpSDtZQUNQMmY7ZUFDR3JIO01BQ1gsT0FBTy83QyxJQUNYO0lBeE9BLFNBQVMybUQsb0JBQW9CNzRELEVBQUc1QjtNQUM1QixXQUFXMmQsT0FBTyxlQUFlL2IsUUFBUzVCLFNBQzlDO0lmMGRvQixTQUFoQjA2RCxnQkFBNEI5NEQsRUFBRzVCO01BQy9CLElBQUlpQyxJQUFNLDJCQUEyQkwsRUFBRzVCO01BQ3hDLGlCQUFpQmlDO01BQ2pCLE9BQU9BLEdBSFc7SThCN21CdEIsU0FBUzA0RCxrQkFBbUIvNEQsRUFBRzVCO01BQzdCLFVBQVdBLGlCQUFpQixDQUFFNEIsUUFBUTVCLEVBQUc7TUFDekMsR0FBSUEsTUFBUSxDQUFFNEIsUUFBUTVCLE1BQU87TUFDN0IsSUFBSVIsRUFBSVE7TUFBVSxNQUFPUixJQUFLb0MsRUFBRXBDLEtBQUtRLEVBQUVSO01BQUksUUFDN0M7SUZrRUEsU0FBU283RCxnQkFBZ0I5N0MsTUFBTzFMLElBQUtwUixJQUFLRjtNQUN4QyxJQUFVLElBQUZ0QyxJQUFPQSxJQUFJd0MsSUFBS3hDLElBQUksTUFDcEI0VCxNQUFJNVQsU0FBT3NDLEVBRW5CLFFBQ0Y7STFCdWVBLFNBQVMrNEQsdUJBQXVCbnpELEdBQUlFLElBQ2xDLE9BQU8sb0JBQW9CQSxHQUFJRixHQUNqQztJc0J2TEEsU0FBU296RCxtQkFBbUJuM0M7TUFDMUI7T0FBTSxFQUFFO09BQ0YsRUFBRUE7T0FDRixFQUFFQTtPQUNELEdBQUUsMEJBQTBCN0osRUFBRXRMO01BQ3JDLElBQVMsSUFBRGhQLElBQUlBLElBQUVnUCxFQUFFaFA7T0FBSSxJQUNULElBQURtRixJQUFJQSxJQUFFbVYsRUFBRW5WO1FBQUksQ0FDbEIsSUFBTSxFQUFFZ2YsSUFBSW5rQixPQUFLbUYsT0FDWCxFQUFFbkYsS0FBR3NhLFNBQVFuVjtTQUNuQixHQUFHRjtVQUFTLENBQ1YrVCxRQUFRck87V0FDUnFPLFFBQVFyTztXQUNScU8sUUFBUXJPO1dBQ1JxTyxRQUFRck87O1VBQ0gsQ0FDTHFPLFFBQVFyTyxTQUFTMUY7V0FDakIrVCxRQUFRck8sU0FBUzFGO1dBQ2pCK1QsUUFBUXJPLFNBQVMxRjtXQUNqQitULFFBQVFyTztNQUlkLE9BQU9xTyxFQUNUO0lHek5BLFNBQVN1aUQsMkJBQTJCeCtDLE9BQU90WDtNQUN6QyxJQUFJdVgsS0FBT0gsaUJBQWlCRTtNQUM1QnhWLHFCQUFxQnlWLGtCQUFrQnZYO01BQ3ZDLFFBQ0Y7STNCKzFEMkMsU0FBdkMrMUQsdUNBQW1EckYsUUFBU0M7TUFDNUREOztNQUFVO1FBQTBCQSxRQUFTOWlEO01BQzdDK2lELFNBQVMsMEJBQTBCQSxPQUFRMy9CO01BQzNDLE9BQU8sa0RBQWtEMC9CLFFBQVNDLE9BSHpCO0lTOXREN0MsU0FBU3FGO01BQ1AsSUFBSTV0RCxFQUFJcFI7TUFDUixHQUFHb1IsYUFBYUE7T0FBYzs7a0JBQ2dCeEQsSUFBS3F4RDtXQUMvQyw4QkFBOEJyeEQsS0FDOUIsaUJBRmdDOztPQUsvQixHQUFHd0Q7UUFBbUI7O21CQUNZOHREO1lBQ25DLEdBQUdBLFlBQVksOEJBQ2lCQSxZQUZOLEVBTWhDO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVIiwic291cmNlc0NvbnRlbnQiOltudWxsLCIvL1xuLy8gc3RyZnRpbWVcbi8vIGdpdGh1Yi5jb20vc2Ftc29uanMvc3RyZnRpbWVcbi8vIEBfc2pzXG4vL1xuLy8gQ29weXJpZ2h0IDIwMTAgLSAyMDE1IFNhbWkgU2FtaHVyaSA8c2FtaUBzYW1odXJpLm5ldD5cbi8vXG4vLyBNSVQgTGljZW5zZVxuLy8gaHR0cDovL3Nqcy5taXQtbGljZW5zZS5vcmdcbi8vXG5cbjsoZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgRGVmYXVsdExvY2FsZSA9IHtcbiAgICAgICAgICAgIGRheXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcbiAgICAgICAgICAgIHNob3J0RGF5czogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgICAgICAgICAgIG1vbnRoczogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG4gICAgICAgICAgICBzaG9ydE1vbnRoczogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICAgICAgICAgICAgQU06ICdBTScsXG4gICAgICAgICAgICBQTTogJ1BNJyxcbiAgICAgICAgICAgIGFtOiAnYW0nLFxuICAgICAgICAgICAgcG06ICdwbScsXG4gICAgICAgICAgICBmb3JtYXRzOiB7XG4gICAgICAgICAgICAgICAgRDogJyVtLyVkLyV5JyxcbiAgICAgICAgICAgICAgICBGOiAnJVktJW0tJWQnLFxuICAgICAgICAgICAgICAgIFI6ICclSDolTScsXG4gICAgICAgICAgICAgICAgVDogJyVIOiVNOiVTJyxcbiAgICAgICAgICAgICAgICBYOiAnJVQnLFxuICAgICAgICAgICAgICAgIGM6ICclYSAlYiAlZCAlWCAlWScsXG4gICAgICAgICAgICAgICAgcjogJyVJOiVNOiVTICVwJyxcbiAgICAgICAgICAgICAgICB2OiAnJWUtJWItJVknLFxuICAgICAgICAgICAgICAgIHg6ICclRCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFN0cmZ0aW1lID0gbmV3IFN0cmZ0aW1lKERlZmF1bHRMb2NhbGUsIDAsIGZhbHNlKSxcbiAgICAgICAgaXNDb21tb25KUyA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnLFxuICAgICAgICBuYW1lc3BhY2U7XG5cbiAgICAvLyBDb21tb25KUyAvIE5vZGUgbW9kdWxlXG4gICAgaWYgKGlzQ29tbW9uSlMpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gbW9kdWxlLmV4cG9ydHMgPSBhZGFwdGVkU3RyZnRpbWU7XG4gICAgICAgIG5hbWVzcGFjZS5zdHJmdGltZSA9IGRlcHJlY2F0ZWRTdHJmdGltZTtcbiAgICAgICAgaWYoam9vX2dsb2JhbF9vYmplY3QpIGpvb19nbG9iYWxfb2JqZWN0LnN0cmZ0aW1lID0gYWRhcHRlZFN0cmZ0aW1lO1xuICAgIH1cbiAgICAvLyBCcm93c2VycyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEdldCB0aGUgZ2xvYmFsIG9iamVjdC4gV29ya3MgaW4gRVMzLCBFUzUsIGFuZCBFUzUgc3RyaWN0IG1vZGUuXG4gICAgICAgIG5hbWVzcGFjZSA9IGpvb19nbG9iYWxfb2JqZWN0IHx8IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfHwgKDEsZXZhbCkoJ3RoaXMnKTsgfSgpKTtcbiAgICAgICAgbmFtZXNwYWNlLnN0cmZ0aW1lID0gYWRhcHRlZFN0cmZ0aW1lO1xuICAgIH1cblxuICAgIC8vIERlcHJlY2F0ZWQgQVBJLCB0byBiZSByZW1vdmVkIGluIHYxLjBcbiAgICB2YXIgX3JlcXVpcmUgPSBpc0NvbW1vbkpTID8gXCJyZXF1aXJlKCdzdHJmdGltZScpXCIgOiBcInN0cmZ0aW1lXCI7XG4gICAgdmFyIF9kZXByZWNhdGlvbldhcm5pbmdzID0ge307XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRpb25XYXJuaW5nKG5hbWUsIGluc3RlYWQpIHtcbiAgICAgICAgaWYgKCFfZGVwcmVjYXRpb25XYXJuaW5nc1tuYW1lXSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS53YXJuID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR10gXCIgKyBuYW1lICsgXCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMS4wLiBJbnN0ZWFkLCB1c2UgYFwiICsgaW5zdGVhZCArIFwiYC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZGVwcmVjYXRpb25XYXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lc3BhY2Uuc3RyZnRpbWVUWiA9IGRlcHJlY2F0ZWRTdHJmdGltZVRaO1xuICAgIG5hbWVzcGFjZS5zdHJmdGltZVVUQyA9IGRlcHJlY2F0ZWRTdHJmdGltZVVUQztcbiAgICBuYW1lc3BhY2UubG9jYWxpemVkU3RyZnRpbWUgPSBkZXByZWNhdGVkU3RyZnRpbWVMb2NhbGl6ZWQ7XG5cbiAgICAvLyBBZGFwdCB0aGUgb2xkIEFQSSB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBuZXcgQVBJLlxuICAgIGZ1bmN0aW9uIGFkYXB0Rm9yd2FyZHMoZm4pIHtcbiAgICAgICAgZm4ubG9jYWxpemUgPSBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUuYmluZChkZWZhdWx0U3RyZnRpbWUpO1xuICAgICAgICBmbi50aW1lem9uZSA9IGRlZmF1bHRTdHJmdGltZS50aW1lem9uZS5iaW5kKGRlZmF1bHRTdHJmdGltZSk7XG4gICAgICAgIGZuLnV0YyA9IGRlZmF1bHRTdHJmdGltZS51dGMuYmluZChkZWZhdWx0U3RyZnRpbWUpO1xuICAgIH1cblxuICAgIGFkYXB0Rm9yd2FyZHMoYWRhcHRlZFN0cmZ0aW1lKTtcbiAgICBmdW5jdGlvbiBhZGFwdGVkU3RyZnRpbWUoZm10LCBkLCBsb2NhbGUpIHtcbiAgICAgICAgLy8gZCBhbmQgbG9jYWxlIGFyZSBvcHRpb25hbCwgY2hlY2sgaWYgdGhpcyBpcyAoZm9ybWF0LCBsb2NhbGUpXG4gICAgICAgIGlmIChkICYmIGQuZGF5cykge1xuICAgICAgICAgICAgbG9jYWxlID0gZDtcbiAgICAgICAgICAgIGQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIihmb3JtYXQsIFtkYXRlXSwgW2xvY2FsZV0pYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJmdGltZSA9IGxvY2FsZSA/IGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpIDogZGVmYXVsdFN0cmZ0aW1lO1xuICAgICAgICByZXR1cm4gc3RyZnRpbWUoZm10LCBkKTtcbiAgICB9XG5cbiAgICBhZGFwdEZvcndhcmRzKGRlcHJlY2F0ZWRTdHJmdGltZSk7XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lKGZtdCwgZCwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWUoZm9ybWF0LCBbZGF0ZV0sIFtsb2NhbGVdKWBcIiwgXCJ2YXIgcyA9IFwiICsgX3JlcXVpcmUgKyBcIi5sb2NhbGl6ZShsb2NhbGUpOyBzKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWUoZm9ybWF0LCBbZGF0ZV0pYFwiLCBfcmVxdWlyZSArIFwiKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZnRpbWUgPSBsb2NhbGUgPyBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUobG9jYWxlKSA6IGRlZmF1bHRTdHJmdGltZTtcbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lKGZtdCwgZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lVFooZm10LCBkLCBsb2NhbGUsIHRpbWV6b25lKSB7XG4gICAgICAgIC8vIGxvY2FsZSBpcyBvcHRpb25hbCwgY2hlY2sgaWYgdGhpcyBpcyAoZm9ybWF0LCBkYXRlLCB0aW1lem9uZSlcbiAgICAgICAgaWYgKCh0eXBlb2YgbG9jYWxlID09ICdudW1iZXInIHx8IHR5cGVvZiBsb2NhbGUgPT0gJ3N0cmluZycpICYmIHRpbWV6b25lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWV6b25lID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVRaKGZvcm1hdCwgZGF0ZSwgbG9jYWxlLCB0eilgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKS50aW1lem9uZSh0eik7IHMoZm9ybWF0LCBbZGF0ZV0pYCBvciBgdmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKTsgcy50aW1lem9uZSh0eikoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVRaKGZvcm1hdCwgZGF0ZSwgdHopYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLnRpbWV6b25lKHR6KTsgcyhmb3JtYXQsIFtkYXRlXSlgIG9yIGBcIiArIF9yZXF1aXJlICsgXCIudGltZXpvbmUodHopKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJmdGltZSA9IChsb2NhbGUgPyBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUobG9jYWxlKSA6IGRlZmF1bHRTdHJmdGltZSkudGltZXpvbmUodGltZXpvbmUpO1xuICAgICAgICByZXR1cm4gc3RyZnRpbWUoZm10LCBkKTtcbiAgICB9XG5cbiAgICB2YXIgdXRjU3RyZnRpbWUgPSBkZWZhdWx0U3RyZnRpbWUudXRjKCk7XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lVVRDKGZtdCwgZCwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWVVVEMoZm9ybWF0LCBkYXRlLCBsb2NhbGUpYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSkudXRjKCk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVVUQyhmb3JtYXQsIFtkYXRlXSlgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIudXRjKCk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJmdGltZSA9IGxvY2FsZSA/IHV0Y1N0cmZ0aW1lLmxvY2FsaXplKGxvY2FsZSkgOiB1dGNTdHJmdGltZTtcbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lKGZtdCwgZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lTG9jYWxpemVkKGxvY2FsZSkge1xuICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoXCJgXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplZFN0cmZ0aW1lKGxvY2FsZSlgXCIsIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKVwiKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpO1xuICAgIH1cbiAgICAvLyBFbmQgb2YgZGVwcmVjYXRlZCBBUElcblxuICAgIC8vIFBvbHlmaWxsIERhdGUubm93IGZvciBvbGQgYnJvd3NlcnMuXG4gICAgaWYgKHR5cGVvZiBEYXRlLm5vdyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiArbmV3IERhdGUoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTdHJmdGltZShsb2NhbGUsIGN1c3RvbVRpbWV6b25lT2Zmc2V0LCB1c2VVdGNUaW1lem9uZSkge1xuICAgICAgICB2YXIgX2xvY2FsZSA9IGxvY2FsZSB8fCBEZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgX2N1c3RvbVRpbWV6b25lT2Zmc2V0ID0gY3VzdG9tVGltZXpvbmVPZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIF91c2VVdGNCYXNlZERhdGUgPSB1c2VVdGNUaW1lem9uZSB8fCBmYWxzZSxcblxuICAgICAgICAgICAgLy8gd2Ugc3RvcmUgdW5peCB0aW1lc3RhbXAgdmFsdWUgaGVyZSB0byBub3QgY3JlYXRlIG5ldyBEYXRlKCkgZWFjaCBpdGVyYXRpb24gKGVhY2ggbWlsbGlzZWNvbmQpXG4gICAgICAgICAgICAvLyBEYXRlLm5vdygpIGlzIDIgdGltZXMgZmFzdGVyIHRoYW4gbmV3IERhdGUoKVxuICAgICAgICAgICAgLy8gd2hpbGUgbWlsbGlzZWNvbmQgcHJlY2lzZSBpcyBlbm91Z2ggaGVyZVxuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSB2ZXJ5IGhlbHBmdWwgd2hlbiBzdHJmdGltZSB0cmlnZ2VyZWQgYSBsb3Qgb2YgdGltZXMgb25lIGJ5IG9uZVxuICAgICAgICAgICAgX2NhY2hlZERhdGVUaW1lc3RhbXAgPSAwLFxuICAgICAgICAgICAgX2NhY2hlZERhdGU7XG5cbiAgICAgICAgZnVuY3Rpb24gX3N0cmZ0aW1lKGZvcm1hdCwgZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcDtcblxuICAgICAgICAgICAgaWYgKCFkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZXN0YW1wID4gX2NhY2hlZERhdGVUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhY2hlZERhdGVUaW1lc3RhbXAgPSBjdXJyZW50VGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgICBfY2FjaGVkRGF0ZSA9IG5ldyBEYXRlKF9jYWNoZWREYXRlVGltZXN0YW1wKTtcblxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBfY2FjaGVkRGF0ZVRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX3VzZVV0Y0Jhc2VkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG93IHRvIGF2b2lkIGR1cGxpY2F0aW9uIG9mIGRhdGUgaW5zdGFudGlhdGlvbiBmb3IgdXRjIGhlcmU/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0aWVkIHRvIGdldFRpbWV6b25lT2Zmc2V0IG9mIHRoZSBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jYWNoZWREYXRlID0gbmV3IERhdGUoX2NhY2hlZERhdGVUaW1lc3RhbXAgKyBnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvcihfY2FjaGVkRGF0ZSkgKyBfY3VzdG9tVGltZXpvbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGUgPSBfY2FjaGVkRGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF91c2VVdGNCYXNlZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgZ2V0VGltZXN0YW1wVG9VdGNPZmZzZXRGb3IoZGF0ZSkgKyBfY3VzdG9tVGltZXpvbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzRm9ybWF0KGZvcm1hdCwgZGF0ZSwgX2xvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9wcm9jZXNzRm9ybWF0KGZvcm1hdCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRTdHJpbmcgPSAnJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpc0luU2NvcGUgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBmb3JtYXQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGV4dGVuZGVkVFogPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyQ29kZSA9IGZvcm1hdC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5TY29wZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAnLSdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICdfJ1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gJzAnXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAnOidcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudENoYXJDb2RlID09PSA1OCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZFRaKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR10gZGV0ZWN0ZWQgdXNlIG9mIHVuc3VwcG9ydGVkICU6OiBvciAlOjo6IG1vZGlmaWVycyB0byBzdHJmdGltZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRUWiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDaGFyQ29kZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGFtcGxlcyBmb3IgbmV3IERhdGUoMCkgaW4gR01UXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdUaHVyc2RheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2NTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gbG9jYWxlLmRheXNbZGF0ZS5nZXREYXkoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdKYW51YXJ5J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnQic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUubW9udGhzW2RhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2NzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyAxMDApLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAxLzAxLzcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5ELCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOTcwLTAxLTAxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnRic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDcwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5GLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3MjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoZGF0ZS5nZXRIb3VycygpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnSSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDczOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihob3VyczEyKGRhdGUuZ2V0SG91cnMoKSksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMyhNYXRoLmZsb29yKHRpbWVzdGFtcCAlIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldE1pbnV0ZXMoKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdhbSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4MDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF0ZS5nZXRIb3VycygpIDwgMTIgPyBsb2NhbGUuYW0gOiBsb2NhbGUucG07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMDowMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4MjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuUiwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0U2Vjb25kcygpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwOjAwOjAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5ULCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4NTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIod2Vla051bWJlcihkYXRlLCAnc3VuZGF5JyksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdXJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKHdlZWtOdW1iZXIoZGF0ZSwgJ21vbmRheScpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzE2OjAwOjAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnWCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5YLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOTcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnWSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdHTVQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF91c2VVdGNCYXNlZERhdGUgJiYgX2N1c3RvbVRpbWV6b25lT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBcIkdNVFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4bWUgb3B0aW1pemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR6U3RyaW5nID0gZGF0ZS50b1N0cmluZygpLm1hdGNoKC9cXCgoW1xcd1xcc10rKVxcKS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gdHpTdHJpbmcgJiYgdHpTdHJpbmdbMV0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnVGh1J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUuc2hvcnREYXlzW2RhdGUuZ2V0RGF5KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnSmFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUuc2hvcnRNb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuYywgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldERhdGUoKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcgMSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0RGF0ZSgpLCBwYWRkaW5nID09IG51bGwgPyAnICcgOiBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ0phbidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGxvY2FsZS5zaG9ydE1vbnRoc1tkYXRlLmdldE1vbnRoKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnaic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRheSA9IE1hdGguY2VpbCgoZGF0ZS5nZXRUaW1lKCkgLSB5LmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMyhkYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnIDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldEhvdXJzKCksIHBhZGRpbmcgPT0gbnVsbCA/ICcgJyA6IHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTInXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihob3VyczEyKGRhdGUuZ2V0SG91cnMoKSksIHBhZGRpbmcgPT0gbnVsbCA/ICcgJyA6IHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldE1vbnRoKCkgKyAxLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ1xcbidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nKGRhdGUuZ2V0RGF0ZSgpKSArIG9yZGluYWwoZGF0ZS5nZXREYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnQU0nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXRlLmdldEhvdXJzKCkgPCAxMiA/IGxvY2FsZS5BTSA6IGxvY2FsZS5QTTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyOjAwOjAwIEFNJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuciwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IE1hdGguZmxvb3IodGltZXN0YW1wIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdcXHQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXkgPT09IDAgPyA3IDogZGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxIC0gNywgTW9uZGF5IGlzIGZpcnN0IGRheSBvZiB0aGUgd2Vla1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnIDEtSmFuLTE5NzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy52LCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICc0J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gMCAtIDYsIFN1bmRheSBpcyBmaXJzdCBkYXkgb2YgdGhlIHdlZWtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyLzMxLzY5J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMueCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnNzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSAoJycgKyBkYXRlLmdldEZ1bGxZZWFyKCkpLnNsaWNlKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnKzAwMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdXNlVXRjQmFzZWREYXRlICYmIF9jdXN0b21UaW1lem9uZU9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZXh0ZW5kZWRUWiA/IFwiKzAwOjAwXCIgOiBcIiswMDAwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2N1c3RvbVRpbWV6b25lT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmYgPSBfY3VzdG9tVGltZXpvbmVPZmZzZXQgLyAoNjAgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZiA9IC1kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBvZmYgPCAwID8gJy0nIDogJysnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VwID0gZXh0ZW5kZWRUWiA/ICc6JyA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKE1hdGguYWJzKG9mZiAvIDYwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5zID0gTWF0aC5hYnMob2ZmICUgNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gc2lnbiArIHBhZFRpbGwyKGhvdXJzKSArIHNlcCArIHBhZFRpbGwyKG1pbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlzSW5TY29wZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAnJSdcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSAzNykge1xuICAgICAgICAgICAgICAgICAgICBpc0luU2NvcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0U3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmZ0aW1lID0gX3N0cmZ0aW1lO1xuXG4gICAgICAgIHN0cmZ0aW1lLmxvY2FsaXplID0gZnVuY3Rpb24obG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmZ0aW1lKGxvY2FsZSB8fCBfbG9jYWxlLCBfY3VzdG9tVGltZXpvbmVPZmZzZXQsIF91c2VVdGNCYXNlZERhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0cmZ0aW1lLnRpbWV6b25lID0gZnVuY3Rpb24odGltZXpvbmUpIHtcbiAgICAgICAgICAgIHZhciBjdXN0b21UaW1lem9uZU9mZnNldCA9IF9jdXN0b21UaW1lem9uZU9mZnNldDtcbiAgICAgICAgICAgIHZhciB1c2VVdGNCYXNlZERhdGUgPSBfdXNlVXRjQmFzZWREYXRlO1xuXG4gICAgICAgICAgICB2YXIgdGltZXpvbmVUeXBlID0gdHlwZW9mIHRpbWV6b25lO1xuICAgICAgICAgICAgaWYgKHRpbWV6b25lVHlwZSA9PT0gJ251bWJlcicgfHwgdGltZXpvbmVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHVzZVV0Y0Jhc2VkRGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBJU08gODYwMSBmb3JtYXQgdGltZXpvbmUgc3RyaW5nLCBbLStdSEhNTVxuICAgICAgICAgICAgICAgIGlmICh0aW1lem9uZVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gdGltZXpvbmVbMF0gPT09ICctJyA/IC0xIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXJzID0gcGFyc2VJbnQodGltZXpvbmUuc2xpY2UoMSwgMyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBwYXJzZUludCh0aW1lem9uZS5zbGljZSgzLCA1KSwgMTApO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVRpbWV6b25lT2Zmc2V0ID0gc2lnbiAqICgoNjAgKiBob3VycykgKyBtaW51dGVzKSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gbWludXRlczogNDIwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWV6b25lVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tVGltZXpvbmVPZmZzZXQgPSB0aW1lem9uZSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyZnRpbWUoX2xvY2FsZSwgY3VzdG9tVGltZXpvbmVPZmZzZXQsIHVzZVV0Y0Jhc2VkRGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3RyZnRpbWUudXRjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmZ0aW1lKF9sb2NhbGUsIF9jdXN0b21UaW1lem9uZU9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhZFRpbGwyKG51bWJlclRvUGFkLCBwYWRkaW5nQ2hhcikge1xuICAgICAgICBpZiAocGFkZGluZ0NoYXIgPT09ICcnIHx8IG51bWJlclRvUGFkID4gOSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclRvUGFkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkaW5nQ2hhciA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYWRkaW5nQ2hhciA9ICcwJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZ0NoYXIgKyBudW1iZXJUb1BhZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWRUaWxsMyhudW1iZXJUb1BhZCkge1xuICAgICAgICBpZiAobnVtYmVyVG9QYWQgPiA5OSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclRvUGFkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1iZXJUb1BhZCA+IDkpIHtcbiAgICAgICAgICAgIHJldHVybiAnMCcgKyBudW1iZXJUb1BhZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzAwJyArIG51bWJlclRvUGFkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhvdXJzMTIoaG91cikge1xuICAgICAgICBpZiAoaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDEyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvdXIgPiAxMikge1xuICAgICAgICAgICAgcmV0dXJuIGhvdXIgLSAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG5cbiAgICAvLyBmaXJzdFdlZWtkYXk6ICdzdW5kYXknIG9yICdtb25kYXknLCBkZWZhdWx0IGlzICdzdW5kYXknXG4gICAgLy9cbiAgICAvLyBQaWxmZXJlZCAmIHBvcnRlZCBmcm9tIFJ1YnkncyBzdHJmdGltZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmdW5jdGlvbiB3ZWVrTnVtYmVyKGRhdGUsIGZpcnN0V2Vla2RheSkge1xuICAgICAgICBmaXJzdFdlZWtkYXkgPSBmaXJzdFdlZWtkYXkgfHwgJ3N1bmRheSc7XG5cbiAgICAgICAgLy8gVGhpcyB3b3JrcyBieSBzaGlmdGluZyB0aGUgd2Vla2RheSBiYWNrIGJ5IG9uZSBkYXkgaWYgd2VcbiAgICAgICAgLy8gYXJlIHRyZWF0aW5nIE1vbmRheSBhcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICB2YXIgd2Vla2RheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChmaXJzdFdlZWtkYXkgPT09ICdtb25kYXknKSB7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA9PT0gMCkgLy8gU3VuZGF5XG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IDY7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgd2Vla2RheS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0RGF5T2ZZZWFyVXRjID0gRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKSxcbiAgICAgICAgICAgIGRhdGVVdGMgPSBEYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpLFxuICAgICAgICAgICAgeWRheSA9IE1hdGguZmxvb3IoKGRhdGVVdGMgLSBmaXJzdERheU9mWWVhclV0YykgLyA4NjQwMDAwMCksXG4gICAgICAgICAgICB3ZWVrTnVtID0gKHlkYXkgKyA3IC0gd2Vla2RheSkgLyA3O1xuXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHdlZWtOdW0pO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgb3JkaW5hbCBzdWZmaXggZm9yIGEgbnVtYmVyOiBzdCwgbmQsIHJkLCBvciB0aFxuICAgIGZ1bmN0aW9uIG9yZGluYWwobnVtYmVyKSB7XG4gICAgICAgIHZhciBpID0gbnVtYmVyICUgMTA7XG4gICAgICAgIHZhciBpaSA9IG51bWJlciAlIDEwMDtcblxuICAgICAgICBpZiAoKGlpID49IDExICYmIGlpIDw9IDEzKSB8fCBpID09PSAwIHx8IGkgPj0gNCkge1xuICAgICAgICAgICAgcmV0dXJuICd0aCc7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiAnc3QnO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gJ25kJztcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuICdyZCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvcihkYXRlKSB7XG4gICAgICAgIHJldHVybiAoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIHx8IDApICogNjAwMDA7XG4gICAgfVxuXG59KCkpO1xuIiwiLy8gUHJvdmlkZXM6IHBsb25rX3dhc21cbnZhciBwbG9ua193YXNtID0gam9vX2dsb2JhbF9vYmplY3QucGxvbmtfd2FzbTtcbiIsIi8qIGdsb2JhbCBqb29fZ2xvYmFsX29iamVjdCwgcGxvbmtfd2FzbSwgY2FtbF9qc190b19ib29sLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyxcbiAgICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuICAgIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9tbF9ieXRlc19sZW5ndGgsXG4gICAgVUludDY0LCBjYW1sX2ludDY0X29mX2ludDMyXG4qL1xuXG4vLyBQcm92aWRlczogY2FtbF9ieXRlc19vZl91aW50OGFycmF5XG4vLyBSZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxudmFyIGNhbWxfYnl0ZXNfb2ZfdWludDhhcnJheSA9IGZ1bmN0aW9uICh1aW50OGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IHVpbnQ4YXJyYXkubGVuZ3RoO1xuICAgIHZhciBvY2FtbF9ieXRlcyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNvbnZlcnQgaGVyZTogT0NhbWwgQ2hhci50IGlzIGp1c3QgYW4gaW50IHVuZGVyIHRoZSBob29kLlxuICAgICAgICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQob2NhbWxfYnl0ZXMsIGksIHVpbnQ4YXJyYXlbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gb2NhbWxfYnl0ZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9ieXRlc190b191aW50OGFycmF5XG4vLyBSZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxudmFyIGNhbWxfYnl0ZXNfdG9fdWludDhhcnJheSA9IGZ1bmN0aW9uIChvY2FtbF9ieXRlcykge1xuICAgIHZhciBsZW5ndGggPSBjYW1sX21sX2J5dGVzX2xlbmd0aChvY2FtbF9ieXRlcyk7XG4gICAgdmFyIGJ5dGVzID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY29udmVydCBoZXJlOiBPQ2FtbCBDaGFyLnQgaXMganVzdCBhbiBpbnQgdW5kZXIgdGhlIGhvb2QuXG4gICAgICAgIGJ5dGVzW2ldID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0KG9jYW1sX2J5dGVzLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfYmlnaW50XzI1Nl9vZl9udW1lcmFsXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbnZhciBjYW1sX2JpZ2ludF8yNTZfb2ZfbnVtZXJhbCA9IGZ1bmN0aW9uIChzLCBsZW4sIGJhc2UpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX2JpZ2ludF8yNTZfb2ZfbnVtZXJhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSwgbGVuLCBiYXNlKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfb2ZfZGVjaW1hbF9zdHJpbmdcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfYmlnaW50XzI1Nl9vZl9kZWNpbWFsX3N0cmluZyA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9iaWdpbnRfMjU2X29mX2RlY2ltYWxfc3RyaW5nKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfbnVtX2xpbWJzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfYmlnaW50XzI1Nl9udW1fbGltYnMgPSBwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl9udW1fbGltYnNcblxuLy8gUHJvdmlkZXM6IGNhbWxfYmlnaW50XzI1Nl9ieXRlc19wZXJfbGltYlxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX2JpZ2ludF8yNTZfYnl0ZXNfcGVyX2xpbWIgPSBwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl9ieXRlc19wZXJfbGltYlxuXG4vLyBQcm92aWRlczogY2FtbF9iaWdpbnRfMjU2X2RpdlxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX2JpZ2ludF8yNTZfZGl2ID0gcGxvbmtfd2FzbS5jYW1sX2JpZ2ludF8yNTZfZGl2XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfY29tcGFyZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX2JpZ2ludF8yNTZfY29tcGFyZSA9IHBsb25rX3dhc20uY2FtbF9iaWdpbnRfMjU2X2NvbXBhcmVcblxuLy8gUHJvdmlkZXM6IGNhbWxfYmlnaW50XzI1Nl9wcmludFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX2JpZ2ludF8yNTZfcHJpbnQgPSBwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl9wcmludFxuXG4vLyBQcm92aWRlczogY2FtbF9iaWdpbnRfMjU2X3RvX3N0cmluZ1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9iaWdpbnRfMjU2X3RvX3N0cmluZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHBsb25rX3dhc20uY2FtbF9iaWdpbnRfMjU2X3RvX3N0cmluZyh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9iaWdpbnRfMjU2X3Rlc3RfYml0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc190b19ib29sXG52YXIgY2FtbF9iaWdpbnRfMjU2X3Rlc3RfYml0ID0gZnVuY3Rpb24gKHgsIGkpIHtcbiAgICByZXR1cm4gY2FtbF9qc190b19ib29sKHBsb25rX3dhc20uY2FtbF9iaWdpbnRfMjU2X3Rlc3RfYml0KHgsIGkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfdG9fYnl0ZXNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXlcbnZhciBjYW1sX2JpZ2ludF8yNTZfdG9fYnl0ZXMgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXkocGxvbmtfd2FzbS5jYW1sX2JpZ2ludF8yNTZfdG9fYnl0ZXMoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfYmlnaW50XzI1Nl9vZl9ieXRlc1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYnl0ZXNfdG9fdWludDhhcnJheVxudmFyIGNhbWxfYmlnaW50XzI1Nl9vZl9ieXRlcyA9IGZ1bmN0aW9uIChvY2FtbF9ieXRlcykge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl9vZl9ieXRlcyhjYW1sX2J5dGVzX3RvX3VpbnQ4YXJyYXkob2NhbWxfYnl0ZXMpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfYmlnaW50XzI1Nl9kZWVwX2NvcHkgPSBwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl9kZWVwX2NvcHlcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9jb3B5XG52YXIgY2FtbF9wYXN0YV9mcF9jb3B5ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHgubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHhbaV0gPSB5W2ldO1xuICAgIH1cbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX29wdGlvbl9vZl9tYXliZV91bmRlZmluZWRcbnZhciBjYW1sX29wdGlvbl9vZl9tYXliZV91bmRlZmluZWQgPSBmdW5jdGlvbiAoeCkge1xuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDA7IC8vIE5vbmVcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzAsIHhdOyAvLyBTb21lKHgpXG4gICAgfVxufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfb3B0aW9uX3RvX21heWJlX3VuZGVmaW5lZFxudmFyIGNhbWxfb3B0aW9uX3RvX21heWJlX3VuZGVmaW5lZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHggPT09IDApIHsgLy8gTm9uZVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB4WzFdO1xuICAgIH1cbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3NpemVfaW5fYml0c1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3NpemVfaW5fYml0cyA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9zaXplX2luX2JpdHNcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfc2l6ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3NpemUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfc2l6ZVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9hZGRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9hZGQgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfYWRkXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3N1YlxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3N1YiA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9zdWJcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfbmVnYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfbmVnYXRlID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX25lZ2F0ZVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9tdWxcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9tdWwgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfbXVsXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX2RpdlxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX2RpdiA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9kaXZcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfaW52XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkXG52YXIgY2FtbF9wYXN0YV9mcF9pbnYgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBjYW1sX29wdGlvbl9vZl9tYXliZV91bmRlZmluZWQocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX2ludih4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9zcXVhcmVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9zcXVhcmUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfc3F1YXJlXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX2lzX3NxdWFyZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNfdG9fYm9vbFxudmFyIGNhbWxfcGFzdGFfZnBfaXNfc3F1YXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gY2FtbF9qc190b19ib29sKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9pc19zcXVhcmUoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfc3FydFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZFxudmFyIGNhbWxfcGFzdGFfZnBfc3FydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfc3FydCh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9vZl9pbnRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9vZl9pbnQgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfb2ZfaW50XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3RvX3N0cmluZ1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9wYXN0YV9mcF90b19zdHJpbmcgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfdG9fc3RyaW5nKHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX29mX3N0cmluZ1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG52YXIgY2FtbF9wYXN0YV9mcF9vZl9zdHJpbmcgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfb2Zfc3RyaW5nKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3ByaW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfcHJpbnQgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcHJpbnRcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfbXV0X2FkZFxuLy8gUmVxdWlyZXM6IGNhbWxfcGFzdGFfZnBfY29weSwgY2FtbF9wYXN0YV9mcF9hZGRcbnZhciBjYW1sX3Bhc3RhX2ZwX211dF9hZGQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGNhbWxfcGFzdGFfZnBfY29weSh4LCBjYW1sX3Bhc3RhX2ZwX2FkZCh4LCB5KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9tdXRfc3ViXG4vLyBSZXF1aXJlczogY2FtbF9wYXN0YV9mcF9jb3B5LCBjYW1sX3Bhc3RhX2ZwX3N1YlxudmFyIGNhbWxfcGFzdGFfZnBfbXV0X3N1YiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgY2FtbF9wYXN0YV9mcF9jb3B5KHgsIGNhbWxfcGFzdGFfZnBfc3ViKHgsIHkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX211dF9tdWxcbi8vIFJlcXVpcmVzOiBjYW1sX3Bhc3RhX2ZwX2NvcHksIGNhbWxfcGFzdGFfZnBfbXVsXG52YXIgY2FtbF9wYXN0YV9mcF9tdXRfbXVsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBjYW1sX3Bhc3RhX2ZwX2NvcHkoeCwgY2FtbF9wYXN0YV9mcF9tdWwoeCwgeSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfbXV0X3NxdWFyZVxuLy8gUmVxdWlyZXM6IGNhbWxfcGFzdGFfZnBfY29weSwgY2FtbF9wYXN0YV9mcF9zcXVhcmVcbnZhciBjYW1sX3Bhc3RhX2ZwX211dF9zcXVhcmUgPSBmdW5jdGlvbiAoeCkge1xuICAgIGNhbWxfcGFzdGFfZnBfY29weSh4LCBjYW1sX3Bhc3RhX2ZwX3NxdWFyZSh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9jb21wYXJlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfY29tcGFyZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9jb21wYXJlXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX2VxdWFsXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfZXF1YWwgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfZXF1YWxcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcmFuZG9tXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfcmFuZG9tID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3JhbmRvbVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9ybmdcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9ybmcgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcm5nXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3RvX2JpZ2ludFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3RvX2JpZ2ludCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF90b19iaWdpbnRcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfb2ZfYmlnaW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfb2ZfYmlnaW50ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX29mX2JpZ2ludFxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF90d29fYWRpY19yb290X29mX3VuaXR5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfdHdvX2FkaWNfcm9vdF9vZl91bml0eSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF90d29fYWRpY19yb290X29mX3VuaXR5XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX2RvbWFpbl9nZW5lcmF0b3Jcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9kb21haW5fZ2VuZXJhdG9yID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX2RvbWFpbl9nZW5lcmF0b3JcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfdG9fYnl0ZXNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXlcbnZhciBjYW1sX3Bhc3RhX2ZwX3RvX2J5dGVzID0gZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3RvX2J5dGVzKHgpO1xuICAgIHJldHVybiBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXkocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3RvX2J5dGVzKHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX29mX2J5dGVzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9ieXRlc190b191aW50OGFycmF5XG52YXIgY2FtbF9wYXN0YV9mcF9vZl9ieXRlcyA9IGZ1bmN0aW9uIChvY2FtbF9ieXRlcykge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfb2ZfYnl0ZXMoY2FtbF9ieXRlc190b191aW50OGFycmF5KG9jYW1sX2J5dGVzKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9kZWVwX2NvcHlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9kZWVwX2NvcHkgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfZGVlcF9jb3B5XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfY29weVxudmFyIGNhbWxfcGFzdGFfZnFfY29weSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB4W2ldID0geVtpXTtcbiAgICB9XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9zaXplX2luX2JpdHNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9zaXplX2luX2JpdHMgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfc2l6ZV9pbl9iaXRzXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3NpemVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9zaXplID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3NpemVcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfYWRkXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfYWRkID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX2FkZFxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9zdWJcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9zdWIgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfc3ViXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX25lZ2F0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX25lZ2F0ZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9uZWdhdGVcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfbXVsXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfbXVsID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX211bFxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9kaXZcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9kaXYgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfZGl2XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX2ludlxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZFxudmFyIGNhbWxfcGFzdGFfZnFfaW52ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9pbnYoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfc3F1YXJlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfc3F1YXJlID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3NxdWFyZVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9pc19zcXVhcmVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzX3RvX2Jvb2xcbnZhciBjYW1sX3Bhc3RhX2ZxX2lzX3NxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGNhbWxfanNfdG9fYm9vbChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfaXNfc3F1YXJlKHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3NxcnRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX29wdGlvbl9vZl9tYXliZV91bmRlZmluZWRcbnZhciBjYW1sX3Bhc3RhX2ZxX3NxcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBjYW1sX29wdGlvbl9vZl9tYXliZV91bmRlZmluZWQocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3NxcnQoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfb2ZfaW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfb2ZfaW50ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX29mX2ludFxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV90b19zdHJpbmdcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIGNhbWxfcGFzdGFfZnFfdG9fc3RyaW5nID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3RvX3N0cmluZyh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9vZl9zdHJpbmdcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfcGFzdGFfZnFfb2Zfc3RyaW5nID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX29mX3N0cmluZyhjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wcmludFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3ByaW50ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3ByaW50XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX211dF9hZGRcbi8vIFJlcXVpcmVzOiBjYW1sX3Bhc3RhX2ZxX2NvcHksIGNhbWxfcGFzdGFfZnFfYWRkXG52YXIgY2FtbF9wYXN0YV9mcV9tdXRfYWRkID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBjYW1sX3Bhc3RhX2ZxX2NvcHkoeCwgY2FtbF9wYXN0YV9mcV9hZGQoeCwgeSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfbXV0X3N1YlxuLy8gUmVxdWlyZXM6IGNhbWxfcGFzdGFfZnFfY29weSwgY2FtbF9wYXN0YV9mcV9zdWJcbnZhciBjYW1sX3Bhc3RhX2ZxX211dF9zdWIgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGNhbWxfcGFzdGFfZnFfY29weSh4LCBjYW1sX3Bhc3RhX2ZxX3N1Yih4LCB5KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9tdXRfbXVsXG4vLyBSZXF1aXJlczogY2FtbF9wYXN0YV9mcV9jb3B5LCBjYW1sX3Bhc3RhX2ZxX211bFxudmFyIGNhbWxfcGFzdGFfZnFfbXV0X211bCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgY2FtbF9wYXN0YV9mcV9jb3B5KHgsIGNhbWxfcGFzdGFfZnFfbXVsKHgsIHkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX211dF9zcXVhcmVcbi8vIFJlcXVpcmVzOiBjYW1sX3Bhc3RhX2ZxX2NvcHksIGNhbWxfcGFzdGFfZnFfc3F1YXJlXG52YXIgY2FtbF9wYXN0YV9mcV9tdXRfc3F1YXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgICBjYW1sX3Bhc3RhX2ZxX2NvcHkoeCwgY2FtbF9wYXN0YV9mcV9zcXVhcmUoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfY29tcGFyZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX2NvbXBhcmUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfY29tcGFyZVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9lcXVhbFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX2VxdWFsID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX2VxdWFsXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3JhbmRvbVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3JhbmRvbSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9yYW5kb21cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcm5nXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfcm5nID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3JuZ1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV90b19iaWdpbnRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV90b19iaWdpbnQgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfdG9fYmlnaW50XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX29mX2JpZ2ludFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX29mX2JpZ2ludCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9vZl9iaWdpbnRcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfdHdvX2FkaWNfcm9vdF9vZl91bml0eVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3R3b19hZGljX3Jvb3Rfb2ZfdW5pdHkgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfdHdvX2FkaWNfcm9vdF9vZl91bml0eVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9kb21haW5fZ2VuZXJhdG9yXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfZG9tYWluX2dlbmVyYXRvciA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9kb21haW5fZ2VuZXJhdG9yXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3RvX2J5dGVzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9ieXRlc19vZl91aW50OGFycmF5XG52YXIgY2FtbF9wYXN0YV9mcV90b19ieXRlcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV90b19ieXRlcyh4KTtcbiAgICByZXR1cm4gY2FtbF9ieXRlc19vZl91aW50OGFycmF5KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV90b19ieXRlcyh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9vZl9ieXRlc1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYnl0ZXNfdG9fdWludDhhcnJheVxudmFyIGNhbWxfcGFzdGFfZnFfb2ZfYnl0ZXMgPSBmdW5jdGlvbiAob2NhbWxfYnl0ZXMpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX29mX2J5dGVzKGNhbWxfYnl0ZXNfdG9fdWludDhhcnJheShvY2FtbF9ieXRlcykpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfZGVlcF9jb3B5ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX2RlZXBfY29weVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3IgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciBpID0gMTsgLy8gVGhlIGZpcnN0IGVudHJ5IGlzIHRoZSBPQ2FtbCB0YWcgZm9yIGFycmF5c1xuICAgIHZhciBsZW4gPSB2Lmxlbmd0aCAtIGk7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIHZhciBpbm5lcl9sZW4gPSB2W2ldLmxlbmd0aDtcbiAgICB2YXIgcmVzID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkobGVuICogaW5uZXJfbGVuKTtcbiAgICBmb3IgKHZhciBwb3MgPSAwOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5uZXJfbGVuOyBqKyssIHBvcysrKSB7XG4gICAgICAgICAgICByZXNbcG9zXSA9IHZbaV1bal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3IgPSBmdW5jdGlvbiAodiwgaW5uZXJfbGVuKSB7XG4gICAgdmFyIGxlbiA9IHYubGVuZ3RoO1xuICAgIHZhciBvdXRwdXRfbGVuID0gbGVuIC8gaW5uZXJfbGVuO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkob3V0cHV0X2xlbiArIDEpXG4gICAgcmVzWzBdID0gMCAvLyBPQ2FtbCB0YWcgYmVmb3JlIGFycmF5IGNvbnRlbnRzLCBzbyB0aGF0IHdlIGNhbiB1c2UgdGhpcyB3aXRoIGFycmF5cyBvciB2ZWN0b3JzXG4gICAgZm9yICh2YXIgaSA9IDEsIHBvcyA9IDA7IGkgPD0gb3V0cHV0X2xlbjsgaSsrKSB7XG4gICAgICAgIHZhciBpbm5lcl9yZXMgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShpbm5lcl9sZW4pO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlubmVyX2xlbjsgaisrLCBwb3MrKykge1xuICAgICAgICAgICAgaW5uZXJfcmVzW2pdID0gdltwb3NdO1xuICAgICAgICB9XG4gICAgICAgIHJlc1tpXSA9IGlubmVyX3JlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvclxudmFyIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGxlbiA9IHYubGVuZ3RoO1xuICAgIHZhciByZXMgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDMyQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIEJld2FyZTogY2FsbGVyIG1heSBuZWVkIHRvIGRvIGZpbmFsaXplciB0aGluZ3MgdG8gYXZvaWQgdGhlc2VcbiAgICAgICAgLy8gcG9pbnRlcnMgZGlzYXBwZWFyaW5nIG91dCBmcm9tIHVuZGVyIHVzLlxuICAgICAgICByZXNbaV0gPSB2W2ldLnB0cjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3JcbnZhciBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IgPSBmdW5jdGlvbiAodiwga2xhc3MpIHtcbiAgICAvLyByZXR1cm4gdi5tYXAoa2xhc3MuX193cmFwKVxuICAgIHZhciBsZW4gPSB2Lmxlbmd0aDtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDAsIHBvcyA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBCZXdhcmU6IHRoZSBjYWxsZXIgbWF5IG5lZWQgdG8gYWRkIGZpbmFsaXplcnMgdG8gdGhlc2UuXG4gICAgICAgIHJlc1tpXSA9IGtsYXNzLl9fd3JhcCh2W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfdmVjdG9yX2NyZWF0ZVxudmFyIGNhbWxfZnBfdmVjdG9yX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gWzBdOyAvLyBPQ2FtbCB0YWcgZm9yIGFycmF5cywgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZSBzYW1lIHV0aWxpdHkgZm5zIG9uIGJvdGhcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3ZlY3Rvcl9sZW5ndGhcbnZhciBjYW1sX2ZwX3ZlY3Rvcl9sZW5ndGggPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2Lmxlbmd0aCAtIDE7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcF92ZWN0b3JfZW1wbGFjZV9iYWNrXG52YXIgY2FtbF9mcF92ZWN0b3JfZW1wbGFjZV9iYWNrID0gZnVuY3Rpb24gKHYsIHgpIHtcbiAgICB2LnB1c2goeCk7XG59XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3ZlY3Rvcl9nZXRcbnZhciBjYW1sX2ZwX3ZlY3Rvcl9nZXQgPSBmdW5jdGlvbiAodiwgaSkge1xuICAgIHZhciB2YWx1ZSA9IHZbaSArIDFdO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBFcnJvcignY2FtbF9mcF92ZWN0b3JfZ2V0OiBJbmRleCBvdXQgb2YgYm91bmRzLCBnb3QgJyArIGkgKyAnLycgKyAodi5sZW5ndGggLSAxKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSh2YWx1ZSk7XG59XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0XG4vLyBSZXF1aXJlczogY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yXG52YXIgY2FtbF9mcF92ZWN0b3JfdG9fcnVzdCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3Rvcih2KTtcbn1cblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfdmVjdG9yX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX2ZwX3ZlY3Rvcl9vZl9ydXN0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAvLyBUT0RPOiBIYXJkY29kaW5nIHRoaXMgaXMgYSBsaXR0bGUgYnJpdHRsZVxuICAgIHJldHVybiBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3IodiwgMzIpO1xufVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3ZlY3Rvcl9jcmVhdGVcbnZhciBjYW1sX2ZxX3ZlY3Rvcl9jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFswXTsgLy8gT0NhbWwgdGFnIGZvciBhcnJheXMsIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGUgc2FtZSB1dGlsaXR5IGZucyBvbiBib3RoXG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcV92ZWN0b3JfbGVuZ3RoXG52YXIgY2FtbF9mcV92ZWN0b3JfbGVuZ3RoID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdi5sZW5ndGggLSAxO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfdmVjdG9yX2VtcGxhY2VfYmFja1xudmFyIGNhbWxfZnFfdmVjdG9yX2VtcGxhY2VfYmFjayA9IGZ1bmN0aW9uICh2LCB4KSB7XG4gICAgdi5wdXNoKHgpO1xufVxuXG4vLyBQcm92aWRlczogY2FtbF9mcV92ZWN0b3JfZ2V0XG52YXIgY2FtbF9mcV92ZWN0b3JfZ2V0ID0gZnVuY3Rpb24gKHYsIGkpIHtcbiAgICB2YXIgdmFsdWUgPSB2W2kgKyAxXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NhbWxfZnFfdmVjdG9yX2dldDogSW5kZXggb3V0IG9mIGJvdW5kcywgZ290ICcgKyBpICsgJy8nICsgKHYubGVuZ3RoIC0gMSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkodmFsdWUpO1xufVxuXG4vLyBQcm92aWRlczogY2FtbF9mcV92ZWN0b3JfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvclxudmFyIGNhbWxfZnFfdmVjdG9yX3RvX3J1c3QgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3Iodik7XG59XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3ZlY3Rvcl9vZl9ydXN0XG4vLyBSZXF1aXJlczogY2FtbF91OGFycmF5X3ZlY3Rvcl9vZl9ydXN0X2ZsYXRfdmVjdG9yXG52YXIgY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgLy8gVE9ETzogSGFyZGNvZGluZyB0aGlzIGlzIGEgbGl0dGxlIGJyaXR0bGVcbiAgICByZXR1cm4gY2FtbF91OGFycmF5X3ZlY3Rvcl9vZl9ydXN0X2ZsYXRfdmVjdG9yKHYsIDMyKTtcbn1cblxuXG5cblxuXG4vLyBQcm92aWRlczogZnJlZV9maW5hbGl6YXRpb25fcmVnaXN0cnlcbnZhciBmcmVlX2ZpbmFsaXphdGlvbl9yZWdpc3RyeSA9XG4gICAgbmV3IGpvb19nbG9iYWxfb2JqZWN0LkZpbmFsaXphdGlvblJlZ2lzdHJ5KGZ1bmN0aW9uIChpbnN0YW5jZV9yZXByZXNlbnRhdGl2ZSkge1xuICAgICAgICBpbnN0YW5jZV9yZXByZXNlbnRhdGl2ZS5mcmVlKCk7XG4gICAgfSk7XG5cbi8vIFByb3ZpZGVzOiBmcmVlX29uX2ZpbmFsaXplXG4vLyBSZXF1aXJlczogZnJlZV9maW5hbGl6YXRpb25fcmVnaXN0cnlcbnZhciBmcmVlX29uX2ZpbmFsaXplID0gZnVuY3Rpb24gKHgpIHtcbiAgICAvLyBUaGlzIGlzIGFuIHVuZm9ydHVuYXRlIGhhY2s6IHdlJ3JlIGNyZWF0aW5nIGEgc2Vjb25kIGluc3RhbmNlIG9mIHRoZVxuICAgIC8vIGNsYXNzIHRvIGJlIGFibGUgdG8gY2FsbCBmcmVlIG9uIGl0LiBXZSBjYW4ndCBwYXNzIHRoZSB2YWx1ZSBpdHNlbGYsXG4gICAgLy8gc2luY2UgdGhlIHJlZ2lzdHJ5IGhvbGRzIGEgc3Ryb25nIHJlZmVyZW5jZSB0byB0aGUgcmVwcmVzZW50YXRpdmUgdmFsdWUuXG4gICAgLy9cbiAgICAvLyBIb3dldmVyLCB0aGUgY2xhc3MgaXMgb25seSByZWFsbHkgYSB3cmFwcGVyIGFyb3VuZCBhIHBvaW50ZXIsIHdpdGggYVxuICAgIC8vIHJlZmVyZW5jZSB0byB0aGUgY2xhc3MnIHByb3RvdHlwZSBhcyBpdHMgX19wcm90b3R5cGVfXy5cbiAgICAvL1xuICAgIC8vIEl0IG1pZ2h0IHNlZW0gY2xlYW5lciB0byBjYWxsIHRoZSBkZXN0cnVjdG9yIGhlcmUgb24gdGhlIHBvaW50ZXJcbiAgICAvLyBkaXJlY3RseSwgYnV0IHVuZm9ydHVuYXRlbHkgdGhlIGRlc3RydWN0b3IgbmFtZSBpcyBzb21lIG1hbmdsZWQgaW50ZXJuYWxcbiAgICAvLyBzdHJpbmcgZ2VuZXJhdGVkIGJ5IHdhc21fYmluZGdlbi4gRm9yIG5vdywgdGhpcyBpcyB0aGUgYmVzdCxcbiAgICAvLyBsZWFzdC1icml0dGxlIHdheSB0byBmcmVlIG9uY2UgdGhlIG9yaWdpbmFsIGNsYXNzIGluc3RhbmNlIGdldHMgY29sbGVjdGVkLlxuICAgIHZhciBpbnN0YW5jZV9yZXByZXNlbnRhdGl2ZSA9IHguY29uc3RydWN0b3IuX193cmFwKHgucHRyKVxuICAgIGZyZWVfZmluYWxpemF0aW9uX3JlZ2lzdHJ5LnJlZ2lzdGVyKHgsIGluc3RhbmNlX3JlcHJlc2VudGF0aXZlLCB4KTtcbiAgICByZXR1cm4geDtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lXG52YXIgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUgPSBmdW5jdGlvbiAocHQpIHtcbiAgICB2YXIgaW5maW5pdHkgPSBwdC5pbmZpbml0eTtcbiAgICBpZiAoaW5maW5pdHkpIHtcbiAgICAgICAgcHQuZnJlZSgpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeCA9IHB0Lng7XG4gICAgICAgIHZhciB5ID0gcHQueTtcbiAgICAgICAgcHQuZnJlZSgpO1xuICAgICAgICByZXR1cm4gWzAsIFswLCB4LCB5XV07XG4gICAgfVxufTtcblxuLy8gUHJvdmlkZXM6IHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lXG52YXIgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUgPSBmdW5jdGlvbiAocHQsIGtsYXNzKSB7XG4gICAgdmFyIHJlcyA9IG5ldyBrbGFzcygpO1xuICAgIGlmIChwdCA9PT0gMCkge1xuICAgICAgICByZXMuaW5maW5pdHkgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExheW91dCBpcyBbMCwgWzAsIHgsIHldXVxuICAgICAgICAvLyBGaXJzdCAwIGlzIHRoZSB0YWcgKGl0J3MgdGhlIDB0aCBjb25zdHJ1Y3RvciB0aGF0IHRha2VzIGFyZ3VtZW50cylcbiAgICAgICAgLy8gU2Vjb25kIDAgaXMgdGhlIGJsb2NrIG1hcmtlciBmb3IgdGhlIGFub255bW91cyB0dXBsZSBhcmd1bWVudHNcbiAgICAgICAgcmVzLnggPSBwdFsxXVsxXTtcbiAgICAgICAgcmVzLnkgPSBwdFsxXVsyXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX29uZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3BhbGxhc19vbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYWxsYXNfb25lKCk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfYWRkXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFsbGFzX2FkZCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWRkKHgsIHkpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX3N1YlxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3BhbGxhc19zdWIgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX3N1Yih4LCB5KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19uZWdhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9wYWxsYXNfbmVnYXRlID0gZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19uZWdhdGUoeCk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfZG91YmxlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFsbGFzX2RvdWJsZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYWxsYXNfZG91YmxlKHgpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX3NjYWxlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFsbGFzX3NjYWxlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19zY2FsZSh4LCB5KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19yYW5kb21cbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9wYWxsYXNfcmFuZG9tID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX3JhbmRvbSgpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX3JuZ1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3BhbGxhc19ybmcgPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX3JuZyhpKTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc190b19hZmZpbmVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZVxudmFyIGNhbWxfcGFsbGFzX3RvX2FmZmluZSA9IGZ1bmN0aW9uIChwdCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX3RvX2FmZmluZShwdCk7XG4gICAgcmV0dXJuIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lKHJlcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfb2ZfYWZmaW5lXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3BhbGxhc19vZl9hZmZpbmUgPSBmdW5jdGlvbiAocHQpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19vZl9hZmZpbmUocnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUocHQsIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSkpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX29mX2FmZmluZV9jb29yZGluYXRlc1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3BhbGxhc19vZl9hZmZpbmVfY29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX29mX2FmZmluZV9jb29yZGluYXRlcyh4LCB5KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19lbmRvX2Jhc2Vcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYWxsYXNfZW5kb19iYXNlID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19lbmRvX2Jhc2U7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19lbmRvX3NjYWxhclxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3BhbGxhc19lbmRvX3NjYWxhciA9IHBsb25rX3dhc20uY2FtbF9wYWxsYXNfZW5kb19zY2FsYXI7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19hZmZpbmVfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lXG52YXIgY2FtbF9wYWxsYXNfYWZmaW5lX2RlZXBfY29weSA9IGZ1bmN0aW9uIChwdCkge1xuICAgIHJldHVybiBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZShwbG9ua193YXNtLmNhbWxfcGFsbGFzX2FmZmluZV9kZWVwX2NvcHkocnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUocHQsIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSkpKTtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfdmVzdGFfb25lXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfdmVzdGFfb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfdmVzdGFfb25lKCk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9hZGRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF92ZXN0YV9hZGQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfdmVzdGFfYWRkKHgsIHkpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfdmVzdGFfc3ViXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfdmVzdGFfc3ViID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX3N1Yih4LCB5KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX25lZ2F0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Zlc3RhX25lZ2F0ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9uZWdhdGUoeCk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9kb3VibGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF92ZXN0YV9kb3VibGUgPSBmdW5jdGlvbiAoeCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfdmVzdGFfZG91YmxlKHgpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfdmVzdGFfc2NhbGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF92ZXN0YV9zY2FsZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9zY2FsZSh4LCB5KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX3JhbmRvbVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Zlc3RhX3JhbmRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX3JhbmRvbSgpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfdmVzdGFfcm5nXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfdmVzdGFfcm5nID0gZnVuY3Rpb24gKGkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX3JuZyhpKTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX3RvX2FmZmluZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lXG52YXIgY2FtbF92ZXN0YV90b19hZmZpbmUgPSBmdW5jdGlvbiAocHQpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX3RvX2FmZmluZShwdCk7XG4gICAgcmV0dXJuIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lKHJlcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9vZl9hZmZpbmVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfdmVzdGFfb2ZfYWZmaW5lID0gZnVuY3Rpb24gKHB0KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9vZl9hZmZpbmUocnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUocHQsIHBsb25rX3dhc20uY2FtbF92ZXN0YV9hZmZpbmVfb25lKSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9vZl9hZmZpbmVfY29vcmRpbmF0ZXNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF92ZXN0YV9vZl9hZmZpbmVfY29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfdmVzdGFfb2ZfYWZmaW5lX2Nvb3JkaW5hdGVzKHgsIHkpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfdmVzdGFfZW5kb19iYXNlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfdmVzdGFfZW5kb19iYXNlID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2VuZG9fYmFzZTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfdmVzdGFfZW5kb19zY2FsYXJcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF92ZXN0YV9lbmRvX3NjYWxhciA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9lbmRvX3NjYWxhcjtcblxuLy8gUHJvdmlkZXM6IGNhbWxfdmVzdGFfYWZmaW5lX2RlZXBfY29weVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZVxudmFyIGNhbWxfdmVzdGFfYWZmaW5lX2RlZXBfY29weSA9IGZ1bmN0aW9uIChwdCkge1xuICAgIHJldHVybiBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZShwbG9ua193YXNtLmNhbWxfdmVzdGFfYWZmaW5lX2RlZXBfY29weShydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZShwdCwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUpKSk7XG59O1xuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9hcnJheV9vZl9ydXN0X3ZlY3RvclxuLy8gUmVxdWlyZXM6IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvclxudmFyIGNhbWxfYXJyYXlfb2ZfcnVzdF92ZWN0b3IgPSBmdW5jdGlvbiAodiwga2xhc3MsIGNvbnZlcnQsIHNob3VsZF9mcmVlKSB7XG4gICAgdiA9IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3Rvcih2LCBrbGFzcyk7XG4gICAgdmFyIGxlbiA9IHYubGVuZ3RoO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgcmVzWzBdID0gMDsgLy8gT0NhbWwgdGFnIGJlZm9yZSBhcnJheSBjb250ZW50c1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHJ1c3RfdmFsID0gdltpXTtcbiAgICAgICAgcmVzW2kgKyAxXSA9IGNvbnZlcnQocnVzdF92YWwpO1xuICAgICAgICBpZiAoc2hvdWxkX2ZyZWUpIHsgcnVzdF92YWwuZnJlZSgpOyB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvclxuLy8gUmVxdWlyZXM6IGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvciwgZnJlZV9maW5hbGl6YXRpb25fcmVnaXN0cnlcbnZhciBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yID0gZnVuY3Rpb24gKHYsIGNvbnZlcnQsIG1rX25ldykge1xuICAgIHYgPSB2LnNsaWNlKDEpOyAvLyBDb3B5LCBkcm9wcGluZyBPQ2FtbCB0YWdcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHYubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjbGFzc192YWwgPSBjb252ZXJ0KHZbaV0sIG1rX25ldyk7XG4gICAgICAgIHZbaV0gPSBjbGFzc192YWw7XG4gICAgICAgIC8vIERvbid0IGZyZWUgd2hlbiBHQyBydW5zOyBydXN0IHdpbGwgZnJlZSBvbiBpdHMgZW5kLlxuICAgICAgICBmcmVlX2ZpbmFsaXphdGlvbl9yZWdpc3RyeS51bnJlZ2lzdGVyKGNsYXNzX3ZhbCk7XG4gICAgfVxuICAgIHJldHVybiBqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3Iodik7XG59XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcG9seV9jb21tX29mX3J1c3RfcG9seV9jb21tXG4vLyBSZXF1aXJlczogcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUsIGNhbWxfYXJyYXlfb2ZfcnVzdF92ZWN0b3JcbnZhciBjYW1sX3BvbHlfY29tbV9vZl9ydXN0X3BvbHlfY29tbSA9IGZ1bmN0aW9uIChwb2x5X2NvbW0sIGtsYXNzLCBzaG91bGRfZnJlZSkge1xuICAgIHZhciBydXN0X3NoaWZ0ZWQgPSBwb2x5X2NvbW0uc2hpZnRlZDtcbiAgICB2YXIgcnVzdF91bnNoaWZ0ZWQgPSBwb2x5X2NvbW0udW5zaGlmdGVkO1xuICAgIHZhciBjYW1sX3NoaWZ0ZWQ7XG4gICAgaWYgKHJ1c3Rfc2hpZnRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbWxfc2hpZnRlZCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2FtbF9zaGlmdGVkID0gWzAsIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lKHJ1c3Rfc2hpZnRlZCldO1xuICAgIH1cbiAgICB2YXIgY2FtbF91bnNoaWZ0ZWQgPSBjYW1sX2FycmF5X29mX3J1c3RfdmVjdG9yKHJ1c3RfdW5zaGlmdGVkLCBrbGFzcywgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUsIHNob3VsZF9mcmVlKTtcbiAgICByZXR1cm4gWzAsIGNhbWxfdW5zaGlmdGVkLCBjYW1sX3NoaWZ0ZWRdO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcG9seV9jb21tX3RvX3J1c3RfcG9seV9jb21tXG4vLyBSZXF1aXJlczogcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3JcbnZhciBjYW1sX3BvbHlfY29tbV90b19ydXN0X3BvbHlfY29tbSA9IGZ1bmN0aW9uIChwb2x5X2NvbW0sIHBvbHlfY29tbV9jbGFzcywgbWtfYWZmaW5lKSB7XG4gICAgdmFyIGNhbWxfdW5zaGlmdGVkID0gcG9seV9jb21tWzFdO1xuICAgIHZhciBjYW1sX3NoaWZ0ZWQgPSBwb2x5X2NvbW1bMl07XG4gICAgdmFyIHJ1c3Rfc2hpZnRlZCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2FtbF9zaGlmdGVkICE9PSAwKSB7XG4gICAgICAgIHJ1c3Rfc2hpZnRlZCA9IHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lKGNhbWxfc2hpZnRlZFsxXSwgbWtfYWZmaW5lKTtcbiAgICB9XG4gICAgdmFyIHJ1c3RfdW5zaGlmdGVkID0gY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvcihjYW1sX3Vuc2hpZnRlZCwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIG1rX2FmZmluZSk7XG4gICAgcmV0dXJuIG5ldyBwb2x5X2NvbW1fY2xhc3MocnVzdF91bnNoaWZ0ZWQsIHJ1c3Rfc2hpZnRlZCk7XG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wb2x5X2NvbW1fb2ZfcnVzdF9wb2x5X2NvbW1cbnZhciBjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gY2FtbF9wb2x5X2NvbW1fb2ZfcnVzdF9wb2x5X2NvbW0oeCwgcGxvbmtfd2FzbS5XYXNtR1Zlc3RhLCBmYWxzZSk7XG59XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX3BvbHlfY29tbV90b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wb2x5X2NvbW1fdG9fcnVzdF9wb2x5X2NvbW1cbnZhciBjYW1sX3Zlc3RhX3BvbHlfY29tbV90b19ydXN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gY2FtbF9wb2x5X2NvbW1fdG9fcnVzdF9wb2x5X2NvbW0oeCwgcGxvbmtfd2FzbS5XYXNtRnBQb2x5Q29tbSwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUpO1xufVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcG9seV9jb21tX29mX3J1c3RfcG9seV9jb21tXG52YXIgY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBjYW1sX3BvbHlfY29tbV9vZl9ydXN0X3BvbHlfY29tbSh4LCBwbG9ua193YXNtLldhc21HUGFsbGFzLCBmYWxzZSk7XG59XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19wb2x5X2NvbW1fdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcG9seV9jb21tX3RvX3J1c3RfcG9seV9jb21tXG52YXIgY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBjYW1sX3BvbHlfY29tbV90b19ydXN0X3BvbHlfY29tbSh4LCBwbG9ua193YXNtLldhc21GcVBvbHlDb21tLCBwbG9ua193YXNtLmNhbWxfcGFsbGFzX2FmZmluZV9vbmUpO1xufVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3Nyc19jcmVhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9mcF9zcnNfY3JlYXRlID0gZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gZnJlZV9vbl9maW5hbGl6ZShwbG9ua193YXNtLmNhbWxfZnBfc3JzX2NyZWF0ZShpKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcF9zcnNfd3JpdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfZnBfc3JzX3dyaXRlID0gZnVuY3Rpb24gKGFwcGVuZCwgdCwgcGF0aCkge1xuICAgIGlmIChhcHBlbmQgPT09IDApIHtcbiAgICAgICAgYXBwZW5kID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCA9IGFwcGVuZFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9mcF9zcnNfd3JpdGUoYXBwZW5kLCB0LCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcF9zcnNfcmVhZFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG52YXIgY2FtbF9mcF9zcnNfcmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIHBhdGgpIHtcbiAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXRbMV07XG4gICAgfVxuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfZnBfc3JzX3JlYWQob2Zmc2V0LCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSk7XG4gICAgaWYgKHJlcykge1xuICAgICAgICByZXR1cm4gWzAsIHJlc107IC8vIFNvbWUocmVzKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwOyAvLyBOb25lXG4gICAgfVxufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfc3JzX2xhZ3JhbmdlX2NvbW1pdG1lbnRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0XG52YXIgY2FtbF9mcF9zcnNfbGFncmFuZ2VfY29tbWl0bWVudCA9IGZ1bmN0aW9uICh0LCBkb21haW5fc2l6ZSwgaSkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfZnBfc3JzX2xhZ3JhbmdlX2NvbW1pdG1lbnQodCwgZG9tYWluX3NpemUsIGkpO1xuICAgIHJldHVybiBjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0KHJlcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcF9zcnNfY29tbWl0X2V2YWx1YXRpb25zXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdCwgY2FtbF9mcF92ZWN0b3JfdG9fcnVzdFxudmFyIGNhbWxfZnBfc3JzX2NvbW1pdF9ldmFsdWF0aW9ucyA9IGZ1bmN0aW9uICh0LCBkb21haW5fc2l6ZSwgZnBzKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9mcF9zcnNfY29tbWl0X2V2YWx1YXRpb25zKHQsIGRvbWFpbl9zaXplLCBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0KGZwcykpO1xuICAgIHJldHVybiBjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0KHJlcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcF9zcnNfYl9wb2x5X2NvbW1pdG1lbnRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0LCBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX2ZwX3Nyc19iX3BvbHlfY29tbWl0bWVudCA9IGZ1bmN0aW9uIChzcnMsIGNoYWxzKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9mcF9zcnNfYl9wb2x5X2NvbW1pdG1lbnQoc3JzLCBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3IoY2hhbHMpKTtcbiAgICByZXR1cm4gY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdChyZXMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfc3JzX2JhdGNoX2FjY3VtdWxhdG9yX2NoZWNrXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IsIGNhbWxfZnBfdmVjdG9yX3RvX3J1c3RcbnZhciBjYW1sX2ZwX3Nyc19iYXRjaF9hY2N1bXVsYXRvcl9jaGVjayA9IGZ1bmN0aW9uIChzcnMsIGNvbW1zLCBjaGFscykge1xuICAgIHZhciBydXN0X2NvbW1zID0gY2FtbF9hcnJheV90b19ydXN0X3ZlY3Rvcihjb21tcywgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIHBsb25rX3dhc20uY2FtbF92ZXN0YV9hZmZpbmVfb25lKTtcbiAgICB2YXIgcnVzdF9jaGFscyA9IGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QoY2hhbHMpO1xuICAgIHZhciBvayA9IHBsb25rX3dhc20uY2FtbF9mcF9zcnNfYmF0Y2hfYWNjdW11bGF0b3JfY2hlY2soc3JzLCBydXN0X2NvbW1zLCBydXN0X2NoYWxzKTtcbiAgICByZXR1cm4gb2s7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcF9zcnNfYmF0Y2hfYWNjdW11bGF0b3JfZ2VuZXJhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSwgY2FtbF9hcnJheV9vZl9ydXN0X3ZlY3RvciwgY2FtbF9mcF92ZWN0b3JfdG9fcnVzdFxudmFyIGNhbWxfZnBfc3JzX2JhdGNoX2FjY3VtdWxhdG9yX2dlbmVyYXRlID0gZnVuY3Rpb24gKHNycywgY29tbXMsIGNoYWxzKSB7XG4gICAgdmFyIHJ1c3RfY2hhbHMgPSBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0KGNoYWxzKTtcbiAgICB2YXIgcnVzdF9jb21tcyA9IHBsb25rX3dhc20uY2FtbF9mcF9zcnNfYmF0Y2hfYWNjdW11bGF0b3JfZ2VuZXJhdGUoc3JzLCBjb21tcywgcnVzdF9jaGFscyk7XG4gICAgcmV0dXJuIGNhbWxfYXJyYXlfb2ZfcnVzdF92ZWN0b3IocnVzdF9jb21tcywgcGxvbmtfd2FzbS5XYXNtR1Zlc3RhLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSwgZmFsc2UpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfc3JzX2hcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZVxudmFyIGNhbWxfZnBfc3JzX2ggPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZShwbG9ua193YXNtLmNhbWxfZnBfc3JzX2godCkpO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9mcV9zcnNfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfZnFfc3JzX2NyZWF0ZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGZyZWVfb25fZmluYWxpemUocGxvbmtfd2FzbS5jYW1sX2ZxX3Nyc19jcmVhdGUoaSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfc3JzX3dyaXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbnZhciBjYW1sX2ZxX3Nyc193cml0ZSA9IGZ1bmN0aW9uIChhcHBlbmQsIHQsIHBhdGgpIHtcbiAgICBpZiAoYXBwZW5kID09PSAwKSB7XG4gICAgICAgIGFwcGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmQgPSBhcHBlbmRbMV07XG4gICAgfVxuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfZnFfc3JzX3dyaXRlKGFwcGVuZCwgdCwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfc3JzX3JlYWRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfZnFfc3JzX3JlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCBwYXRoKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICBvZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0WzFdO1xuICAgIH1cbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX2ZxX3Nyc19yZWFkKG9mZnNldCwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgICAgcmV0dXJuIFswLCByZXNdOyAvLyBTb21lKHJlcylcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDsgLy8gTm9uZVxuICAgIH1cbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3Nyc19sYWdyYW5nZV9jb21taXRtZW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3RcbnZhciBjYW1sX2ZxX3Nyc19sYWdyYW5nZV9jb21taXRtZW50ID0gZnVuY3Rpb24gKHQsIGRvbWFpbl9zaXplLCBpKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9mcV9zcnNfbGFncmFuZ2VfY29tbWl0bWVudCh0LCBkb21haW5fc2l6ZSwgaSk7XG4gICAgcmV0dXJuIGNhbWxfcGFsbGFzX3BvbHlfY29tbV9vZl9ydXN0KHJlcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcV9zcnNfY29tbWl0X2V2YWx1YXRpb25zXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QsIGNhbWxfZnFfdmVjdG9yX3RvX3J1c3RcbnZhciBjYW1sX2ZxX3Nyc19jb21taXRfZXZhbHVhdGlvbnMgPSBmdW5jdGlvbiAodCwgZG9tYWluX3NpemUsIGZxcykge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfZnFfc3JzX2NvbW1pdF9ldmFsdWF0aW9ucyh0LCBkb21haW5fc2l6ZSwgY2FtbF9mcV92ZWN0b3JfdG9fcnVzdChmcXMpKTtcbiAgICByZXR1cm4gY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QocmVzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3Nyc19iX3BvbHlfY29tbWl0bWVudFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFsbGFzX3BvbHlfY29tbV9vZl9ydXN0LCBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX2ZxX3Nyc19iX3BvbHlfY29tbWl0bWVudCA9IGZ1bmN0aW9uIChzcnMsIGNoYWxzKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9mcV9zcnNfYl9wb2x5X2NvbW1pdG1lbnQoc3JzLCBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3IoY2hhbHMpKTtcbiAgICByZXR1cm4gY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QocmVzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3Nyc19iYXRjaF9hY2N1bXVsYXRvcl9jaGVja1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yLCBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0XG52YXIgY2FtbF9mcV9zcnNfYmF0Y2hfYWNjdW11bGF0b3JfY2hlY2sgPSBmdW5jdGlvbiAoc3JzLCBjb21tcywgY2hhbHMpIHtcbiAgICB2YXIgcnVzdF9jb21tcyA9IGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IoY29tbXMsIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBwbG9ua193YXNtLmNhbWxfcGFsbGFzX2FmZmluZV9vbmUpO1xuICAgIHZhciBydXN0X2NoYWxzID0gY2FtbF9mcV92ZWN0b3JfdG9fcnVzdChjaGFscyk7XG4gICAgdmFyIG9rID0gcGxvbmtfd2FzbS5jYW1sX2ZxX3Nyc19iYXRjaF9hY2N1bXVsYXRvcl9jaGVjayhzcnMsIHJ1c3RfY29tbXMsIHJ1c3RfY2hhbHMpO1xuICAgIHJldHVybiBvaztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3Nyc19iYXRjaF9hY2N1bXVsYXRvcl9nZW5lcmF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lLCBjYW1sX2FycmF5X29mX3J1c3RfdmVjdG9yLCBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0XG52YXIgY2FtbF9mcV9zcnNfYmF0Y2hfYWNjdW11bGF0b3JfZ2VuZXJhdGUgPSBmdW5jdGlvbiAoc3JzLCBjb21tcywgY2hhbHMpIHtcbiAgICB2YXIgcnVzdF9jaGFscyA9IGNhbWxfZnFfdmVjdG9yX3RvX3J1c3QoY2hhbHMpO1xuICAgIHZhciBydXN0X2NvbW1zID0gcGxvbmtfd2FzbS5jYW1sX2ZxX3Nyc19iYXRjaF9hY2N1bXVsYXRvcl9nZW5lcmF0ZShzcnMsIGNvbW1zLCBydXN0X2NoYWxzKTtcbiAgICByZXR1cm4gY2FtbF9hcnJheV9vZl9ydXN0X3ZlY3RvcihydXN0X2NvbW1zLCBwbG9ua193YXNtLldhc21HUGFsbGFzLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSwgZmFsc2UpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfc3JzX2hcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZVxudmFyIGNhbWxfZnFfc3JzX2ggPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZShwbG9ua193YXNtLmNhbWxfZnFfc3JzX2godCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfc3JzX2FkZF9sYWdyYW5nZV9iYXNpc1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbmZ1bmN0aW9uIGNhbWxfZnFfc3JzX2FkZF9sYWdyYW5nZV9iYXNpcyhzcnMsIGxvZzJfc2l6ZSkge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfZnFfc3JzX2FkZF9sYWdyYW5nZV9iYXNpcyhzcnMsIGxvZzJfc2l6ZSk7XG59XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGxvbmtfd2lyZV9vZl9ydXN0XG52YXIgY2FtbF9wbG9ua193aXJlX29mX3J1c3QgPSBmdW5jdGlvbiAod2lyZSkge1xuICAgIHZhciByZXMgPSBbMCwgd2lyZS5yb3csIHdpcmUuY29sXTtcbiAgICB3aXJlLmZyZWUoKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGxvbmtfd2lyZV90b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGxvbmtfd2lyZV90b19ydXN0ID0gZnVuY3Rpb24gKHdpcmUpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5XaXJlLmNyZWF0ZSh3aXJlWzFdLCB3aXJlWzJdKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX3dpcmVzX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3Bsb25rX3dpcmVfb2ZfcnVzdFxudmFyIGNhbWxfcGxvbmtfd2lyZXNfb2ZfcnVzdCA9IGZ1bmN0aW9uICh3aXJlcykge1xuICAgIHZhciByZXMgPSBbMCxcbiAgICAgICAgY2FtbF9wbG9ua193aXJlX29mX3J1c3Qod2lyZXNbMF0pLFxuICAgICAgICBjYW1sX3Bsb25rX3dpcmVfb2ZfcnVzdCh3aXJlc1sxXSksXG4gICAgICAgIGNhbWxfcGxvbmtfd2lyZV9vZl9ydXN0KHdpcmVzWzJdKSxcbiAgICAgICAgY2FtbF9wbG9ua193aXJlX29mX3J1c3Qod2lyZXNbM10pLFxuICAgICAgICBjYW1sX3Bsb25rX3dpcmVfb2ZfcnVzdCh3aXJlc1s0XSksXG4gICAgICAgIGNhbWxfcGxvbmtfd2lyZV9vZl9ydXN0KHdpcmVzWzVdKSxcbiAgICAgICAgY2FtbF9wbG9ua193aXJlX29mX3J1c3Qod2lyZXNbNl0pXTtcbiAgICB3aXJlcy5mcmVlKCk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX3dpcmVzX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdFxudmFyIGNhbWxfcGxvbmtfd2lyZXNfdG9fcnVzdCA9IGZ1bmN0aW9uICh3aXJlcykge1xuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtR2F0ZVdpcmVzKFxuICAgICAgICBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh3aXJlc1sxXSksXG4gICAgICAgIGNhbWxfcGxvbmtfd2lyZV90b19ydXN0KHdpcmVzWzJdKSxcbiAgICAgICAgY2FtbF9wbG9ua193aXJlX3RvX3J1c3Qod2lyZXNbM10pLFxuICAgICAgICBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh3aXJlc1s0XSksXG4gICAgICAgIGNhbWxfcGxvbmtfd2lyZV90b19ydXN0KHdpcmVzWzVdKSxcbiAgICAgICAgY2FtbF9wbG9ua193aXJlX3RvX3J1c3Qod2lyZXNbNl0pLFxuICAgICAgICBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh3aXJlc1s3XSlcbiAgICApO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGxvbmtfZ2F0ZV9vZl9ydXN0XG4vLyBSZXF1aXJlczogY2FtbF9wbG9ua193aXJlc19vZl9ydXN0LCBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX3Bsb25rX2dhdGVfb2ZfcnVzdCA9IGZ1bmN0aW9uIChnYXRlKSB7XG4gICAgLy8gVE9ETzogSGFyZGNvZGluZyAzMiBoZXJlIGlzIGEgbGl0dGxlIGJyaXR0bGVcbiAgICB2YXIgcmVzID0gWzAsIGdhdGUudHlwLCBjYW1sX3Bsb25rX3dpcmVzX29mX3J1c3QoZ2F0ZS53aXJlcyksIGNhbWxfdThhcnJheV92ZWN0b3Jfb2ZfcnVzdF9mbGF0X3ZlY3RvcihnYXRlLmMsIDMyKV07XG4gICAgZ2F0ZS5mcmVlKCk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3Bsb25rX2dhdGVfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfd2lyZXNfdG9fcnVzdCwgY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yXG52YXIgY2FtbF9mcF9wbG9ua19nYXRlX3RvX3J1c3QgPSBmdW5jdGlvbiAoZ2F0ZSkge1xuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtRnBHYXRlKFxuICAgICAgICBnYXRlWzFdLFxuICAgICAgICBjYW1sX3Bsb25rX3dpcmVzX3RvX3J1c3QoZ2F0ZVsyXSksXG4gICAgICAgIGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvcihnYXRlWzNdKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcV9wbG9ua19nYXRlX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX3dpcmVzX3RvX3J1c3QsIGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvclxudmFyIGNhbWxfZnFfcGxvbmtfZ2F0ZV90b19ydXN0ID0gZnVuY3Rpb24gKGdhdGUpIHtcbiAgICAvLyBUT0RPOiBIYXJkY29kaW5nIDMyIGhlcmUgaXMgYSBsaXR0bGUgYnJpdHRsZVxuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtRnFHYXRlKFxuICAgICAgICBnYXRlWzFdLFxuICAgICAgICBjYW1sX3Bsb25rX3dpcmVzX3RvX3J1c3QoZ2F0ZVsyXSksXG4gICAgICAgIGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvcihnYXRlWzNdKSlcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmcmVlX29uX2ZpbmFsaXplKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9jcmVhdGUoKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9hZGRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2ZwX3Bsb25rX2dhdGVfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfYWRkID0gZnVuY3Rpb24gKHYsIHgpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2FkZCh2LCBjYW1sX2ZwX3Bsb25rX2dhdGVfdG9fcnVzdCh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9nZXRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX2dhdGVfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfZ2V0ID0gZnVuY3Rpb24gKHYsIGkpIHtcbiAgICByZXR1cm4gY2FtbF9wbG9ua19nYXRlX29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2dldCh2LCBpKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9sZW5cbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9sZW4gPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfbGVuKHYpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3Jfd3JhcFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfd2lyZV90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl93cmFwID0gZnVuY3Rpb24gKHYsIHgsIHkpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX3dyYXAodiwgY2FtbF9wbG9ua193aXJlX3RvX3J1c3QoeCksIGNhbWxfcGxvbmtfd2lyZV90b19ydXN0KHkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2RpZ2VzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYnl0ZXNfb2ZfdWludDhhcnJheVxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfZGlnZXN0ID0gZnVuY3Rpb24gKHB1YmxpY19pbnB1dF9zaXplLCBnYXRlX3ZlY3Rvcikge1xuICAgIHZhciB1aW50OGFycmF5ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2RpZ2VzdChwdWJsaWNfaW5wdXRfc2l6ZSwgZ2F0ZV92ZWN0b3IpO1xuICAgIHJldHVybiBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXkodWludDhhcnJheSk7XG59XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2NpcmN1aXRfc2VyaWFsaXplXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2NpcmN1aXRfc2VyaWFsaXplID0gZnVuY3Rpb24gKHB1YmxpY19pbnB1dF9zaXplLCBnYXRlX3ZlY3Rvcikge1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfY2lyY3VpdF9zZXJpYWxpemUocHVibGljX2lucHV0X3NpemUsIGdhdGVfdmVjdG9yKSk7XG59XG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2NyZWF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnJlZV9vbl9maW5hbGl6ZShwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfY3JlYXRlKCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfYWRkXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9mcV9wbG9ua19nYXRlX3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2FkZCA9IGZ1bmN0aW9uICh2LCB4KSB7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9hZGQodiwgY2FtbF9mcV9wbG9ua19nYXRlX3RvX3J1c3QoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfZ2V0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wbG9ua19nYXRlX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2dldCA9IGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgcmV0dXJuIGNhbWxfcGxvbmtfZ2F0ZV9vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9nZXQodiwgaSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfbGVuXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfbGVuID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2xlbih2KTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX3dyYXBcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3Jfd3JhcCA9IGZ1bmN0aW9uICh2LCB4LCB5KSB7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl93cmFwKHYsIGNhbWxfcGxvbmtfd2lyZV90b19ydXN0KHgpLCBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh5KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9kaWdlc3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXlcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2RpZ2VzdCA9IGZ1bmN0aW9uIChwdWJsaWNfaW5wdXRfc2l6ZSwgZ2F0ZV92ZWN0b3IpIHtcbiAgICB2YXIgdWludDhhcnJheSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9kaWdlc3QocHVibGljX2lucHV0X3NpemUsIGdhdGVfdmVjdG9yKTtcbiAgICByZXR1cm4gY2FtbF9ieXRlc19vZl91aW50OGFycmF5KHVpbnQ4YXJyYXkpO1xufVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19jaXJjdWl0X3NlcmlhbGl6ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19jaXJjdWl0X3NlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwdWJsaWNfaW5wdXRfc2l6ZSwgZ2F0ZV92ZWN0b3IpIHtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2NpcmN1aXRfc2VyaWFsaXplKHB1YmxpY19pbnB1dF9zaXplLCBnYXRlX3ZlY3RvcikpO1xufVxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2NyZWF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2NyZWF0ZSA9IGZ1bmN0aW9uIChnYXRlcywgcHVibGljX2lucHV0cywgcHJldl9jaGFsbGVuZ2VzLCB1cnMpIHtcbiAgICB2YXIgdCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9jcmVhdGUoZ2F0ZXMsIHB1YmxpY19pbnB1dHMsIHByZXZfY2hhbGxlbmdlcywgdXJzKTtcbiAgICByZXR1cm4gZnJlZV9vbl9maW5hbGl6ZSh0KTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X21heF9kZWdyZWVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9tYXhfZGVncmVlID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X21heF9kZWdyZWU7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X3B1YmxpY19pbnB1dHNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9wdWJsaWNfaW5wdXRzID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X3B1YmxpY19pbnB1dHM7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kMV9zaXplXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2QxX3NpemUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2QxX3NpemU7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kNF9zaXplXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2Q0X3NpemUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2Q0X3NpemU7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kOF9zaXplXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2Q4X3NpemUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2Q4X3NpemU7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X3JlYWRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfcmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIHVycywgcGF0aCkge1xuICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9yZWFkKG9mZnNldCwgdXJzLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF93cml0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF93cml0ZSA9IGZ1bmN0aW9uIChhcHBlbmQsIHQsIHBhdGgpIHtcbiAgICBpZiAoYXBwZW5kID09PSAwKSB7XG4gICAgICAgIGFwcGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmQgPSBhcHBlbmRbMV07XG4gICAgfVxuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfd3JpdGUoYXBwZW5kLCB0LCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSk7XG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2NyZWF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2NyZWF0ZSA9IGZ1bmN0aW9uIChnYXRlcywgcHVibGljX2lucHV0cywgcHJldl9jaGFsbGVuZ2VzLCB1cnMpIHtcbiAgICByZXR1cm4gZnJlZV9vbl9maW5hbGl6ZShwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfY3JlYXRlKGdhdGVzLCBwdWJsaWNfaW5wdXRzLCBwcmV2X2NoYWxsZW5nZXMsIHVycykpO1xufVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9tYXhfZGVncmVlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfbWF4X2RlZ3JlZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9tYXhfZGVncmVlO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9wdWJsaWNfaW5wdXRzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfcHVibGljX2lucHV0cyA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9wdWJsaWNfaW5wdXRzO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDFfc2l6ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kMV9zaXplID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kMV9zaXplO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDRfc2l6ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kNF9zaXplID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kNF9zaXplO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDhfc2l6ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kOF9zaXplID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kOF9zaXplO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9yZWFkXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3JlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCB1cnMsIHBhdGgpIHtcbiAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXRbMV07XG4gICAgfVxuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfcmVhZChvZmZzZXQsIHVycywgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfd3JpdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfd3JpdGUgPSBmdW5jdGlvbiAoYXBwZW5kLCB0LCBwYXRoKSB7XG4gICAgaWYgKGFwcGVuZCA9PT0gMCkge1xuICAgICAgICBhcHBlbmQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXBwZW5kID0gYXBwZW5kWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3dyaXRlKGFwcGVuZCwgdCwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua19kb21haW5fb2ZfcnVzdFxudmFyIGNhbWxfcGxvbmtfZG9tYWluX29mX3J1c3QgPSBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBsb2dfc2l6ZV9vZl9ncm91cCA9IHgubG9nX3NpemVfb2ZfZ3JvdXA7XG4gICAgdmFyIGdyb3VwX2dlbiA9IHguZ3JvdXBfZ2VuO1xuICAgIHguZnJlZSgpO1xuICAgIHJldHVybiBbMCwgbG9nX3NpemVfb2ZfZ3JvdXAsIGdyb3VwX2dlbl07XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua19kb21haW5fdG9fcnVzdFxuLy8gUmVxdWlyZXM6IGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Bsb25rX2RvbWFpbl90b19ydXN0ID0gZnVuY3Rpb24gKHgsIGtsYXNzKSB7XG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyBnZXRzIGZpbmFsaXplZFxuICAgIHJldHVybiBuZXcga2xhc3MoeFsxXSwgeFsyXSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua192ZXJpZmljYXRpb25fZXZhbHNfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfcG9seV9jb21tX29mX3J1c3RfcG9seV9jb21tLCBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IsIHBsb25rX3dhc21cbnZhciBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9ldmFsc19vZl9ydXN0ID0gZnVuY3Rpb24gKHgsIGFmZmluZV9rbGFzcykge1xuICAgIHZhciBjb252ZXJ0ID0gZnVuY3Rpb24gKHBvbHlfY29tbSkge1xuICAgICAgICByZXR1cm4gY2FtbF9wb2x5X2NvbW1fb2ZfcnVzdF9wb2x5X2NvbW0ocG9seV9jb21tLCBhZmZpbmVfa2xhc3MsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgLy8gdmFyIGNvbnZlcnRBcnJheSA9IGZ1bmN0aW9uKGNvbW1zKSB7XG4gICAgLy8gICAgIHZhciBuID0gY29tbXMubGVuZ3RoO1xuICAgIC8vICAgICB2YXIgcmVzID0gbmV3IEFycmF5KG4tMSk7XG4gICAgLy8gICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgLy8gICAgICAgICByZXNbaS0xXSA9IGNvbnZlcnQoY29tbXNbaV0pO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHJldHVybiBqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3IocmVzKTtcbiAgICAvLyAgIH07XG5cbiAgICAvLyBzaG91bGQgYmUgaW52ZXJzZSBvZiB0aGUgYWJvdmUgXlxuICAgIC8vIFRPRE86IG1ha2Ugd29yayBmb3IgYm90aCBXYXNtLi5Qb2x5Q29tbSB0eXBlc1xuICAgIHZhciBjb252ZXJ0QXJyYXkgPSBmdW5jdGlvbiAoY29tbXMpIHtcbiAgICAgICAgY29tbXMgPSBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IoY29tbXMsIHBsb25rX3dhc20uV2FzbUZxUG9seUNvbW0pO1xuICAgICAgICAvLyBjb21tcyA9IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3Rvcihjb21tcywgcGxvbmtfd2FzbS5XYXNtRnBQb2x5Q29tbSk7XG4gICAgICAgIHJldHVybiBbMF0uY29uY2F0KGNvbW1zLm1hcChjb252ZXJ0KSk7XG4gICAgfTtcblxuICAgIHZhciBzaWdtYV9jb21tID0gY29udmVydEFycmF5KHguc2lnbWFfY29tbSk7XG4gICAgdmFyIGNvZWZmaWNpZW50c19jb21tID0gY29udmVydEFycmF5KHguY29lZmZpY2llbnRzX2NvbW0pO1xuICAgIHZhciBnZW5lcmljX2NvbW0gPSBjb252ZXJ0KHguZ2VuZXJpY19jb21tKTtcbiAgICB2YXIgcHNtX2NvbW0gPSBjb252ZXJ0KHgucHNtX2NvbW0pO1xuICAgIHZhciBjb21wbGV0ZV9hZGRfY29tbSA9IGNvbnZlcnQoeC5jb21wbGV0ZV9hZGRfY29tbSk7XG4gICAgdmFyIG11bF9jb21tID0gY29udmVydCh4Lm11bF9jb21tKTtcbiAgICB2YXIgZW11bF9jb21tID0gY29udmVydCh4LmVtdWxfY29tbSk7XG4gICAgdmFyIGVuZG9tdWxfc2NhbGFyX2NvbW0gPSBjb252ZXJ0KHguZW5kb211bF9zY2FsYXJfY29tbSk7XG5cbiAgICB4LmZyZWUoKTtcbiAgICByZXR1cm4gWzBcbiAgICAgICAgLCBzaWdtYV9jb21tXG4gICAgICAgICwgY29lZmZpY2llbnRzX2NvbW1cbiAgICAgICAgLCBnZW5lcmljX2NvbW1cbiAgICAgICAgLCBwc21fY29tbVxuICAgICAgICAsIGNvbXBsZXRlX2FkZF9jb21tXG4gICAgICAgICwgbXVsX2NvbW1cbiAgICAgICAgLCBlbXVsX2NvbW1cbiAgICAgICAgLCBlbmRvbXVsX3NjYWxhcl9jb21tXG4gICAgICAgICwgMF07XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua192ZXJpZmljYXRpb25fZXZhbHNfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfcG9seV9jb21tX3RvX3J1c3RfcG9seV9jb21tLCBqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3JcbnZhciBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9ldmFsc190b19ydXN0ID0gZnVuY3Rpb24gKHgsIGtsYXNzLCBwb2x5X2NvbW1fY2xhc3MsIG1rX2FmZmluZSkge1xuICAgIHZhciBjb252ZXJ0ID0gZnVuY3Rpb24gKHBvbHlfY29tbSkge1xuICAgICAgICByZXR1cm4gY2FtbF9wb2x5X2NvbW1fdG9fcnVzdF9wb2x5X2NvbW0ocG9seV9jb21tLCBwb2x5X2NvbW1fY2xhc3MsIG1rX2FmZmluZSk7XG4gICAgfTtcblxuICAgIHZhciBjb252ZXJ0QXJyYXkgPSBmdW5jdGlvbiAoY29tbXMpIHtcbiAgICAgICAgdmFyIG4gPSBjb21tcy5sZW5ndGg7XG4gICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkobiAtIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcmVzW2kgLSAxXSA9IGNvbnZlcnQoY29tbXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3IocmVzKTtcbiAgICB9O1xuXG4gICAgdmFyIHNpZ21hX2NvbW0gPSBjb252ZXJ0QXJyYXkoeFsxXSk7XG4gICAgdmFyIGNvZWZmaWNpZW50c19jb21tID0gY29udmVydEFycmF5KHhbMl0pO1xuICAgIHZhciBnZW5lcmljX2NvbW0gPSBjb252ZXJ0KHhbM10pO1xuICAgIHZhciBwc21fY29tbSA9IGNvbnZlcnQoeFs0XSk7XG4gICAgdmFyIGNvbXBsZXRlX2FkZF9jb21tID0gY29udmVydCh4WzVdKTtcbiAgICB2YXIgbXVsX2NvbW0gPSBjb252ZXJ0KHhbNl0pO1xuICAgIHZhciBlbXVsX2NvbW0gPSBjb252ZXJ0KHhbN10pO1xuICAgIHZhciBlbmRvbXVsX3NjYWxhcl9jb21tID0gY29udmVydCh4WzhdKTtcblxuICAgIHJldHVybiBuZXcga2xhc3MoXG4gICAgICAgIHNpZ21hX2NvbW0sXG4gICAgICAgIGNvZWZmaWNpZW50c19jb21tLFxuICAgICAgICBnZW5lcmljX2NvbW0sXG4gICAgICAgIHBzbV9jb21tLFxuICAgICAgICBjb21wbGV0ZV9hZGRfY29tbSxcbiAgICAgICAgbXVsX2NvbW0sXG4gICAgICAgIGVtdWxfY29tbSxcbiAgICAgICAgZW5kb211bF9zY2FsYXJfY29tbSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX29mX3J1c3RcbnZhciBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9zaGlmdHNfb2ZfcnVzdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIHJlcyA9IFswLCB4LnMwLCB4LnMxLCB4LnMyLCB4LnMzLCB4LnM0LCB4LnM1LCB4LnM2XTtcbiAgICB4LmZyZWUoKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c190b19ydXN0XG52YXIgY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX3RvX3J1c3QgPSBmdW5jdGlvbiAoeCwga2xhc3MpIHtcbiAgICByZXR1cm4gbmV3IGtsYXNzKHhbMV0sIHhbMl0sIHhbM10sIHhbNF0sIHhbNV0sIHhbNl0sIHhbN10pO1xufTtcblxuLy8gUHJvdmlkZXM6IGNvbHVtbl9vZl9ydXN0XG5mdW5jdGlvbiBjb2x1bW5fb2ZfcnVzdChjb2wpIHtcbiAgICAvLyB0eXBlIG5vbnJlYyBjb2x1bW4gPSBXaXRuZXNzIG9mIGludCB8IFogfCBMb29rdXBTb3J0ZWQgb2YgaW50IHwgTG9va3VwQWdncmVnIHwgTG9va3VwVGFibGUgfCBMb29rdXBLaW5kSW5kZXggb2YgaW50IHwgSW5kZXggb2YgZ2F0ZV90eXBlIHwgQ29lZmZpY2llbnQgb2YgaW50XG4gICAgdmFyIHRhZyA9IGNvbC50YWc7XG4gICAgdmFyIGdhdGVfdHlwZSA9IGNvbC5nYXRlX3R5cGU7XG4gICAgdmFyIGkgPSBjb2wuaTtcbiAgICBjb2wuZnJlZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIDA6IFt0YWcsIGldLFxuICAgICAgICAyOiBbdGFnLCBpXSxcbiAgICAgICAgNTogW3RhZywgaV0sXG4gICAgICAgIDY6IFt0YWcsIGdhdGVfdHlwZV0sXG4gICAgICAgIDc6IFt0YWcsIGldXG4gICAgfVt0YWddIHx8IHRhZztcbn1cblxuLy8gUHJvdmlkZXM6IHZhcmlhYmxlX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjb2x1bW5fb2ZfcnVzdFxuZnVuY3Rpb24gdmFyaWFibGVfb2ZfcnVzdCh2YXJpYWJsZSkge1xuICAgIC8vIGNvbCAqIHJvd1xuICAgIHZhciBjb2wgPSB2YXJpYWJsZS5jb2w7XG4gICAgdmFyIHJvdyA9IHZhcmlhYmxlLnJvdzsgLy8gMCwgMVxuICAgIHZhcmlhYmxlLmZyZWUoKTtcbiAgICByZXR1cm4gWzAsIGNvbHVtbl9vZl9ydXN0KGNvbCksIHJvd107XG59XG5cbi8vIFByb3ZpZGVzOiBwb2xpc2hfdG9rZW5fb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHZhcmlhYmxlX29mX3J1c3RcbmZ1bmN0aW9uIHBvbGlzaF90b2tlbl9vZl9ydXN0KHRva2VuKSB7XG4gICAgdmFyIHRhZyA9IHRva2VuLnRhZztcbiAgICB2YXIgaTAgPSB0b2tlbi5pMDtcbiAgICB2YXIgaTEgPSB0b2tlbi5pMTtcbiAgICB2YXIgZiA9IHRva2VuLmY7XG4gICAgdmFyIHYgPSB2YXJpYWJsZV9vZl9ydXN0KHRva2VuLnYpO1xuICAgIHRva2VuLmZyZWUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICA1OiBbNSwgaTAsIGkxXSxcbiAgICAgICAgNjogWzYsIGZdLFxuICAgICAgICA3OiBbNywgdl0sXG4gICAgICAgIDk6IFs5LCBpMF0sXG4gICAgICAgIDE0OiBbMTQsIGkwXSxcbiAgICAgICAgMTY6IFsxNiwgaTBdXG4gICAgfVt0YWddIHx8IHRhZztcbn1cblxuLy8gUHJvdmlkZXM6IGluZGV4X3Rlcm1fb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IGNvbHVtbl9vZl9ydXN0LCBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IsIHBvbGlzaF90b2tlbl9vZl9ydXN0XG5mdW5jdGlvbiBpbmRleF90ZXJtX29mX3J1c3QodGVybSwgdG9rZW5fY2xhc3MpIHtcbiAgICAvLyBwdWIgY29sdW1uOiBXYXNtQ29sdW1uLFxuICAgIC8vIHB1YiBjb2VmZmljaWVudDogV2FzbVZlY3RvcjxXYXNtUG9saXNoVG9rZW4+LFxuICAgIHZhciBjb2x1bW4gPSBjb2x1bW5fb2ZfcnVzdCh0ZXJtLmNvbHVtbik7XG4gICAgdmFyIGNvZWZmaWNpZW50ID0ganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yKHRlcm0uY29lZmZpY2llbnQsIHRva2VuX2NsYXNzKTtcbiAgICBjb2VmZmljaWVudCA9IGNvZWZmaWNpZW50Lm1hcChwb2xpc2hfdG9rZW5fb2ZfcnVzdClcbiAgICBjb2VmZmljaWVudCA9IFswXS5jb25jYXQoY29lZmZpY2llbnQpO1xuICAgIHRlcm0uZnJlZSgpO1xuICAgIHJldHVybiBbMCwgY29sdW1uLCBjb2VmZmljaWVudF07XG59XG5cbi8vIFByb3ZpZGVzOiB3cmFwXG5mdW5jdGlvbiB3cmFwKHB0ciwga2xhc3MpIHtcbiAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShrbGFzcy5wcm90b3R5cGUpO1xuICAgIG9iai5wdHIgPSBwdHI7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuLy8gUHJvdmlkZXM6IGxpbmVhcml6YXRpb25fb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvciwgcG9saXNoX3Rva2VuX29mX3J1c3QsIHdyYXAsIGluZGV4X3Rlcm1fb2ZfcnVzdFxuZnVuY3Rpb24gbGluZWFyaXphdGlvbl9vZl9ydXN0KGxpbmVhcml6YXRpb24sIGFmZmluZV9jbGFzcykge1xuICAgIHZhciBGID0gYWZmaW5lX2NsYXNzID09PSBwbG9ua193YXNtLldhc21HVmVzdGEgPyAnRnEnIDogJ0ZwJztcbiAgICB2YXIgV2FzbVBvbGlzaFRva2VuID0gcGxvbmtfd2FzbVsnV2FzbScgKyBGICsgJ1BvbGlzaFRva2VuJ107XG4gICAgdmFyIFdhc21JbmRleFRlcm0gPSBwbG9ua193YXNtWydXYXNtJyArIEYgKyAnSW5kZXhUZXJtJ107XG5cbiAgICB2YXIgY29uc3RhbnRfdGVybSA9IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvcihsaW5lYXJpemF0aW9uLmNvbnN0YW50X3Rlcm0sIFdhc21Qb2xpc2hUb2tlbik7XG4gICAgY29uc3RhbnRfdGVybSA9IGNvbnN0YW50X3Rlcm0ubWFwKHBvbGlzaF90b2tlbl9vZl9ydXN0KVxuICAgIGNvbnN0YW50X3Rlcm0gPSBbMF0uY29uY2F0KGNvbnN0YW50X3Rlcm0pO1xuXG4gICAgdmFyIGluZGV4X3Rlcm1zID0gQXJyYXkuZnJvbShsaW5lYXJpemF0aW9uLmluZGV4X3Rlcm1zKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChwdHIpIHtcbiAgICAgICAgICAgIHZhciB3YXNtSW5kZXhUZXJtID0gd3JhcChwdHIsIFdhc21JbmRleFRlcm0pO1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4X3Rlcm1fb2ZfcnVzdCh3YXNtSW5kZXhUZXJtLCBXYXNtUG9saXNoVG9rZW4pO1xuICAgICAgICB9KTtcbiAgICBpbmRleF90ZXJtcyA9IFswXS5jb25jYXQoaW5kZXhfdGVybXMpO1xuXG4gICAgbGluZWFyaXphdGlvbi5mcmVlKCk7XG4gICAgcmV0dXJuIFswLCBjb25zdGFudF90ZXJtLCBpbmRleF90ZXJtc107XG59XG5cbi8vIFByb3ZpZGVzOiBOb25lXG52YXIgTm9uZSA9IDA7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBsaW5lYXJpemF0aW9uX29mX3J1c3QsIGNhbWxfcGxvbmtfZG9tYWluX29mX3J1c3QsIGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX2V2YWxzX29mX3J1c3QsIGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c19vZl9ydXN0LCBmcmVlX29uX2ZpbmFsaXplLCBOb25lXG52YXIgY2FtbF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0ID0gZnVuY3Rpb24gKHgsIGFmZmluZV9jbGFzcykge1xuICAgIHZhciBkb21haW4gPSBjYW1sX3Bsb25rX2RvbWFpbl9vZl9ydXN0KHguZG9tYWluKTtcbiAgICB2YXIgbWF4X3BvbHlfc2l6ZSA9IHgubWF4X3BvbHlfc2l6ZTtcbiAgICB2YXIgcHVibGljXyA9IHgucHVibGljXztcbiAgICB2YXIgcHJldl9jaGFsbGVuZ2VzID0geC5wcmV2X2NoYWxsZW5nZXM7XG4gICAgdmFyIHNycyA9IGZyZWVfb25fZmluYWxpemUoeC5zcnMpO1xuICAgIHZhciBldmFscyA9IGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX2V2YWxzX29mX3J1c3QoeC5ldmFscywgYWZmaW5lX2NsYXNzKTtcbiAgICB2YXIgc2hpZnRzID0gY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX29mX3J1c3QoeC5zaGlmdHMpO1xuICAgIC8vIFRPRE86IEhhbmRsZSBsaW5lYXJpemF0aW9uIGNvcnJlY3RseSFcbiAgICAvLyB2YXIgbGluZWFyaXphdGlvbiA9IGxpbmVhcml6YXRpb25fb2ZfcnVzdCh4LmxpbmVhcml6YXRpb24sIGFmZmluZV9jbGFzcyk7XG4gICAgdmFyIGxvb2t1cF9pbmRleCA9IE5vbmU7XG4gICAgeC5mcmVlKCk7XG4gICAgcmV0dXJuIFswLCBkb21haW4sIG1heF9wb2x5X3NpemUsIHB1YmxpY18sIHByZXZfY2hhbGxlbmdlcywgc3JzLCBldmFscywgc2hpZnRzLCBOb25lXTtcbn07XG4vLyBQcm92aWRlczogY2FtbF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0XG4vLyBSZXF1aXJlczogY2FtbF9wbG9ua19kb21haW5fdG9fcnVzdCwgY2FtbF9wbG9ua192ZXJpZmljYXRpb25fZXZhbHNfdG9fcnVzdCwgY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX3RvX3J1c3QsIGZyZWVfZmluYWxpemF0aW9uX3JlZ2lzdHJ5XG52YXIgY2FtbF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0ID0gZnVuY3Rpb24gKHgsIGtsYXNzLCBkb21haW5fY2xhc3MsIHZlcmlmaWNhdGlvbl9ldmFsc19jbGFzcywgcG9seV9jb21tX2NsYXNzLCBta19hZmZpbmUsIHZlcmlmaWNhdGlvbl9zaGlmdHNfY2xhc3MpIHtcbiAgICB2YXIgZG9tYWluID0gY2FtbF9wbG9ua19kb21haW5fdG9fcnVzdCh4WzFdLCBkb21haW5fY2xhc3MpO1xuICAgIHZhciBtYXhfcG9seV9zaXplID0geFsyXTtcbiAgICB2YXIgcHVibGljXyA9IHhbM107XG4gICAgdmFyIHByZXZfY2hhbGxlbmdlcyA9IHhbNF07XG4gICAgdmFyIHNycyA9IHhbNV07XG4gICAgdmFyIGV2YWxzID0gY2FtbF9wbG9ua192ZXJpZmljYXRpb25fZXZhbHNfdG9fcnVzdCh4WzZdLCB2ZXJpZmljYXRpb25fZXZhbHNfY2xhc3MsIHBvbHlfY29tbV9jbGFzcywgbWtfYWZmaW5lKTtcbiAgICB2YXIgc2hpZnRzID0gY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX3RvX3J1c3QoeFs3XSwgdmVyaWZpY2F0aW9uX3NoaWZ0c19jbGFzcyk7XG4gICAgcmV0dXJuIG5ldyBrbGFzcyhkb21haW4sIG1heF9wb2x5X3NpemUsIHB1YmxpY18sIHByZXZfY2hhbGxlbmdlcywgc3JzLCBldmFscywgc2hpZnRzKTtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdCh4LCBwbG9ua193YXNtLldhc21HVmVzdGEpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCh4LCBwbG9ua193YXNtLldhc21GcFBsb25rVmVyaWZpZXJJbmRleCwgcGxvbmtfd2FzbS5XYXNtRnBEb21haW4sIHBsb25rX3dhc20uV2FzbUZwUGxvbmtWZXJpZmljYXRpb25FdmFscywgcGxvbmtfd2FzbS5XYXNtRnBQb2x5Q29tbSwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUsIHBsb25rX3dhc20uV2FzbUZwU2hpZnRzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2NyZWF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfY3JlYXRlID0gZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgdmsgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfY3JlYXRlKHgpO1xuICAgIHZhciB2a19jYW1sID0gY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0KHZrKTtcbiAgICByZXR1cm4gdmtfY2FtbDtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3JlYWRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9yZWFkID0gZnVuY3Rpb24gKG9mZnNldCwgdXJzLCBwYXRoKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICBvZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0WzFdO1xuICAgIH1cbiAgICByZXR1cm4gY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9yZWFkKG9mZnNldCwgdXJzLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfd3JpdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF93cml0ZSA9IGZ1bmN0aW9uIChhcHBlbmQsIHQsIHBhdGgpIHtcbiAgICBpZiAoYXBwZW5kID09PSAwKSB7XG4gICAgICAgIGFwcGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmQgPSBhcHBlbmRbMV07XG4gICAgfVxuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfd3JpdGUoYXBwZW5kLCBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QodCksIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBhdGgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3NoaWZ0c1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c19vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9zaGlmdHMgPSBmdW5jdGlvbiAobG9nMl9zaXplKSB7XG4gICAgcmV0dXJuIGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c19vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9zaGlmdHMobG9nMl9zaXplKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9kdW1teVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZHVtbXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9kdW1teSgpO1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QocmVzKTtcbiAgICAvLyByZXR1cm4gY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9kdW1teSgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2RlZXBfY29weVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdCwgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9kZWVwX2NvcHkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2RlZXBfY29weShjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QoeCkpKTtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdCh4LCBwbG9ua193YXNtLldhc21HUGFsbGFzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QoeCwgcGxvbmtfd2FzbS5XYXNtRnFQbG9ua1ZlcmlmaWVySW5kZXgsIHBsb25rX3dhc20uV2FzbUZxRG9tYWluLCBwbG9ua193YXNtLldhc21GcVBsb25rVmVyaWZpY2F0aW9uRXZhbHMsIHBsb25rX3dhc20uV2FzbUZxUG9seUNvbW0sIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSwgcGxvbmtfd2FzbS5XYXNtRnFTaGlmdHMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9jcmVhdGUgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2NyZWF0ZSh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9yZWFkXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcsIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfcmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIHVycywgcGF0aCkge1xuICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfcmVhZChvZmZzZXQsIHVycywgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3dyaXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcsIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfd3JpdGUgPSBmdW5jdGlvbiAoYXBwZW5kLCB0LCBwYXRoKSB7XG4gICAgaWYgKGFwcGVuZCA9PT0gMCkge1xuICAgICAgICBhcHBlbmQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXBwZW5kID0gYXBwZW5kWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3dyaXRlKGFwcGVuZCwgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0KHQpLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9zaGlmdHNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9zaGlmdHNfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfc2hpZnRzID0gZnVuY3Rpb24gKGxvZzJfc2l6ZSkge1xuICAgIHJldHVybiBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9zaGlmdHNfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfc2hpZnRzKGxvZzJfc2l6ZSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZHVtbXlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2R1bW15ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2R1bW15KCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0LCBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2RlZXBfY29weSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZGVlcF9jb3B5KGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCh4KSkpO1xufTtcblxuXG4vLyBQcm92aWRlczogQ09MVU1OU1xudmFyIENPTFVNTlMgPSAxNTtcbi8vIFByb3ZpZGVzOiBQRVJNVVRTX01JTlVTXzFcbnZhciBQRVJNVVRTX01JTlVTXzEgPSA2O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9mcF92ZWN0b3JfdG9fcnVzdCwgUEVSTVVUU19NSU5VU18xLCBDT0xVTU5TXG52YXIgY2FtbF9wYXN0YV9mcF9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4O1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfZnBfdmVjdG9yX29mX3J1c3QsIENPTFVNTlMsIFBFUk1VVFNfTUlOVVNfMVxudmFyIGNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geDtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX29wZW5pbmdfcHJvb2ZfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IsIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lXG52YXIgY2FtbF9wYXN0YV9mcF9vcGVuaW5nX3Byb29mX3RvX3J1c3QgPSBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBjb252ZXJ0X2FmZmluZXMgPSBmdW5jdGlvbiAoYWZmaW5lcykge1xuICAgICAgICByZXR1cm4gY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvcihhZmZpbmVzLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUpO1xuICAgIH1cbiAgICB2YXIgbHIgPSB4WzFdO1xuICAgIHZhciBkZWx0YSA9IHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lKHhbMl0sIHBsb25rX3dhc20uY2FtbF92ZXN0YV9hZmZpbmVfb25lKTtcbiAgICB2YXIgejEgPSB4WzNdO1xuICAgIHZhciB6MiA9IHhbNF07XG4gICAgdmFyIHNnID0gcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUoeFs1XSwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUpO1xuICAgIHZhciBsZW4gPSBsci5sZW5ndGg7XG4gICAgLy8gV2UgcGFzcyBsIGFuZCByIGFzIHNlcGFyYXRlIHZlY3RvcnMgb3ZlciB0aGUgRkZJXG4gICAgdmFyIGxfb2NhbWwgPSBuZXcgQXJyYXkobGVuKTtcbiAgICB2YXIgcl9vY2FtbCA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbF9vY2FtbFtpXSA9IGxyW2ldWzFdO1xuICAgICAgICByX29jYW1sW2ldID0gbHJbaV1bMl07XG4gICAgfVxuICAgIHZhciBsID0gY29udmVydF9hZmZpbmVzKGxfb2NhbWwpO1xuICAgIHZhciByID0gY29udmVydF9hZmZpbmVzKHJfb2NhbWwpO1xuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtRnBPcGVuaW5nUHJvb2YobCwgciwgZGVsdGEsIHoxLCB6Miwgc2cpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl9vZl9ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9hcnJheV9vZl9ydXN0X3ZlY3RvciwgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmVcbnZhciBjYW1sX3Bhc3RhX2ZwX29wZW5pbmdfcHJvb2Zfb2ZfcnVzdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIGNvbnZlcnRfYWZmaW5lcyA9IGZ1bmN0aW9uIChhZmZpbmVzKSB7XG4gICAgICAgIHJldHVybiBjYW1sX2FycmF5X29mX3J1c3RfdmVjdG9yKGFmZmluZXMsIHBsb25rX3dhc20uV2FzbUdWZXN0YSwgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUsIGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIGwgPSBjb252ZXJ0X2FmZmluZXMoeC5scl8wKTtcbiAgICB2YXIgciA9IGNvbnZlcnRfYWZmaW5lcyh4LmxyXzEpO1xuICAgIHZhciBkZWx0YSA9IHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lKHguZGVsdGEpO1xuICAgIHZhciB6MSA9IHguejE7XG4gICAgdmFyIHoyID0geC56MjtcbiAgICB2YXIgc2cgPSBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSh4LnNnKTtcbiAgICB4LmZyZWUoKTtcbiAgICB2YXIgbGVuID0gbC5sZW5ndGg7XG4gICAgaWYgKGxlbiAhPT0gci5sZW5ndGgpIHsgdGhyb3cgbmV3IEVycm9yKFwibCBhbmQgciBsZW5ndGhzIGRvbid0IG1hdGNoXCIpOyB9XG4gICAgdmFyIGxyID0gbmV3IEFycmF5KGxlbik7XG4gICAgbHJbMF0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHR1cGxlID0gbmV3IEFycmF5KDMpO1xuICAgICAgICB0dXBsZVswXSA9IDA7XG4gICAgICAgIHR1cGxlWzFdID0gbFtpXTtcbiAgICAgICAgdHVwbGVbMl0gPSByW2ldO1xuICAgICAgICBscltpXSA9IHR1cGxlO1xuICAgIH1cbiAgICByZXR1cm4gWzAsIGxyLCBkZWx0YSwgejEsIHoyLCBzZ107XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9jb21taXRtZW50c190b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdCwganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yXG52YXIgY2FtbF9wYXN0YV9mcF9jb21taXRtZW50c190b19ydXN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgY29udmVydEFycmF5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG4gPSB2Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBjYW1sX3Zlc3RhX3BvbHlfY29tbV90b19ydXN0KHZbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG5lZWQgdG8gZG8gZmluYWxpemVyIHRoaW5ncz9cbiAgICAgICAgcmV0dXJuIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvcihyZXMpO1xuICAgIH07XG5cbiAgICB2YXIgd19jb21tID0gY29udmVydEFycmF5KHhbMV0pO1xuICAgIHZhciB6X2NvbW0gPSBjYW1sX3Zlc3RhX3BvbHlfY29tbV90b19ydXN0KHhbMl0pO1xuICAgIHZhciB0X2NvbW0gPSBjYW1sX3Zlc3RhX3BvbHlfY29tbV90b19ydXN0KHhbM10pO1xuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtRnBQcm92ZXJDb21taXRtZW50cyh3X2NvbW0sIHpfY29tbSwgdF9jb21tKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX2NvbW1pdG1lbnRzX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0LCBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IsIHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX2NvbW1pdG1lbnRzX29mX3J1c3QgPSBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBjb252ZXJ0QXJyYXkgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgYSA9IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3Rvcih2LCBwbG9ua193YXNtLldhc21GcFBvbHlDb21tKTtcbiAgICAgICAgdmFyIHJlcyA9IFswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIENoZWNrIHRoaXMuIENvdWxkIGJlIG9mZiBieSAxXG4gICAgICAgICAgICByZXMucHVzaChjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0KGFbaV0pKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIHZhciB3X2NvbW0gPSBjb252ZXJ0QXJyYXkoeC53X2NvbW0pO1xuICAgIHZhciB6X2NvbW0gPSBjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0KHguel9jb21tKTtcbiAgICB2YXIgdF9jb21tID0gY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdCh4LnRfY29tbSk7XG4gICAgeC5mcmVlKCk7XG4gICAgcmV0dXJuIFswLCB3X2NvbW0sIHpfY29tbSwgdF9jb21tXTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Byb29mX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZwX2NvbW1pdG1lbnRzX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl90b19ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Byb29mX2V2YWx1YXRpb25zX3RvX3J1c3QsIGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QsIGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QsIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvclxudmFyIGNhbWxfcGFzdGFfZnBfcHJvb2ZfdG9fcnVzdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIGNvbW1pdG1lbnRzID0gY2FtbF9wYXN0YV9mcF9jb21taXRtZW50c190b19ydXN0KHhbMV0pO1xuICAgIHZhciBwcm9vZiA9IGNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl90b19ydXN0KHhbMl0pO1xuICAgIHZhciBldmFscyA9IGNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfdG9fcnVzdCh4WzNdKTtcbiAgICB2YXIgZnRfZXZhbDEgPSB4WzRdO1xuICAgIHZhciBwdWJsaWNfID0gY2FtbF9mcF92ZWN0b3JfdG9fcnVzdCh4WzVdKTtcbiAgICB2YXIgcHJldl9jaGFsbGVuZ2VzID0geFs2XTtcbiAgICB2YXIgY2hhbHNfbGVuID0gcHJldl9jaGFsbGVuZ2VzLmxlbmd0aDtcbiAgICB2YXIgcHJldl9jaGFsbGVuZ2VzX3NjYWxhcnMgPSBuZXcgcGxvbmtfd2FzbS5XYXNtVmVjVmVjRnAoY2hhbHNfbGVuIC0gMSk7XG4gICAgdmFyIHByZXZfY2hhbGxlbmdlc19jb21tcyA9IG5ldyBBcnJheShjaGFsc19sZW4gLSAxKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoYWxzX2xlbjsgaSsrKSB7XG4gICAgICAgIHByZXZfY2hhbGxlbmdlc19zY2FsYXJzLnB1c2goY2FtbF9mcF92ZWN0b3JfdG9fcnVzdChwcmV2X2NoYWxsZW5nZXNbaV1bMV0pKTtcbiAgICAgICAgcHJldl9jaGFsbGVuZ2VzX2NvbW1zW2kgLSAxXSA9IGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QocHJldl9jaGFsbGVuZ2VzW2ldWzJdKTtcbiAgICB9XG4gICAgcHJldl9jaGFsbGVuZ2VzX2NvbW1zID0ganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yKHByZXZfY2hhbGxlbmdlc19jb21tcyk7XG4gICAgcmV0dXJuIG5ldyBwbG9ua193YXNtLldhc21GcFByb3ZlclByb29mKGNvbW1pdG1lbnRzLCBwcm9vZiwgZXZhbHMsIGZ0X2V2YWwxLCBwdWJsaWNfLCBwcmV2X2NoYWxsZW5nZXNfc2NhbGFycywgcHJldl9jaGFsbGVuZ2VzX2NvbW1zKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZwX2NvbW1pdG1lbnRzX29mX3J1c3QsIGNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl9vZl9ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Byb29mX2V2YWx1YXRpb25zX29mX3J1c3QsIGNhbWxfZnBfdmVjdG9yX29mX3J1c3QsIGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvciwgY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcHJvb2Zfb2ZfcnVzdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIG1lc3NhZ2VzID0gY2FtbF9wYXN0YV9mcF9jb21taXRtZW50c19vZl9ydXN0KHguY29tbWl0bWVudHMpO1xuICAgIHZhciBwcm9vZiA9IGNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl9vZl9ydXN0KHgucHJvb2YpO1xuICAgIHZhciBldmFscyA9IGNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCh4LmV2YWxzKTtcbiAgICB2YXIgZnRfZXZhbDEgPSB4LmZ0X2V2YWwxO1xuICAgIHZhciBwdWJsaWNfID0gY2FtbF9mcF92ZWN0b3Jfb2ZfcnVzdCh4LnB1YmxpY18pO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXNfc2NhbGFycyA9IHgucHJldl9jaGFsbGVuZ2VzX3NjYWxhcnM7XG4gICAgdmFyIHByZXZfY2hhbGxlbmdlc19jb21tcyA9IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3Rvcih4LnByZXZfY2hhbGxlbmdlc19jb21tcywgcGxvbmtfd2FzbS5XYXNtRnBQb2x5Q29tbSk7XG4gICAgdmFyIGNoYWxzX2xlbiA9IHByZXZfY2hhbGxlbmdlc19jb21tcy5sZW5ndGg7XG4gICAgdmFyIHByZXZfY2hhbGxlbmdlcyA9IG5ldyBBcnJheShjaGFsc19sZW4pO1xuICAgIHByZXZfY2hhbGxlbmdlc1swXSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjaGFsc19sZW47IGkrKykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KDMpO1xuICAgICAgICByZXNbMF0gPSAwO1xuICAgICAgICByZXNbMV0gPSBjYW1sX2ZwX3ZlY3Rvcl9vZl9ydXN0KHByZXZfY2hhbGxlbmdlc19zY2FsYXJzLmdldChpIC0gMSkpO1xuICAgICAgICAvLyBUT0RPIENoZWNrIHRoaXMuIENvdWxkIGJlIG9mZiBieSAxXG4gICAgICAgIHJlc1syXSA9IGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3QocHJldl9jaGFsbGVuZ2VzX2NvbW1zW2ldKTtcbiAgICAgICAgcHJldl9jaGFsbGVuZ2VzW2ldID0gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gWzAsIG1lc3NhZ2VzLCBwcm9vZiwgZXZhbHMsIGZ0X2V2YWwxLCBwdWJsaWNfLCBwcmV2X2NoYWxsZW5nZXNdO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9mcF92ZWN0b3JfdG9fcnVzdCwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIGNhbWxfcGFzdGFfZnBfcHJvb2Zfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfY3JlYXRlID0gZnVuY3Rpb24gKGluZGV4LCB3aXRuZXNzX2NvbHMsIHByZXZfY2hhbGxlbmdlcywgcHJldl9zZ3MpIHtcbiAgICB2YXIgdyA9IG5ldyBwbG9ua193YXNtLldhc21WZWNWZWNGcCh3aXRuZXNzX2NvbHMubGVuZ3RoIC0gMSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB3aXRuZXNzX2NvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdy5wdXNoKGNhbWxfZnBfdmVjdG9yX3RvX3J1c3Qod2l0bmVzc19jb2xzW2ldKSk7XG4gICAgfVxuICAgIHdpdG5lc3NfY29scyA9IHc7XG4gICAgcHJldl9jaGFsbGVuZ2VzID0gY2FtbF9mcF92ZWN0b3JfdG9fcnVzdChwcmV2X2NoYWxsZW5nZXMpO1xuICAgIHByZXZfc2dzID0gY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvcihwcmV2X3NncywgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIHBsb25rX3dhc20uY2FtbF92ZXN0YV9hZmZpbmVfb25lKTtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2NyZWF0ZShpbmRleCwgd2l0bmVzc19jb2xzLCBwcmV2X2NoYWxsZW5nZXMsIHByZXZfc2dzKTtcbiAgICB2YXIgcHJvb2YgPSBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3QocmVzKTtcbiAgICByZXR1cm4gcHJvb2Y7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl92ZXJpZnlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yLCBjYW1sX3Zlc3RhX3BvbHlfY29tbV90b19ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QsIGNhbWxfcGFzdGFfZnBfcHJvb2ZfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfdmVyaWZ5ID0gZnVuY3Rpb24gKGluZGV4LCBwcm9vZikge1xuICAgIGluZGV4ID0gY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0KGluZGV4KTtcbiAgICBwcm9vZiA9IGNhbWxfcGFzdGFfZnBfcHJvb2ZfdG9fcnVzdChwcm9vZik7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl92ZXJpZnkoaW5kZXgsIHByb29mKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2JhdGNoX3ZlcmlmeVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IsIGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcF9wcm9vZl90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9iYXRjaF92ZXJpZnkgPSBmdW5jdGlvbiAoaW5kZXhlcywgcHJvb2ZzKSB7XG4gICAgaW5kZXhlcyA9IGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IoaW5kZXhlcywgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0KTtcbiAgICBwcm9vZnMgPSBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yKHByb29mcywgY2FtbF9wYXN0YV9mcF9wcm9vZl90b19ydXN0KTtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2JhdGNoX3ZlcmlmeShpbmRleGVzLCBwcm9vZnMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZHVtbXlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2R1bW15ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2R1bW15KCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcF9wcm9vZl90b19ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2RlZXBfY29weSA9IGZ1bmN0aW9uIChwcm9vZikge1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2RlZXBfY29weShjYW1sX3Bhc3RhX2ZwX3Byb29mX3RvX3J1c3QocHJvb2YpKSk7XG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Byb29mX2V2YWx1YXRpb25zX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0LCBQRVJNVVRTX01JTlVTXzEsIENPTFVNTlNcbnZhciBjYW1sX3Bhc3RhX2ZxX3Byb29mX2V2YWx1YXRpb25zX3RvX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHg7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc19vZl9ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdCwgQ09MVU1OUywgUEVSTVVUU19NSU5VU18xXG52YXIgY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc19vZl9ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4O1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfb3BlbmluZ19wcm9vZl90b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmVcbnZhciBjYW1sX3Bhc3RhX2ZxX29wZW5pbmdfcHJvb2ZfdG9fcnVzdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIGNvbnZlcnRfYWZmaW5lcyA9IGZ1bmN0aW9uIChhZmZpbmVzKSB7XG4gICAgICAgIHJldHVybiBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yKGFmZmluZXMsIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBwbG9ua193YXNtLmNhbWxfcGFsbGFzX2FmZmluZV9vbmUpO1xuICAgIH1cbiAgICB2YXIgbHIgPSB4WzFdO1xuICAgIHZhciBkZWx0YSA9IHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lKHhbMl0sIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSk7XG4gICAgdmFyIHoxID0geFszXTtcbiAgICB2YXIgejIgPSB4WzRdO1xuICAgIHZhciBzZyA9IHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lKHhbNV0sIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSk7XG4gICAgdmFyIGxlbiA9IGxyLmxlbmd0aDtcbiAgICAvLyBXZSBwYXNzIGwgYW5kIHIgYXMgc2VwYXJhdGUgdmVjdG9ycyBvdmVyIHRoZSBGRklcbiAgICB2YXIgbF9vY2FtbCA9IG5ldyBBcnJheShsZW4pO1xuICAgIHZhciByX29jYW1sID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsX29jYW1sW2ldID0gbHJbaV1bMV07XG4gICAgICAgIHJfb2NhbWxbaV0gPSBscltpXVsyXTtcbiAgICB9XG4gICAgdmFyIGwgPSBjb252ZXJ0X2FmZmluZXMobF9vY2FtbCk7XG4gICAgdmFyIHIgPSBjb252ZXJ0X2FmZmluZXMocl9vY2FtbCk7XG4gICAgcmV0dXJuIG5ldyBwbG9ua193YXNtLldhc21GcU9wZW5pbmdQcm9vZihsLCByLCBkZWx0YSwgejEsIHoyLCBzZyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9vcGVuaW5nX3Byb29mX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2FycmF5X29mX3J1c3RfdmVjdG9yLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZVxudmFyIGNhbWxfcGFzdGFfZnFfb3BlbmluZ19wcm9vZl9vZl9ydXN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgY29udmVydF9hZmZpbmVzID0gZnVuY3Rpb24gKGFmZmluZXMpIHtcbiAgICAgICAgcmV0dXJuIGNhbWxfYXJyYXlfb2ZfcnVzdF92ZWN0b3IoYWZmaW5lcywgcGxvbmtfd2FzbS5XYXNtR1BhbGxhcywgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUsIGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIGwgPSBjb252ZXJ0X2FmZmluZXMoeC5scl8wKTtcbiAgICB2YXIgciA9IGNvbnZlcnRfYWZmaW5lcyh4LmxyXzEpO1xuICAgIHZhciBkZWx0YSA9IHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lKHguZGVsdGEpO1xuICAgIHZhciB6MSA9IHguejE7XG4gICAgdmFyIHoyID0geC56MjtcbiAgICB2YXIgc2cgPSBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSh4LnNnKTtcbiAgICB4LmZyZWUoKTtcbiAgICB2YXIgbGVuID0gbC5sZW5ndGg7XG4gICAgaWYgKGxlbiAhPT0gci5sZW5ndGgpIHsgdGhyb3cgbmV3IEVycm9yKFwibCBhbmQgciBsZW5ndGhzIGRvbid0IG1hdGNoXCIpOyB9XG4gICAgdmFyIGxyID0gbmV3IEFycmF5KGxlbik7XG4gICAgbHJbMF0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHR1cGxlID0gbmV3IEFycmF5KDMpO1xuICAgICAgICB0dXBsZVswXSA9IDA7XG4gICAgICAgIHR1cGxlWzFdID0gbFtpXTtcbiAgICAgICAgdHVwbGVbMl0gPSByW2ldO1xuICAgICAgICBscltpXSA9IHR1cGxlO1xuICAgIH1cbiAgICByZXR1cm4gWzAsIGxyLCBkZWx0YSwgejEsIHoyLCBzZ107XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9jb21taXRtZW50c190b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QsIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvclxudmFyIGNhbWxfcGFzdGFfZnFfY29tbWl0bWVudHNfdG9fcnVzdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIGNvbnZlcnRBcnJheSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBuID0gdi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgcmVzW2ldID0gY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QodltpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3IocmVzKTtcbiAgICB9O1xuXG4gICAgdmFyIHdfY29tbSA9IGNvbnZlcnRBcnJheSh4WzFdKTtcbiAgICB2YXIgel9jb21tID0gY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QoeFsyXSk7XG4gICAgdmFyIHRfY29tbSA9IGNhbWxfcGFsbGFzX3BvbHlfY29tbV90b19ydXN0KHhbM10pO1xuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtRnFQcm92ZXJDb21taXRtZW50cyh3X2NvbW0sIHpfY29tbSwgdF9jb21tKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX2NvbW1pdG1lbnRzX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdCwganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yLCBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9jb21taXRtZW50c19vZl9ydXN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgY29udmVydEFycmF5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIGEgPSBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IodiwgcGxvbmtfd2FzbS5XYXNtRnFQb2x5Q29tbSk7XG4gICAgICAgIHZhciByZXMgPSBbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy8gVE9ETyBDaGVjayB0aGlzLiBDb3VsZCBiZSBvZmYgYnkgMVxuICAgICAgICAgICAgcmVzLnB1c2goY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QoYVtpXSkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgdmFyIHdfY29tbSA9IGNvbnZlcnRBcnJheSh4LndfY29tbSk7XG4gICAgdmFyIHpfY29tbSA9IGNhbWxfcGFsbGFzX3BvbHlfY29tbV9vZl9ydXN0KHguel9jb21tKTtcbiAgICB2YXIgdF9jb21tID0gY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QoeC50X2NvbW0pO1xuICAgIHguZnJlZSgpO1xuICAgIHJldHVybiBbMCwgd19jb21tLCB6X2NvbW0sIHRfY29tbV07XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcV9jb21taXRtZW50c190b19ydXN0LCBjYW1sX3Bhc3RhX2ZxX29wZW5pbmdfcHJvb2ZfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0LCBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0LCBjYW1sX3BhbGxhc19wb2x5X2NvbW1fdG9fcnVzdCwganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yXG52YXIgY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgbWVzc2FnZXMgPSBjYW1sX3Bhc3RhX2ZxX2NvbW1pdG1lbnRzX3RvX3J1c3QoeFsxXSk7XG4gICAgdmFyIHByb29mID0gY2FtbF9wYXN0YV9mcV9vcGVuaW5nX3Byb29mX3RvX3J1c3QoeFsyXSk7XG4gICAgdmFyIGV2YWxzID0gY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0KHhbM10pO1xuICAgIHZhciBmdF9ldmFsMSA9IHhbNF07XG4gICAgdmFyIHB1YmxpY18gPSBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0KHhbNV0pO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXMgPSB4WzZdO1xuICAgIHZhciBjaGFsc19sZW4gPSBwcmV2X2NoYWxsZW5nZXMubGVuZ3RoO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXNfc2NhbGFycyA9IG5ldyBwbG9ua193YXNtLldhc21WZWNWZWNGcShjaGFsc19sZW4gLSAxKTtcbiAgICB2YXIgcHJldl9jaGFsbGVuZ2VzX2NvbW1zID0gbmV3IEFycmF5KGNoYWxzX2xlbiAtIDEpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY2hhbHNfbGVuOyBpKyspIHtcbiAgICAgICAgcHJldl9jaGFsbGVuZ2VzX3NjYWxhcnMucHVzaChjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0KHByZXZfY2hhbGxlbmdlc1tpXVsxXSkpO1xuICAgICAgICBwcmV2X2NoYWxsZW5nZXNfY29tbXNbaSAtIDFdID0gY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QocHJldl9jaGFsbGVuZ2VzW2ldWzJdKTtcbiAgICB9XG4gICAgcHJldl9jaGFsbGVuZ2VzX2NvbW1zID0ganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yKHByZXZfY2hhbGxlbmdlc19jb21tcyk7XG4gICAgcmV0dXJuIG5ldyBwbG9ua193YXNtLldhc21GcVByb3ZlclByb29mKG1lc3NhZ2VzLCBwcm9vZiwgZXZhbHMsIGZ0X2V2YWwxLCBwdWJsaWNfLCBwcmV2X2NoYWxsZW5nZXNfc2NhbGFycywgcHJldl9jaGFsbGVuZ2VzX2NvbW1zKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Byb29mX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZxX2NvbW1pdG1lbnRzX29mX3J1c3QsIGNhbWxfcGFzdGFfZnFfb3BlbmluZ19wcm9vZl9vZl9ydXN0LCBjYW1sX3Bhc3RhX2ZxX3Byb29mX2V2YWx1YXRpb25zX29mX3J1c3QsIGNhbWxfZnFfdmVjdG9yX29mX3J1c3QsIGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvciwgY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Byb29mX29mX3J1c3QgPSBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBtZXNzYWdlcyA9IGNhbWxfcGFzdGFfZnFfY29tbWl0bWVudHNfb2ZfcnVzdCh4LmNvbW1pdG1lbnRzKTtcbiAgICB2YXIgcHJvb2YgPSBjYW1sX3Bhc3RhX2ZxX29wZW5pbmdfcHJvb2Zfb2ZfcnVzdCh4LnByb29mKTtcbiAgICB2YXIgZXZhbHMgPSBjYW1sX3Bhc3RhX2ZxX3Byb29mX2V2YWx1YXRpb25zX29mX3J1c3QoeC5ldmFscyk7XG4gICAgdmFyIGV2YWxzMSA9IGNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCh4LmV2YWxzMSk7XG4gICAgdmFyIGZ0X2V2YWwxID0geC5mdF9ldmFsMTtcbiAgICB2YXIgcHVibGljXyA9IGNhbWxfZnFfdmVjdG9yX29mX3J1c3QoeC5wdWJsaWNfKTtcbiAgICB2YXIgcHJldl9jaGFsbGVuZ2VzX3NjYWxhcnMgPSB4LnByZXZfY2hhbGxlbmdlc19zY2FsYXJzO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXNfY29tbXMgPSBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IoeC5wcmV2X2NoYWxsZW5nZXNfY29tbXMsIHBsb25rX3dhc20uV2FzbUZxUG9seUNvbW0pO1xuICAgIHZhciBjaGFsc19sZW4gPSBwcmV2X2NoYWxsZW5nZXNfY29tbXMubGVuZ3RoO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXMgPSBuZXcgQXJyYXkoY2hhbHNfbGVuKTtcbiAgICBwcmV2X2NoYWxsZW5nZXNbMF0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY2hhbHNfbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheSgzKTtcbiAgICAgICAgcmVzWzBdID0gMDtcbiAgICAgICAgcmVzWzFdID0gY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdChwcmV2X2NoYWxsZW5nZXNfc2NhbGFycy5nZXQoaSAtIDEpKTtcbiAgICAgICAgcmVzWzJdID0gY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QocHJldl9jaGFsbGVuZ2VzX2NvbW1zW2ldKTtcbiAgICAgICAgcHJldl9jaGFsbGVuZ2VzW2ldID0gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gWzAsIG1lc3NhZ2VzLCBwcm9vZiwgZXZhbHMsIGZ0X2V2YWwxLCBwdWJsaWNfLCBwcmV2X2NoYWxsZW5nZXNdO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9mcV92ZWN0b3JfdG9fcnVzdCwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIGNhbWxfcGFzdGFfZnFfcHJvb2Zfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfY3JlYXRlID0gZnVuY3Rpb24gKGluZGV4LCB3aXRuZXNzX2NvbHMsIHByZXZfY2hhbGxlbmdlcywgcHJldl9zZ3MpIHtcbiAgICB2YXIgdyA9IG5ldyBwbG9ua193YXNtLldhc21WZWNWZWNGcSh3aXRuZXNzX2NvbHMubGVuZ3RoIC0gMSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB3aXRuZXNzX2NvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdy5wdXNoKGNhbWxfZnFfdmVjdG9yX3RvX3J1c3Qod2l0bmVzc19jb2xzW2ldKSk7XG4gICAgfVxuICAgIHdpdG5lc3NfY29scyA9IHc7XG4gICAgcHJldl9jaGFsbGVuZ2VzID0gY2FtbF9mcV92ZWN0b3JfdG9fcnVzdChwcmV2X2NoYWxsZW5nZXMpO1xuICAgIHByZXZfc2dzID0gY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvcihwcmV2X3NncywgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSk7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9jcmVhdGUoaW5kZXgsIHdpdG5lc3NfY29scywgcHJldl9jaGFsbGVuZ2VzLCBwcmV2X3Nncyk7XG4gICAgdmFyIHByb29mID0gY2FtbF9wYXN0YV9mcV9wcm9vZl9vZl9ydXN0KHJlcyk7XG4gICAgcmV0dXJuIHByb29mO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfdmVyaWZ5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl92ZXJpZnkgPSBmdW5jdGlvbiAoaW5kZXgsIHByb29mKSB7XG4gICAgaW5kZXggPSBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QoaW5kZXgpO1xuICAgIHByb29mID0gY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0KHByb29mKTtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX3ZlcmlmeShpbmRleCwgcHJvb2YpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfYmF0Y2hfdmVyaWZ5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9iYXRjaF92ZXJpZnkgPSBmdW5jdGlvbiAoaW5kZXhlcywgcHJvb2ZzKSB7XG4gICAgaW5kZXhlcyA9IGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IoaW5kZXhlcywgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0KTtcbiAgICBwcm9vZnMgPSBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yKHByb29mcywgY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0KTtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2JhdGNoX3ZlcmlmeShpbmRleGVzLCBwcm9vZnMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfZHVtbXlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZxX3Byb29mX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2R1bW15ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZxX3Byb29mX29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2R1bW15KCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0LCBjYW1sX3Bhc3RhX2ZxX3Byb29mX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2RlZXBfY29weSA9IGZ1bmN0aW9uIChwcm9vZikge1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZxX3Byb29mX29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2RlZXBfY29weShjYW1sX3Bhc3RhX2ZxX3Byb29mX3RvX3J1c3QocHJvb2YpKSk7XG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3JhbmRvbV9vcmFjbGVzX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3IsIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZFxudmFyIGNhbWxfcmFuZG9tX29yYWNsZXNfb2ZfcnVzdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIGpvaW50X2NvbWJpbmVyX2NoYWwgPSB4LmpvaW50X2NvbWJpbmVyX2NoYWw7XG4gICAgdmFyIGpvaW50X2NvbWJpbmVyID0geC5qb2ludF9jb21iaW5lcjtcbiAgICB2YXIgam9pbnRfY29tYmluZXJfb2NhbWwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGpvaW50X2NvbWJpbmVyX2NoYWwgIT09IHVuZGVmaW5lZCAmJiBqb2ludF9jb21iaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGpvaW50X2NvbWJpbmVyX29jYW1sID0gWzAsIFswLCBqb2ludF9jb21iaW5lcl9jaGFsXSwgam9pbnRfY29tYmluZXJdO1xuICAgIH1cbiAgICByZXR1cm4gWzAsXG4gICAgICAgIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZChqb2ludF9jb21iaW5lcl9vY2FtbCksXG4gICAgICAgIHguYmV0YSxcbiAgICAgICAgeC5nYW1tYSxcbiAgICAgICAgWzAsIHguYWxwaGFfY2hhbF0sXG4gICAgICAgIHguYWxwaGEsXG4gICAgICAgIHguemV0YSxcbiAgICAgICAgeC52LFxuICAgICAgICB4LnUsXG4gICAgICAgIFswLCB4LnpldGFfY2hhbF0sXG4gICAgICAgIFswLCB4LnZfY2hhbF0sXG4gICAgICAgIFswLCB4LnVfY2hhbF1dO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcmFuZG9tX29yYWNsZXNfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvciwgY2FtbF9vcHRpb25fdG9fbWF5YmVfdW5kZWZpbmVkXG52YXIgY2FtbF9yYW5kb21fb3JhY2xlc190b19ydXN0ID0gZnVuY3Rpb24gKHgsIHJvS2xhc3MpIHtcbiAgICAvLyB2YXIgY2FtbF92ZWN0b3IgPSBbMCwgeFsxXSwgeFsyXSwgeFszXVsxXSwgeFs0XSwgeFs1XSwgeFs2XSwgeFs3XSwgeFs4XVsxXSwgeFs5XVsxXSwgeFsxMF1bMV1dO1xuICAgIHZhciBqb2ludF9jb21iaW5lcl9vY2FtbCA9IGNhbWxfb3B0aW9uX3RvX21heWJlX3VuZGVmaW5lZCh4WzFdKTtcbiAgICB2YXIgam9pbnRfY29tYmluZXJfY2hhbCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgam9pbnRfY29tYmluZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGpvaW50X2NvbWJpbmVyX29jYW1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgam9pbnRfY29tYmluZXJfY2hhbCA9IGpvaW50X2NvbWJpbmVyX29jYW1sWzFdWzFdO1xuICAgICAgICBqb2ludF9jb21iaW5lciA9IGpvaW50X2NvbWJpbmVyX29jYW1sWzJdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHJvS2xhc3MoXG4gICAgICAgIGpvaW50X2NvbWJpbmVyX2NoYWwsXG4gICAgICAgIGpvaW50X2NvbWJpbmVyLFxuICAgICAgICB4WzJdLFxuICAgICAgICB4WzNdLFxuICAgICAgICB4WzRdWzFdLFxuICAgICAgICB4WzVdLFxuICAgICAgICB4WzZdLFxuICAgICAgICB4WzddLFxuICAgICAgICB4WzhdLFxuICAgICAgICB4WzldWzFdLFxuICAgICAgICB4WzEwXVsxXSxcbiAgICAgICAgeFsxMV1bMV0pO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfb3JhY2xlc19vZl9ydXN0XG4vLyBSZXF1aXJlczogY2FtbF91OGFycmF5X3ZlY3Rvcl9vZl9ydXN0X2ZsYXRfdmVjdG9yLCBjYW1sX3JhbmRvbV9vcmFjbGVzX29mX3J1c3RcbnZhciBjYW1sX29yYWNsZXNfb2ZfcnVzdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIFswLCBjYW1sX3JhbmRvbV9vcmFjbGVzX29mX3J1c3QoeC5vKSwgWzAsIHgucF9ldmFsMCwgeC5wX2V2YWwxXSwgY2FtbF91OGFycmF5X3ZlY3Rvcl9vZl9ydXN0X2ZsYXRfdmVjdG9yKHgub3BlbmluZ19wcmVjaGFsbGVuZ2VzLCAzMiAvKiBUT0RPOiBEb24ndCBoYXJkY29kZSAqLyksIHguZGlnZXN0X2JlZm9yZV9ldmFsdWF0aW9uc107XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9vcmFjbGVzX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3IsIGNhbWxfcmFuZG9tX29yYWNsZXNfdG9fcnVzdFxudmFyIGNhbWxfb3JhY2xlc190b19ydXN0ID0gZnVuY3Rpb24gKHgsIGtsYXNzLCByb0tsYXNzKSB7XG4gICAgcmV0dXJuIG5ldyBrbGFzcyhcbiAgICAgICAgY2FtbF9yYW5kb21fb3JhY2xlc190b19ydXN0KHhbMV0sIHJvS2xhc3MpLFxuICAgICAgICB4WzJdWzFdLFxuICAgICAgICB4WzJdWzJdLFxuICAgICAgICBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3IoeFszXSksXG4gICAgICAgIHhbNF1cbiAgICApO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogZnBfb3JhY2xlc19jcmVhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX29yYWNsZXNfb2ZfcnVzdCwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdCwgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Byb29mX3RvX3J1c3RcbnZhciBmcF9vcmFjbGVzX2NyZWF0ZSA9IGZ1bmN0aW9uIChsZ3JfY29tbSwgdmVyaWZpZXJfaW5kZXgsIHByb29mKSB7XG4gICAgcmV0dXJuIGNhbWxfb3JhY2xlc19vZl9ydXN0KHBsb25rX3dhc20uZnBfb3JhY2xlc19jcmVhdGUoXG4gICAgICAgIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IobGdyX2NvbW0sIGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QpLFxuICAgICAgICBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QodmVyaWZpZXJfaW5kZXgpLFxuICAgICAgICBjYW1sX3Bhc3RhX2ZwX3Byb29mX3RvX3J1c3QocHJvb2YpXG4gICAgKSk7XG59O1xuXG4vLyBQcm92aWRlczogZnBfb3JhY2xlc19kdW1teVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfb3JhY2xlc19vZl9ydXN0XG52YXIgZnBfb3JhY2xlc19kdW1teSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FtbF9vcmFjbGVzX29mX3J1c3QocGxvbmtfd2FzbS5mcF9vcmFjbGVzX2R1bW15KCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGZwX29yYWNsZXNfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9vcmFjbGVzX29mX3J1c3QsIGNhbWxfb3JhY2xlc190b19ydXN0XG52YXIgZnBfb3JhY2xlc19kZWVwX2NvcHkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBjYW1sX29yYWNsZXNfb2ZfcnVzdChwbG9ua193YXNtLmZwX29yYWNsZXNfZGVlcF9jb3B5KFxuICAgICAgICBjYW1sX29yYWNsZXNfdG9fcnVzdCh4LCBwbG9ua193YXNtLldhc21GcE9yYWNsZXMsIHBsb25rX3dhc20uV2FzbUZwUmFuZG9tT3JhY2xlcykpKTtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGZxX29yYWNsZXNfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9vcmFjbGVzX29mX3J1c3QsIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IsIGNhbWxfcGFsbGFzX3BvbHlfY29tbV90b19ydXN0LCBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QsIGNhbWxfcGFzdGFfZnFfcHJvb2ZfdG9fcnVzdFxudmFyIGZxX29yYWNsZXNfY3JlYXRlID0gZnVuY3Rpb24gKGxncl9jb21tLCB2ZXJpZmllcl9pbmRleCwgcHJvb2YpIHtcbiAgICByZXR1cm4gY2FtbF9vcmFjbGVzX29mX3J1c3QocGxvbmtfd2FzbS5mcV9vcmFjbGVzX2NyZWF0ZShcbiAgICAgICAgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvcihsZ3JfY29tbSwgY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QpLFxuICAgICAgICBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QodmVyaWZpZXJfaW5kZXgpLFxuICAgICAgICBjYW1sX3Bhc3RhX2ZxX3Byb29mX3RvX3J1c3QocHJvb2YpXG4gICAgKSk7XG59O1xuXG4vLyBQcm92aWRlczogZnFfb3JhY2xlc19kdW1teVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfb3JhY2xlc19vZl9ydXN0XG52YXIgZnFfb3JhY2xlc19kdW1teSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FtbF9vcmFjbGVzX29mX3J1c3QocGxvbmtfd2FzbS5mcV9vcmFjbGVzX2R1bW15KCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGZxX29yYWNsZXNfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9vcmFjbGVzX29mX3J1c3QsIGNhbWxfb3JhY2xlc190b19ydXN0XG52YXIgZnFfb3JhY2xlc19kZWVwX2NvcHkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBjYW1sX29yYWNsZXNfb2ZfcnVzdChcbiAgICAgICAgcGxvbmtfd2FzbS5mcV9vcmFjbGVzX2RlZXBfY29weShcbiAgICAgICAgICAgIGNhbWxfb3JhY2xlc190b19ydXN0KHgsIHBsb25rX3dhc20uV2FzbUZxT3JhY2xlcywgcGxvbmtfd2FzbS5XYXNtRnFSYW5kb21PcmFjbGVzKSkpO1xufTtcblxuXG4vLyBUaGlzIGlzIGZha2UgLS0gcGFyYW1ldGVycyBhcmUgb25seSBuZWVkZWQgb24gdGhlIFJ1c3Qgc2lkZSwgc28gbm8gbmVlZCB0byByZXR1cm4gc29tZXRoaW5nIG1lYW5pbmdmdWxcbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bvc2VpZG9uX3BhcmFtc19jcmVhdGVcbmZ1bmN0aW9uIGNhbWxfcGFzdGFfZnBfcG9zZWlkb25fcGFyYW1zX2NyZWF0ZSgpIHtcbiAgICByZXR1cm4gWzBdO1xufVxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcG9zZWlkb25fcGFyYW1zX2NyZWF0ZVxuZnVuY3Rpb24gY2FtbF9wYXN0YV9mcV9wb3NlaWRvbl9wYXJhbXNfY3JlYXRlKCkge1xuICAgIHJldHVybiBbMF07XG59XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bvc2VpZG9uX2Jsb2NrX2NpcGhlclxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QsIGNhbWxfZnBfdmVjdG9yX29mX3J1c3RcbmZ1bmN0aW9uIGNhbWxfcGFzdGFfZnBfcG9zZWlkb25fYmxvY2tfY2lwaGVyKF9mYWtlX3BhcmFtcywgZnBfdmVjdG9yKSB7XG4gICAgLy8gMS4gZ2V0IHBlcm11dGVkIGZpZWxkIHZlY3RvciBmcm9tIHJ1c3RcbiAgICB2YXIgd2FzbV9mbGF0X3ZlY3RvciA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wb3NlaWRvbl9ibG9ja19jaXBoZXIoY2FtbF9mcF92ZWN0b3JfdG9fcnVzdChmcF92ZWN0b3IpKTtcbiAgICB2YXIgbmV3X2ZwX3ZlY3RvciA9IGNhbWxfZnBfdmVjdG9yX29mX3J1c3Qod2FzbV9mbGF0X3ZlY3Rvcik7XG4gICAgLy8gMi4gd3JpdGUgYmFjayBtb2RpZmllZCBmaWVsZCB2ZWN0b3IgdG8gb3JpZ2luYWwgb25lXG4gICAgbmV3X2ZwX3ZlY3Rvci5mb3JFYWNoKGZ1bmN0aW9uIChhLCBpKSB7XG4gICAgICAgIGZwX3ZlY3RvcltpXSA9IGE7XG4gICAgfSk7XG59XG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wb3NlaWRvbl9ibG9ja19jaXBoZXJcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0LCBjYW1sX2ZxX3ZlY3Rvcl9vZl9ydXN0XG5mdW5jdGlvbiBjYW1sX3Bhc3RhX2ZxX3Bvc2VpZG9uX2Jsb2NrX2NpcGhlcihfZmFrZV9wYXJhbXMsIGZxX3ZlY3Rvcikge1xuICAgIC8vIDEuIGdldCBwZXJtdXRlZCBmaWVsZCB2ZWN0b3IgZnJvbSBydXN0XG4gICAgdmFyIHdhc21fZmxhdF92ZWN0b3IgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcG9zZWlkb25fYmxvY2tfY2lwaGVyKGNhbWxfZnFfdmVjdG9yX3RvX3J1c3QoZnFfdmVjdG9yKSk7XG4gICAgdmFyIG5ld19mcV92ZWN0b3IgPSBjYW1sX2ZxX3ZlY3Rvcl9vZl9ydXN0KHdhc21fZmxhdF92ZWN0b3IpO1xuICAgIC8vIDIuIHdyaXRlIGJhY2sgbW9kaWZpZWQgZmllbGQgdmVjdG9yIHRvIG9yaWdpbmFsIG9uZVxuICAgIG5ld19mcV92ZWN0b3IuZm9yRWFjaChmdW5jdGlvbiAoYSwgaSkge1xuICAgICAgICBmcV92ZWN0b3JbaV0gPSBhO1xuICAgIH0pO1xufVxuXG5cbi8vIFByb3ZpZGVzOiBwcm92ZXJfdG9fanNvblxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBwcm92ZXJfdG9fanNvbiA9IHBsb25rX3dhc20ucHJvdmVyX3RvX2pzb247XG5cbi8vIFByb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfb2ZfdWludDMyXG4vLyBSZXF1aXJlczogVUludDY0LCBjYW1sX2ludDY0X29mX2ludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfb2ZfdWludDMyKGkpIHtcbiAgICAvLyBTYW1lIGFzIGludGVnZXJzX3VpbnQ2NF9vZl9pbnRcbiAgICByZXR1cm4gbmV3IFVJbnQ2NChjYW1sX2ludDY0X29mX2ludDMyKGkpKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVGhlICpfZXhhbXBsZV8qIGZ1bmN0aW9ucyBiZWxvdyBhcmUgb25seSB1c2VkIGluIHRoZSBwaWNrbGVzIHVuaXQgdGVzdHMgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZXhhbXBsZV93aXRoX2ZmYWRkXG5mdW5jdGlvbiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2V4YW1wbGVfd2l0aF9mZmFkZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmltcGxlbWVudGVkIGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZXhhbXBsZV93aXRoX2ZmYWRkXCIpO1xufVxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2V4YW1wbGVfd2l0aF9mb3JlaWduX2ZpZWxkX211bFxuZnVuY3Rpb24gY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9leGFtcGxlX3dpdGhfZm9yZWlnbl9maWVsZF9tdWwoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZCBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2V4YW1wbGVfd2l0aF9mb3JlaWduX2ZpZWxkX211bFwiKTtcbn1cblxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9leGFtcGxlX3dpdGhfcmFuZ2VfY2hlY2tcbmZ1bmN0aW9uIGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZXhhbXBsZV93aXRoX3JhbmdlX2NoZWNrKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuaW1wbGVtZW50ZWQgY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9leGFtcGxlX3dpdGhfcmFuZ2VfY2hlY2tcIik7XG59XG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZXhhbXBsZV93aXRoX3JhbmdlX2NoZWNrMFxuZnVuY3Rpb24gY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9leGFtcGxlX3dpdGhfcmFuZ2VfY2hlY2swKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuaW1wbGVtZW50ZWQgY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9leGFtcGxlX3dpdGhfcmFuZ2VfY2hlY2swXCIpO1xufVxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2V4YW1wbGVfd2l0aF9yb3RcbmZ1bmN0aW9uIGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZXhhbXBsZV93aXRoX3JvdCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmltcGxlbWVudGVkIGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZXhhbXBsZV93aXRoX3JvdFwiKTtcbn1cblxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9leGFtcGxlX3dpdGhfeG9yXG5mdW5jdGlvbiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2V4YW1wbGVfd2l0aF94b3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZCBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2V4YW1wbGVfd2l0aF94b3JcIik7XG59XG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZXhhbXBsZV93aXRoX2xvb2t1cFxuZnVuY3Rpb24gY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9leGFtcGxlX3dpdGhfbG9va3VwKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuaW1wbGVtZW50ZWQgY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9leGFtcGxlX3dpdGhfbG9va3VwXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGpzb29fZmxvb3JfbG9nMlxudmFyIGxvZzJfb2sgPSBNYXRoLmxvZzIgJiYgTWF0aC5sb2cyKDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3KSA9PSAxMDIwXG5mdW5jdGlvbiBqc29vX2Zsb29yX2xvZzIoeCkge1xuICBpZihsb2cyX29rKSByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZzIoeCkpXG4gIHZhciBpID0gMDtcbiAgaWYgKHggPT0gMCkgcmV0dXJuIC1JbmZpbml0eTtcbiAgaWYoeD49MSkge3doaWxlICh4Pj0yKSB7eC89MjsgaSsrfSB9XG4gIGVsc2Uge3doaWxlICh4IDwgMSkge3gqPTI7IGktLX0gfTtcbiAgcmV0dXJuIGk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyLCBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaVxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMSwgMCwgMHg3ZmYwKTtcbiAgICBpZiAoeCA+IDApXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMCwgMCwgMHg3ZmYwKVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweGZmZjApXG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8weDgwMDA6KHg+PTApPzA6MHg4MDAwO1xuICBpZiAoc2lnbikgeCA9IC14O1xuICAvLyBJbnQ2NC5iaXRzX29mX2Zsb2F0IDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3ID0gMHg3ZmIwMDAwMDAwMDAwMDAwTFxuICAvLyB1c2luZyBNYXRoLkxPRzJFKk1hdGgubG9nKHgpIGluIHBsYWNlIG9mIE1hdGgubG9nMiByZXN1bHQgaW4gcHJlY2lzaW9uIGxvc3RcbiAgdmFyIGV4cCA9IGpzb29fZmxvb3JfbG9nMih4KSArIDEwMjM7XG4gIGlmIChleHAgPD0gMCkge1xuICAgIGV4cCA9IDA7XG4gICAgeCAvPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgfSBlbHNlIHtcbiAgICB4IC89IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICAgIGlmICh4IDwgMTYpIHtcbiAgICAgIHggKj0gMjsgZXhwIC09MTsgfVxuICAgIGlmIChleHAgPT0gMCkge1xuICAgICAgeCAvPSAyOyB9XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLDI0KTtcbiAgdmFyIHIzID0geHwwO1xuICB4ID0gKHggLSByMykgKiBrO1xuICB2YXIgcjIgPSB4fDA7XG4gIHggPSAoeCAtIHIyKSAqIGs7XG4gIHZhciByMSA9IHh8MDtcbiAgcjMgPSAocjMgJjB4ZikgfCBzaWduIHwgZXhwIDw8IDQ7XG4gIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShyMSwgcjIsIHIzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCAoeCkge1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgZ2xvYmFsVGhpcy5GbG9hdDMyQXJyYXkoMSk7XG4gIGZsb2F0MzJhWzBdID0geDtcbiAgdmFyIGludDMyYSA9IG5ldyBnbG9iYWxUaGlzLkludDMyQXJyYXkoZmxvYXQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGludDMyYVswXSB8IDA7XG59XG5cbi8vRlAgbGl0ZXJhbHMgY2FuIGJlIHdyaXR0ZW4gdXNpbmcgdGhlIGhleGFkZWNpbWFsXG4vL25vdGF0aW9uIDB4PG1hbnRpc3NhIGluIGhleD5wPGV4cG9uZW50PiBmcm9tIElTTyBDOTkuXG4vL2h0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1oZXhmbG9hdC9ibG9iL21hc3Rlci9oZXhmbG9hdC5qc1xuLy9Qcm92aWRlczogY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0ICh4LCBwcmVjLCBzdHlsZSkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoXCJuYW5cIik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nICgoeCA+IDApP1wiaW5maW5pdHlcIjpcIi1pbmZpbml0eVwiKTtcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzE6KHg+PTApPzA6MTtcbiAgaWYoc2lnbikgeCA9IC14O1xuICB2YXIgZXhwID0gMDtcbiAgaWYgKHggPT0gMCkgeyB9XG4gIGVsc2UgaWYgKHggPCAxKSB7XG4gICAgd2hpbGUgKHggPCAxICYmIGV4cCA+IC0xMDIyKSAgeyB4ICo9IDI7IGV4cC0tIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoeCA+PSAyKSB7IHggLz0gMjsgZXhwKysgfVxuICB9XG4gIHZhciBleHBfc2lnbiA9IGV4cCA8IDAgPyAnJyA6ICcrJztcbiAgdmFyIHNpZ25fc3RyID0gJyc7XG4gIGlmIChzaWduKSBzaWduX3N0ciA9ICctJ1xuICBlbHNlIHtcbiAgICBzd2l0Y2goc3R5bGUpe1xuICAgIGNhc2UgNDMgLyogJysnICovOiBzaWduX3N0ciA9ICcrJzsgYnJlYWs7XG4gICAgY2FzZSAzMiAvKiAnICcgKi86IHNpZ25fc3RyID0gJyAnOyBicmVhaztcbiAgICBkZWZhdWx0OiBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHByZWMgPj0gMCAmJiBwcmVjIDwgMTMpIHtcbiAgICAvKiBJZiBhIHByZWNpc2lvbiBpcyBnaXZlbiwgYW5kIGlzIHNtYWxsLCByb3VuZCBtYW50aXNzYSBhY2NvcmRpbmdseSAqL1xuICAgIHZhciBjc3QgPSBNYXRoLnBvdygyLHByZWMgKiA0KTtcbiAgICB4ID0gTWF0aC5yb3VuZCh4ICogY3N0KSAvIGNzdDtcbiAgfVxuICB2YXIgeF9zdHIgPSB4LnRvU3RyaW5nKDE2KTtcbiAgaWYocHJlYyA+PSAwKXtcbiAgICB2YXIgaWR4ID0geF9zdHIuaW5kZXhPZignLicpO1xuICAgIGlmKGlkeDwwKSB7XG4gICAgICB4X3N0ciArPSAnLicgKyBjYW1sX3N0cl9yZXBlYXQocHJlYywgJzAnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2l6ZSA9IGlkeCsxK3ByZWM7XG4gICAgICBpZih4X3N0ci5sZW5ndGggPCBzaXplKVxuICAgICAgICB4X3N0ciArPSBjYW1sX3N0cl9yZXBlYXQoc2l6ZSAtIHhfc3RyLmxlbmd0aCwgJzAnKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeF9zdHIgPSB4X3N0ci5zdWJzdHIoMCxzaXplKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzaWduX3N0ciArICcweCcgKyB4X3N0ciArICdwJyArIGV4cF9zaWduICsgZXhwLnRvU3RyaW5nKDEwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzICh4KSB7XG4gIHZhciBsbyA9IHgubG87XG4gIHZhciBtaSA9IHgubWk7XG4gIHZhciBoaSA9IHguaGk7XG4gIHZhciBleHAgPSAoaGkgJiAweDdmZmYpID4+IDQ7XG4gIGlmIChleHAgPT0gMjA0Nykge1xuICAgIGlmICgobG98bWl8KGhpJjB4ZikpID09IDApXG4gICAgICByZXR1cm4gKGhpICYgMHg4MDAwKT8oLUluZmluaXR5KTpJbmZpbml0eTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTmFOO1xuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwtMjQpO1xuICB2YXIgcmVzID0gKGxvKmsrbWkpKmsrKGhpJjB4Zik7XG4gIGlmIChleHAgPiAwKSB7XG4gICAgcmVzICs9IDE2O1xuICAgIHJlcyAqPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgfSBlbHNlXG4gICAgcmVzICo9IE1hdGgucG93KDIsLTEwMjYpO1xuICBpZiAoaGkgJiAweDgwMDApIHJlcyA9IC0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25leHRhZnRlcl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X3N1YixjYW1sX2ludDY0X29mX2ludDMyXG5mdW5jdGlvbiBjYW1sX25leHRhZnRlcl9mbG9hdCAoeCx5KSB7XG4gIGlmKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gTmFOO1xuICBpZih4PT15KSByZXR1cm4geTtcbiAgaWYoeD09MCl7XG4gICAgaWYoeSA8IDApXG4gICAgICByZXR1cm4gLU1hdGgucG93KDIsIC0xMDc0KVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTA3NClcbiAgfVxuICB2YXIgYml0cyA9IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh4KTtcbiAgdmFyIG9uZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoMSk7XG4gIGlmICgoeDx5KSA9PSAoeD4wKSlcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9hZGQoYml0cywgb25lKVxuICBlbHNlXG4gICAgYml0cyA9IGNhbWxfaW50NjRfc3ViKGJpdHMsIG9uZSlcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhiaXRzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF90cnVuY19mbG9hdFxuZnVuY3Rpb24gY2FtbF90cnVuY19mbG9hdCh4KXtcbiAgcmV0dXJuIE1hdGgudHJ1bmMoeCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzICh4KSB7XG4gIHZhciBpbnQzMmEgPSBuZXcgZ2xvYmFsVGhpcy5JbnQzMkFycmF5KDEpO1xuICBpbnQzMmFbMF0gPSB4O1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgZ2xvYmFsVGhpcy5GbG9hdDMyQXJyYXkoaW50MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBmbG9hdDMyYVswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jbGFzc2lmeV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jbGFzc2lmeV9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpID49IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSByZXR1cm4gMDtcbiAgICBpZiAoeCAhPSAwKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gaXNOYU4oeCk/NDozO1xufVxuLy9Qcm92aWRlczogY2FtbF9tb2RmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX21vZGZfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIHZhciBuZWcgPSAoMS94KSA8IDA7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vciAoeCk7XG4gICAgdmFyIGYgPSB4IC0gaTtcbiAgICBpZiAobmVnKSB7IGkgPSAtaTsgZiA9IC1mOyB9XG4gICAgcmV0dXJuIFswLCBmLCBpXTtcbiAgfVxuICBpZiAoaXNOYU4gKHgpKSByZXR1cm4gWzAsIE5hTiwgTmFOXTtcbiAgcmV0dXJuIFswLCAxL3gsIHhdO1xufVxuLy9Qcm92aWRlczogY2FtbF9sZGV4cF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sZGV4cF9mbG9hdCAoeCxleHApIHtcbiAgZXhwIHw9IDA7XG4gIGlmIChleHAgPiAxMDIzKSB7XG4gICAgZXhwIC09IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICBpZiAoZXhwID4gMTAyMykgeyAgLy8gaW4gY2FzZSB4IGlzIHN1Ym5vcm1hbFxuICAgICAgZXhwIC09IDEwMjM7XG4gICAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhwIDwgLTEwMjMpIHtcbiAgICBleHAgKz0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIC0xMDIzKTtcbiAgfVxuICB4ICo9IE1hdGgucG93KDIsIGV4cCk7XG4gIHJldHVybiB4O1xufVxuLy9Qcm92aWRlczogY2FtbF9mcmV4cF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ZyZXhwX2Zsb2F0ICh4KSB7XG4gIGlmICgoeCA9PSAwKSB8fCAhaXNGaW5pdGUoeCkpIHJldHVybiBbMCwgeCwgMF07XG4gIHZhciBuZWcgPSB4IDwgMDtcbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgdmFyIGV4cCA9IE1hdGgubWF4KC0xMDIzLCBqc29vX2Zsb29yX2xvZzIoeCkgKyAxKTtcbiAgeCAqPSBNYXRoLnBvdygyLC1leHApO1xuICB3aGlsZSAoeCA8IDAuNSkge1xuICAgIHggKj0gMjtcbiAgICBleHAtLTtcbiAgfVxuICB3aGlsZSAoeCA+PSAxKSB7XG4gICAgeCAqPSAwLjU7XG4gICAgZXhwKys7XG4gIH1cbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSAoeCwgeSkge1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIDA7XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeCA+IHkpIHJldHVybiAxO1xuICBpZiAoeCA9PT0geCkgcmV0dXJuIDE7XG4gIGlmICh5ID09PSB5KSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvcHlzaWduX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvcHlzaWduX2Zsb2F0ICh4LCB5KSB7XG4gIGlmICh5ID09IDApIHkgPSAxIC8geTtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICByZXR1cm4gKHkgPCAwKT8oLXgpOng7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2lnbmJpdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaWduYml0X2Zsb2F0KHgpIHtcbiAgaWYgKHggPT0gMCkgeCA9IDEgLyB4O1xuICByZXR1cm4gKHggPCAwKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhwbTFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwbTFfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguZXhwbTEoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZXhwMl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHAyX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgucG93KDIsIHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzFwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzFwX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgubG9nMXAoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cyX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgubG9nMih4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9oeXBvdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9oeXBvdF9mbG9hdCAoeCwgeSkgeyByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTsgfVxuLy9Qcm92aWRlczogY2FtbF9sb2cxMF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxMF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5sb2cxMCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9jb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Nvc2hfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguY29zaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hY29zaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hY29zaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9zaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguc2luaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hc2luaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF90YW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3RhbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgudGFuaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hdGFuaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hdGFuaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9yb3VuZF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9yb3VuZF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9jYnJ0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NicnRfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguY2JydCh4KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VyZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9lcmZfZmxvYXQoeCkge1xuICB2YXIgYTEgPSAwLjI1NDgyOTU5MjtcbiAgdmFyIGEyID0gLTAuMjg0NDk2NzM2O1xuICB2YXIgYTMgPSAxLjQyMTQxMzc0MTtcbiAgdmFyIGE0ID0gLTEuNDUzMTUyMDI3O1xuICB2YXIgYTUgPSAxLjA2MTQwNTQyOTtcbiAgdmFyIHAgPSAwLjMyNzU5MTE7XG5cbiAgdmFyIHNpZ24gPSAxO1xuICBpZiAoeCA8IDApIHtcbiAgICBzaWduID0gLTE7XG4gIH1cbiAgeCA9IE1hdGguYWJzKHgpO1xuICB2YXIgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XG4gIHZhciB5ID0gMS4wIC0gKCgoKGE1ICogdCArIGE0KSAqIHQgKyBhMykgKiB0ICsgYTIpICogdCArIGExKSAqIHQgKiBNYXRoLmV4cCgteCAqIHgpO1xuXG4gIHJldHVybiBzaWduICogeTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcmZjX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2VyZl9mbG9hdFxuZnVuY3Rpb24gY2FtbF9lcmZjX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIDEgLSBjYW1sX2VyZl9mbG9hdCh4KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZtYV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbWFfZmxvYXQoeCwgeSwgeikge1xuICB2YXIgU1BMSVQgPSBNYXRoLnBvdygyLCAyNykgKyAxO1xuICB2YXIgTUlOX1ZBTFVFID0gTWF0aC5wb3coMiwgLTEwMjIpO1xuICB2YXIgRVBTSUxPTiA9IE1hdGgucG93KDIsIC01Mik7XG4gIHZhciBDID0gNDE2O1xuICB2YXIgQSA9IE1hdGgucG93KDIsICtDKTtcbiAgdmFyIEIgPSBNYXRoLnBvdygyLCAtQyk7XG5cbiAgZnVuY3Rpb24gbXVsdGlwbHkgKGEsIGIpIHtcbiAgICB2YXIgYXQgPSBTUExJVCAqIGE7XG4gICAgdmFyIGFoaSA9IGF0IC0gKGF0IC0gYSk7XG4gICAgdmFyIGFsbyA9IGEgLSBhaGk7XG4gICAgdmFyIGJ0ID0gU1BMSVQgKiBiO1xuICAgIHZhciBiaGkgPSBidCAtIChidCAtIGIpO1xuICAgIHZhciBibG8gPSBiIC0gYmhpO1xuICAgIHZhciBwID0gYSAqIGI7XG4gICAgdmFyIGUgPSAoKGFoaSAqIGJoaSAtIHApICsgYWhpICogYmxvICsgYWxvICogYmhpKSArIGFsbyAqIGJsbztcbiAgICByZXR1cm4ge1xuICAgICAgcDogcCxcbiAgICAgIGU6IGVcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHZhciBzID0gYSArIGI7XG4gICAgdmFyIHYgPSBzIC0gYTtcbiAgICB2YXIgZSA9IChhIC0gKHMgLSB2KSkgKyAoYiAtIHYpO1xuICAgIHJldHVybiB7XG4gICAgICBzOiBzLFxuICAgICAgZTogZVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gYWRqdXN0ICh4LCB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgJiYgeSAhPT0gMCAmJiBTUExJVCAqIHggLSAoU1BMSVQgKiB4IC0geCkgPT09IHggPyB4ICogKDEgKyAoeCA8IDAgPyAtMSA6ICsxKSAqICh5IDwgMCA/IC0xIDogKzEpICogRVBTSUxPTikgOiB4O1xuICB9O1xuXG4gIGlmICh4ID09PSAwIHx8IHggIT09IHggfHwgeCA9PT0gKzEgLyAwIHx8IHggPT09IC0xIC8gMCB8fFxuICAgICAgeSA9PT0gMCB8fCB5ICE9PSB5IHx8IHkgPT09ICsxIC8gMCB8fCB5ID09PSAtMSAvIDApIHtcbiAgICByZXR1cm4geCAqIHkgKyB6O1xuICB9XG4gIGlmICh6ID09PSAwKSB7XG4gICAgcmV0dXJuIHggKiB5O1xuICB9XG4gIGlmICh6ICE9PSB6IHx8IHogPT09ICsxIC8gMCB8fCB6ID09PSAtMSAvIDApIHtcbiAgICByZXR1cm4gejtcbiAgfVxuXG4gIHZhciBzY2FsZSA9IDE7XG4gIHdoaWxlIChNYXRoLmFicyh4KSA+IEEpIHtcbiAgICBzY2FsZSAqPSBBO1xuICAgIHggKj0gQjtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeSkgPiBBKSB7XG4gICAgc2NhbGUgKj0gQTtcbiAgICB5ICo9IEI7XG4gIH1cbiAgaWYgKHNjYWxlID09PSAxIC8gMCkge1xuICAgIHJldHVybiB4ICogeSAqIHNjYWxlO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh4KSA8IEIpIHtcbiAgICBzY2FsZSAqPSBCO1xuICAgIHggKj0gQTtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeSkgPCBCKSB7XG4gICAgc2NhbGUgKj0gQjtcbiAgICB5ICo9IEE7XG4gIH1cbiAgaWYgKHNjYWxlID09PSAwKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cblxuICB2YXIgeHMgPSB4O1xuICB2YXIgeXMgPSB5O1xuICB2YXIgenMgPSB6IC8gc2NhbGU7XG5cbiAgaWYgKE1hdGguYWJzKHpzKSA+IE1hdGguYWJzKHhzICogeXMpICogNCAvIEVQU0lMT04pIHtcbiAgICByZXR1cm4gejtcbiAgfVxuICBpZiAoTWF0aC5hYnMoenMpIDwgTWF0aC5hYnMoeHMgKiB5cykgKiBFUFNJTE9OIC8gNCAqIEVQU0lMT04gLyA0KSB7XG4gICAgenMgPSAoeiA8IDAgPyAtMSA6ICsxKSAqIE1JTl9WQUxVRTtcbiAgfVxuXG4gIHZhciB4eSA9IG11bHRpcGx5KHhzLCB5cyk7XG4gIHZhciBzID0gYWRkKHh5LnAsIHpzKTtcbiAgdmFyIHUgPSBhZGQoeHkuZSwgcy5lKTtcbiAgdmFyIGkgPSBhZGQocy5zLCB1LnMpO1xuXG4gIHZhciBmID0gaS5zICsgYWRqdXN0KGkuZSwgdS5lKTtcbiAgaWYgKGYgPT09IDApIHtcbiAgICByZXR1cm4gZjtcbiAgfVxuXG4gIHZhciBmcyA9IGYgKiBzY2FsZTtcbiAgaWYgKE1hdGguYWJzKGZzKSA+IE1JTl9WQUxVRSkge1xuICAgIHJldHVybiBmcztcbiAgfVxuXG4gIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlcmUgd2FzIGV4dHJhIHJvdW5kaW5nIGZvciBhIGRlbm9ybWFsaXplZCB2YWx1ZS5cbiAgcmV0dXJuIGZzICsgYWRqdXN0KGYgLSBmcyAvIHNjYWxlLCBpLmUpICogc2NhbGU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfZmxvYXQgKGZtdCwgeCkge1xuICBmdW5jdGlvbiB0b0ZpeGVkKHgsZHApIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPCAxLjApIHtcbiAgICAgIHJldHVybiB4LnRvRml4ZWQoZHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZSA9IHBhcnNlSW50KHgudG9TdHJpbmcoKS5zcGxpdCgnKycpWzFdKTtcbiAgICAgIGlmIChlID4gMjApIHtcbiAgICAgICAgZSAtPSAyMDtcbiAgICAgICAgeCAvPSBNYXRoLnBvdygxMCxlKTtcbiAgICAgICAgeCArPSAobmV3IEFycmF5KGUrMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgaWYoZHAgPiAwKSB7XG4gICAgICAgICAgeCA9IHggKyAnLicgKyAobmV3IEFycmF5KGRwKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICBlbHNlIHJldHVybiB4LnRvRml4ZWQoZHApXG4gICAgfVxuICB9XG4gIHZhciBzLCBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgdmFyIHByZWMgPSAoZi5wcmVjIDwgMCk/NjpmLnByZWM7XG4gIGlmICh4IDwgMCB8fCAoeCA9PSAwICYmIDEveCA9PSAtSW5maW5pdHkpKSB7IGYuc2lnbiA9IC0xOyB4ID0gLXg7IH1cbiAgaWYgKGlzTmFOKHgpKSB7IHMgPSBcIm5hblwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlIGlmICghaXNGaW5pdGUoeCkpIHsgcyA9IFwiaW5mXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2VcbiAgICBzd2l0Y2ggKGYuY29udikge1xuICAgIGNhc2UgJ2UnOlxuICAgICAgdmFyIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyk7XG4gICAgICAvLyBleHBvbmVudCBzaG91bGQgYmUgYXQgbGVhc3QgdHdvIGRpZ2l0c1xuICAgICAgdmFyIGkgPSBzLmxlbmd0aDtcbiAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZic6XG4gICAgICBzID0gdG9GaXhlZCh4LCBwcmVjKTsgYnJlYWs7XG4gICAgY2FzZSAnZyc6XG4gICAgICBwcmVjID0gcHJlYz9wcmVjOjE7XG4gICAgICBzID0geC50b0V4cG9uZW50aWFsKHByZWMgLSAxKTtcbiAgICAgIHZhciBqID0gcy5pbmRleE9mKCdlJyk7XG4gICAgICB2YXIgZXhwID0gK3Muc2xpY2UoaiArIDEpO1xuICAgICAgaWYgKGV4cCA8IC00IHx8IHggPj0gMWUyMSB8fCB4LnRvRml4ZWQoMCkubGVuZ3RoID4gcHJlYykge1xuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgIHZhciBpID0gaiAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSkgKyBzLnNsaWNlKGopO1xuICAgICAgICBpID0gcy5sZW5ndGg7XG4gICAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHAgPSBwcmVjO1xuICAgICAgICBpZiAoZXhwIDwgMCkgeyBwIC09IGV4cCArIDE7IHMgPSB4LnRvRml4ZWQocCk7IH1cbiAgICAgICAgZWxzZSB3aGlsZSAocyA9IHgudG9GaXhlZChwKSwgcy5sZW5ndGggPiBwcmVjICsgMSkgcC0tO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgICB2YXIgaSA9IHMubGVuZ3RoIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHJlcztcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocylcbiAgcmVzID0gK3M7XG4gIGlmICgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSByZXR1cm4gcmVzO1xuICBzID0gcy5yZXBsYWNlKC9fL2csXCJcIik7XG4gIHJlcyA9ICtzO1xuICBpZiAoKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHx8IC9eWystXT9uYW4kL2kudGVzdChzKSkgcmV0dXJuIHJlcztcbiAgdmFyIG0gPSAvXiAqKFsrLV0/KTB4KFswLTlhLWZdKylcXC4/KFswLTlhLWZdKikocChbKy1dP1swLTldKykpPy9pLmV4ZWMocyk7XG4gIC8vICAgICAgICAgIDEgICAgICAgIDIgICAgICAgICAgICAgMyAgICAgICAgICAgNVxuICBpZihtKXtcbiAgICB2YXIgbTMgPSBtWzNdLnJlcGxhY2UoLzArJC8sJycpO1xuICAgIHZhciBtYW50aXNzYSA9IHBhcnNlSW50KG1bMV0gKyBtWzJdICsgbTMsIDE2KTtcbiAgICB2YXIgZXhwb25lbnQgPSAobVs1XXwwKSAtIDQqbTMubGVuZ3RoO1xuICAgIHJlcyA9IG1hbnRpc3NhICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYoL15cXCs/aW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIEluZmluaXR5O1xuICBpZigvXi1pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gLUluZmluaXR5O1xuICBjYW1sX2ZhaWx3aXRoKFwiZmxvYXRfb2Zfc3RyaW5nXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQW4gT0NhbWwgc3RyaW5nIGlzIGFuIG9iamVjdCB3aXRoIHRocmVlIGZpZWxkczpcbi8vIC0gdGFnICd0J1xuLy8gLSBsZW5ndGggJ2wnXG4vLyAtIGNvbnRlbnRzICdjJ1xuLy9cbi8vIFRoZSBjb250ZW50cyBvZiB0aGUgc3RyaW5nIGNhbiBiZSBlaXRoZXIgYSBKYXZhU2NyaXB0IGFycmF5IG9yXG4vLyBhIEphdmFTY3JpcHQgc3RyaW5nLiBUaGUgbGVuZ3RoIG9mIHRoaXMgc3RyaW5nIGNhbiBiZSBsZXNzIHRoYW4gdGhlXG4vLyBsZW5ndGggb2YgdGhlIE9DYW1sIHN0cmluZy4gSW4gdGhpcyBjYXNlLCByZW1haW5pbmcgYnl0ZXMgYXJlXG4vLyBhc3N1bWVkIHRvIGJlIHplcm9lcy4gQXJyYXlzIGFyZSBtdXRhYmxlIGJ1dCBjb25zdW1lcyBtb3JlIG1lbW9yeVxuLy8gdGhhbiBzdHJpbmdzLiBBIGNvbW1vbiBwYXR0ZXJuIGlzIHRvIHN0YXJ0IGZyb20gYW4gZW1wdHkgc3RyaW5nIGFuZFxuLy8gcHJvZ3Jlc3NpdmVseSBmaWxsIGl0IGZyb20gdGhlIHN0YXJ0LiBQYXJ0aWFsIHN0cmluZ3MgbWFrZXMgaXRcbi8vIHBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGVmZmljaWVudGx5LlxuLy9cbi8vIFdoZW4gY29udmVydGluZyB0byBhbmQgZnJvbSBVVEYtMTYsIHdlIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGVcbi8vIHN0cmluZyBpcyBjb21wb3NlZCBvbmx5IG9mIEFTQ0lJIGNoYXJhY3RlcnMgKGluIHdoaWNoIGNhc2UsIG5vXG4vLyBjb252ZXJzaW9uIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCkgb3Igbm90LlxuLy9cbi8vIFRoZSBzdHJpbmcgdGFnIGNhbiB0aHVzIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4vLyAgIGZ1bGwgc3RyaW5nICAgICBCWVRFIHwgVU5LTk9XTjogICAgICAwXG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgQVNDSUk6ICAgICAgICA5XG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgTk9UX0FTQ0lJOiAgICA4XG4vLyAgIHN0cmluZyBwcmVmaXggICBQQVJUSUFMOiAgICAgICAgICAgICAyXG4vLyAgIGFycmF5ICAgICAgICAgICBBUlJBWTogICAgICAgICAgICAgICA0XG4vL1xuLy8gT25lIGNhbiB1c2UgYml0IG1hc2tpbmcgdG8gZGlzY3JpbWluYXRlIHRoZXNlIGRpZmZlcmVudCBjYXNlczpcbi8vICAga25vd25fZW5jb2RpbmcoeCkgPSB4Jjhcbi8vICAgaXNfYXNjaWkoeCkgPSAgICAgICB4JjFcbi8vICAga2luZCh4KSA9ICAgICAgICAgICB4JjZcblxuLy9Qcm92aWRlczogY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX3N0cl9yZXBlYXQobiwgcykge1xuICBpZihuID09IDApIHJldHVybiBcIlwiO1xuICBpZiAocy5yZXBlYXQpIHtyZXR1cm4gcy5yZXBlYXQobik7fSAvLyBFQ01Bc2NyaXB0IDYgYW5kIEZpcmVmb3ggMjQrXG4gIHZhciByID0gXCJcIiwgbCA9IDA7XG4gIGZvcig7Oykge1xuICAgIGlmIChuICYgMSkgciArPSBzO1xuICAgIG4gPj49IDE7XG4gICAgaWYgKG4gPT0gMCkgcmV0dXJuIHI7XG4gICAgcyArPSBzO1xuICAgIGwrKztcbiAgICBpZiAobCA9PSA5KSB7XG4gICAgICBzLnNsaWNlKDAsMSk7IC8vIGZsYXR0ZW4gdGhlIHN0cmluZ1xuICAgICAgLy8gdGhlbiwgdGhlIGZsYXR0ZW5pbmcgb2YgdGhlIHdob2xlIHN0cmluZyB3aWxsIGJlIGZhc3RlcixcbiAgICAgIC8vIGFzIGl0IHdpbGwgYmUgY29tcG9zZWQgb2YgbGFyZ2VyIHBpZWNlc1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbi8vV2Vha2RlZlxuLy8gUHJlIEVDTUFTY3JpcHQgNSwgW2FwcGx5XSB3b3VsZCBub3Qgc3VwcG9ydCBhcnJheS1saWtlIG9iamVjdC5cbi8vIEluIHN1Y2ggc2V0dXAsIFR5cGVkX2FycmF5IHdvdWxkIGJlIGltcGxlbWVudGVkIGFzIHBvbHlmaWxsLCBhbmQgW2YuYXBwbHldIHdvdWxkXG4vLyBmYWlsIGhlcmUuIE1hcmsgdGhlIHByaW1pdGl2ZSBhcyBXZWFrZGVmLCBzbyB0aGF0IHBlb3BsZSBjYW4gb3ZlcnJpZGUgaXQgZWFzaWx5LlxuZnVuY3Rpb24gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChhLCBpLCBsZW4pIHtcbiAgdmFyIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICBpZiAoaSA9PSAwICYmIGxlbiA8PSA0MDk2ICYmIGxlbiA9PSBhLmxlbmd0aCkgcmV0dXJuIGYuYXBwbHkgKG51bGwsIGEpO1xuICB2YXIgcyA9IFwiXCI7XG4gIGZvciAoOyAwIDwgbGVuOyBpICs9IDEwMjQsbGVuLT0xMDI0KVxuICAgIHMgKz0gZi5hcHBseSAobnVsbCwgYS5zbGljZShpLGkgKyBNYXRoLm1pbihsZW4sIDEwMjQpKSk7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0Zjhfb2ZfdXRmMTZcbmZ1bmN0aW9uIGNhbWxfdXRmOF9vZl91dGYxNihzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gYiwgYywgZCwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCAoYyA+PiA2KSk7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZGZmZikge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTAgfCAoYyA+PiAxMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhkYmZmIHx8IGkgKyAxID09IGwgfHxcbiAgICAgICAgICAgICAgIChkID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgZCA+IDB4ZGZmZikge1xuICAgICAgLy8gVW5tYXRjaGVkIHN1cnJvZ2F0ZSBwYWlyLCByZXBsYWNlZCBieSBcXHVmZmZkIChyZXBsYWNlbWVudCBjaGFyYWN0ZXIpXG4gICAgICB0ICs9IFwiXFx4ZWZcXHhiZlxceGJkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICAgIGMgPSAoYyA8PCAxMCkgKyBkIC0gMHgzNWZkYzAwO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZjAgfCAoYyA+PiAxOCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH1cbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gY2FtbF91dGYxNl9vZl91dGY4KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBcIlwiLCBjLCBjMSwgYzIsIHYsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjMSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYzEgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMxID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIHYgPSAxO1xuICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICBjID0gYzIgKyAoYzEgPDwgNik7XG4gICAgICBpZiAoYzEgPCAweGUwKSB7XG4gICAgICAgIHYgPSBjIC0gMHgzMDgwO1xuICAgICAgICBpZiAodiA8IDB4ODApIHYgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IDI7XG4gICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICAgICAgYyA9IGMyICsgKGMgPDwgNik7XG4gICAgICAgICAgaWYgKGMxIDwgMHhmMCkge1xuICAgICAgICAgICAgdiA9IGMgLSAweGUyMDgwO1xuICAgICAgICAgICAgaWYgKCh2IDwgMHg4MDApIHx8ICgodiA+PSAweGQ3ZmYpICYmICh2IDwgMHhlMDAwKSkpIHYgPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gMztcbiAgICAgICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGMxIDwgMHhmNSkpIHtcbiAgICAgICAgICAgICAgdiA9IGMyIC0gMHgzYzgyMDgwICsgKGMgPDwgNik7XG4gICAgICAgICAgICAgIGlmICh2IDwgMHgxMDAwMCB8fCB2ID4gMHgxMGZmZmYpIHYgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodiA8IDQpIHsgLy8gSW52YWxpZCBzZXF1ZW5jZVxuICAgICAgaSAtPSB2O1xuICAgICAgdCArPSBcIlxcdWZmZmRcIjtcbiAgICB9IGVsc2UgaWYgKHYgPiAweGZmZmYpXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkN2MwICsgKHYgPj4gMTApLCAweGRjMDAgKyAodiAmIDB4M0ZGKSlcbiAgICBlbHNlXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2lzX2FzY2lpXG5mdW5jdGlvbiBqc29vX2lzX2FzY2lpIChzKSB7XG4gIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2V0cyBiZXR0ZXIgYXQgYXJvdW5kIHRoaXMgcG9pbnQgZm9yIGFsbCBicm93c2Vyc1xuICBpZiAocy5sZW5ndGggPCAyNCkge1xuICAgIC8vIFNwaWRlcm1vbmtleSBnZXRzIG11Y2ggc2xvd2VyIHdoZW4gcy5sZW5ndGggPj0gMjQgKG9uIDY0IGJpdCBhcmNocylcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIGlmIChzLmNoYXJDb2RlQXQoaSkgPiAxMjcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuICEvW15cXHgwMC1cXHg3Zl0vLnRlc3Qocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBpZiAoaSA+PSBzLmMubGVuZ3RoKSByZXR1cm4gMDtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBzLmNbaV1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIC8vIFRoZSBPQ2FtbCBjb21waWxlciB1c2VzIENoYXIudW5zYWZlX2NociBvbiBpbnRlZ2VycyBsYXJnZXIgdGhhbiAyNTUhXG4gIGMgJj0gMHhmZjtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSB7XG4gICAgaWYgKGkgPT0gcy5jLmxlbmd0aCkge1xuICAgICAgcy5jICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgaWYgKGkgKyAxID09IHMubCkgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKTtcbiAgfVxuICBzLmNbaV0gPSBjO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDEpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDcpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNil7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIyID0gMHhGRiAmIGkxNiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTE2O1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQxNlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiNCA9IDB4RkYgJiBpMzIgPj4gMjQsXG4gICAgICBiMyA9IDB4RkYgJiBpMzIgPj4gMTYsXG4gICAgICBiMiA9IDB4RkYgJiBpMzIgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkzMjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDIsIGIzKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMywgYjQpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDMyXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQzMlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCl7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGk2NCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyA3IC0gaiwgYVtqXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQ2NFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcgKHMpIHtcbiAgdmFyIHRhZyA9IDkgLyogQllURVMgfCBBU0NJSSAqLztcbiAgaWYgKCFqc29vX2lzX2FzY2lpKHMpKVxuICAgIHRhZyA9IDggLyogQllURVMgfCBOT1RfQVNDSUkgKi8sIHMgPSBjYW1sX3V0Zjhfb2ZfdXRmMTYocyk7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0YWcsIHMsIHMubGVuZ3RoKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBqc29vX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIE1sQnl0ZXMgKHRhZywgY29udGVudHMsIGxlbmd0aCkge1xuICB0aGlzLnQ9dGFnOyB0aGlzLmM9Y29udGVudHM7IHRoaXMubD1sZW5ndGg7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHN3aXRjaCAodGhpcy50KSB7XG4gIGNhc2UgOTogLypCWVRFUyB8IEFTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICBkZWZhdWx0OlxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXModGhpcyk7XG4gIGNhc2UgMDogLypCWVRFUyB8IFVOS09XTiovXG4gICAgaWYgKGpzb29faXNfYXNjaWkodGhpcy5jKSkge1xuICAgICAgdGhpcy50ID0gOTsgLypCWVRFUyB8IEFTQ0lJKi9cbiAgICAgIHJldHVybiB0aGlzLmM7XG4gICAgfVxuICAgIHRoaXMudCA9IDg7IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICBjYXNlIDg6IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIH1cbn07XG5NbEJ5dGVzLnByb3RvdHlwZS50b1V0ZjE2ID0gZnVuY3Rpb24gKCl7XG4gIHZhciByID0gdGhpcy50b1N0cmluZygpO1xuICBpZih0aGlzLnQgPT0gOSkgcmV0dXJuIHJcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChyKTtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKCl7XG4gIHZhciBjb250ZW50ID0gdGhpcy50ID09IDQgPyB0aGlzLmMuc2xpY2UoKSA6IHRoaXMuYztcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRoaXMudCxjb250ZW50LHRoaXMubCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEJZVEVTICovXG4gIGlmIChzLnQgPT0gMiAvKiBQQVJUSUFMICovKVxuICAgIHMuYyArPSBjYW1sX3N0cl9yZXBlYXQocy5sIC0gcy5jLmxlbmd0aCwgJ1xcMCcpXG4gIGVsc2VcbiAgICBzLmMgPSBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKHMuYywgMCwgcy5jLmxlbmd0aCk7XG4gIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocykge1xuICAvKiBBc3N1bWVzIG5vdCBBUlJBWSAqL1xuICBpZihnbG9iYWxUaGlzLlVpbnQ4QXJyYXkpIHtcbiAgICB2YXIgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkocy5sKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheShzLmwpO1xuICB9XG4gIHZhciBiID0gcy5jLCBsID0gYi5sZW5ndGgsIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgZm9yIChsID0gcy5sOyBpIDwgbDsgaSsrKSBhW2ldID0gMDtcbiAgcy5jID0gYTtcbiAgcy50ID0gNDsgLyogQVJSQVkgKi9cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2ZfYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX2J5dGVzIChzKSB7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIGwgPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgaWYobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCeXRlcy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGEpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKGEsMCxhLmxlbmd0aCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBuZXcgTWxCeXRlcyg0LGEsYS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczIsczEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMyLHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09IDAgJiYgKGwgPj0gcy5sIHx8IChzLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGwgPj0gcy5jLmxlbmd0aCkpKSB7XG4gICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdCAobCwgU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgIHMudCA9IChsID09IHMubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSBzLmNbaV0gPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9maWxsX2J5dGVzXG52YXIgY2FtbF9maWxsX3N0cmluZyA9IGNhbWxfZmlsbF9ieXRlc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JsaXRfYnl0ZXMoczEsIGkxLCBzMiwgaTIsIGxlbikge1xuICBpZiAobGVuID09IDApIHJldHVybiAwO1xuICBpZiAoKGkyID09IDApICYmXG4gICAgICAobGVuID49IHMyLmwgfHwgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGxlbiA+PSBzMi5jLmxlbmd0aCkpKSB7XG4gICAgczIuYyA9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2UgaWYgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGkyID09IHMyLmMubGVuZ3RoKSB7XG4gICAgczIuYyArPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIHtcbiAgICBpZiAoczIudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkoczIpO1xuICAgIHZhciBjMSA9IHMxLmMsIGMyID0gczIuYztcbiAgICBpZiAoczEudCA9PSA0IC8qIEFSUkFZICovKSB7XG4gICAgICBpZiAoaTIgPD0gaTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGwgPSBNYXRoLm1pbiAobGVuLCBjMS5sZW5ndGggLSBpMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgYzIgW2kyICsgaV0gPSBjMS5jaGFyQ29kZUF0KGkxICsgaSk7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2JsaXRfc3RyaW5nKGEsYixjLGQsZSkge1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcoYSksYixjLGQsZSk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKSB7IHJldHVybiBzLmwgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIHMuY2hhckNvZGVBdChpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ191bnNhZmVfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIHMubGVuZ3RoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmUgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8tMTooczEgPiBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPD0gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW4gY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7XG4gIChzLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzLmMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0Zjhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykge1xuICBpZihqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBzO1xuICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHMpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgaWYgKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocylcbiAgZWxzZSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX3V0Zjhfb2ZfdXRmMTYocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKSB7IHJldHVybiBuZXcgTWxCeXRlcygwLHMscy5sZW5ndGgpOyB9XG5cblxuLy8gVGhlIHNlY3Rpb24gYmVsb3cgc2hvdWxkIGJlIHVzZWQgd2hlbiB1c2UtanMtc3RyaW5nPWZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0KHMsaSxjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfY29tcGFyZShzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19lcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgeyByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcocykge1xuICAocy50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIHMuYyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocyl7XG4gIHJldHVybiBzLnRvVXRmMTYoKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfYnl0ZXMocykge1xuICByZXR1cm4gKHMgaW5zdGFuY2VvZiBNbEJ5dGVzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ieXRlc19jb250ZW50XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2NvbnRlbnQocykge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICByZXR1cm4gcy5jO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHMuY1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfc3RyaW5nKHMpIHtcbiAgcmV0dXJuICh0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIiAmJiAhL1teXFx4MDAtXFx4ZmZdLy50ZXN0KHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfaXNfbWxfYnl0ZXMocyk7XG59XG5cbi8vIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIGRlcHJlY2F0ZWRcblxuLy9Qcm92aWRlczogY2FtbF9qc190b19ieXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9qc190b19ieXRlX3N0cmluZyhzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX25ld19zdHJpbmcgKHMpIHsgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF90b19qc19zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF90b19qc19zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc190b19zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX3RvX3N0cmluZyAocykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocyk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBnbG9iYWxUaGlzLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzLnZlcnNpb25zICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGdsb2JhbFRoaXMucHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJylcbn1cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCAoKSB7XG4gIHJldHVybiBmYWxzZVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9SZXF1aXJlczogTWxOb2RlRmlsZSwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzXG4vL1JlcXVpcmVzOiBtYWtlX3VuaXhfZXJyX2FyZ3MsIGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiBNbE5vZGVEZXZpY2Uocm9vdCkge1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubm0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAodGhpcy5yb290ICsgbmFtZSk7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbihuYW1lLCBtb2RlLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5ta2RpclN5bmModGhpcy5ubShuYW1lKSx7bW9kZTptb2RlfSk7XG4gICAgcmV0dXJuIDBcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ybWRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJtZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMucmVhZGRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzRGlyZWN0b3J5KCk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBiID0gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgICB0aGlzLmZzLnVubGlua1N5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIGI7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIGNvbnN0cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBrZXkgaW4gZil7XG4gICAgc3dpdGNoKGtleSl7XG4gICAgY2FzZSBcInJkb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19SRE9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJ3cm9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fV1JPTkxZOyBicmVhaztcbiAgICBjYXNlIFwiYXBwZW5kXCIgIDpcbiAgICAgIHJlcyB8PSBjb25zdHMuT19XUk9OTFkgfCBjb25zdHMuT19BUFBFTkQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY3JlYXRlXCIgICA6IHJlcyB8PSBjb25zdHMuT19DUkVBVDsgICAgYnJlYWs7XG4gICAgY2FzZSBcInRydW5jYXRlXCIgOiByZXMgfD0gY29uc3RzLk9fVFJVTkM7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJleGNsXCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX0VYQ0w7ICAgICBicmVhaztcbiAgICBjYXNlIFwiYmluYXJ5XCIgICA6IHJlcyB8PSBjb25zdHMuT19CSU5BUlk7ICAgYnJlYWs7XG4gICAgY2FzZSBcInRleHRcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fVEVYVDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub25ibG9ja1wiIDogcmVzIHw9IGNvbnN0cy5PX05PTkJMT0NLOyBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgZmQgPSB0aGlzLmZzLm9wZW5TeW5jKHRoaXMubm0obmFtZSksIHJlcyk7XG4gICAgcmV0dXJuIG5ldyBNbE5vZGVGaWxlKGZkKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKG8sIG4sIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3RhdCA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIganNfc3RhdHMgPSB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiB0aGlzLnN0YXRzX2Zyb21fanMoanNfc3RhdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmxzdGF0ID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMubHN0YXRTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiB0aGlzLnN0YXRzX2Zyb21fanMoanNfc3RhdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnN5bWxpbmsgPSBmdW5jdGlvbih0b19kaXIsIHRhcmdldCwgcGF0aCwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMuc3ltbGlua1N5bmModGhpcy5ubSh0YXJnZXQpLCB0aGlzLm5tKHBhdGgpLCB0b19kaXIgPyAnZGlyJyA6ICdmaWxlJyk7XG4gICAgcmV0dXJuIDA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGxpbmsgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGxpbmsgPSB0aGlzLmZzLnJlYWRsaW5rU3luYyh0aGlzLm5tKG5hbWUpLCAndXRmOCcpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhsaW5rKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yYWlzZV9ub2RlanNfZXJyb3IgPSBmdW5jdGlvbihlcnIsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSBjYW1sX25hbWVkX3ZhbHVlKFwiVW5peC5Vbml4X2Vycm9yXCIpO1xuICBpZiAocmFpc2VfdW5peCAmJiB1bml4X2Vycm9yKSB7XG4gICAgdmFyIGFyZ3MgPSBtYWtlX3VuaXhfZXJyX2FyZ3MoZXJyLmNvZGUsIGVyci5zeXNjYWxsLCBlcnIucGF0aCwgZXJyLmVycm5vKTtcbiAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3RhdHNfZnJvbV9qcyA9IGZ1bmN0aW9uKGpzX3N0YXRzKSB7XG4gIC8qID09PVVuaXguZmlsZV9raW5kPT09XG4gICAqIHR5cGUgZmlsZV9raW5kID1cbiAgICogICAgIFNfUkVHICAgICAgICAgICAgICAgICAgICAgICAoKiogUmVndWxhciBmaWxlICopXG4gICAqICAgfCBTX0RJUiAgICAgICAgICAgICAgICAgICAgICAgKCoqIERpcmVjdG9yeSAqKVxuICAgKiAgIHwgU19DSFIgICAgICAgICAgICAgICAgICAgICAgICgqKiBDaGFyYWN0ZXIgZGV2aWNlICopXG4gICAqICAgfCBTX0JMSyAgICAgICAgICAgICAgICAgICAgICAgKCoqIEJsb2NrIGRldmljZSAqKVxuICAgKiAgIHwgU19MTksgICAgICAgICAgICAgICAgICAgICAgICgqKiBTeW1ib2xpYyBsaW5rICopXG4gICAqICAgfCBTX0ZJRk8gICAgICAgICAgICAgICAgICAgICAgKCoqIE5hbWVkIHBpcGUgKilcbiAgICogICB8IFNfU09DSyAgICAgICAgICAgICAgICAgICAgICAoKiogU29ja2V0ICopXG4gICAqL1xuICB2YXIgZmlsZV9raW5kO1xuICBpZiAoanNfc3RhdHMuaXNGaWxlKCkpIHtcbiAgICBmaWxlX2tpbmQgPSAwO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBmaWxlX2tpbmQgPSAxO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzQ2hhcmFjdGVyRGV2aWNlKCkpIHtcbiAgICBmaWxlX2tpbmQgPSAyO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzQmxvY2tEZXZpY2UoKSkge1xuICAgIGZpbGVfa2luZCA9IDM7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgIGZpbGVfa2luZCA9IDQ7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNGSUZPKCkpIHtcbiAgICBmaWxlX2tpbmQgPSA1O1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzU29ja2V0KCkpIHtcbiAgICBmaWxlX2tpbmQgPSA2O1xuICB9XG4gIC8qID09PVVuaXguc3RhdHM9PT1cbiAgICogdHlwZSBzdGF0cyA9XG4gICAqICB7IHN0X2RldiA6IGludDsgICAgICAgICAgICAgICAoKiogRGV2aWNlIG51bWJlciAqKVxuICAgKiAgICBzdF9pbm8gOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIElub2RlIG51bWJlciAqKVxuICAgKiAgICBzdF9raW5kIDogZmlsZV9raW5kOyAgICAgICAgKCoqIEtpbmQgb2YgdGhlIGZpbGUgKilcbiAgICogICAgc3RfcGVybSA6IGZpbGVfcGVybTsgICAgICAgICgqKiBBY2Nlc3MgcmlnaHRzICopXG4gICAqICAgIHN0X25saW5rIDogaW50OyAgICAgICAgICAgICAoKiogTnVtYmVyIG9mIGxpbmtzICopXG4gICAqICAgIHN0X3VpZCA6IGludDsgICAgICAgICAgICAgICAoKiogVXNlciBpZCBvZiB0aGUgb3duZXIgKilcbiAgICogICAgc3RfZ2lkIDogaW50OyAgICAgICAgICAgICAgICgqKiBHcm91cCBJRCBvZiB0aGUgZmlsZSdzIGdyb3VwICopXG4gICAqICAgIHN0X3JkZXYgOiBpbnQ7ICAgICAgICAgICAgICAoKiogRGV2aWNlIElEIChpZiBzcGVjaWFsIGZpbGUpICopXG4gICAqICAgIHN0X3NpemUgOiBpbnQ7ICAgICAgICAgICAgICAoKiogU2l6ZSBpbiBieXRlcyAqKVxuICAgKiAgICBzdF9hdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3QgYWNjZXNzIHRpbWUgKilcbiAgICogICAgc3RfbXRpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IG1vZGlmaWNhdGlvbiB0aW1lICopXG4gICAqICAgIHN0X2N0aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBzdGF0dXMgY2hhbmdlIHRpbWUgKilcbiAgICogIH1cbiAgICovXG4gIHJldHVybiBCTE9DSyhcbiAgICAwLFxuICAgIGpzX3N0YXRzLmRldixcbiAgICBqc19zdGF0cy5pbm8sXG4gICAgZmlsZV9raW5kLFxuICAgIGpzX3N0YXRzLm1vZGUsXG4gICAganNfc3RhdHMubmxpbmssXG4gICAganNfc3RhdHMudWlkLFxuICAgIGpzX3N0YXRzLmdpZCxcbiAgICBqc19zdGF0cy5yZGV2LFxuICAgIGpzX3N0YXRzLnNpemUsXG4gICAganNfc3RhdHMuYXRpbWVNcyxcbiAgICBqc19zdGF0cy5tdGltZU1zLFxuICAgIGpzX3N0YXRzLmN0aW1lTXNcbiAgKTtcbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIE1sTm9kZURldmljZSgpIHtcbn1cblxuLy9Qcm92aWRlczogTWxOb2RlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlLCBjYW1sX2FycmF5X29mX3N0cmluZywgY2FtbF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19zZXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBNbE5vZGVGaWxlKGZkKXtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMuZmQgPSBmZDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcblxuTWxOb2RlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB0cnkge1xuICAgIHRoaXMuZnMuZnRydW5jYXRlU3luYyh0aGlzLmZkLGxlbnwwKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5mc3RhdFN5bmModGhpcy5mZCkuc2l6ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB2YXIgYSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkpKVxuICAgIGEgPSBuZXcgZ2xvYmFsVGhpcy5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLndyaXRlU3luYyh0aGlzLmZkLCBidWZmZXIsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB2YXIgYSA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMoYnVmKTtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIGNhbWxfYnl0ZXNfc2V0KGJ1ZixidWZfb2Zmc2V0ICsgaSxidWZmZXJbYnVmX29mZnNldCtpXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLnJlYWRfb25lID0gZnVuY3Rpb24ob2Zmc2V0KXtcbiAgdmFyIGEgPSBuZXcgZ2xvYmFsVGhpcy5VaW50OEFycmF5KDEpO1xuICB2YXIgYnVmZmVyID0gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgMCwgMSwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBidWZmZXJbMF07XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5jbG9zZVN5bmModGhpcy5mZCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZUZpbGU7XG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZpbGVcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIE1sTm9kZUZpbGUoKXtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRHVtbXkgZmlsZXN5c3RlbVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX3RyYWlsaW5nX3NsYXNoKG5hbWUpe1xuICByZXR1cm4gKG5hbWUuc2xpY2UoLTEpICE9PSBcIi9cIikgPyAobmFtZSArIFwiL1wiKSA6IG5hbWU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VycmVudF9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfdHJhaWxpbmdfc2xhc2gsIGZzX25vZGVfc3VwcG9ydGVkXG5pZihmc19ub2RlX3N1cHBvcnRlZCAoKSAmJiBnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLmN3ZClcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSBnbG9iYWxUaGlzLnByb2Nlc3MuY3dkKCkucmVwbGFjZSgvXFxcXC9nLCcvJyk7XG5lbHNlXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gIFwiL3N0YXRpY1wiO1xuY2FtbF9jdXJyZW50X2RpciA9IGNhbWxfdHJhaWxpbmdfc2xhc2goY2FtbF9jdXJyZW50X2Rpcik7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3Jvb3Rcbi8vUmVxdWlyZXM6IHBhdGhfaXNfYWJzb2x1dGVcbmZ1bmN0aW9uIGNhbWxfZ2V0X3Jvb3QocGF0aCl7XG4gIHZhciB4ID0gcGF0aF9pc19hYnNvbHV0ZShwYXRoKTtcbiAgaWYgKCF4KSByZXR1cm47XG4gIHJldHVybiB4WzBdICsgXCIvXCJ9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcm9vdFxuLy9SZXF1aXJlczogY2FtbF9nZXRfcm9vdCwgY2FtbF9jdXJyZW50X2RpciwgY2FtbF9mYWlsd2l0aFxudmFyIGNhbWxfcm9vdCA9IGNhbWxfZ2V0X3Jvb3QoY2FtbF9jdXJyZW50X2RpcikgfHwgY2FtbF9mYWlsd2l0aChcInVuYWJsZSB0byBjb21wdXRlIGNhbWxfcm9vdFwiKTtcblxuXG4vL1Byb3ZpZGVzOiBNbEZpbGVcbmZ1bmN0aW9uIE1sRmlsZSgpeyAgfVxuXG4vL1Byb3ZpZGVzOiBwYXRoX2lzX2Fic29sdXRlXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gbWFrZV9wYXRoX2lzX2Fic29sdXRlKCkge1xuICBmdW5jdGlvbiBwb3NpeChwYXRoKSB7XG4gICAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHJldHVybiBbXCJcIiwgcGF0aC5zdWJzdHJpbmcoMSldO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpbjMyKHBhdGgpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9iM2ZjYzI0NWZiMjU1Mzk5MDllZjFkNWVhYTAxZGJmOTJlMTY4NjMzL2xpYi9wYXRoLmpzI0w1NlxuICAgIHZhciBzcGxpdERldmljZVJlID0gL14oW2EtekEtWl06fFtcXFxcL117Mn1bXlxcXFwvXStbXFxcXC9dK1teXFxcXC9dKyk/KFtcXFxcL10pPyhbXFxzXFxTXSo/KSQvO1xuICAgIHZhciByZXN1bHQgPSBzcGxpdERldmljZVJlLmV4ZWMocGF0aCk7XG4gICAgdmFyIGRldmljZSA9IHJlc3VsdFsxXSB8fCAnJztcbiAgICB2YXIgaXNVbmMgPSBCb29sZWFuKGRldmljZSAmJiBkZXZpY2UuY2hhckF0KDEpICE9PSAnOicpO1xuXG4gICAgLy8gVU5DIHBhdGhzIGFyZSBhbHdheXMgYWJzb2x1dGVcbiAgICBpZiAoQm9vbGVhbihyZXN1bHRbMl0gfHwgaXNVbmMpKSB7XG4gICAgICB2YXIgcm9vdCA9IChyZXN1bHRbMV0gfHwgJycpO1xuICAgICAgdmFyIHNlcCA9IChyZXN1bHRbMl0gfHwgJycpO1xuICAgICAgcmV0dXJuIFtyb290LCBwYXRoLnN1YnN0cmluZyhyb290Lmxlbmd0aCArIHNlcC5sZW5ndGgpXVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYoZnNfbm9kZV9zdXBwb3J0ZWQgKCkgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMiA6IHBvc2l4O1xuICB9XG4gIGVsc2UgcmV0dXJuIHBvc2l4XG59XG52YXIgcGF0aF9pc19hYnNvbHV0ZSA9IG1ha2VfcGF0aF9pc19hYnNvbHV0ZSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfcGF0aFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcsIHBhdGhfaXNfYWJzb2x1dGVcbmZ1bmN0aW9uIGNhbWxfbWFrZV9wYXRoIChuYW1lKSB7XG4gIG5hbWU9Y2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKCAhcGF0aF9pc19hYnNvbHV0ZShuYW1lKSApXG4gICAgbmFtZSA9IGNhbWxfY3VycmVudF9kaXIgKyBuYW1lO1xuICB2YXIgY29tcDAgPSBwYXRoX2lzX2Fic29sdXRlKG5hbWUpO1xuICB2YXIgY29tcCA9IGNvbXAwWzFdLnNwbGl0KFwiL1wiKTtcbiAgdmFyIG5jb21wID0gW11cbiAgZm9yKHZhciBpID0gMDsgaTxjb21wLmxlbmd0aDsgaSsrKXtcbiAgICBzd2l0Y2goY29tcFtpXSl7XG4gICAgY2FzZSBcIi4uXCI6IGlmKG5jb21wLmxlbmd0aD4xKSBuY29tcC5wb3AoKTsgYnJlYWs7XG4gICAgY2FzZSBcIi5cIjogYnJlYWs7XG4gICAgZGVmYXVsdDogbmNvbXAucHVzaChjb21wW2ldKTticmVha1xuICAgIH1cbiAgfVxuICBuY29tcC51bnNoaWZ0KGNvbXAwWzBdKTtcbiAgbmNvbXAub3JpZyA9IG5hbWU7XG4gIHJldHVybiBuY29tcDtcbn1cblxuLy9Qcm92aWRlczpqc29vX21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIE1sTm9kZURldmljZSwgY2FtbF9yb290LCBmc19ub2RlX3N1cHBvcnRlZFxudmFyIGpzb29fbW91bnRfcG9pbnQgPSBbXVxuaWYgKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShjYW1sX3Jvb3QpfSk7XG59IGVsc2Uge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn1cbmpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpcIi9zdGF0aWMvXCIsIGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKFwiL3N0YXRpYy9cIil9KTtcblxuLy9Qcm92aWRlczpjYW1sX2xpc3RfbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGlzdF9tb3VudF9wb2ludCgpe1xuICB2YXIgcHJldiA9IDBcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspe1xuICAgIHZhciBvbGQgPSBwcmV2O1xuICAgIHByZXYgPSBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhqc29vX21vdW50X3BvaW50W2ldLnBhdGgpLCBvbGRdXG4gIH1cbiAgcmV0dXJuIHByZXY7XG59XG5cbi8vUHJvdmlkZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2V0X3Jvb3QsIE1sTm9kZURldmljZSwgY2FtbF90cmFpbGluZ19zbGFzaCwgZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gY2FtbF90cmFpbGluZ19zbGFzaChuYW1lKTtcbiAgdmFyIHJlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbSA9IGpzb29fbW91bnRfcG9pbnRbaV07XG4gICAgaWYobmFtZV9zbGFzaC5zZWFyY2gobS5wYXRoKSA9PSAwXG4gICAgICAgJiYgKCFyZXMgfHwgcmVzLnBhdGgubGVuZ3RoIDwgbS5wYXRoLmxlbmd0aCkpXG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICB9XG4gIGlmKCAhcmVzICYmIGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAgICB2YXIgcm9vdCA9IGNhbWxfZ2V0X3Jvb3QobmFtZSk7XG4gICAgaWYgKHJvb3QgJiYgcm9vdC5tYXRjaCgvXlthLXpBLVpdOlxcLyQvKSl7XG4gICAgICB2YXIgbSA9IHtwYXRoOnJvb3QsZGV2aWNlOm5ldyBNbE5vZGVEZXZpY2Uocm9vdCl9O1xuICAgICAganNvb19tb3VudF9wb2ludC5wdXNoKG0pO1xuICAgICAgcmVzID0ge3BhdGg6bS5wYXRoLGRldmljZTptLmRldmljZSxyZXN0Om5hbWUuc3Vic3RyaW5nKG0ucGF0aC5sZW5ndGgsbmFtZS5sZW5ndGgpfTtcbiAgICB9XG4gIH1cbiAgaWYoIHJlcyApIHJldHVybiByZXM7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwibm8gZGV2aWNlIGZvdW5kIGZvciBcIiArIG5hbWVfc2xhc2gpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vdW50X2F1dG9sb2FkXG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX21vdW50X2F1dG9sb2FkKG5hbWUsZil7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gY2FtbF90cmFpbGluZ19zbGFzaChwYXRoLmpvaW4oXCIvXCIpKTtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOm5hbWUsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UobmFtZSxmKX0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VubW91bnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbWFrZV9wYXRoLCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX3VubW91bnQobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gY2FtbF90cmFpbGluZ19zbGFzaChwYXRoLmpvaW4oXCIvXCIpKTtcbiAgdmFyIGlkeCA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKylcbiAgICBpZihqc29vX21vdW50X3BvaW50W2ldLnBhdGggPT0gbmFtZSkgaWR4ID0gaTtcbiAgaWYoaWR4ID4gLTEpIGpzb29fbW91bnRfcG9pbnQuc3BsaWNlKGlkeCwxKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0Y3dkXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRjd2QoKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19jaGRpcihkaXIpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkaXIpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGlmKHJvb3QucmVzdCkgY2FtbF9jdXJyZW50X2RpciA9IGNhbWxfdHJhaWxpbmdfc2xhc2gocm9vdC5wYXRoICsgcm9vdC5yZXN0KTtcbiAgICBlbHNlIGNhbWxfY3VycmVudF9kaXIgPSByb290LnBhdGg7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhkaXIpKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpe1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9hX2RpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2FfZGlyKG5hbWUpe1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2ZpbGVfZXhpc3RzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfZmlsZV9leGlzdHMgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfYV9kaXIsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5yZWFkZGlyKHJvb3QucmVzdCk7XG4gIHZhciBsID0gbmV3IEFycmF5KGEubGVuZ3RoICsgMSk7XG4gIGxbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKylcbiAgICBsW2krMV0gPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGFbaV0pO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVtb3ZlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbW92ZShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIG9rID0gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCk7XG4gIGlmKG9rID09IDApIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLmlzX2Rpcihyb290LnJlc3QpO1xuICByZXR1cm4gYT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbmFtZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbmFtZShvLG4pe1xuICB2YXIgb19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobyk7XG4gIHZhciBuX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuKTtcbiAgaWYob19yb290LmRldmljZSAhPSBuX3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IGNhbm5vdCBtb3ZlIGZpbGUgYmV0d2VlbiB0d28gZmlsZXN5c3RlbVwiKTtcbiAgaWYoIW9fcm9vdC5kZXZpY2UucmVuYW1lKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IG5vIGltcGxlbWVudGVkXCIpO1xuICBvX3Jvb3QuZGV2aWNlLnJlbmFtZShvX3Jvb3QucmVzdCwgbl9yb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19ta2RpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3N5c19ta2RpcihuYW1lLCBwZXJtKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcm9vdC5kZXZpY2UubWtkaXIocm9vdC5yZXN0LHBlcm0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcm1kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV9ub3RfYV9kaXJcbmZ1bmN0aW9uIGNhbWxfc3lzX3JtZGlyKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByb290LmRldmljZS5ybWRpcihyb290LnJlc3QpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZSh2ZmQsIGtpbmQsIGxheW91dCwgc2hhcmVkLCBkaW1zLCBwb3MpIHtcbiAgLy8gdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1t2ZmRdO1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9iYV9tYXBfZmlsZSBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUoYXJndixhcmduKXtcbiAgcmV0dXJuIGNhbWxfYmFfbWFwX2ZpbGUoYXJndlswXSxhcmd2WzFdLGFyZ3ZbMl0sYXJndlszXSxhcmd2WzRdLGFyZ3ZbNV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2NyZWF0ZV9maWxlX2V4dGVyblxuZnVuY3Rpb24ganNvb19jcmVhdGVfZmlsZV9leHRlcm4obmFtZSxjb250ZW50KXtcbiAgaWYoZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlKVxuICAgIGdsb2JhbFRoaXMuanNvb19jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpO1xuICBlbHNlIHtcbiAgICBpZighZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcCkgZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcCA9IFtdO1xuICAgIGdsb2JhbFRoaXMuY2FtbF9mc190bXAucHVzaCh7bmFtZTpuYW1lLGNvbnRlbnQ6Y29udGVudH0pO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZzX2luaXRcbi8vUmVxdWlyZXM6IGpzb29fY3JlYXRlX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfZnNfaW5pdCAoKXtcbiAgdmFyIHRtcD1nbG9iYWxUaGlzLmNhbWxfZnNfdG1wXG4gIGlmKHRtcCl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKyl7XG4gICAgICBqc29vX2NyZWF0ZV9maWxlKHRtcFtpXS5uYW1lLHRtcFtpXS5jb250ZW50KTtcbiAgICB9XG4gIH1cbiAgZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlID0ganNvb19jcmVhdGVfZmlsZTtcbiAgZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcCA9IFtdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKCEgcm9vdC5kZXZpY2UucmVnaXN0ZXIpIGNhbWxfZmFpbHdpdGgoXCJjYW5ub3QgcmVnaXN0ZXIgZmlsZVwiKTtcbiAgcm9vdC5kZXZpY2UucmVnaXN0ZXIocm9vdC5yZXN0LGNvbnRlbnQpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBqc29vX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9maWxlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBqc29vX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgbmFtZSA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSk7XG4gIHZhciBjb250ZW50ID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjb250ZW50KTtcbiAgcmV0dXJuIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSwgY29udGVudCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9yZWFkX2ZpbGVfY29udGVudFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmVhZF9maWxlX2NvbnRlbnQgKG5hbWUpIHtcbiAgdmFyIG5hbWUgPSAodHlwZW9mIG5hbWUgPT0gXCJzdHJpbmdcIik/Y2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTpuYW1lO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3Qse3Jkb25seToxfSk7XG4gICAgdmFyIGxlbiAgPSBmaWxlLmxlbmd0aCgpO1xuICAgIHZhciBidWYgID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBmaWxlLnJlYWQoMCxidWYsMCxsZW4pO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9ieXRlcyhidWYpXG4gIH1cbiAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSk7XG59XG4iLCIvL1Byb3ZpZGVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF9nZXR0aW1lb2ZkYXkgKCkge1xuICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAvIDEwMDA7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfdGltZVxuLy9SZXF1aXJlczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIHVuaXhfdGltZSAoKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHVuaXhfZ2V0dGltZW9mZGF5ICgpKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9nbXRpbWVcbmZ1bmN0aW9uIHVuaXhfZ210aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0VVRDU2Vjb25kcygpLCBkLmdldFVUQ01pbnV0ZXMoKSwgZC5nZXRVVENIb3VycygpLFxuICAgICAgICAgICAgICAgZC5nZXRVVENEYXRlKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICAgICAgIGQuZ2V0VVRDRGF5KCksIGRveSxcbiAgICAgICAgICAgICAgIGZhbHNlIHwgMCAvKiBmb3IgVVRDIGRheWxpZ2h0IHNhdmluZ3MgdGltZSBpcyBmYWxzZSAqLylcbn1cblxuLy9Qcm92aWRlczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIHVuaXhfbG9jYWx0aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICB2YXIgamFuID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgdmFyIGp1bCA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KGphbi5nZXRUaW1lem9uZU9mZnNldCgpLCBqdWwuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFNlY29uZHMoKSwgZC5nZXRNaW51dGVzKCksIGQuZ2V0SG91cnMoKSxcbiAgICAgICAgICAgICAgIGQuZ2V0RGF0ZSgpLCBkLmdldE1vbnRoKCksIGQuZ2V0RnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgICAgICBkLmdldERheSgpLCBkb3ksXG4gICAgICAgICAgICAgICAoZC5nZXRUaW1lem9uZU9mZnNldCgpIDwgc3RkVGltZXpvbmVPZmZzZXQpIHwgMCAvKiBkYXlsaWdodCBzYXZpbmdzIHRpbWUgIGZpZWxkLiAqLylcbn1cblxuLy9Qcm92aWRlczogdW5peF9ta3RpbWVcbi8vUmVxdWlyZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X21rdGltZSh0bSl7XG4gIHZhciBkID0gKG5ldyBEYXRlKHRtWzZdKzE5MDAsdG1bNV0sdG1bNF0sdG1bM10sdG1bMl0sdG1bMV0pKS5nZXRUaW1lKCk7XG4gIHZhciB0ID0gTWF0aC5mbG9vcihkIC8gMTAwMCk7XG4gIHZhciB0bTIgPSB1bml4X2xvY2FsdGltZSh0KTtcbiAgcmV0dXJuIEJMT0NLKDAsdCx0bTIpO1xufVxuXG4vL1Byb3ZpZGVzOiB3aW5fc3RhcnR1cCBjb25zdFxuZnVuY3Rpb24gd2luX3N0YXJ0dXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiB3aW5fY2xlYW51cCBjb25zdFxuZnVuY3Rpb24gd2luX2NsZWFudXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiB3aW5faGFuZGxlX2ZkIGNvbnN0XG5mdW5jdGlvbiB3aW5faGFuZGxlX2ZkKHgpIHtyZXR1cm4geDt9XG5cbi8vUHJvdmlkZXM6IHVuaXhfaXNhdHR5XG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gdW5peF9pc2F0dHkoZmlsZURlc2NyaXB0b3IpIHtcbiAgaWYoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICAgIHZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbiAgICByZXR1cm4gdHR5LmlzYXR0eShmaWxlRGVzY3JpcHRvcik/MTowO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IG1ha2VfdW5peF9lcnJfYXJnc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbnZhciB1bml4X2Vycm9yID0gW1xuICAvKiA9PT1Vbml4LmVycm9yPT09XG4gICAqXG4gICAqIFRoaXMgYXJyYXkgaXMgaW4gb3JkZXIgb2YgdGhlIHZhcmlhbnQgaW4gT0NhbWxcbiAgICovXG4gIFwiRTJCSUdcIiwgXCJFQUNDRVNcIiwgXCJFQUdBSU5cIiwgXCJFQkFERlwiLCBcIkVCVVNZXCIsIFwiRUNISUxEXCIsIFwiRURFQURMS1wiLCBcIkVET01cIixcbiAgXCJFRVhJU1RcIiwgXCJFRkFVTFRcIiwgXCJFRkJJR1wiLCBcIkVJTlRSXCIsIFwiRUlOVkFMXCIsIFwiRUlPXCIsIFwiRUlTRElSXCIsIFwiRU1GSUxFXCIsXG4gIFwiRU1MSU5LXCIsIFwiRU5BTUVUT09MT05HXCIsIFwiRU5GSUxFXCIsIFwiRU5PREVWXCIsIFwiRU5PRU5UXCIsIFwiRU5PRVhFQ1wiLCBcIkVOT0xDS1wiLFxuICBcIkVOT01FTVwiLCBcIkVOT1NQQ1wiLCBcIkVOT1NZU1wiLCBcIkVOT1RESVJcIiwgXCJFTk9URU1QVFlcIiwgXCJFTk9UVFlcIiwgXCJFTlhJT1wiLFxuICBcIkVQRVJNXCIsIFwiRVBJUEVcIiwgXCJFUkFOR0VcIiwgXCJFUk9GU1wiLCBcIkVTUElQRVwiLCBcIkVTUkNIXCIsIFwiRVhERVZcIiwgXCJFV09VTERCTE9DS1wiLFxuICBcIkVJTlBST0dSRVNTXCIsIFwiRUFMUkVBRFlcIiwgXCJFTk9UU09DS1wiLCBcIkVERVNUQUREUlJFUVwiLCBcIkVNU0dTSVpFXCIsXG4gIFwiRVBST1RPVFlQRVwiLCBcIkVOT1BST1RPT1BUXCIsIFwiRVBST1RPTk9TVVBQT1JUXCIsIFwiRVNPQ0tUTk9TVVBQT1JUXCIsXG4gIFwiRU9QTk9UU1VQUFwiLCBcIkVQRk5PU1VQUE9SVFwiLCBcIkVBRk5PU1VQUE9SVFwiLCBcIkVBRERSSU5VU0VcIiwgXCJFQUREUk5PVEFWQUlMXCIsXG4gIFwiRU5FVERPV05cIiwgXCJFTkVUVU5SRUFDSFwiLCBcIkVORVRSRVNFVFwiLCBcIkVDT05OQUJPUlRFRFwiLCBcIkVDT05OUkVTRVRcIiwgXCJFTk9CVUZTXCIsXG4gIFwiRUlTQ09OTlwiLCBcIkVOT1RDT05OXCIsIFwiRVNIVVRET1dOXCIsIFwiRVRPT01BTllSRUZTXCIsIFwiRVRJTUVET1VUXCIsIFwiRUNPTk5SRUZVU0VEXCIsXG4gIFwiRUhPU1RET1dOXCIsIFwiRUhPU1RVTlJFQUNIXCIsIFwiRUxPT1BcIiwgXCJFT1ZFUkZMT1dcIlxuXTtcbmZ1bmN0aW9uIG1ha2VfdW5peF9lcnJfYXJncyhjb2RlLCBzeXNjYWxsLCBwYXRoLCBlcnJubykge1xuICB2YXIgdmFyaWFudCA9IHVuaXhfZXJyb3IuaW5kZXhPZihjb2RlKTtcbiAgaWYgKHZhcmlhbnQgPCAwKSB7XG4gICAgLy8gRGVmYXVsdCBpZiB1bmRlZmluZWRcbiAgICBpZiAoZXJybm8gPT0gbnVsbCkge1xuICAgICAgZXJybm8gPSAtOTk5OVxuICAgIH1cbiAgICAvLyBJZiBub25lIG9mIHRoZSBhYm92ZSB2YXJpYW50cywgZmFsbGJhY2sgdG8gRVVOS05PV05FUlIoaW50KVxuICAgIHZhcmlhbnQgPSBCTE9DSygwLCBlcnJubyk7XG4gIH1cbiAgdmFyIGFyZ3MgPSBbXG4gICAgdmFyaWFudCxcbiAgICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzeXNjYWxsIHx8IFwiXCIpLFxuICAgIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHBhdGggfHwgXCJcIilcbiAgXTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfc3RhdFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIHVuaXhfc3RhdChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2Uuc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X3N0YXQ6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2Uuc3RhdChyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfc3RhdF82NFxuLy9SZXF1aXJlczogdW5peF9zdGF0XG52YXIgdW5peF9zdGF0XzY0ID0gdW5peF9zdGF0O1xuXG4vL1Byb3ZpZGVzOiB1bml4X2xzdGF0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF9sc3RhdChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UubHN0YXQpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9sc3RhdDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5sc3RhdChyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbHN0YXRfNjRcbi8vUmVxdWlyZXM6IHVuaXhfbHN0YXRcbnZhciB1bml4X2xzdGF0XzY0ID0gdW5peF9sc3RhdDtcblxuLy9Qcm92aWRlczogdW5peF9ta2RpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIHVuaXhfbWtkaXIobmFtZSwgcGVybSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLm1rZGlyKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcInVuaXhfbWtkaXI6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UubWtkaXIocm9vdC5yZXN0LCBwZXJtLCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3JtZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF9ybWRpcihuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2Uucm1kaXIpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9ybWRpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5ybWRpcihyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfc3ltbGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIHVuaXhfc3ltbGluayh0b19kaXIsIHNyYywgZHN0KSB7XG4gIHZhciBzcmNfcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKHNyYyk7XG4gIHZhciBkc3Rfcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRzdCk7XG4gIGlmKHNyY19yb290LmRldmljZSAhPSBkc3Rfcm9vdC5kZXZpY2UpXG4gICAgY2FtbF9mYWlsd2l0aChcInVuaXhfc3ltbGluazogY2Fubm90IHN5bWxpbmsgYmV0d2VlbiB0d28gZmlsZXN5c3RlbXNcIik7XG4gIGlmICghc3JjX3Jvb3QuZGV2aWNlLnN5bWxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9zeW1saW5rOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNyY19yb290LmRldmljZS5zeW1saW5rKHRvX2Rpciwgc3JjX3Jvb3QucmVzdCwgZHN0X3Jvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9yZWFkbGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIHVuaXhfcmVhZGxpbmsobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnJlYWRsaW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcInVuaXhfcmVhZGxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UucmVhZGxpbmsocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3VubGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIHVuaXhfdW5saW5rKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS51bmxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF91bmxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9nZXR1aWRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG5mdW5jdGlvbiB1bml4X2dldHVpZCh1bml0KSB7XG4gIGlmKGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0dWlkKXtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5wcm9jZXNzLmdldHVpZCgpO1xuICB9XG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kKCk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfZ2V0cHd1aWRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG5mdW5jdGlvbiB1bml4X2dldHB3dWlkKHVuaXQpIHtcbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2hhc19zeW1saW5rXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gdW5peF9oYXNfc3ltbGluayh1bml0KSB7XG4gIHJldHVybiBmc19ub2RlX3N1cHBvcnRlZCgpPzE6MFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgaWYoZi5mdW4pXG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5mdW4sIGFyZ3MpO1xuICAvL0ZJWE1FLCBjYW4gaGFwcGVuIHdpdGggdG9vIG1hbnkgYXJndW1lbnRzXG4gIGlmKHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmO1xuICB2YXIgbiA9IGYubGVuZ3RoIHwgMDtcbiAgaWYobiA9PT0gMCkgcmV0dXJuIGYuYXBwbHkobnVsbCxhcmdzKTtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aCB8IDA7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW4gfCAwO1xuICBpZiAoZCA9PSAwKVxuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICBlbHNlIGlmIChkIDwgMCkge1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuYXBwbHkobnVsbCxhcmdzLnNsaWNlKDAsbikpLGFyZ3Muc2xpY2UobikpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKXtcbiAgICAgIHZhciBleHRyYV9hcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT0gMCk/MTphcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoK2V4dHJhX2FyZ3MpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkgbmFyZ3NbYXJncy5sZW5ndGgraV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBuYXJncylcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZXNcbnZhciBjYW1sX25hbWVkX3ZhbHVlcyA9IHt9O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIChjb25zdCxjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlKG5tLHYpIHtcbiAgY2FtbF9uYW1lZF92YWx1ZXNbY2FtbF9qc2J5dGVzX29mX3N0cmluZyhubSldID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG5mdW5jdGlvbiBjYW1sX25hbWVkX3ZhbHVlKG5tKSB7XG4gIHJldHVybiBjYW1sX25hbWVkX3ZhbHVlc1tubV1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nbG9iYWxfZGF0YVxudmFyIGNhbWxfZ2xvYmFsX2RhdGEgPSBbMF07XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChjb25zdCwgc2hhbGxvdywgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAobiwgdiwgbmFtZV9vcHQpIHtcbiAgaWYobmFtZV9vcHQgJiYgZ2xvYmFsVGhpcy50b3BsZXZlbFJlbG9jKVxuICAgIG4gPSBnbG9iYWxUaGlzLnRvcGxldmVsUmVsb2MobmFtZV9vcHQpO1xuICBjYW1sX2dsb2JhbF9kYXRhW24gKyAxXSA9IHY7XG4gIGlmKG5hbWVfb3B0KSBjYW1sX2dsb2JhbF9kYXRhW25hbWVfb3B0XSA9IHY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2dsb2JhbF9kYXRhIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZ2V0X2dsb2JhbF9kYXRhICgpIHsgcmV0dXJuIGNhbWxfZ2xvYmFsX2RhdGE7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pc19wcmludGFibGUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pc19wcmludGFibGUoYykgeyByZXR1cm4gKyhjID4gMzEgJiYgYyA8IDEyNyk7IH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUmFpc2UgZXhjZXB0aW9uXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9jb25zdGFudCAodGFnKSB7IHRocm93IHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50ICh0YWcpIHsgcmV0dXJuIHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGFyZykgeyB0aHJvdyBbMCwgdGFnLCBhcmddOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmdzIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJncyAodGFnLCBhcmdzKSB7IHRocm93IFswLCB0YWddLmNvbmNhdChhcmdzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nICh0YWcsIG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobXNnKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmFpbHdpdGggKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9mYWlsd2l0aCAobXNnKSB7XG4gIGlmKCFjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUpXG4gICAgY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlPVsyNDgsY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIkZhaWx1cmVcIiksLTNdO1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSwgbXNnKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkludmFsaWRfYXJndW1lbnQsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRW5kX29mX2ZpbGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkRpdmlzaW9uX2J5X3plcm8pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfZm91bmQgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuTm90X2ZvdW5kKTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4iLCIvKiBnbG9iYWwgam9vX2dsb2JhbF9vYmplY3RcbiAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKHRhZywgbXNnKSB7XG4gIHRocm93IGdsb2JhbFRoaXMuRXJyb3IobXNnLmMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjdXN0b21fcmVyYWlzZV9leG5cbmZ1bmN0aW9uIGN1c3RvbV9yZXJhaXNlX2V4bihleG4sIGZhbGxiYWNrTWVzc2FnZSkge1xuICAvLyB0aGlzIGhhbmRsZXMgdGhlIGNvbW1vbiBjYXNlIG9mIGEgSlMgRXJyb3IgcmVyYWlzZWQgYnkgT0NhbWxcbiAgLy8gaW4gdGhhdCBjYXNlLCB0aGUgZXJyb3Igd2lsbCBmaXJzdCBiZSB3cmFwcGVkIGluIE9DYW1sIHdpdGggXCJjYW1sX3dyYXBfZXhjZXB0aW9uXCJcbiAgLy8gKGRlZmluZWQgaW4ganNfb2Zfb2NhbWwtY29tcGlsZXIgLyBqc2xpYi5qcylcbiAgLy8gd2hpY2ggcmVzdWx0cyBpbiBbMCwgY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIiksIGVycl1cbiAgdmFyIGVyciA9IGV4blsyXTtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRXJyb3IpIHtcbiAgICB0aHJvdyBlcnI7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoZmFsbGJhY2tNZXNzYWdlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgb3ZlcnJpZGVzIHRoZSBoYW5kbGVyIGZvciB1bmNhdWdodCBleGNlcHRpb25zIGluIGpzX29mX29jYW1sLFxuICogZml4aW5nIHRoZSBmbGF3IHRoYXQgYnkgZGVmYXVsdCwgbm8gYWN0dWFsIGBFcnJvcmBzIGFyZSB0aHJvd24sXG4gKiBidXQgb3RoZXIgb2JqZWN0cyAoYXJyYXlzKSB3aGljaCBhcmUgbWlzc2luZyBhbiBlcnJvciB0cmFjZS5cbiAqIFRoaXMgb3ZlcnJpZGUgc2hvdWxkIG1ha2UgaXQgbXVjaCBlYXNpZXIgdG8gZmluZCB0aGUgc291cmNlIG9mIGFuIGVycm9yLlxuICovXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24oZXJyKSB7XG4gIC8vIGZpcnN0LCB3ZSBzZWFyY2ggZm9yIGFuIGFjdHVhbCBlcnJvciBpbnNpZGUgYGVycmAsXG4gIC8vIHNpbmNlIHRoaXMgaXMgdGhlIGJlc3QgdGhpbmcgdG8gdGhyb3dcbiAgZnVuY3Rpb24gdGhyb3dfZXJyb3JzKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgZXJyO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZXJyKSkge1xuICAgICAgZXJyLmZvckVhY2godGhyb3dfZXJyb3JzKTtcbiAgICB9XG4gIH1cbiAgdGhyb3dfZXJyb3JzKGVycik7XG4gIC8vIGlmIHRoaXMgZGlkbid0IHRocm93IGFuIGVycm9yLCBsZXQncyBsb2cgd2hhdGV2ZXIgd2UgZ290XG4gIGNvbnNvbGUuZGlyKGVyciwgeyBkZXB0aDogMjAgfSk7XG4gIC8vIG5vdywgdHJ5IHRvIGNvbGxlY3QgYWxsIHN0cmluZ3MgaW4gdGhlIGVycm9yIGFuZCB0aHJvdyB0aGF0XG4gIGZ1bmN0aW9uIGNvbGxlY3Rfc3RyaW5ncyhlcnIsIGFjYykge1xuICAgIHZhciBzdHIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzdHIgPSBlcnI7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgZXJyLmNvbnN0cnVjdG9yICYmIGVyci5jb25zdHJ1Y3Rvci5uYW1lID09PSAnTWxCeXRlcycpIHtcbiAgICAgIHN0ciA9IGVyci5jO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlcnIpKSB7XG4gICAgICBlcnIuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICBjb2xsZWN0X3N0cmluZ3MoZSwgYWNjKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXN0cikgcmV0dXJuIGFjYy5zdHJpbmc7XG4gICAgaWYgKGFjYy5zdHJpbmcgPT09IHVuZGVmaW5lZCkgYWNjLnN0cmluZyA9IHN0cjtcbiAgICBlbHNlIGFjYy5zdHJpbmcgPSBhY2Muc3RyaW5nICsgJ1xcbicgKyBzdHI7XG4gICAgcmV0dXJuIGFjYy5zdHJpbmc7XG4gIH1cbiAgdmFyIHN0ciA9IGNvbGxlY3Rfc3RyaW5ncyhlcnIsIHt9KTtcbiAgaWYgKHN0ciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBqb29fZ2xvYmFsX29iamVjdC5FcnJvcihzdHIpO1xuICAvLyBvdGhlcndpc2UsIGp1c3QgdGhyb3cgYW4gdW5oZWxwZnVsIGVycm9yXG4gIGNvbnNvbGUuZGlyKGVyciwgeyBkZXB0aDogMTAgfSk7XG4gIHRocm93IGpvb19nbG9iYWxfb2JqZWN0LkVycm9yKCdVbmtub3duIGVycm9yIHRocm93biBmcm9tIE9DYW1sJyk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIFN5c1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3N5c19lcnJvciAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5TeXNfZXJyb3IsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4aXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zeXNfZXhpdCAoY29kZSkge1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIGlmKGcucXVpdCkgZy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZihnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLmV4aXQpXG4gICAgZy5wcm9jZXNzLmV4aXQoY29kZSk7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkZ1bmN0aW9uICdleGl0JyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuKXtcbiAgc3dpdGNoKGV4blsyXSkge1xuICBjYXNlIC04OiAvLyBNYXRjaF9mYWlsdXJlXG4gIGNhc2UgLTExOiAvLyBBc3NlcnRfZmFpbHVyZVxuICBjYXNlIC0xMjogLy8gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGVcbiAgICByZXR1cm4gMTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9leGNlcHRpb25cbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2V4Y2VwdGlvbihleG4pe1xuICB2YXIgciA9IFwiXCI7XG4gIGlmKGV4blswXSA9PSAwKSB7XG4gICAgciArPSBleG5bMV1bMV07XG4gICAgaWYoZXhuLmxlbmd0aCA9PSAzICYmIGV4blsyXVswXSA9PSAwICYmIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuWzFdKSkge1xuXG4gICAgICB2YXIgYnVja2V0ID0gZXhuWzJdO1xuICAgICAgdmFyIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gMlxuICAgICAgdmFyIGJ1Y2tldCA9IGV4bjtcbiAgICB9XG4gICAgciArPSBcIihcIjtcbiAgICBmb3IodmFyIGkgPSBzdGFydDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkgKyspe1xuICAgICAgaWYoaSA+IHN0YXJ0KSByKz1cIiwgXCI7XG4gICAgICB2YXIgdiA9IGJ1Y2tldFtpXVxuICAgICAgaWYodHlwZW9mIHYgPT0gXCJudW1iZXJcIilcbiAgICAgICAgcis9IHYudG9TdHJpbmcoKTtcbiAgICAgIGVsc2UgaWYodiBpbnN0YW5jZW9mIE1sQnl0ZXMpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHR5cGVvZiB2ID09IFwic3RyaW5nXCIpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIHIgKz0gXCJfXCI7XG4gICAgfVxuICAgIHIgKz0gXCIpXCJcbiAgfSBlbHNlIGlmIChleG5bMF0gPT0gMjQ4KXtcbiAgICByICs9IGV4blsxXVxuICB9XG4gIHJldHVybiByXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX2Zvcm1hdF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGVycil7XG4gIGlmKGVyciBpbnN0YW5jZW9mIEFycmF5ICYmIChlcnJbMF0gPT0gMCB8fCBlcnJbMF0gPT0gMjQ4KSkge1xuICAgIHZhciBoYW5kbGVyID0gY2FtbF9uYW1lZF92YWx1ZShcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIik7XG4gICAgaWYoaGFuZGxlcikgaGFuZGxlcihlcnIsZmFsc2UpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIG1zZyA9IGNhbWxfZm9ybWF0X2V4Y2VwdGlvbihlcnIpO1xuICAgICAgdmFyIGF0X2V4aXQgPSBjYW1sX25hbWVkX3ZhbHVlKFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIpO1xuICAgICAgaWYoYXRfZXhpdCkgeyBhdF9leGl0KDApIH1cbiAgICAgIGdsb2JhbFRoaXMuY29uc29sZS5lcnJvcihcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gXCIgKyBtc2cgKyBcIlxcblwiKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9zdGF0aWNfZW52XG5mdW5jdGlvbiBjYW1sX3NldF9zdGF0aWNfZW52KGssdil7XG4gIGlmKCFnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudilcbiAgICBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudiA9IHt9XG4gIGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W2tdID0gdjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRlbnYgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKSB7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgdmFyIG4gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgLy9ub2RlanMgZW52XG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuZW52XG4gICAgICYmIGcucHJvY2Vzcy5lbnZbbl0gIT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhnLnByb2Nlc3MuZW52W25dKTtcbiAgaWYoZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZcbiAgICAgJiYgZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZbbl0pXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W25dKVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdW5zYWZlX2dldGVudlxuLy9SZXF1aXJlczogY2FtbF9zeXNfZ2V0ZW52XG5mdW5jdGlvbiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52KG5hbWUpe1xuICByZXR1cm4gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIGNhbWxfYXJndiA9ICgoZnVuY3Rpb24gKCkge1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIHZhciBtYWluID0gXCJhLm91dFwiO1xuICB2YXIgYXJncyA9IFtdXG5cbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5hcmd2XG4gICAgICYmIGcucHJvY2Vzcy5hcmd2Lmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYXJndiA9IGcucHJvY2Vzcy5hcmd2XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gYXJndi5zbGljZSgyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBhcmdzMjtcbn0pKCkpXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbnZhciBjYW1sX2V4ZWN1dGFibGVfbmFtZSA9IGNhbWxfYXJndlsxXVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfYXJndiAoYSkge1xuICByZXR1cm4gWzAsIGNhbWxfYXJndlsxXSwgY2FtbF9hcmd2XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19hcmd2IChhKSB7XG4gIHJldHVybiBjYW1sX2FyZ3Y7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21vZGlmeV9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX21vZGlmeV9hcmd2KGFyZyl7XG4gIGNhbWxfYXJndiA9IGFyZztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZShhKXtcbiAgcmV0dXJuIGNhbWxfZXhlY3V0YWJsZV9uYW1lXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgdmFyIGNtZCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPSBcInVuZGVmaW5lZFwiXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcbiAgICAgICYmIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYykge1xuICAgIHRyeSB7cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKGNtZCx7c3RkaW86ICdpbmhlcml0J30pOyByZXR1cm4gMH1cbiAgICBjYXRjaCAoZSkge3JldHVybiAxfVxuICB9XG4gIGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZSBtdXRhYmxlXG52YXIgY2FtbF9pbml0aWFsX3RpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICogMC4wMDE7XG5mdW5jdGlvbiBjYW1sX3N5c190aW1lICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHJldHVybiBub3cgKiAwLjAwMSAtIGNhbWxfaW5pdGlhbF90aW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW5cbi8vUmVxdWlyZXM6IGNhbWxfc3lzX3RpbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbihiKSB7XG4gIHJldHVybiBjYW1sX3N5c190aW1lKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JhbmRvbV9zZWVkIG11dGFibGVcbi8vVGhlIGZ1bmN0aW9uIG5lZWRzIHRvIHJldHVybiBhbiBhcnJheSBzaW5jZSBPQ2FtbCA0LjAuLi5cbmZ1bmN0aW9uIGNhbWxfc3lzX3JhbmRvbV9zZWVkICgpIHtcbiAgaWYoZ2xvYmFsVGhpcy5jcnlwdG8pIHtcbiAgICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIC8vIFdlYmJyb3dzZXJzXG4gICAgICB2YXIgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQzMkFycmF5KDEpO1xuICAgICAgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGEpO1xuICAgICAgcmV0dXJuIFswLGFbMF1dO1xuICAgIH0gZWxzZSBpZihnbG9iYWxUaGlzLmNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAvLyBOb2RlanNcbiAgICAgIHZhciBidWZmID0gZ2xvYmFsVGhpcy5jcnlwdG8ucmFuZG9tQnl0ZXMoNCk7XG4gICAgICB2YXIgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQzMkFycmF5KGJ1ZmYpO1xuICAgICAgcmV0dXJuIFswLGFbMF1dO1xuICAgIH1cbiAgfVxuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgdmFyIHggPSBub3deMHhmZmZmZmZmZipNYXRoLnJhbmRvbSgpO1xuICByZXR1cm4gWzAseF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfaW50X3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSBjb25zdFxuLy8gbWF4X2ludCAvIDQgc28gdGhhdCB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG92ZXJmbG93XG4vL2xldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMTs7XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplICgpIHsgcmV0dXJuICgweDdGRkZGRkZGLzQpIHwgMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCAoKSB7IHJldHVybiBvc190eXBlID09IFwiVW5peFwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyICgpIHsgcmV0dXJuIG9zX3R5cGUgPT0gXCJXaW4zMlwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gKCkgeyByZXR1cm4gb3NfdHlwZSA9PSBcIkN5Z3dpblwiID8gMSA6IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJqc19vZl9vY2FtbFwiKV07XG59XG5cbi8vUHJvdmlkZXM6IG9zX3R5cGVcbnZhciBvc190eXBlID0gKGdsb2JhbFRoaXMucHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtICYmXG4gICAgICAgICAgICAgICBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gPT0gXCJ3aW4zMlwiKSA/IFwiQ3lnd2luXCIgOiBcIlVuaXhcIjtcblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfY29uZmlnIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG9zX3R5cGUpLCAzMiwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzYXR0eVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNhdHR5KF9jaGFuKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfdmFyaWFudFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3ZhcmlhbnQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyKCl7cmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZ1xuZnVuY3Rpb24gdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nICgpIHtyZXR1cm4gMDt9XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbnZhciBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MgKGJvb2wpIHtcbiAgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gYm9vbDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9ydW50aW1lX3dhcm5pbmdzO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfZW5hYmxlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZShfY2hhbm5lbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiU3BhY2V0aW1lIHByb2ZpbGluZyBvbmx5IHdvcmtzIGZvciBuYXRpdmUgY29kZVwiKTtcbn1cblxuLy9BbHdheXNcbi8vUmVxdWlyZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyKCkge1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIGlmKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Mub24pIHtcbiAgICBnLnByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gKGVyciwgb3JpZ2luKSB7XG4gICAgICBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihlcnIpO1xuICAgICAgZy5wcm9jZXNzLmV4aXQgKDIpO1xuICAgIH0pXG4gIH1cbiAgZWxzZSBpZihnLmFkZEV2ZW50TGlzdGVuZXIpe1xuICAgIGcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbihldmVudCl7XG4gICAgICBpZihldmVudC5lcnJvcil7XG4gICAgICAgIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGV2ZW50LmVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlcigpO1xuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogTWxGYWtlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9hcnJheSwgY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlc1xuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzXG5mdW5jdGlvbiBNbEZha2VEZXZpY2UgKHJvb3QsIGYpIHtcbiAgdGhpcy5jb250ZW50PXt9O1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmxvb2t1cEZ1biA9IGY7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jcmVhdGVfZGlyX2lmX25lZWRlZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNvbXAgPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjb21wLmxlbmd0aCAtIDE7IGkrKyl7XG4gICAgcmVzICs9IGNvbXBbaV0gKyBcIi9cIjtcbiAgICBpZih0aGlzLmNvbnRlbnRbcmVzXSkgY29udGludWU7XG4gICAgdGhpcy5jb250ZW50W3Jlc10gPSBTeW1ib2woXCJkaXJlY3RvcnlcIik7XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuc2xhc2ggPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIC9cXC8kLy50ZXN0KG5hbWUpP25hbWU6KG5hbWUgKyBcIi9cIik7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIXRoaXMuY29udGVudFtuYW1lXSAmJiB0aGlzLmxvb2t1cEZ1bikge1xuICAgIHZhciByZXMgPSB0aGlzLmxvb2t1cEZ1bihjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucm9vdCksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSkpO1xuICAgIGlmKHJlcyAhPT0gMCkge1xuICAgICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICAgIHRoaXMuY29udGVudFtuYW1lXT1uZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhyZXNbMV0pKTtcbiAgICB9XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBUaGUgcm9vdCBvZiB0aGUgZGV2aWNlIGV4aXN0c1xuICBpZihuYW1lID09IFwiXCIpIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGRpcmVjdG9yeSBleGlzdHNcbiAgdmFyIG5hbWVfc2xhc2ggPSB0aGlzLnNsYXNoKG5hbWUpO1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF0pIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbihuYW1lLG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICBpZih0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFRVhJU1RcIiwgXCJta2RpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBGaWxlIGV4aXN0c1wiKTtcbiAgICB9XG4gIH1cbiAgdmFyIHBhcmVudCA9IC9eKC4qKVxcL1teL10rLy5leGVjKG5hbWUpO1xuICBwYXJlbnQgPSAocGFyZW50ICYmIHBhcmVudFsxXSkgfHwgJyc7XG4gIGlmKCF0aGlzLmV4aXN0cyhwYXJlbnQpKXtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PRU5UXCIsIFwibWtkaXJcIiwgdGhpcy5ubShwYXJlbnQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IocGFyZW50ICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihwYXJlbnQpKXtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVERJUlwiLCBcIm1rZGlyXCIsIHRoaXMubm0ocGFyZW50KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHBhcmVudCArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQodGhpcy5zbGFzaChuYW1lKSk7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IHJhaXNlX3VuaXggJiYgY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoodGhpcy5zbGFzaChuYW1lKSk7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIGlmKCF0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9FTlRcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICBpZighdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVERJUlwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmKG4ubWF0Y2gocikpIHtcbiAgICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RFTVBUWVwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIjogRGlyZWN0b3J5IG5vdCBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lX3NsYXNoXTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOih0aGlzLnNsYXNoKG5hbWUpKTtcbiAgaWYoIXRoaXMuZXhpc3RzKG5hbWUpKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihuYW1lKSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICB9XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIHZhciBzZWVuID0ge31cbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtICYmICFzZWVuW21bMV1dKSB7c2VlblttWzFdXSA9IHRydWU7IGEucHVzaChtWzFdKX1cbiAgfVxuICByZXR1cm4gYTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICBpZihuYW1lID09IFwiXCIpICByZXR1cm4gdHJ1ZTtcbiAgdmFyIG5hbWVfc2xhc2ggPSB0aGlzLnNsYXNoKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVfc2xhc2hdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgb2sgPSB0aGlzLmNvbnRlbnRbbmFtZV0/dHJ1ZTpmYWxzZTtcbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lXTtcbiAgcmV0dXJuIG9rO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBpcyBhIGRpcmVjdG9yeVwiKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIHZhciBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGlmKGYudHJ1bmNhdGUpIGZpbGUudHJ1bmNhdGUoKTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVnaXN0ZXI9IGZ1bmN0aW9uIChuYW1lLGNvbnRlbnQpe1xuICB2YXIgZmlsZTtcbiAgaWYodGhpcy5jb250ZW50W25hbWVdKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICBpZihjYW1sX2lzX21sX2J5dGVzKGNvbnRlbnQpKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjb250ZW50KTtcbiAgaWYoY2FtbF9pc19tbF9zdHJpbmcoY29udGVudCkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoY29udGVudCkpO1xuICBlbHNlIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQudG9TdHJpbmcpIHtcbiAgICB2YXIgYnl0ZXMgPSBjYW1sX2J5dGVzX29mX3N0cmluZyhjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhjb250ZW50LnRvU3RyaW5nKCkpKTtcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoYnl0ZXMpO1xuICB9XG4gIGlmKGZpbGUpe1xuICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gZmlsZTtcbiAgfVxuICBlbHNlIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IHJlZ2lzdGVyaW5nIGZpbGUgd2l0aCBpbnZhbGlkIGNvbnRlbnQgdHlwZVwiKTtcbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2dldFxuZnVuY3Rpb24gTWxGYWtlRmlsZShjb250ZW50KXtcbiAgdGhpcy5kYXRhID0gY29udGVudDtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdmFyIG9sZCA9IHRoaXMuZGF0YTtcbiAgdGhpcy5kYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICBjYW1sX2JsaXRfYnl0ZXMob2xkLCAwLCB0aGlzLmRhdGEsIDAsIGxlbik7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aCh0aGlzLmRhdGEpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGlmKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgdmFyIG5ld19zdHIgPSBjYW1sX2NyZWF0ZV9ieXRlcyhvZmZzZXQgKyBsZW4pO1xuICAgIHZhciBvbGRfZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSBuZXdfc3RyO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhvbGRfZGF0YSwgMCwgdGhpcy5kYXRhLCAwLCBjbGVuKTtcbiAgfVxuICBjYW1sX2JsaXRfc3RyaW5nKGJ1ZiwgcG9zLCB0aGlzLmRhdGEsIG9mZnNldCwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGNhbWxfYmxpdF9ieXRlcyh0aGlzLmRhdGEsIG9mZnNldCwgYnVmLCBwb3MsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX2dldCh0aGlzLmRhdGEsIG9mZnNldCk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG5cbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRmlsZVxuIiwiLy9Qcm92aWRlczogaW5pdGlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogc2VyaWFsaXplX25hdCwgZGVzZXJpYWxpemVfbmF0LCBjYW1sX2hhc2hfbmF0XG5mdW5jdGlvbiBpbml0aWFsaXplX25hdCgpIHtcbiAgY2FtbF9jdXN0b21fb3BzW1wiX25hdFwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZSA6IGRlc2VyaWFsaXplX25hdCxcbiAgICAgIHNlcmlhbGl6ZSA6IHNlcmlhbGl6ZV9uYXQsXG4gICAgICBoYXNoIDogY2FtbF9oYXNoX25hdFxuICAgIH1cbn1cblxuLy9Qcm92aWRlczogTWxOYXRcbmZ1bmN0aW9uIE1sTmF0KHgpe1xuICB0aGlzLmRhdGEgPSBuZXcgZ2xvYmFsVGhpcy5JbnQzMkFycmF5KHgpO1xuICAvLyBsZW5ndGhfbmF0IGlzbid0IGV4dGVybmFsLCBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhlIE9iai5zaXplXG4gIC8vIHdvcmsgb3V0IHJpZ2h0LiBUaGUgKzIgdG8gYXJyYXkgbGVuZ3RoIHNlZW1zIHRvIHdvcmsuXG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCArIDJcbn1cblxuTWxOYXQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfbmF0XCI7XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY2FtbF9oYXNoX25hdCh4KSB7XG4gIHZhciBsZW4gPSBudW1fZGlnaXRzX25hdCh4LCAwLCB4LmRhdGEubGVuZ3RoKTtcbiAgdmFyIGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHguZGF0YVtpXSk7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cblxuLy9Qcm92aWRlczogbmF0X29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gbmF0X29mX2FycmF5KGwpe1xuICByZXR1cm4gbmV3IE1sTmF0KGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjcmVhdGVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gY3JlYXRlX25hdChzaXplKSB7XG4gIHZhciBhcnIgPSBuZXcgTWxOYXQoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBhcnIuZGF0YVtpXSA9IC0xO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8vUHJvdmlkZXM6IHNldF90b196ZXJvX25hdFxuZnVuY3Rpb24gc2V0X3RvX3plcm9fbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmxpdF9uYXRcbmZ1bmN0aW9uIGJsaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IG5hdDIuZGF0YVtvZnMyK2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0XG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0KG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0XG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0KG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIG51bV9kaWdpdHNfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZihuYXQuZGF0YVtvZnMraV0gIT0gMCkgcmV0dXJuIGkrMTtcbiAgfVxuICByZXR1cm4gMTsgLy8gMCBjb3VudHMgYXMgMSBkaWdpdFxufVxuXG4vL1Byb3ZpZGVzOiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXRcbmZ1bmN0aW9uIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQsIG9mcykge1xuICB2YXIgYSA9IG5hdC5kYXRhW29mc107XG4gIHZhciBiID0gMDtcbiAgaWYoYSAmIDB4RkZGRjAwMDApIHsgYiArPTE2OyBhID4+Pj0xNjsgfVxuICBpZihhICYgMHhGRjAwKSAgICAgeyBiICs9IDg7IGEgPj4+PSA4OyB9XG4gIGlmKGEgJiAweEYwKSAgICAgICB7IGIgKz0gNDsgYSA+Pj49IDQ7IH1cbiAgaWYoYSAmIDEyKSAgICAgICAgIHsgYiArPSAyOyBhID4+Pj0gMjsgfVxuICBpZihhICYgMikgICAgICAgICAgeyBiICs9IDE7IGEgPj4+PSAxOyB9XG4gIGlmKGEgJiAxKSAgICAgICAgICB7IGIgKz0gMTsgfVxuICByZXR1cm4gMzIgLSBiO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9pbnRcbmZ1bmN0aW9uIGlzX2RpZ2l0X2ludChuYXQsIG9mcykge1xuICBpZiAobmF0LmRhdGFbb2ZzXSA+PSAwKSByZXR1cm4gMVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfemVyb1xuZnVuY3Rpb24gaXNfZGlnaXRfemVybyhuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdID09IDApIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfb2RkXG5mdW5jdGlvbiBpc19kaWdpdF9vZGQobmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSAmIDEpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGluY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKHggfCAwKTtcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IGFkZF9uYXRcbi8vUmVxdWlyZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geFxuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBjYXJyeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBsZW1lbnRfbmF0XG5mdW5jdGlvbiBjb21wbGVtZW50X25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICgtMSA+Pj4gMCkgLSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKTtcbiAgfVxufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy9Qcm92aWRlczogZGVjcl9uYXRcbmZ1bmN0aW9uIGRlY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PjApIC0gYm9ycm93O1xuICAgIG5hdC5kYXRhW29mcytpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGJvcnJvdyA9PSAxKSA/IDAgOiAxO1xufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBzdWJfbmF0XG4vL1JlcXVpcmVzOiBkZWNyX25hdFxuZnVuY3Rpb24gc3ViX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgLSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApIC0gYm9ycm93O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIChib3Jyb3c9PTEpPzA6MSk7XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNbb2ZzM11cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogbXVsdF9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGFkZF9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMykge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgYSA9IChuYXQzLmRhdGFbb2ZzM10gPj4+IDApO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHgxID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSAmIDB4MDAwMEZGRkYpICsgY2Fycnk7XG4gICAgdmFyIHgyID0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhID4+PiAxNik7XG4gICAgY2FycnkgPSBNYXRoLmZsb29yKHgyLzY1NTM2KTtcbiAgICB2YXIgeDMgPSB4MSArICh4MiAlIDY1NTM2KSAqIDY1NTM2O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDM7XG4gICAgY2FycnkgKz0gTWF0aC5mbG9vcih4My80Mjk0OTY3Mjk2KTtcbiAgfVxuXG4gIGlmKGxlbjIgPCBsZW4xICYmIGNhcnJ5KSB7XG4gICAgcmV0dXJuIGFkZF9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIG5hdF9vZl9hcnJheShbY2FycnldKSwgMCwgMSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhcnJ5O1xuICB9XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNcbi8vIGxlbjEgPj0gbGVuMiArIGxlbjMuXG4vL1Byb3ZpZGVzOiBtdWx0X25hdFxuLy9SZXF1aXJlczogbXVsdF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMsIGxlbjMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjM7IGkrKykge1xuICAgIGNhcnJ5ICs9IG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEraSwgbGVuMS1pLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzK2kpO1xuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbmF0MSA9IDIgKiBuYXQxICsgbmF0MiAqIG5hdDJcbi8vIGxlbjEgPj0gMiAqIGxlbjJcbi8vUHJvdmlkZXM6IHNxdWFyZV9uYXRcbi8vUmVxdWlyZXM6IG11bHRfbmF0LCBhZGRfbmF0XG5mdW5jdGlvbiBzcXVhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgY2FycnkgKz0gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQxLCBvZnMxLCBsZW4xLCAwKTtcbiAgY2FycnkgKz0gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMik7XG4gIHJldHVybiBjYXJyeTtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X2xlZnRfbmF0XG5mdW5jdGlvbiBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICB2YXIgYSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA8PCBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhID4+PiAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIEFzc3VtaW5nIGMgPiBhLCByZXR1cm5zIFtxdW90aWVudCwgcmVtYWluZGVyXSBvZiAoYTw8MzIgKyBiKS9jXG4vL1Byb3ZpZGVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfaGVscGVyKGEsIGIsIGMpIHtcbiAgdmFyIHggPSBhICogNjU1MzYgKyAoYj4+PjE2KTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHgvYykgKiA2NTUzNjtcbiAgdmFyIHogPSAoeCAlIGMpICogNjU1MzY7XG4gIHZhciB3ID0geiArIChiICYgMHgwMDAwRkZGRik7XG4gIHJldHVybiBbeSArIE1hdGguZmxvb3Iody9jKSwgdyAlIGNdO1xufVxuXG4vLyBuYXQxW29mczErbGVuXSA8IG5hdDJbb2ZzMl1cbi8vUHJvdmlkZXM6IGRpdl9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9kaWdpdF9uYXQobmF0cSwgb2ZzcSwgbmF0ciwgb2ZzciwgbmF0MSwgb2ZzMSwgbGVuLCBuYXQyLCBvZnMyKSB7XG4gIHZhciByZW0gPSAobmF0MS5kYXRhW29mczErbGVuLTFdID4+PjApO1xuICAvLyBuYXRxW29mc3ErbGVuLTFdIGlzIGd1YXJhbnRlZWQgdG8gYmUgemVybyAoZHVlIHRvIHRoZSBNU0QgcmVxdWlyZW1lbnQpLFxuICAvLyBhbmQgc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvLlxuICBmb3IodmFyIGkgPSBsZW4tMjsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgeCA9IGRpdl9oZWxwZXIocmVtLCAobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0Mi5kYXRhW29mczJdID4+PiAwKSk7XG4gICAgbmF0cS5kYXRhW29mc3EraV0gPSB4WzBdO1xuICAgIHJlbSA9IHhbMV07XG4gIH1cbiAgbmF0ci5kYXRhW29mc3JdID0gcmVtO1xuICByZXR1cm4gMDtcbn1cblxuLy8gbmF0MVtuYXQyOl0gOj0gbmF0MSAvIG5hdDJcbi8vIG5hdDFbOm5hdDJdIDo9IG5hdDEgJSBuYXQyXG4vLyBsZW4xID4gbGVuMiwgbmF0MltvZnMyK2xlbjItMV0gPiBuYXQxW29mczErbGVuMS0xXVxuLy9Qcm92aWRlczogZGl2X25hdFxuLy9SZXF1aXJlczogZGl2X2RpZ2l0X25hdCwgZGl2X2hlbHBlciwgbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0LCBzaGlmdF9sZWZ0X25hdCwgc2hpZnRfcmlnaHRfbmF0LCBjcmVhdGVfbmF0LCBzZXRfdG9femVyb19uYXQsIG11bHRfZGlnaXRfbmF0LCBzdWJfbmF0LCBjb21wYXJlX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBkaXZfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgaWYobGVuMiA9PSAxKSB7XG4gICAgZGl2X2RpZ2l0X25hdChuYXQxLCBvZnMxKzEsIG5hdDEsIG9mczEsIG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHMgPSBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0Miwgb2ZzMitsZW4yLTEpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcblxuICB2YXIgZCA9IChuYXQyLmRhdGFbb2ZzMitsZW4yLTFdID4+PiAwKSArIDE7XG4gIHZhciBhID0gY3JlYXRlX25hdChsZW4yKzEpO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gbGVuMjsgaS0tKSB7XG4gICAgLy8gRGVjZW50IGxvd2VyIGJvdW5kIG9uIHF1b1xuICAgIHZhciBxdW8gPSBkID09IDQyOTQ5NjcyOTYgPyAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDogZGl2X2hlbHBlcigobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0MS5kYXRhW29mczEraS0xXSA+Pj4wKSwgZClbMF07XG4gICAgc2V0X3RvX3plcm9fbmF0KGEsIDAsIGxlbjIrMSk7XG4gICAgbXVsdF9kaWdpdF9uYXQoYSwgMCwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoW3F1b10pLCAwKTtcbiAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIGEsIDAsIGxlbjIrMSwgMSk7XG5cbiAgICB3aGlsZSAobmF0MS5kYXRhW29mczEraV0gIT0gMCB8fCBjb21wYXJlX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMikgPj0gMCkge1xuICAgICAgcXVvID0gcXVvICsgMTtcbiAgICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgMSk7XG4gICAgfVxuXG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBxdW87XG4gIH1cblxuICBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyBzaGlmdCByZW1haW5kZXJcbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gcmVzdG9yZVxuICByZXR1cm4gMDtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X3JpZ2h0X25hdFxuZnVuY3Rpb24gc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gbGVuMS0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBhID0gbmF0MS5kYXRhW29mczEraV0gPj4+IDA7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA+Pj4gbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA8PCAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgaWYobmF0MS5kYXRhW29mczFdID4gbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gMTtcbiAgaWYobmF0MS5kYXRhW29mczFdIDwgbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdFxuLy9SZXF1aXJlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGEgPSBudW1fZGlnaXRzX25hdChuYXQxLCBvZnMxLCBsZW4xKTtcbiAgdmFyIGIgPSBudW1fZGlnaXRzX25hdChuYXQyLCBvZnMyLCBsZW4yKTtcbiAgaWYoYSA+IGIpIHJldHVybiAxO1xuICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICBmb3IodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA+IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAxO1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDwgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdF9yZWFsXG4vL1JlcXVpcmVzOiBjb21wYXJlX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXRfcmVhbChuYXQxLG5hdDIpe1xuICByZXR1cm4gY29tcGFyZV9uYXQobmF0MSwwLG5hdDEuZGF0YS5sZW5ndGgsbmF0MiwwLG5hdDIuZGF0YS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBsYW5kX2RpZ2l0X25hdFxuZnVuY3Rpb24gbGFuZF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gJj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSB8PSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBseG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbHhvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gXj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBzZXJpYWxpemVfbmF0XG5mdW5jdGlvbiBzZXJpYWxpemVfbmF0KHdyaXRlciwgbmF0LCBzeil7XG4gIHZhciBsZW4gPSBuYXQuZGF0YS5sZW5ndGg7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICB3cml0ZXIud3JpdGUoMzIsIG5hdC5kYXRhW2ldKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHN6WzFdID0gbGVuICogODtcbn1cblxuLy9Qcm92aWRlczogZGVzZXJpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gZGVzZXJpYWxpemVfbmF0KHJlYWRlciwgc3ope1xuICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIG5hdCA9IG5ldyBNbE5hdChsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIG5hdC5kYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHJldHVybiBuYXQ7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2NvbnN0YW50c1xudmFyIGNhbWxfbWFyc2hhbF9jb25zdGFudHMgPSB7XG4gIFBSRUZJWF9TTUFMTF9CTE9DSzogICAgICAgICAweDgwLFxuICBQUkVGSVhfU01BTExfSU5UOiAgICAgICAgICAgMHg0MCxcbiAgUFJFRklYX1NNQUxMX1NUUklORzogICAgICAgIDB4MjAsXG4gIENPREVfSU5UODogICAgICAgICAgICAgICAgICAweDAwLFxuICBDT0RFX0lOVDE2OiAgICAgICAgICAgICAgICAgMHgwMSxcbiAgQ09ERV9JTlQzMjogICAgICAgICAgICAgICAgIDB4MDIsXG4gIENPREVfSU5UNjQ6ICAgICAgICAgICAgICAgICAweDAzLFxuICBDT0RFX1NIQVJFRDg6ICAgICAgICAgICAgICAgMHgwNCxcbiAgQ09ERV9TSEFSRUQxNjogICAgICAgICAgICAgIDB4MDUsXG4gIENPREVfU0hBUkVEMzI6ICAgICAgICAgICAgICAweDA2LFxuICBDT0RFX0JMT0NLMzI6ICAgICAgICAgICAgICAgMHgwOCxcbiAgQ09ERV9CTE9DSzY0OiAgICAgICAgICAgICAgIDB4MTMsXG4gIENPREVfU1RSSU5HODogICAgICAgICAgICAgICAweDA5LFxuICBDT0RFX1NUUklORzMyOiAgICAgICAgICAgICAgMHgwQSxcbiAgQ09ERV9ET1VCTEVfQklHOiAgICAgICAgICAgIDB4MEIsXG4gIENPREVfRE9VQkxFX0xJVFRMRTogICAgICAgICAweDBDLFxuICBDT0RFX0RPVUJMRV9BUlJBWThfQklHOiAgICAgMHgwRCxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTogIDB4MEUsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfQklHOiAgICAweDBGLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTogMHgwNyxcbiAgQ09ERV9DT0RFUE9JTlRFUjogICAgICAgICAgIDB4MTAsXG4gIENPREVfSU5GSVhQT0lOVEVSOiAgICAgICAgICAweDExLFxuICBDT0RFX0NVU1RPTTogICAgICAgICAgICAgICAgMHgxMixcbiAgQ09ERV9DVVNUT01fTEVOOiAgICAgICAgICAgIDB4MTgsXG4gIENPREVfQ1VTVE9NX0ZJWEVEOiAgICAgICAgICAweDE5XG59XG5cblxuLy9Qcm92aWRlczogTWxTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIE1sU3RyaW5nUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0ID4+IDE2KSB8IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnMuc3Vic3RyaW5nKGksIGkgKyBsZW4pKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBCaWdTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBCaWdTdHJpbmdSZWFkZXIgKGJzLCBpKSB7IHRoaXMucyA9IGJzOyB0aGlzLmkgPSBpOyB9XG5CaWdTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCA4KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgMjQgPj4gMTYpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMykgICAgICAgICApID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspe1xuICAgICAgYXJyW2pdID0gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIGkraik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIH1cbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9ieXRlcyAoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzIChhKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciwgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSwgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgc2l6ZVswXSA9IDg7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzICh0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X21hcnNoYWwod3JpdGVyLCB2LCBzaXplcykge1xuICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKHYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgd3JpdGVyLndyaXRlICg4LCBiW2ldKTtcbiAgc2l6ZXNbMF0gPSA4OyBzaXplc1sxXSA9IDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsXG5mdW5jdGlvbiBjYW1sX2ludDMyX3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzaXplWzBdID0gNDtcbiAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzd2l0Y2ggKHJlYWRlci5yZWFkOHUgKCkpIHtcbiAgY2FzZSAxOlxuICAgIHNpemVbMF0gPSA0O1xuICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgY2FzZSAyOlxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICBkZWZhdWx0OiBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbmF0aXZlIGludGVnZXJcIik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3VubWFyc2hhbCwgY2FtbF9pbnQ2NF9tYXJzaGFsLCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50NjRfaGFzaFxuLy9SZXF1aXJlczogY2FtbF9pbnQzMl91bm1hcnNoYWwsIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXJpYWxpemUsIGNhbWxfYmFfZGVzZXJpYWxpemUsIGNhbWxfYmFfY29tcGFyZSwgY2FtbF9iYV9oYXNoXG52YXIgY2FtbF9jdXN0b21fb3BzID1cbiAgICB7XCJfalwiOiB7XG4gICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50NjRfdW5tYXJzaGFsLFxuICAgICAgc2VyaWFsaXplICA6IGNhbWxfaW50NjRfbWFyc2hhbCxcbiAgICAgIGZpeGVkX2xlbmd0aCA6IDgsXG4gICAgICBjb21wYXJlIDogY2FtbF9pbnQ2NF9jb21wYXJlLFxuICAgICAgaGFzaCA6IGNhbWxfaW50NjRfaGFzaFxuICAgIH0sXG4gICAgIFwiX2lcIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQzMl91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfblwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyYXlcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycmF5XCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycjAyXCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnIwMlwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9XG4gICAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKSB7XG4gIHZhciBfbWFnaWMgPSByZWFkZXIucmVhZDMydSAoKVxuICB2YXIgX2Jsb2NrX2xlbiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgbnVtX29iamVjdHMgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzMyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV82NCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSAobnVtX29iamVjdHMgPiAwKT9bXTpudWxsO1xuICB2YXIgb2JqX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbnRlcm5fcmVjICgpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweEY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAoY29kZSAmIDB4M0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MUY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4cyAoKTtcbiAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDE2cyAoKTtcbiAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW50ZWdlciB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDE2dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4RkY7XG4gICAgICAgICAgdmFyIHNpemUgPSBoZWFkZXIgPj4gMTA7XG4gICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEzOiAvL2NzdC5DT0RFX0JMT0NLNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBDOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0W2ldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBFOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwNzogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgIGNhc2UgMHgxMTogLy9jc3QuQ09ERV9JTkZJWFBPSU5URVI6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICBjYXNlIDB4MTg6IC8vY3N0LkNPREVfQ1VTVE9NX0xFTjpcbiAgICAgICAgY2FzZSAweDE5OiAvL2NzdC5DT0RFX0NVU1RPTV9GSVhFRDpcbiAgICAgICAgICB2YXIgYywgcyA9IFwiXCI7XG4gICAgICAgICAgd2hpbGUgKChjID0gcmVhZGVyLnJlYWQ4dSAoKSkgIT0gMCkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW3NdO1xuICAgICAgICAgIHZhciBleHBlY3RlZF9zaXplO1xuICAgICAgICAgIGlmKCFvcHMpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHVua25vd24gY3VzdG9tIGJsb2NrIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgIGNhc2UgMHgxMjogLy8gY3N0LkNPREVfQ1VTVE9NIChkZXByZWNhdGVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE5OiAvLyBjc3QuQ09ERV9DVVNUT01fRklYRURcbiAgICAgICAgICAgIGlmKCFvcHMuZml4ZWRfbGVuZ3RoKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gb3BzLmZpeGVkX2xlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxODogLy8gY3N0LkNPREVfQ1VTVE9NX0xFTlxuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgICAgLy8gU2tpcCBzaXplNjRcbiAgICAgICAgICAgIHJlYWRlci5yZWFkMzJzKCk7IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSByZWFkZXIuaTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IFswXTtcbiAgICAgICAgICB2YXIgdiA9IG9wcy5kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpO1xuICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gc2l6ZVswXSlcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbmNvcnJlY3QgbGVuZ3RoIG9mIHNlcmlhbGl6ZWQgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBtZXNzYWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXMgPSBpbnRlcm5fcmVjICgpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBzaXplID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZCA9IHYubGVuZ3RoO1xuICAgIGlmIChkIDwgc2l6ZSkgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICB2W2RdID0gaW50ZXJuX3JlYyAoKTtcbiAgfVxuICBpZiAodHlwZW9mIG9mcyE9XCJudW1iZXJcIikgb2ZzWzBdID0gcmVhZGVyLmk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChzLCBvZnMpIHtcbiAgZnVuY3Rpb24gZ2V0MzIocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSkgPDwgMjQpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAyKSA8PCA4KSB8XG4gICAgICBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDMpO1xuICB9XG4gIGlmIChnZXQzMihzLCBvZnMpICE9ICgweDg0OTVBNkJFfDApKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJNYXJzaGFsLmRhdGFfc2l6ZTogYmFkIG9iamVjdFwiKTtcbiAgcmV0dXJuIChnZXQzMihzLCBvZnMgKyA0KSk7XG59XG5cbi8vUHJvdmlkZXM6IE1sT2JqZWN0VGFibGVcbnZhciBNbE9iamVjdFRhYmxlO1xuaWYgKHR5cGVvZiBnbG9iYWxUaGlzLldlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBwb2x5ZmlsbCAodXNpbmcgbGluZWFyIHNlYXJjaCkgKi9cbiAgICBmdW5jdGlvbiBOYWl2ZUxvb2t1cChvYmpzKSB7IHRoaXMub2JqcyA9IG9ianM7IH1cbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGhlcmUuIFtNbE9iamVjdFRhYmxlLnN0b3JlXSB3aWxsIHB1c2ggdG8gW3RoaXMub2Jqc10gZGlyZWN0bHkuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IE5haXZlTG9va3VwKHRoaXMub2Jqcyk7XG4gICAgfTtcbiAgfSgpO1xufVxuZWxzZSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBnbG9iYWxUaGlzLldlYWtNYXAoKTtcbiAgfTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMubG9va3VwLnNldCh2LCB0aGlzLm9ianMubGVuZ3RoKTtcbiAgdGhpcy5vYmpzLnB1c2godik7XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnJlY2FsbCA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIGkgPSB0aGlzLmxvb2t1cC5nZXQodik7XG4gIHJldHVybiAoaSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkIDogdGhpcy5vYmpzLmxlbmd0aCAtIGk7ICAgLyogaW5kZXggaXMgcmVsYXRpdmUgKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGVcbi8vVmVyc2lvbjogPj0gNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGVcbi8vVmVyc2lvbjogPCA0LjA4XG52YXIgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUgPSB0cnVlXG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBNbE9iamVjdFRhYmxlLCBjYW1sX2xpc3RfdG9fanNfYXJyYXksIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG52YXIgY2FtbF9vdXRwdXRfdmFsID0gZnVuY3Rpb24gKCl7XG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7IHRoaXMuY2h1bmsgPSBbXTsgfVxuICBXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIGNodW5rX2lkeDoyMCwgYmxvY2tfbGVuOjAsIG9ial9jb3VudGVyOjAsIHNpemVfMzI6MCwgc2l6ZV82NDowLFxuICAgIHdyaXRlOmZ1bmN0aW9uIChzaXplLCB2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfYXQ6ZnVuY3Rpb24gKHBvcywgc2l6ZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwb3MgPSBwb3M7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1twb3MrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfY29kZTpmdW5jdGlvbiAoc2l6ZSwgY29kZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSBjb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfc2hhcmVkOmZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgPCAoMSA8PCA4KSkgdGhpcy53cml0ZV9jb2RlKDgsIDB4MDQgLypjc3QuQ09ERV9TSEFSRUQ4Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIGlmIChvZmZzZXQgPCAoMSA8PCAxNikpIHRoaXMud3JpdGVfY29kZSgxNiwgMHgwNSAvKmNzdC5DT0RFX1NIQVJFRDE2Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIHRoaXMud3JpdGVfY29kZSgzMiwgMHgwNiAvKmNzdC5DT0RFX1NIQVJFRDMyKi8sIG9mZnNldCk7XG4gICAgfSxcbiAgICBwb3M6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jaHVua19pZHggfSxcbiAgICBmaW5hbGl6ZTpmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJsb2NrX2xlbiA9IHRoaXMuY2h1bmtfaWR4IC0gMjA7XG4gICAgICB0aGlzLmNodW5rX2lkeCA9IDA7XG4gICAgICB0aGlzLndyaXRlICgzMiwgMHg4NDk1QTZCRSk7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5ibG9ja19sZW4pO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMub2JqX2NvdW50ZXIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV8zMik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzY0KTtcbiAgICAgIHJldHVybiB0aGlzLmNodW5rO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKHYsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSBjYW1sX2xpc3RfdG9fanNfYXJyYXkoZmxhZ3MpO1xuXG4gICAgdmFyIG5vX3NoYXJpbmcgPSAoZmxhZ3MuaW5kZXhPZigwIC8qTWFyc2hhbC5Ob19zaGFyaW5nKi8pICE9PSAtMSksXG4gICAgICAgIGNsb3N1cmVzID0gIChmbGFncy5pbmRleE9mKDEgLypNYXJzaGFsLkNsb3N1cmVzKi8pICE9PSAtMSk7XG4gICAgLyogTWFyc2hhbC5Db21wYXRfMzIgaXMgcmVkdW5kYW50IHNpbmNlIGludGVnZXJzIGFyZSAzMi1iaXQgYW55d2F5ICovXG5cbiAgICBpZiAoY2xvc3VyZXMpXG4gICAgICBnbG9iYWxUaGlzLmNvbnNvbGUud2FybihcImluIGNhbWxfb3V0cHV0X3ZhbDogZmxhZyBNYXJzaGFsLkNsb3N1cmVzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIgKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGludGVybl9vYmpfdGFibGUgPSBub19zaGFyaW5nID8gbnVsbCA6IG5ldyBNbE9iamVjdFRhYmxlKCk7XG5cbiAgICBmdW5jdGlvbiBtZW1vKHYpIHtcbiAgICAgIGlmIChub19zaGFyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZXhpc3Rpbmdfb2Zmc2V0ID0gaW50ZXJuX29ial90YWJsZS5yZWNhbGwodik7XG4gICAgICBpZiAoZXhpc3Rpbmdfb2Zmc2V0KSB7IHdyaXRlci53cml0ZV9zaGFyZWQoZXhpc3Rpbmdfb2Zmc2V0KTsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGVsc2UgeyBpbnRlcm5fb2JqX3RhYmxlLnN0b3JlKHYpOyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlcm5fcmVjICh2KSB7XG4gICAgICBpZiAodi5jYW1sX2N1c3RvbSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZSA9IHYuY2FtbF9jdXN0b207XG4gICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbbmFtZV07XG4gICAgICAgIHZhciBzel8zMl82NCA9IFswLDBdO1xuICAgICAgICBpZighb3BzLnNlcmlhbGl6ZSlcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChDdXN0b20pXCIpO1xuICAgICAgICBpZihjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxMiAvKmNzdC5DT0RFX0NVU1RPTSovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgIH0gZWxzZSBpZihvcHMuZml4ZWRfbGVuZ3RoID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE4IC8qY3N0LkNPREVfQ1VTVE9NX0xFTiovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBoZWFkZXJfcG9zID0gd3JpdGVyLnBvcyAoKTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zLCAzMiwgc3pfMzJfNjRbMF0pO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgNCwgMzIsIDApOyAvLyB6ZXJvXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA4LCAzMiwgc3pfMzJfNjRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOSAvKmNzdC5DT0RFX0NVU1RPTV9GSVhFRCovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBvbGRfcG9zID0gd3JpdGVyLnBvcygpO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgaWYgKG9wcy5maXhlZF9sZW5ndGggIT0gd3JpdGVyLnBvcygpIC0gb2xkX3BvcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGluY29ycmVjdCBmaXhlZCBzaXplcyBzcGVjaWZpZWQgYnkgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAyICsgKChzel8zMl82NFswXSArIDMpID4+IDIpO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyICsgKChzel8zMl82NFsxXSArIDcpID4+IDMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICAgIGlmICh2WzBdID09IDI1MSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChBYnN0cmFjdClcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSAmJiBtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIGlmICh2WzBdIDwgMTYgJiYgdi5sZW5ndGggLSAxIDwgOClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8gKyB2WzBdICsgKCh2Lmxlbmd0aCAtIDEpPDw0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwOCAvKmNzdC5DT0RFX0JMT0NLMzIqLywgKCh2Lmxlbmd0aC0xKSA8PCAxMCkgfCB2WzBdKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gdi5sZW5ndGg7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxKSBzdGFjay5wdXNoICh2LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgICBpZighKGNhbWxfaXNfbWxfYnl0ZXMoY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKSkpKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogW0J5dGVzLnRdIGNhbm5vdCBzYWZlbHkgYmUgbWFyc2hhbGVkIHdpdGggWy0tZW5hYmxlIHVzZS1qcy1zdHJpbmddXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX2J5dGVzX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgIT0gKHZ8MCkpe1xuICAgICAgICAgIHZhciB0eXBlX29mX3YgPSB0eXBlb2YgdjtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGEgZmxvYXQgaGFwcGVucyB0byBiZSBhbiBpbnRlZ2VyIGl0IGlzIHNlcmlhbGl6ZWQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgIC8vIChKc19vZl9vY2FtbCBjYW5ub3QgdGVsbCB3aGV0aGVyIHRoZSB0eXBlIG9mIGFuIGludGVnZXIgbnVtYmVyIGlzXG4gICAgICAgICAgLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuICAgICAgICAgIC8vIHVubWFyc2hhbGxpbmcgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bnRpbWUuIEl0IHNlZW1zIGJldHRlciB0b1xuICAgICAgICAgIC8vIHN5c3RlbWF0aWNhbGx5IGZhaWwgb24gbWFyc2hhbGxpbmcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAgICAgICBpZih0eXBlX29mX3YgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIrdHlwZV9vZl92K1wiKVwiKTtcbiAgICAgICAgICAvLyAgICAgICAgICB2YXIgdCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHYpKTtcbiAgICAgICAgICAvLyAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MEIgLypjc3QuQ09ERV9ET1VCTEVfQklHKi8pO1xuICAgICAgICAgIC8vICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8ODsgaSsrKXt3cml0ZXIud3JpdGUoOCx0W2ldKX1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IDAgJiYgdiA8IDB4NDApIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDBYNDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovICsgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgPj0gLSgxIDw8IDcpICYmIHYgPCAoMSA8PCA3KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDAgLypjc3QuQ09ERV9JTlQ4Ki8sIHYpO1xuICAgICAgICAgIGVsc2UgaWYgKHYgPj0gLSgxIDw8IDE1KSAmJiB2IDwgKDEgPDwgMTUpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMTYsIDB4MDEgLypjc3QuQ09ERV9JTlQxNiovLCB2KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwMiAvKmNzdC5DT0RFX0lOVDMyKi8sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dGVybl9yZWMgKHYpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaSA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIHZhciB2ID0gc3RhY2sucG9wICgpO1xuICAgICAgaWYgKGkgKyAxIDwgdi5sZW5ndGgpIHN0YWNrLnB1c2ggKHYsIGkgKyAxKTtcbiAgICAgIGV4dGVybl9yZWMgKHZbaV0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgd3JpdGVyLm9ial9jb3VudGVyID0gaW50ZXJuX29ial90YWJsZS5vYmpzLmxlbmd0aDtcbiAgICB3cml0ZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gd3JpdGVyLmNodW5rO1xuICB9XG59ICgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2J5dGVzX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfYmxpdF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIChzLCBvZnMsIGxlbiwgdiwgZmxhZ3MpIHtcbiAgdmFyIHQgPSBjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKTtcbiAgaWYgKHQubGVuZ3RoID4gbGVuKSBjYW1sX2ZhaWx3aXRoIChcIk1hcnNoYWwudG9fYnVmZmVyOiBidWZmZXIgb3ZlcmZsb3dcIik7XG4gIGNhbWxfYmxpdF9ieXRlcyh0LCAwLCBzLCBvZnMsIHQubGVuZ3RoKTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZmZzZXRcbnZhciBjYW1sX2ludDY0X29mZnNldCA9IE1hdGgucG93KDIsIC0yNCk7XG5cbi8vUHJvdmlkZXM6IE1sSW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBNbEludDY0IChsbyxtaSxoaSkge1xuICB0aGlzLmxvID0gbG8gJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9IG1pICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSBoaSAmIDB4ZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfalwiXG5NbEludDY0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyx0aGlzLm1pLHRoaXMuaGkpO1xufVxuXG5NbEludDY0LnByb3RvdHlwZS51Y29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIGlmICh0aGlzLmhpID4geC5oaSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmhpIDwgeC5oaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBoaSA9IHRoaXMuaGkgPDwgMTY7XG4gIHZhciB4aGkgPSB4LmhpIDw8IDE2O1xuICBpZiAoaGkgPiB4aGkpIHJldHVybiAxO1xuICBpZiAoaGkgPCB4aGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvID0gLSB0aGlzLmxvO1xuICB2YXIgbWkgPSAtIHRoaXMubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSAtIHRoaXMuaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICsgeC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSArIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpICsgeC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gLSB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pIC0geC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgLSB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAqIHgubG87XG4gIHZhciBtaSA9ICgobG8gKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMubWkgKiB4LmxvICsgdGhpcy5sbyAqIHgubWk7XG4gIHZhciBoaSA9ICgobWkgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMuaGkgKiB4LmxvICsgdGhpcy5taSAqIHgubWkgKyB0aGlzLmxvICogeC5oaTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMubG98dGhpcy5taXx0aGlzLmhpKSA9PSAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5oaSA8PCAxNikgPCAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8gJiB4LmxvLCB0aGlzLm1pICYgeC5taSwgdGhpcy5oaSAmIHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb3x4LmxvLCB0aGlzLm1pfHgubWksIHRoaXMuaGl8eC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb154LmxvLCB0aGlzLm1pXngubWksIHRoaXMuaGleeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9sZWZ0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpIHtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMubG8gPDwgcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IHMpIHwgKHRoaXMubG8gPj4gKDI0IC0gcykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaGkgPDwgcykgfCAodGhpcy5taSA+PiAoMjQgLSBzKSkpO1xuICB9XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sbyA8PCAocyAtIDI0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IChzIC0gMjQpKSB8ICh0aGlzLmxvID4+ICg0OCAtIHMpKSk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCgwLCAwLCB0aGlzLmxvIDw8IChzIC0gNDgpKVxufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHRfdW5zaWduZWQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8ICh0aGlzLmhpIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IHMpKTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gKHMgLSAyNCkpLFxuICAgICAgMCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5oaSA+PiAocyAtIDQ4KSwgMCwgMCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICB2YXIgaCA9ICh0aGlzLmhpIDw8IDE2KSA+PiAxNjtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8IChoIDw8ICgyNCAtIHMpKSxcbiAgICAgICgodGhpcy5oaSA8PCAxNikgPj4gcykgPj4+IDE2KTtcbiAgdmFyIHNpZ24gPSAodGhpcy5oaSA8PCAxNikgPj4gMzE7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDI0KSA+PiAxNixcbiAgICAgIHNpZ24gJiAweGZmZmYpO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKCh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDMyKSwgc2lnbiwgc2lnbik7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc2wxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhpID0gKHRoaXMuaGkgPDwgMSkgfCAodGhpcy5taSA+PiAyMyk7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPDwgMSkgfCAodGhpcy5sbyA+PiAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubG8gPSAodGhpcy5sbyA8PCAxKSAmIDB4ZmZmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNyMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sbyA9ICgodGhpcy5sbyA+Pj4gMSkgfCAodGhpcy5taSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPj4+IDEpIHwgKHRoaXMuaGkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gdGhpcy5oaSA+Pj4gMTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnVkaXZtb2QgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIG1vZHVsdXMgPSB0aGlzLmNvcHkoKTtcbiAgdmFyIGRpdmlzb3IgPSB4LmNvcHkoKTtcbiAgdmFyIHF1b3RpZW50ID0gbmV3IE1sSW50NjQoMCwwLDApO1xuICB3aGlsZSAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+IDApIHtcbiAgICBvZmZzZXQrKztcbiAgICBkaXZpc29yLmxzbDEoKTtcbiAgfVxuICB3aGlsZSAob2Zmc2V0ID49IDApIHtcbiAgICBvZmZzZXQgLS07XG4gICAgcXVvdGllbnQubHNsMSgpO1xuICAgIGlmIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID49IDApIHtcbiAgICAgIHF1b3RpZW50LmxvICsrO1xuICAgICAgbW9kdWx1cyA9IG1vZHVsdXMuc3ViKGRpdmlzb3IpO1xuICAgIH1cbiAgICBkaXZpc29yLmxzcjEoKTtcbiAgfVxuICByZXR1cm4geyBxdW90aWVudCA6IHF1b3RpZW50LCBtb2R1bHVzIDogbW9kdWx1cyB9O1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaSBeIHkuaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgcSA9IHgudWRpdm1vZCh5KS5xdW90aWVudDtcbiAgaWYgKHNpZ24gJiAweDgwMDApIHEgPSBxLm5lZygpO1xuICByZXR1cm4gcTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgciA9IHgudWRpdm1vZCh5KS5tb2R1bHVzO1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgciA9IHIubmVnKCk7XG4gIHJldHVybiByO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKHRoaXMubWkgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9GbG9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5oaSA8PCAxNikgKiBNYXRoLnBvdygyLCAzMikgKyB0aGlzLm1pICogTWF0aC5wb3coMiwgMjQpKSArIHRoaXMubG87XG59XG5NbEludDY0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW3RoaXMuaGkgPj4gOCxcbiAgICAgICAgICB0aGlzLmhpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pID4+IDE2LFxuICAgICAgICAgICh0aGlzLm1pID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvID4+IDE2LFxuICAgICAgICAgICh0aGlzLmxvID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvICYgMHhmZl07XG59XG5NbEludDY0LnByb3RvdHlwZS5sbzMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICgodGhpcy5taSAmIDB4ZmYpIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmhpMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMubWkgPj4+IDgpICYgMHhmZmZmKSB8ICh0aGlzLmhpIDw8IDE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWx0KHgseSkgeyByZXR1cm4geC51Y29tcGFyZSh5KSA8IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NvbXBhcmUoeCx5LCB0b3RhbCkgeyByZXR1cm4geC5jb21wYXJlKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9uZWcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbmVnICh4KSB7IHJldHVybiB4Lm5lZygpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hZGQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYWRkICh4LCB5KSB7IHJldHVybiB4LmFkZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc3ViIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3N1YiAoeCwgeSkgeyByZXR1cm4geC5zdWIoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X211bCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbXVsKHgseSkgeyByZXR1cm4geC5tdWwoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX3plcm8gY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfemVybyh4KSB7IHJldHVybiAreC5pc1plcm8oKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpIHsgcmV0dXJuICt4LmlzTmVnKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hbmQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYW5kICh4LCB5KSB7IHJldHVybiB4LmFuZCh5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29yICh4LCB5KSB7IHJldHVybiB4Lm9yKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfeG9yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3hvciAoeCwgeSkgeyByZXR1cm4geC54b3IoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfbGVmdCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9sZWZ0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodF91bnNpZ25lZChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2RpdiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9kaXYgKHgsIHkpIHsgcmV0dXJuIHguZGl2KHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tb2QgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbW9kICh4LCB5KSB7IHJldHVybiB4Lm1vZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfaW50MzIgKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHggJiAweGZmZmZmZiwgKHggPj4gMjQpICYgMHhmZmZmZmYsICh4ID4+IDMxKSAmIDB4ZmZmZilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19pbnQzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19pbnQzMiAoeCkgeyByZXR1cm4geC50b0ludCgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19mbG9hdCAoeCkgeyByZXR1cm4geC50b0Zsb2F0ICgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKHggPCAwKSB4ID0gTWF0aC5jZWlsKHgpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgeCAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mb3JtYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZm9ybWF0IChmbXQsIHgpIHtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoZi5zaWduZWRjb252ICYmIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkpIHtcbiAgICBmLnNpZ24gPSAtMTsgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICB9XG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICB2YXIgd2Jhc2UgPSBjYW1sX2ludDY0X29mX2ludDMyKGYuYmFzZSk7XG4gIHZhciBjdnRibCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICBkbyB7XG4gICAgdmFyIHAgPSB4LnVkaXZtb2Qod2Jhc2UpO1xuICAgIHggPSBwLnF1b3RpZW50O1xuICAgIGJ1ZmZlciA9IGN2dGJsLmNoYXJBdChjYW1sX2ludDY0X3RvX2ludDMyKHAubW9kdWx1cykpICsgYnVmZmVyO1xuICB9IHdoaWxlICghIGNhbWxfaW50NjRfaXNfemVybyh4KSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIGJ1ZmZlciA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIGJ1ZmZlcjtcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBidWZmZXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3BhcnNlX2RpZ2l0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3VsdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGJhc2U2NCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoYmFzZSk7XG4gIHZhciB0aHJlc2hvbGQgPVxuICAgICAgbmV3IE1sSW50NjQoMHhmZmZmZmYsIDB4ZmZmZmZmZiwgMHhmZmZmKS51ZGl2bW9kKGJhc2U2NCkucXVvdGllbnQ7XG4gIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBtdWx0aXBsaWNhdGlvbiBiYXNlICogcmVzICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHRocmVzaG9sZCwgcmVzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgZCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwoYmFzZTY0LCByZXMpLCBkKTtcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gYWRkaXRpb24gKGJhc2UgKiByZXMpICsgZCAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdChyZXMsIGQpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoYmFzZSA9PSAxMCAmJiBjYW1sX2ludDY0X3VsdChuZXcgTWxJbnQ2NCgwLCAwLCAweDgwMDApLCByZXMpKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoc2lnbiA8IDApIHJlcyA9IGNhbWxfaW50NjRfbmVnKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShsbywgbWksIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobG8sIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICBsbyAmIDB4ZmZmZmZmLFxuICAgICgobG8gPj4+IDI0KSAmIDB4ZmYpIHwgKChoaSAmIDB4ZmZmZikgPDwgOCksXG4gICAgKGhpID4+PiAxNikgJiAweGZmZmYpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sbzMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xvMzIodil7IHJldHVybiB2LmxvMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGkzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oaTMyKHYpeyByZXR1cm4gdi5oaTMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2J5dGVzKGEpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGFbN10gPDwgMCB8IChhWzZdIDw8IDgpIHwgKGFbNV0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVs0XSA8PCAwIHwgKGFbM10gPDwgOCkgfCAoYVsyXSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzFdIDw8IDAgfCAoYVswXSA8PCA4KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2J5dGVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2J5dGVzKHgpIHsgcmV0dXJuIHgudG9BcnJheSgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oYXNoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hhc2godil7XG4gIHJldHVybiAodi5sbzMyKCkpIF4gKHYuaGkzMigpKVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfaW50IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZywgY2FtbF9zdHJfcmVwZWF0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9pbnQoZm10LCBpKSB7XG4gIGlmIChjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCkgPT0gXCIlZFwiKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiK2kpO1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChpIDwgMCkgeyBpZiAoZi5zaWduZWRjb252KSB7IGYuc2lnbiA9IC0xOyBpID0gLWk7IH0gZWxzZSBpID4+Pj0gMDsgfVxuICB2YXIgcyA9IGkudG9TdHJpbmcoZi5iYXNlKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBzLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIHMgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBzO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKSB7XG4gIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBiYXNlID0gMTAsIHNpZ24gPSAxO1xuICBpZiAobGVuID4gMCkge1xuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpKSB7XG4gICAgY2FzZSA0NTogaSsrOyBzaWduID0gLTE7IGJyZWFrO1xuICAgIGNhc2UgNDM6IGkrKzsgc2lnbiA9IDE7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDEgPCBsZW4gJiYgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA9PSA0OClcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpKSB7XG4gICAgY2FzZSAxMjA6IGNhc2UgODg6IGJhc2UgPSAxNjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExMTogY2FzZSA3OTogYmFzZSA9ICA4OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgIDk4OiBjYXNlIDY2OiBiYXNlID0gIDI7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTc6IGNhc2UgODU6IGkgKz0gMjsgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gW2ksIHNpZ24sIGJhc2VdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2RpZ2l0XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2RpZ2l0KGMpIHtcbiAgaWYgKGMgPj0gNDggJiYgYyA8PSA1NykgIHJldHVybiBjIC0gNDg7XG4gIGlmIChjID49IDY1ICYmIGMgPD0gOTApICByZXR1cm4gYyAtIDU1O1xuICBpZiAoYyA+PSA5NyAmJiBjIDw9IDEyMikgcmV0dXJuIGMgLSA4NztcbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfcGFyc2VfZGlnaXQsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfaW50X29mX3N0cmluZyAocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgdGhyZXNob2xkID0gLTEgPj4+IDA7XG4gIHZhciBjID0gKGkgPCBsZW4pP2NhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk6MDtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGQ7XG4gIGZvciAoaSsrO2k8bGVuO2krKykge1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICByZXMgPSBiYXNlICogcmVzICsgZDtcbiAgICBpZiAocmVzID4gdGhyZXNob2xkKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAvLyBGb3IgYmFzZSBkaWZmZXJlbnQgZnJvbSAxMCwgd2UgZXhwZWN0IGFuIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLFxuICAvLyBoZW5jZSBhbnkgdmFsdWUgb2YgJ3JlcycgKGxlc3MgdGhhbiAndGhyZXNob2xkJykgaXMgYWNjZXB0YWJsZS5cbiAgLy8gQnV0IHdlIGhhdmUgdG8gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gYSBzaWduZWQgaW50ZWdlci5cbiAgcmVzID0gc2lnbiAqIHJlcztcbiAgaWYgKChiYXNlID09IDEwKSAmJiAoKHJlcyB8IDApICE9IHJlcykpXG4gICAgLyogU2lnbmVkIHJlcHJlc2VudGF0aW9uIGV4cGVjdGVkLCBhbGxvdyAtMl4obmJpdHMtMSkgdG8gMl4obmJpdHMtMSkgLSAxICovXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHJldHVybiByZXMgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX211bCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tdWwoYSxiKXtcbiAgcmV0dXJuIE1hdGguaW11bChhLGIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RpdlxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9kaXYoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiAoeC95KXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9tb2QoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiB4JXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnN3YXAxNlxuZnVuY3Rpb24gY2FtbF9ic3dhcDE2KHgpIHtcbiAgcmV0dXJuICgoKCh4ICYgMHgwMEZGKSA8PCA4KSB8XG4gICAgICAgICAgICgoeCAmIDB4RkYwMCkgPj4gOCkpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYnN3YXBcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYnN3YXAoeCkge1xuICByZXR1cm4gKCgoeCAmIDB4MDAwMDAwRkYpIDw8IDI0KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMDAwRkYwMCkgPDwgOCkgfFxuICAgICAgICAgICgoeCAmIDB4MDBGRjAwMDApID4+PiA4KSB8XG4gICAgICAgICAgKCh4ICYgMHhGRjAwMDAwMCkgPj4+IDI0KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Jzd2FwXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X2Jzd2FwKHgpIHtcbiAgdmFyIHkgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHgpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbeVs3XSwgeVs2XSwgeVs1XSwgeVs0XSwgeVszXSwgeVsyXSwgeVsxXSwgeVswXV0pO1xufVxuIiwiLy8gVGhpcyBjb2RlIHN1cHBvcnRzIGJvdGggQXJyYXkgYW5kIE1sSW50NjQgaW1wbGVtZW50YXRpb25zIG9mIGludDY0IGluXG4vLyBqc19vZl9vY2FtbCAocHJlLSB2cyBwb3N0LTg4NzUwN2RiMWViOGVmZDc3OTA3MGNiZWRhYjM3NzQwOThhNTI5MzkpLlxuLy9cbi8vIENvbXBpbGF0aW9uIGlzIGN1cnJlbnRseSBicm9rZW4gb24gdGhlIE1sSW50NjQgaW1wbGVtZW50YXRpb24sIGR1ZSB0b1xuLy8gcmVtb3ZlZCBpbnRlcm5hbCBqc19vZl9vY2FtbCBwcmltaXRpdmVzLiBSZW1vdmluZyB0aGVzZSAoYW5kIHRoZSBBcnJheVxuLy8gaW1wbGVtZW50YXRpb25zLCBzaWduYWxsZWQgYnkgW2luc3RhbmNlb2YgQXJyYXldIGNoZWNrcykgd2lsbCBjYXVzZVxuLy8gY29tcGlsYXRpb24gdG8gc3VjY2VlZC5cbi8vXG4vLyBUT0RPOiBidWlsZC10aW1lIG1hZ2ljIHRvIHN0dWIgdGhlIHVuYXZhaWxhYmxlIHByaW1pdGl2ZXMgb24gbGF0ZXIgdmVyc2lvbnMuXG5cbi8vUHJvdmlkZXM6IFVJbnQzMiBjb25zdFxudmFyIFVJbnQzMiA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgVUludDMyID0gZnVuY3Rpb24oeCkge1xuICAgICAgICB0aGlzLnZhbHVlID0geCA+Pj4gMDtcbiAgICB9O1xuICAgIFVJbnQzMi5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcImludGVnZXJzOnVpbnQzMlwiO1xuICAgIHJldHVybiBVSW50MzI7XG59KSgpO1xuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc19pbnQzMl9vZl91aW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX2ludDMyX29mX3VpbnQzMihpKSB7XG4gICAgcmV0dXJuIChpLnZhbHVlIHwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3NpemVfdF9zaXplXG5mdW5jdGlvbiBpbnRlZ2Vyc19zaXplX3Rfc2l6ZSh1bml0KSB7XG4gICAgcmV0dXJuIDQ7IC8vIFNldCBzaXplX3QgPSB1MzJcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDE2X29mX3N0cmluZ1xuLy9SZXF1aXJlczogaW50ZWdlcnNfdWludDMyX29mX3N0cmluZ1xuZnVuY3Rpb24gaW50ZWdlcnNfdWludDE2X29mX3N0cmluZyh4KSB7XG4gICAgdmFyIHkgPSBpbnRlZ2Vyc191aW50MzJfb2Zfc3RyaW5nKHgpO1xuICAgIHJldHVybiAoeS52YWx1ZSAmIDB4RkZGRik7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9hZGRcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2FkZCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSArIHkudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfc3ViXG4vL1JlcXVpcmVzOiBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9zdWIoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDMyKHgudmFsdWUgLSB5LnZhbHVlKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX2RpdlxuLy9SZXF1aXJlczogVUludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfZGl2KHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQzMih4LnZhbHVlIC8geS52YWx1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9sb2dhbmRcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2xvZ2FuZCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSAmIHkudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfbG9nb3Jcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2xvZ29yKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQzMih4LnZhbHVlIHwgeS52YWx1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9sb2d4b3Jcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2xvZ3hvcih4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSBeIHkudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfbWF4XG4vL1JlcXVpcmVzOiBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9tYXgodW5pdCkge1xuICAgIHJldHVybiBuZXcgVUludDMyKDB4RkZGRkZGRkYpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfbXVsXG4vL1JlcXVpcmVzOiBpbnRlZ2Vyc191aW50MzJfdG9faW50NjQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X3RvX2ludDMyLCBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9tdWwoeCwgeSkge1xuICAgIC8vIENvbnZlcnQgdG8gNjQtYml0IGFuZCBjb21wdXRlIHRoZXJlLlxuICAgIHZhciB4XzY0ID0gaW50ZWdlcnNfdWludDMyX3RvX2ludDY0KHgpO1xuICAgIHZhciB5XzY0ID0gaW50ZWdlcnNfdWludDMyX3RvX2ludDY0KHkpO1xuICAgIHJldHVybiBuZXcgVUludDMyIChjYW1sX2ludDY0X3RvX2ludDMyKGNhbWxfaW50NjRfbXVsKHhfNjQsIHlfNjQpKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9vZl9pbnRcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX29mX2ludChpKSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9vZl9pbnQzMlxuLy9SZXF1aXJlczogVUludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfb2ZfaW50MzIoaSkge1xuICAgIHJldHVybiBuZXcgVUludDMyKGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfb2ZfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9faW50MzIsIFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX29mX2ludDY0KGkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQzMihjYW1sX2ludDY0X3RvX2ludDMyKGkpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX29mX3N0cmluZ1xuLy9SZXF1aXJlczogaW50ZWdlcnNfdWludF9vZl9zdHJpbmcsIGludGVnZXJzX3VpbnQzMl9vZl9pbnQ2NCwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9vZl9zdHJpbmcocykge1xuICAgIC8vIFRvIG1hdGNoIHRoZSBDIGltcGxlbWVudGF0aW9uLCB3ZSBzaG91bGQgcGFyc2UgdGhlIHN0cmluZyBhcyBhbiB1aW50NjRcbiAgICAvLyBhbmQgdGhlbiBkb3duY2FzdC5cbiAgICB2YXIgbWF4X3ZhbCA9IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDB4ZmZmZmZmLCAweGZmZmZmZiwgMHhmZmZmKTtcbiAgICByZXR1cm4gaW50ZWdlcnNfdWludDMyX29mX2ludDY0KGludGVnZXJzX3VpbnRfb2Zfc3RyaW5nKHMsIG1heF92YWwpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX3JlbVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSwgVUludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfcmVtKHgsIHkpIHtcbiAgICBpZiAoeS52YWx1ZSA9PSAwKSB7XG4gICAgICAgIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSAlIHkudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfc2hpZnRfbGVmdFxuLy9SZXF1aXJlczogVUludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfc2hpZnRfbGVmdCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSA8PCB5KTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX3NoaWZ0X3JpZ2h0XG4vL1JlcXVpcmVzOiBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9zaGlmdF9yaWdodCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSA+Pj4geSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl90b19pbnRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl90b19pbnQoaSkge1xuICAgIHJldHVybiAoaS52YWx1ZSB8IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfdG9faW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfdG9faW50NjQoaSkge1xuICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShpLnZhbHVlICYgMHhmZmZmZmYsIChpLnZhbHVlID4+PiAyNCkgJiAweGZmZmZmZiwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl90b19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX3RvX3N0cmluZyhpKSB7XG4gICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nKGkudmFsdWUudG9TdHJpbmcoKSk7XG59XG5cbi8vUHJvdmlkZXM6IFVJbnQ2NCBjb25zdFxudmFyIFVJbnQ2NCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFVJbnQ2NCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLnZhbHVlID0geDsgLy8geCBpcyBhbiBNbEludDY0XG4gICAgfTtcbiAgICBVSW50NjQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJpbnRlZ2Vyczp1aW50NjRcIjtcbiAgICByZXR1cm4gVUludDY0O1xufSkoKTtcblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X2FkZFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGQsIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X2FkZCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoY2FtbF9pbnQ2NF9hZGQoeC52YWx1ZSwgeS52YWx1ZSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfZGl2XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9kaXYoeCwgeSkge1xuICAgIGlmICh5LnZhbHVlLmlzWmVybygpKSB7XG4gICAgICAgIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgICB9XG4gICAgLy8gQ29lcmNlIHRoZSBoaWdoIHBhcnRzIHRvIGJlIHVuc2lnbmVkIGJlZm9yZSBkaXZpc2lvbi5cbiAgICB4LnZhbHVlLmhpID0geC52YWx1ZS5oaSA+Pj4gMDtcbiAgICB5LnZhbHVlLmhpID0geS52YWx1ZS5oaSA+Pj4gMDtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NCh4LnZhbHVlLnVkaXZtb2QoeS52YWx1ZSkucXVvdGllbnQpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfbG9nYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FuZCwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfbG9nYW5kKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NChjYW1sX2ludDY0X2FuZCh4LnZhbHVlLCB5LnZhbHVlKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9sb2dvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vciwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfbG9nb3IoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDY0KGNhbWxfaW50NjRfb3IoeC52YWx1ZSwgeS52YWx1ZSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfbG9neG9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3hvciwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfbG9neG9yKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NChjYW1sX2ludDY0X3hvcih4LnZhbHVlLCB5LnZhbHVlKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9tYXhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9tYXgodW5pdCkge1xuICAgIHZhciB4ID0gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMHhmZmZmZmYsIDB4ZmZmZmZmLCAweGZmZmYpO1xuICAgIHguaGkgPSB4LmhpID4+PiAwO1xuICAgIHJldHVybiBuZXcgVUludDY0KHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfbXVsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X211bCwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfbXVsKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NChjYW1sX2ludDY0X211bCh4LnZhbHVlLCB5LnZhbHVlKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9vZl9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X29mX2ludChpKSB7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoY2FtbF9pbnQ2NF9vZl9pbnQzMihpKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9vZl9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGksIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X29mX2ludDY0KGkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NChjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShpLmxvLCBpLm1pLCBpLmhpID4+PiAwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfZmFpbHdpdGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpLCBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX3BhcnNlX2RpZ2l0LCBjYW1sX2ludDY0X3VsdCwgY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X25lZ1xuZnVuY3Rpb24gaW50ZWdlcnNfdWludF9vZl9zdHJpbmcocywgbWF4X3ZhbCkge1xuICAgIC8vIE5vdGU6IFRoaXMgY29kZSBtYXRjaGVzIHRoZSBiZWhhdmlvciBvZiB0aGUgQyBmdW5jdGlvbi5cbiAgICAvLyBJbiBwYXJ0aWN1bGFyLFxuICAgIC8vIC0gb25seSBiYXNlLTEwIG51bWJlcnMgYXJlIGFjY2VwdGVkXG4gICAgLy8gLSBuZWdhdGl2ZSBudW1iZXJzIGFyZSBhY2NlcHRlZCBhbmQgY29lcmNlZCB0byAyJ3MtY29tcGxlbWVudCB1aW50NjRcbiAgICAvLyAtIHRoZSBsb25nZXN0IG51bWVyaWMgcHJlZml4IGlzIGFjY2VwdGVkLCBvbmx5IHJhaXNpbmcgYW4gZXJyb3Igd2hlbiB0aGVyZVxuICAgIC8vICAgaXNuJ3QgYSBudW1lcmljIHByZWZpeFxuICAgIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBuZWdhdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpID49IGxlbikge1xuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgICB9XG4gICAgdmFyIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09PSA0NSkgeyAvLyBNaW51cyBzaWduXG4gICAgICAgIGkrKztcbiAgICAgICAgbmVnYXRpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gNDMpIHsgLy8gUGx1cyBzaWduXG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgdmFyIG5vX2RpZ2l0cyA9IHRydWU7XG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIGhpZ2ggYnl0ZSBpcyB1bnNpZ25lZCBiZWZvcmUgZGl2aXNpb24uXG4gICAgbWF4X3ZhbC5oaSA9IG1heF92YWwuaGkgPj4+IDA7XG4gICAgdmFyIHRlbiA9IGNhbWxfaW50NjRfb2ZfaW50MzIoMTApO1xuICAgIHZhciBtYXhfYmFzZV8xMCA9IG1heF92YWwudWRpdm1vZCh0ZW4pLnF1b3RpZW50O1xuICAgIHZhciByZXMgPSBjYW1sX2ludDY0X29mX2ludDMyKDApO1xuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgICAgICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IDEwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub19kaWdpdHMgPSBmYWxzZTtcbiAgICAgICAgLy8gQW55IGRpZ2l0IGhlcmUgd291bGQgb3ZlcmZsb3cuIFBpbiB0byB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgICAgaWYgKGNhbWxfaW50NjRfdWx0KG1heF9iYXNlXzEwLCByZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4X3ZhbDtcbiAgICAgICAgfVxuICAgICAgICBkID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgICAgICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwodGVuLCByZXMpLCBkKTtcbiAgICAgICAgLy8gVGhlIGdpdmVuIGRpZ2l0IHdhcyB0b28gbGFyZ2UuIFBpbiB0byB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgICAgaWYgKGNhbWxfaW50NjRfdWx0KHJlcywgZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXhfdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub19kaWdpdHMpIHtcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgfVxuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICByZXMgPSBjYW1sX2ludDY0X25lZyhyZXMpO1xuICAgIH1cbiAgICAvLyBTZXQgdGhlIGhpZ2ggYnl0ZSBhcyB1bnNpZ25lZC5cbiAgICByZXMuaGkgPSByZXMuaGkgPj4+IDA7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogaW50ZWdlcnNfdWludF9vZl9zdHJpbmcsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9vZl9zdHJpbmcocykge1xuICB2YXIgbWF4X3ZhbCA9IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDB4ZmZmZmZmLCAweGZmZmZmZiwgMHhmZmZmKTtcbiAgcmV0dXJuIG5ldyBVSW50NjQoaW50ZWdlcnNfdWludF9vZl9zdHJpbmcocywgbWF4X3ZhbCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfcmVtXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlLCBjYW1sX2ludDY0X2lzX3plcm8sIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X3JlbSh4LCB5KSB7XG4gICAgaWYgKHkudmFsdWUuaXNaZXJvKCkpIHtcbiAgICAgICAgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSgpO1xuICAgIH1cbiAgICAvLyBDb2VyY2UgdGhlIGhpZ2ggcGFydHMgdG8gYmUgdW5zaWduZWQgYmVmb3JlIGRpdmlzaW9uLlxuICAgIHgudmFsdWUuaGkgPSB4LnZhbHVlLmhpID4+PiAwO1xuICAgIHkudmFsdWUuaGkgPSB5LnZhbHVlLmhpID4+PiAwO1xuICAgIHJldHVybiBuZXcgVUludDY0KHgudmFsdWUudWRpdm1vZCh5LnZhbHVlKS5tb2R1bHVzKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X3NoaWZ0X2xlZnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc2hpZnRfbGVmdCwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfc2hpZnRfbGVmdCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0KHgudmFsdWUsIHkpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X3NoaWZ0X3JpZ2h0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9zaGlmdF9yaWdodCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LnZhbHVlLCB5KSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc3ViLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9zdWIoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDY0KGNhbWxfaW50NjRfc3ViKHgudmFsdWUsIHkudmFsdWUpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X3RvX2ludFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19pbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X3RvX2ludChpKSB7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfdG9faW50MzIoaS52YWx1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF90b19pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF90b19pbnQ2NChpKSB7XG4gICAgaSA9IGkudmFsdWU7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKGkubG8sIGkubWksIGkuaGkgfCAwKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X3RvX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mb3JtYXQsIGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X3RvX3N0cmluZyhpKSB7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfZm9ybWF0KGNhbWxfbmV3X3N0cmluZyhcIiV1XCIpLCBpLnZhbHVlKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF91bm1hcnNoYWwsIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICAgIHJldHVybiBuZXcgVUludDY0KGNhbWxfaW50NjRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSkpO1xufVxuICBcbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X21hcnNoYWxcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9tYXJzaGFsKHdyaXRlciwgdiwgc2l6ZXMpIHtcbiAgICBjYW1sX2ludDY0X21hcnNoYWwod3JpdGVyLCB2LnZhbHVlLCBzaXplcyk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2hhc2hcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9oYXNoKHYpIHtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9oYXNoKHYudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50OF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGludGVnZXJzX3VpbnQzMl9vZl9zdHJpbmdcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ4X29mX3N0cmluZyh4KSB7XG4gICAgdmFyIHkgPSBpbnRlZ2Vyc191aW50MzJfb2Zfc3RyaW5nKHgpO1xuICAgIHJldHVybiAoeC52YWx1ZSAmIDB4RkYpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50X3NpemVcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnRfc2l6ZSh1bml0KSB7XG4gICAgcmV0dXJuIDQ7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3Vsb25nX3NpemVcbmZ1bmN0aW9uIGludGVnZXJzX3Vsb25nX3NpemUodW5pdCkge1xuICAgIHJldHVybiA0O1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191bG9uZ2xvbmdfc2l6ZVxuZnVuY3Rpb24gaW50ZWdlcnNfdWxvbmdsb25nX3NpemUodW5pdCkge1xuICAgIHJldHVybiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191bnNpZ25lZF9pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHMsIGludGVnZXJzX3VpbnQ4X2Rlc2VyaWFsaXplLCBpbnRlZ2Vyc191aW50MTZfZGVzZXJpYWxpemUsIGludGVnZXJzX3VpbnQzMl9zZXJpYWxpemUsIGludGVnZXJzX3VpbnQzMl9kZXNlcmlhbGl6ZSwgaW50ZWdlcnNfdWludDMyX2hhc2gsIGludGVnZXJzX3VpbnQzMl9jb21wYXJlLCBpbnRlZ2Vyc191aW50NjRfY29tcGFyZSwgaW50ZWdlcnNfdWludDY0X2hhc2gsIGludGVnZXJzX3VpbnQ2NF9tYXJzaGFsLCBpbnRlZ2Vyc191aW50NjRfdW5tYXJzaGFsXG5mdW5jdGlvbiBpbnRlZ2Vyc191bnNpZ25lZF9pbml0KHVuaXQpIHtcbiAgICBjYW1sX2N1c3RvbV9vcHNbXCJpbnRlZ2Vyczp1aW50OFwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZTogaW50ZWdlcnNfdWludDhfZGVzZXJpYWxpemVcbiAgICAsIGZpeGVkX2xlbmd0aDogMSB9O1xuICAgIGNhbWxfY3VzdG9tX29wc1tcImludGVnZXJzOnVpbnQxNlwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZTogaW50ZWdlcnNfdWludDE2X2Rlc2VyaWFsaXplXG4gICAgLCBmaXhlZF9sZW5ndGg6IDIgfTtcbiAgICBjYW1sX2N1c3RvbV9vcHNbXCJpbnRlZ2Vyczp1aW50MzJcIl0gPVxuICAgIHsgc2VyaWFsaXplOiBpbnRlZ2Vyc191aW50MzJfc2VyaWFsaXplXG4gICAgLCBkZXNlcmlhbGl6ZTogaW50ZWdlcnNfdWludDMyX2Rlc2VyaWFsaXplXG4gICAgLCBmaXhlZF9sZW5ndGg6IDRcbiAgICAsIGhhc2g6IGludGVnZXJzX3VpbnQzMl9oYXNoXG4gICAgLCBjb21wYXJlOiBpbnRlZ2Vyc191aW50MzJfY29tcGFyZSB9O1xuICAgIGNhbWxfY3VzdG9tX29wc1tcImludGVnZXJzOnVpbnQ2NFwiXSA9XG4gICAgeyBzZXJpYWxpemU6IGludGVnZXJzX3VpbnQ2NF9tYXJzaGFsXG4gICAgLCBkZXNlcmlhbGl6ZTogaW50ZWdlcnNfdWludDY0X3VubWFyc2hhbFxuICAgICwgaGFzaDogaW50ZWdlcnNfdWludDY0X2hhc2hcbiAgICAsIGNvbXBhcmU6IGludGVnZXJzX3VpbnQ2NF9jb21wYXJlIH07XG4gICAgcmV0dXJuIHVuaXQ7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VzaG9ydF9zaXplXG5mdW5jdGlvbiBpbnRlZ2Vyc191c2hvcnRfc2l6ZSh1bml0KSB7XG4gICAgcmV0dXJuIDQ7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9zZXJpYWxpemVcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9zZXJpYWxpemUod3JpdGVyLCB2LCBzaXplKSB7XG4gICAgd3JpdGVyLndyaXRlKDMyLCB2LnZhbHVlKTtcbiAgICBzaXplWzBdID0gNDtcbiAgICBzaXplWzFdID0gNDtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDhfZGVzZXJpYWxpemVcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ4X2Rlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSkge1xuICAgIHNpemVbMF0gPSAxO1xuICAgIHJldHVybiByZWFkZXIucmVhZDh1KCk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQxNl9kZXNlcmlhbGl6ZVxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDE2X2Rlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSkge1xuICAgIHNpemVbMF0gPSAyO1xuICAgIHJldHVybiByZWFkZXIucmVhZDE2dSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfZGVzZXJpYWxpemVcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2Rlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSkge1xuICAgIHNpemVbMF0gPSA0O1xuICAgIHJldHVybiBuZXcgVUludDMyKHJlYWRlci5yZWFkMzJ1KCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfaGFzaFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2hhc2godikge1xuICAgIHJldHVybiB2LnZhbHVlO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfY29tcGFyZVxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2NvbXBhcmUoeCwgeSkge1xuICAgIGlmICh4LnZhbHVlID4geS52YWx1ZSkgeyByZXR1cm4gMTsgfVxuICAgIGlmICh4LnZhbHVlIDwgeS52YWx1ZSkgeyByZXR1cm4gLTE7IH1cbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY29tcGFyZVxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X2NvbXBhcmUoeCwgeSkge1xuICAgIHgudmFsdWUuaGkgPSB4LnZhbHVlLmhpID4+PiAwO1xuICAgIHkudmFsdWUuaGkgPSB5LnZhbHVlLmhpID4+PiAwO1xuICAgIHJldHVybiB4LnZhbHVlLnVjb21wYXJlKHkudmFsdWUpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmQsIEFuZHkgUmF5XG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4vL1xuLy8gQmlnYXJyYXkuXG4vL1xuLy8gLSBhbGwgYmlnYXJyYXkgdHlwZXMgaW5jbHVkaW5nIEludDY0IGFuZCBDb21wbGV4LlxuLy8gLSBmb3J0cmFuICsgYyBsYXlvdXRzXG4vLyAtIHN1Yi9zbGljZS9yZXNoYXBlXG4vLyAtIHJldGFpbiBmYXN0IHBhdGggZm9yIDFkIGFycmF5IGFjY2Vzc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSB7XG4gIHZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgc2l6ZSA9IHNpemUgKiBkaW1zW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpe1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgNzogY2FzZSAxMDogY2FzZSAxMTogcmV0dXJuIDI7XG4gIGRlZmF1bHQ6IHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSl7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgdmFyIHZpZXc7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAwOiAgdmlldyA9IGcuRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxOiAgdmlldyA9IGcuRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAyOiAgdmlldyA9IGcuSW50OEFycmF5OyBicmVhaztcbiAgY2FzZSAzOiAgdmlldyA9IGcuVWludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgNDogIHZpZXcgPSBnLkludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDU6ICB2aWV3ID0gZy5VaW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNjogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDc6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA4OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgOTogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDEwOiB2aWV3ID0gZy5GbG9hdDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDExOiB2aWV3ID0gZy5GbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDEyOiB2aWV3ID0gZy5VaW50OEFycmF5OyBicmVhaztcbiAgfVxuICBpZiAoIXZpZXcpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgdmFyIGRhdGEgPSBuZXcgdmlldyhzaXplICogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246IDwgNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnJheVwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPj0gNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnIwMlwiXG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpLCBjYW1sX2ludDY0X2hpMzIsIGNhbWxfaW50NjRfbG8zMlxuZnVuY3Rpb24gTWxfQmlnYXJyYXkgKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG5cbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBjYW1sX2JhX2N1c3RvbV9uYW1lO1xuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICB2YXIgb2ZzID0gMDtcbiAgaWYodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikgYXJnID0gW2FyZ107XG4gIGlmICghIChhcmcgaW5zdGFuY2VvZiBBcnJheSkpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ2FycmF5LmpzOiBpbnZhbGlkIG9mZnNldFwiKTtcbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYXJnLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5nZXQvc2V0OiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIGlmKHRoaXMubGF5b3V0ID09IDAgLyogY19sYXlvdXQgKi8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFyZ1tpXSA8IDAgfHwgYXJnW2ldID49IHRoaXMuZGltc1tpXSlcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyBhcmdbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmRpbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChhcmdbaV0gPCAxIHx8IGFyZ1tpXSA+IHRoaXMuZGltc1tpXSl7XG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgKGFyZ1tpXSAtIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2ZzO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGwgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBoID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobCxoKTtcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciByID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaSA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIFsyNTQsIHIsIGldO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiB0aGlzLmRhdGFbb2ZzXVxuICB9XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSB2WzFdO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSB2WzJdO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMFxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBhID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHZhciBiID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGlmKGEgPT0gYil7XG4gICAgICB0aGlzLmRhdGEuZmlsbChhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBhIDogYjtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgaW0gPSB2WzFdO1xuICAgIHZhciByZSA9IHZbMl07XG4gICAgaWYoaW0gPT0gcmUpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoaW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGltIDogcmU7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YS5maWxsKHYpO1xuICAgIGJyZWFrO1xuICB9XG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYiwgdG90YWwpIHtcbiAgaWYgKHRoaXMubGF5b3V0ICE9IGIubGF5b3V0IHx8IHRoaXMua2luZCAhPSBiLmtpbmQpIHtcbiAgICB2YXIgazEgPSB0aGlzLmtpbmQgfCAodGhpcy5sYXlvdXQgPDwgOCk7XG4gICAgdmFyIGsyID0gICAgYi5raW5kIHwgKGIubGF5b3V0IDw8IDgpO1xuICAgIHJldHVybiBrMiAtIGsxO1xuICB9XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGIuZGltcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYi5kaW1zLmxlbmd0aCAtIHRoaXMuZGltcy5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKHRoaXMuZGltc1tpXSAhPSBiLmRpbXNbaV0pXG4gICAgICByZXR1cm4gKHRoaXMuZGltc1tpXSA8IGIuZGltc1tpXSkgPyAtMSA6IDE7XG4gIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICBjYXNlIDEwOlxuICBjYXNlIDExOlxuICAgIC8vIEZsb2F0c1xuICAgIHZhciB4LCB5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB4ID0gdGhpcy5kYXRhW2ldO1xuICAgICAgeSA9IGIuZGF0YVtpXTtcbiAgICAgIGlmICh4IDwgeSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHggPiB5KVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICh4ICE9IHkpIHtcbiAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgaWYgKHggPT0geCkgcmV0dXJuIDE7XG4gICAgICAgIGlmICh5ID09IHkpIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSs9Mikge1xuICAgICAgLy8gQ2hlY2sgaGlnaGVzdCBiaXRzIGZpcnN0XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPCBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdID4gYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApIDwgKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA+IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMjpcbiAgY2FzZSAzOlxuICBjYXNlIDQ6XG4gIGNhc2UgNTpcbiAgY2FzZSA2OlxuICBjYXNlIDg6XG4gIGNhc2UgOTpcbiAgY2FzZSAxMjpcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA8IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA+IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheV9jXzFfMVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhICAgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZSA9IG5ldyBNbF9CaWdhcnJheSgpXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICBpZih0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKXtcbiAgICBpZigoYXJnIGluc3RhbmNlb2YgQXJyYXkpICYmIGFyZy5sZW5ndGggPT0gMSlcbiAgICAgIGFyZyA9IGFyZ1swXTtcbiAgICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIk1sX0JpZ2FycmF5X2NfMV8xLm9mZnNldFwiKTtcbiAgfVxuICBpZiAoYXJnIDwgMCB8fCBhcmcgPj0gdGhpcy5kaW1zWzBdKVxuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFyZztcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgcmV0dXJuIDBcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jb21wYXJlXG5mdW5jdGlvbiBjYW1sX2JhX2NvbXBhcmUoYSxiLHRvdGFsKXtcbiAgcmV0dXJuIGEuY29tcGFyZShiLHRvdGFsKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBNbF9CaWdhcnJheV9jXzFfMSwgY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKXtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpO1xuICBpZihjYW1sX2JhX2dldF9zaXplKGRpbXMpICogc2l6ZV9wZXJfZWxlbWVudCAhPSBkYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImxlbmd0aCBkb2Vzbid0IG1hdGNoIGRpbXNcIik7XG4gIH1cbiAgaWYobGF5b3V0ID09IDAgJiYgLy8gY19sYXlvdXRcbiAgICAgZGltcy5sZW5ndGggPT0gMSAmJiAvLyBBcnJheTFcbiAgICAgc2l6ZV9wZXJfZWxlbWVudCA9PSAxKSAvLyAxLXRvLTEgbWFwcGluZ1xuICAgIHJldHVybiBuZXcgTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlKGtpbmQsIGxheW91dCwgZGltc19tbCkge1xuICB2YXIgZGltcyA9IGNhbWxfanNfZnJvbV9hcnJheShkaW1zX21sKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfY2hhbmdlX2xheW91dChiYSwgbGF5b3V0KSB7XG4gIGlmKGJhLmxheW91dCA9PSBsYXlvdXQpIHJldHVybiBiYTtcbiAgdmFyIG5ld19kaW1zID0gW11cbiAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIG5ld19kaW1zW2ldID0gYmEuZGltc1tiYS5kaW1zLmxlbmd0aCAtIGkgLSAxXTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBsYXlvdXQsIG5ld19kaW1zLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kXG5mdW5jdGlvbiBjYW1sX2JhX2tpbmQoYmEpIHtcbiAgcmV0dXJuIGJhLmtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbGF5b3V0XG5mdW5jdGlvbiBjYW1sX2JhX2xheW91dChiYSkge1xuICByZXR1cm4gYmEubGF5b3V0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX251bV9kaW1zXG5mdW5jdGlvbiBjYW1sX2JhX251bV9kaW1zKGJhKSB7XG4gIHJldHVybiBiYS5kaW1zLmxlbmd0aDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1cbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9kaW0oYmEsIGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZGltXCIpO1xuICByZXR1cm4gYmEuZGltc1tpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMVxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzEoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMlxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzIoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fM1xuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzMoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9nZW5lcmljKGJhLCBpKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKTtcbiAgcmV0dXJuIGJhLmdldChvZnMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDE2KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcyArIDEpO1xuICByZXR1cm4gKGIxIHwgKGIyIDw8IDgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQzMihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgcmV0dXJuICggKGIxIDw8IDApICB8XG4gICAgICAgICAgIChiMiA8PCA4KSAgfFxuICAgICAgICAgICAoYjMgPDwgMTYpIHxcbiAgICAgICAgICAgKGI0IDw8IDI0KSApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDY0KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICB2YXIgYjUgPSBiYS5nZXQob2ZzKzQpO1xuICB2YXIgYjYgPSBiYS5nZXQob2ZzKzUpO1xuICB2YXIgYjcgPSBiYS5nZXQob2ZzKzYpO1xuICB2YXIgYjggPSBiYS5nZXQob2ZzKzcpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbYjgsYjcsYjYsYjUsYjQsYjMsYjIsYjFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMShiYSwgaTApIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoaTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMihiYSwgaTAsIGkxKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMV0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMyhiYSwgaTAsIGkxLCBpMikge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfZ2VuZXJpYyhiYSwgaSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDE2KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQzMihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzIsICh2ID4+PiAxNikgJiAweGZmKTtcbiAgYmEuc2V0KG9mcyszLCAodiA+Pj4gMjQpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDY0KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgdiA9IGNhbWxfaW50NjRfdG9fYnl0ZXModik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpKyspIGJhLnNldChvZnMraSwgdls3LWldKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMShiYSwgaTAsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChpMCksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8yXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8yKGJhLCBpMCwgaTEsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTFdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8zXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8zKGJhLCBpMCwgaTEsIGkyLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxLGkyXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9maWxsXG5mdW5jdGlvbiBjYW1sX2JhX2ZpbGwoYmEsIHYpIHtcbiAgYmEuZmlsbCh2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2JsaXQoc3JjLCBkc3QpIHtcbiAgaWYgKGRzdC5kaW1zLmxlbmd0aCAhPSBzcmMuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRzdC5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmIChkc3QuZGltc1tpXSAhPSBzcmMuZGltc1tpXSlcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZHN0LmRhdGEuc2V0KHNyYy5kYXRhKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc3ViXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zdWIoYmEsIG9mcywgbGVuKSB7XG4gIHZhciBjaGFuZ2VkX2RpbTtcbiAgdmFyIG11bCA9IDE7XG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSAwO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGJhLmRpbXMubGVuZ3RoIC0gMSk7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSBiYS5kaW1zLmxlbmd0aCAtIDE7XG4gICAgb2ZzID0gb2ZzIC0gMTtcbiAgfVxuICBpZiAob2ZzIDwgMCB8fCBsZW4gPCAwIHx8IChvZnMgKyBsZW4pID4gYmEuZGltc1tjaGFuZ2VkX2RpbV0pe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnN1YjogYmFkIHN1Yi1hcnJheVwiKTtcbiAgfVxuICB2YXIgbmV3X2RpbXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIG5ld19kaW1zW2ldID0gYmEuZGltc1tpXTtcbiAgbmV3X2RpbXNbY2hhbmdlZF9kaW1dID0gbGVuO1xuICBtdWwgKj0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBtdWwsIChvZnMgKyBsZW4pICogbXVsKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2xpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc2xpY2UoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG51bV9pbmRzID0gdmluZC5sZW5ndGg7XG4gIHZhciBpbmRleCA9IFtdO1xuICB2YXIgc3ViX2RpbXMgPSBbXTtcbiAgdmFyIG9mcztcblxuICBpZiAobnVtX2luZHMgPiBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zbGljZTogdG9vIG1hbnkgaW5kaWNlc1wiKTtcblxuICAvLyBDb21wdXRlIG9mZnNldCBhbmQgY2hlY2sgYm91bmRzXG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gdmluZFtpXTtcbiAgICBmb3IgKDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDA7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKG51bV9pbmRzKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzICsgaV0gPSB2aW5kW2ldO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAxO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZSgwLCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzKTtcbiAgfVxuICBvZnMgPSBiYS5vZmZzZXQoaW5kZXgpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoc3ViX2RpbXMpO1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogc2l6ZV9wZXJfZWxlbWVudCwgKG9mcyArIHNpemUpICogc2l6ZV9wZXJfZWxlbWVudCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBzdWJfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3Jlc2hhcGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbmZ1bmN0aW9uIGNhbWxfYmFfcmVzaGFwZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbmV3X2RpbSA9IFtdO1xuICB2YXIgbnVtX2RpbXMgPSB2aW5kLmxlbmd0aDtcblxuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgfVxuICB2YXIgbnVtX2VsdHMgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICBuZXdfZGltW2ldID0gdmluZFtpXTtcbiAgICBpZiAobmV3X2RpbVtpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgbnVtX2VsdHMgPSBudW1fZWx0cyAqIG5ld19kaW1baV07XG4gIH1cblxuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIC8vIENoZWNrIHRoYXQgc2l6ZXMgYWdyZWVcbiAgaWYgKG51bV9lbHRzICE9IHNpemUpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogc2l6ZSBtaXNtYXRjaFwiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW0sIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfc2VyaWFsaXplKHdyaXRlciwgYmEsIHN6KSB7XG4gIHdyaXRlci53cml0ZSgzMiwgYmEuZGltcy5sZW5ndGgpO1xuICB3cml0ZXIud3JpdGUoMzIsIChiYS5raW5kIHwgKGJhLmxheW91dCA8PCA4KSkpO1xuICBpZihiYS5jYW1sX2N1c3RvbSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihiYS5kaW1zW2ldIDwgMHhmZmZmKVxuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRpbXNbaV0pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgMHhmZmZmKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCAwKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIGVsc2VcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgd3JpdGVyLndyaXRlKDMyLGJhLmRpbXNbaV0pXG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSg4LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHdyaXRlci53cml0ZSg4LDApO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGJhLmdldChpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGIpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBqID0gYmEuZ2V0KGkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsxXSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsyXSkpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBjb21wbGV4ID0gYmEuZ2V0KGkpO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzFdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsyXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHN6WzBdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA0O1xuICBzelsxXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kZXNlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2Rlc2VyaWFsaXplKHJlYWRlciwgc3osIG5hbWUpe1xuICB2YXIgbnVtX2RpbXMgPSByZWFkZXIucmVhZDMycygpO1xuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB3cm9uZyBudW1iZXIgb2YgYmlnYXJyYXkgZGltZW5zaW9uc1wiKTtcbiAgdmFyIHRhZyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBraW5kID0gdGFnICYgMHhmZlxuICB2YXIgbGF5b3V0ID0gKHRhZyA+PiA4KSAmIDE7XG4gIHZhciBkaW1zID0gW11cbiAgaWYobmFtZSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgICAgdmFyIHNpemVfZGltID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICAgIGlmKHNpemVfZGltID09IDB4ZmZmZil7XG4gICAgICAgIHZhciBzaXplX2RpbV9oaSA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIHZhciBzaXplX2RpbV9sbyA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIGlmKHNpemVfZGltX2hpICE9IDApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBiaWdhcnJheSBkaW1lbnNpb24gb3ZlcmZsb3cgaW4gMzJiaXRcIik7XG4gICAgICAgIHNpemVfZGltID0gc2l6ZV9kaW1fbG87XG4gICAgICB9XG4gICAgICBkaW1zLnB1c2goc2l6ZV9kaW0pO1xuICAgIH1cbiAgZWxzZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykgZGltcy5wdXNoKHJlYWRlci5yZWFkMzJ1KCkpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoZGltcyk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpO1xuICB2YXIgYmEgPSBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB2YXIgc2l4dHkgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgaWYoc2l4dHkpIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogY2Fubm90IHJlYWQgYmlnYXJyYXkgd2l0aCA2NC1iaXQgT0NhbWwgaW50c1wiKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAvLyAoaW50NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGludDY0ID0gY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KTtcbiAgICAgIGJhLnNldChpLGludDY0KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWtcbiAgfVxuICBzelswXSA9ICg0ICsgbnVtX2RpbXMpICogNDtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL0RlcHJlY2F0ZWRcbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2Zyb21cbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRhdGExLCBkYXRhMiwganN0eXAsIGtpbmQsIGxheW91dCwgZGltcyl7XG4gIGlmKGRhdGEyIHx8IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkgPT0gMil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9jcmVhdGVfZnJvbTogdXNlIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcIik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGExKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9oYXNoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9oYXNoKGJhKXtcbiAgdmFyIG51bV9lbHRzID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgdmFyIGggPSAwO1xuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDI1NikgbnVtX2VsdHMgPSAyNTY7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDQgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTQpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgOCkgfCAoYmEuZGF0YVtpKzJdIDw8IDE2KSB8IChiYS5kYXRhW2krM10gPDwgMjQpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIHcgPSAwO1xuICAgIHN3aXRjaCAobnVtX2VsdHMgJiAzKSB7XG4gICAgY2FzZSAzOiB3ICA9IGJhLmRhdGFbaSsyXSA8PCAxNjsgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDI6IHcgfD0gYmEuZGF0YVtpKzFdIDw8IDg7ICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMTogdyB8PSBiYS5kYXRhW2krMF07XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAxMjgpIG51bV9lbHRzID0gMTI4O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyAyIDw9IGJhLmRhdGEubGVuZ3RoOyBpKz0yKXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDE2KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICBpZiAoKG51bV9lbHRzICYgMSkgIT0gMClcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBudW1fZWx0cyAqPSAyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV90b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJhKXtcbiAgcmV0dXJuIGJhLmRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSl7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgdmFyIGtpbmQ7XG4gIGlmICh0YSBpbnN0YW5jZW9mIGcuRmxvYXQzMkFycmF5KSBraW5kID0gMDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkZsb2F0NjRBcnJheSkga2luZCA9IDE7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQ4QXJyYXkpIGtpbmQgPSAyO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDhBcnJheSkga2luZCA9IDM7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQxNkFycmF5KSBraW5kID0gNDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLlVpbnQxNkFycmF5KSBraW5kID0gNTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgcmV0dXJuIGtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQgPSBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsYnMuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlcihicykge1xuICByZXR1cm4gYnMuZGF0YS5idWZmZXJcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b190eXBlZF9hcnJheShicykge1xuICByZXR1cm4gYnMuZGF0YVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcihhYikge1xuICB2YXIgdGEgPSBuZXcgZ2xvYmFsVGhpcy5VaW50OEFycmF5KGFiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5KGJhKSB7XG4gIHZhciB0YSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkoYmEuYnVmZmVyLCBiYS5ieXRlT2Zmc2V0LCBiYS5sZW5ndGggKiBiYS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX21lbWNtcFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfbWVtY21wKHMxLCBwb3MxLCBzMiwgcG9zMiwgbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhID0gY2FtbF9iYV9nZXRfMShzMSxwb3MxICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2JhX2dldF8xKHMyLHBvczIgKyBpKTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoYmExLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKG9mczEgKyBsZW4gPiBiYTEuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc3ViYXJyYXkob2ZzMSxvZnMxK2xlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxwb3MyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBjYW1sX21sX2J5dGVzX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMoc3RyMSkuc2xpY2UocG9zMSxwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLG9mczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoYmExLCBwb3MxLCBieXRlczIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKHBvczIgKyBsZW4gPiBjYW1sX21sX2J5dGVzX2xlbmd0aChieXRlczIpKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc2xpY2Uob2ZzMSwgb2ZzMStsZW4pO1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShzbGljZSksIDAsIGJ5dGVzMiwgcG9zMiwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8vLy8vLy8vLyBCSUdTVFJJTkdcblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2FsbG9jXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZVxuZnVuY3Rpb24gYmlnc3RyaW5nX2FsbG9jKF8sc2l6ZSl7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZSgxMiwgMCwgWzAsc2l6ZV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfaXNfbW1hcHBlZF9zdHViXG5mdW5jdGlvbiBiaWdzdHJpbmdfaXNfbW1hcHBlZF9zdHViKHgpe1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfc3R1YihzMSwgaTEsIHMyLCBpMiwgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoczEsaTEsczIsaTIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfYnl0ZXNfYmlnc3RyaW5nX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19ibGl0X2J5dGVzX2JpZ3N0cmluZ19zdHViKHNyYywgc3JjX3BvcywgZHN0LCBkc3RfcG9zLCBsZW4pe1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYShzcmMsc3JjX3Bvcyxkc3QsZHN0X3BvcyxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWIoc3JjLCBzcmNfcG9zLCBkc3QsIGRzdF9wb3MsIGxlbil7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzKHNyYyxzcmNfcG9zLGRzdCxkc3RfcG9zLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19ibGl0X3N0cmluZ19iaWdzdHJpbmdfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19ibGl0X3N0cmluZ19iaWdzdHJpbmdfc3R1YihzcmMsIHNyY19wb3MsIGRzdCwgZHN0X3BvcywgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHNyYyxzcmNfcG9zLGRzdCxkc3RfcG9zLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19tZW1zZXRfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX21lbXNldF9zdHViKGJpZ3N0cmluZywgdl9wb3MsIHZfbGVuLCB2X2NoYXIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSB7XG4gICAgY2FtbF9iYV9zZXRfMShiaWdzdHJpbmcsIHZfcG9zICsgaSwgdl9jaGFyKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfbWVtY21wX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19tZW1jbXBfc3R1Yih2X3MxLCB2X3MxX3Bvcywgdl9zMiwgdl9zMl9wb3MsIHZfbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHZfczEsdl9zMV9wb3MgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEodl9zMix2X3MyX3BvcyArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGludGVybmFsaGFzaF9mb2xkX2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcbnZhciBpbnRlcm5hbGhhc2hfZm9sZF9iaWdzdHJpbmcgPSBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZ1xuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfZmluZFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX2ZpbmQoYnMsIGNociwgcG9zLCBsZW4pe1xuICB3aGlsZShsZW4gPiAwKXtcbiAgICBpZihjYW1sX2JhX2dldF8xKGJzLHBvcykgPT0gY2hyKSByZXR1cm4gcG9zO1xuICAgIHBvcysrO1xuICAgIGxlbi0tO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBwYXJzaW5nLmMgODk4MyAyMDA4LTA4LTA2IDA5OjM4OjI1WiB4bGVyb3kgJCAqL1xuXG4vKiBUaGUgUERBIGF1dG9tYXRvbiBmb3IgcGFyc2VycyBnZW5lcmF0ZWQgYnkgY2FtbHlhY2MgKi9cblxuLyogVGhlIHB1c2hkb3duIGF1dG9tYXRhICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2xleF9hcnJheVxuZnVuY3Rpb24gY2FtbF9wYXJzZV9lbmdpbmUodGFibGVzLCBlbnYsIGNtZCwgYXJnKVxue1xuICB2YXIgRVJSQ09ERSA9IDI1NjtcblxuICAvL3ZhciBTVEFSVCA9IDA7XG4gIC8vdmFyIFRPS0VOX1JFQUQgPSAxO1xuICAvL3ZhciBTVEFDS1NfR1JPV05fMSA9IDI7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8yID0gMztcbiAgLy92YXIgU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEID0gNDtcbiAgLy92YXIgRVJST1JfREVURUNURUQgPSA1O1xuICB2YXIgbG9vcCA9IDY7XG4gIHZhciB0ZXN0c2hpZnQgPSA3O1xuICB2YXIgc2hpZnQgPSA4O1xuICB2YXIgc2hpZnRfcmVjb3ZlciA9IDk7XG4gIHZhciByZWR1Y2UgPSAxMDtcblxuICB2YXIgUkVBRF9UT0tFTiA9IDA7XG4gIHZhciBSQUlTRV9QQVJTRV9FUlJPUiA9IDE7XG4gIHZhciBHUk9XX1NUQUNLU18xID0gMjtcbiAgdmFyIEdST1dfU1RBQ0tTXzIgPSAzO1xuICB2YXIgQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04gPSA0O1xuICB2YXIgQ0FMTF9FUlJPUl9GVU5DVElPTiA9IDU7XG5cbiAgdmFyIGVudl9zX3N0YWNrID0gMTtcbiAgdmFyIGVudl92X3N0YWNrID0gMjtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0X3N0YWNrID0gMztcbiAgdmFyIGVudl9zeW1iX2VuZF9zdGFjayA9IDQ7XG4gIHZhciBlbnZfc3RhY2tzaXplID0gNTtcbiAgdmFyIGVudl9zdGFja2Jhc2UgPSA2O1xuICB2YXIgZW52X2N1cnJfY2hhciA9IDc7XG4gIHZhciBlbnZfbHZhbCA9IDg7XG4gIHZhciBlbnZfc3ltYl9zdGFydCA9IDk7XG4gIHZhciBlbnZfc3ltYl9lbmQgPSAxMDtcbiAgdmFyIGVudl9hc3AgPSAxMTtcbiAgdmFyIGVudl9ydWxlX2xlbiA9IDEyO1xuICB2YXIgZW52X3J1bGVfbnVtYmVyID0gMTM7XG4gIHZhciBlbnZfc3AgPSAxNDtcbiAgdmFyIGVudl9zdGF0ZSA9IDE1O1xuICB2YXIgZW52X2VycmZsYWcgPSAxNjtcblxuICAvLyB2YXIgX3RibF9hY3Rpb25zID0gMTtcbiAgdmFyIHRibF90cmFuc2xfY29uc3QgPSAyO1xuICB2YXIgdGJsX3RyYW5zbF9ibG9jayA9IDM7XG4gIHZhciB0YmxfbGhzID0gNDtcbiAgdmFyIHRibF9sZW4gPSA1O1xuICB2YXIgdGJsX2RlZnJlZCA9IDY7XG4gIHZhciB0YmxfZGdvdG8gPSA3O1xuICB2YXIgdGJsX3NpbmRleCA9IDg7XG4gIHZhciB0YmxfcmluZGV4ID0gOTtcbiAgdmFyIHRibF9naW5kZXggPSAxMDtcbiAgdmFyIHRibF90YWJsZXNpemUgPSAxMTtcbiAgdmFyIHRibF90YWJsZSA9IDEyO1xuICB2YXIgdGJsX2NoZWNrID0gMTM7XG4gIC8vIHZhciBfdGJsX2Vycm9yX2Z1bmN0aW9uID0gMTQ7XG4gIC8vIHZhciBfdGJsX25hbWVzX2NvbnN0ID0gMTU7XG4gIC8vIHZhciBfdGJsX25hbWVzX2Jsb2NrID0gMTY7XG5cbiAgaWYgKCF0YWJsZXMuZGdvdG8pIHtcbiAgICB0YWJsZXMuZGVmcmVkID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGVmcmVkXSk7XG4gICAgdGFibGVzLnNpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3NpbmRleF0pO1xuICAgIHRhYmxlcy5jaGVjayAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9jaGVja10pO1xuICAgIHRhYmxlcy5yaW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9yaW5kZXhdKTtcbiAgICB0YWJsZXMudGFibGUgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfdGFibGVdKTtcbiAgICB0YWJsZXMubGVuICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGVuXSk7XG4gICAgdGFibGVzLmxocyAgICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2xoc10pO1xuICAgIHRhYmxlcy5naW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9naW5kZXhdKTtcbiAgICB0YWJsZXMuZGdvdG8gID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGdvdG9dKTtcbiAgfVxuXG4gIHZhciByZXMgPSAwLCBuLCBuMSwgbjIsIHN0YXRlMTtcblxuICAvLyBSRVNUT1JFXG4gIHZhciBzcCA9IGVudltlbnZfc3BdO1xuICB2YXIgc3RhdGUgPSBlbnZbZW52X3N0YXRlXTtcbiAgdmFyIGVycmZsYWcgPSBlbnZbZW52X2VycmZsYWddO1xuXG4gIGV4aXQ6Zm9yICg7Oykge1xuICAgIHN3aXRjaChjbWQpIHtcbiAgICBjYXNlIDA6Ly9TVEFSVDpcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGVycmZsYWcgPSAwO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDY6Ly9sb29wOlxuICAgICAgbiA9IHRhYmxlcy5kZWZyZWRbc3RhdGVdO1xuICAgICAgaWYgKG4gIT0gMCkgeyBjbWQgPSByZWR1Y2U7IGJyZWFrOyB9XG4gICAgICBpZiAoZW52W2Vudl9jdXJyX2NoYXJdID49IDApIHsgY21kID0gdGVzdHNoaWZ0OyBicmVhazsgfVxuICAgICAgcmVzID0gUkVBRF9UT0tFTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgbGV4ZXIgYW5kIHVwZGF0ZXMgKi9cbiAgICAgIC8qIHN5bWJfc3RhcnQgYW5kIHN5bWJfZW5kICovXG4gICAgY2FzZSAxOi8vVE9LRU5fUkVBRDpcbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSB0YWJsZXNbdGJsX3RyYW5zbF9ibG9ja11bYXJnWzBdICsgMV07XG4gICAgICAgIGVudltlbnZfbHZhbF0gPSBhcmdbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSB0YWJsZXNbdGJsX3RyYW5zbF9jb25zdF1bYXJnICsgMV07XG4gICAgICAgIGVudltlbnZfbHZhbF0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDc6Ly90ZXN0c2hpZnQ6XG4gICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgY21kID0gc2hpZnQ7IGJyZWFrO1xuICAgICAgfVxuICAgICAgbjEgPSB0YWJsZXMucmluZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIG4gPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgICBjbWQgPSByZWR1Y2U7IGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVycmZsYWcgPD0gMCkge1xuICAgICAgICByZXMgPSBDQUxMX0VSUk9SX0ZVTkNUSU9OO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgZXJyb3IgZnVuY3Rpb24gKi9cbiAgICBjYXNlIDU6Ly9FUlJPUl9ERVRFQ1RFRDpcbiAgICAgIGlmIChlcnJmbGFnIDwgMykge1xuICAgICAgICBlcnJmbGFnID0gMztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3AgKyAxXTtcbiAgICAgICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGUxXTtcbiAgICAgICAgICBuMiA9IG4xICsgRVJSQ09ERTtcbiAgICAgICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IEVSUkNPREUpIHtcbiAgICAgICAgICAgIGNtZCA9IHNoaWZ0X3JlY292ZXI7IGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3AgPD0gZW52W2Vudl9zdGFja2Jhc2VdKSByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgICAgIHNwLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZW52W2Vudl9jdXJyX2NoYXJdID09IDApIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgODovL3NoaWZ0OlxuICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICBpZiAoZXJyZmxhZyA+IDApIGVycmZsYWctLTtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgOTovL3NoaWZ0X3JlY292ZXI6XG4gICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICBzcCsrO1xuICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18xO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICBjYXNlIDI6Ly9TVEFDS1NfR1JPV05fMTpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9sdmFsXTtcbiAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9zdGFydF07XG4gICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF07XG4gICAgICBjbWQgPSBsb29wO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDEwOi8vcmVkdWNlOlxuICAgICAgdmFyIG0gPSB0YWJsZXMubGVuW25dO1xuICAgICAgZW52W2Vudl9hc3BdID0gc3A7XG4gICAgICBlbnZbZW52X3J1bGVfbnVtYmVyXSA9IG47XG4gICAgICBlbnZbZW52X3J1bGVfbGVuXSA9IG07XG4gICAgICBzcCA9IHNwIC0gbSArIDE7XG4gICAgICBtID0gdGFibGVzLmxoc1tuXTtcbiAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3BdO1xuICAgICAgbjEgPSB0YWJsZXMuZ2luZGV4W21dO1xuICAgICAgbjIgPSBuMSArIHN0YXRlMTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBzdGF0ZTEpXG4gICAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMuZGdvdG9bbV07XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzI7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMzovL1NUQUNLU19HUk9XTl8yOlxuICAgICAgcmVzID0gQ09NUFVURV9TRU1BTlRJQ19BQ1RJT047XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIHNlbWFudGljIGFjdGlvbiAqL1xuICAgIGNhc2UgNDovL1NFTUFOVElDX0FDVElPTl9DT01QVVRFRDpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gYXJnO1xuICAgICAgdmFyIGFzcCA9IGVudltlbnZfYXNwXTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIGlmIChzcCA+IGFzcCkge1xuICAgICAgICAvKiBUaGlzIGlzIGFuIGVwc2lsb24gcHJvZHVjdGlvbi4gVGFrZSBzeW1iX3N0YXJ0IGVxdWFsIHRvIHN5bWJfZW5kLiAqL1xuICAgICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIH1cbiAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgLyogU2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvLyBTQVZFXG4gIGVudltlbnZfc3BdID0gc3A7XG4gIGVudltlbnZfc3RhdGVdID0gc3RhdGU7XG4gIGVudltlbnZfZXJyZmxhZ10gPSBlcnJmbGFnO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9wYXJzZXJfdHJhY2UgY29uc3Rcbi8vRHVtbXkgZnVuY3Rpb24hXG5mdW5jdGlvbiBjYW1sX3NldF9wYXJzZXJfdHJhY2UoKSB7IHJldHVybiAwOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWJcblxuLy9Qcm92aWRlczogY2FtbF9qc19wdXJlX2V4cHIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfcHVyZV9leHByIChmKSB7IHJldHVybiBmKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sZix2KSB7IG9bZl09djtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0KG8sZikgeyByZXR1cm4gb1tmXTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19kZWxldGUgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19kZWxldGUobyxmKSB7IGRlbGV0ZSBvW2ZdOyByZXR1cm4gMH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19pbnN0YW5jZW9mIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2luc3RhbmNlb2YobyxjKSB7IHJldHVybiAobyBpbnN0YW5jZW9mIGMpID8gMSA6IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc190eXBlb2YgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190eXBlb2YobykgeyByZXR1cm4gdHlwZW9mIG87IH1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVcbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZShyZXMpIHtcbiAgdmFyIGMgPSAxO1xuICB3aGlsZShyZXMgJiYgcmVzLmpvb190cmFtcCl7XG4gICAgcmVzID0gcmVzLmpvb190cmFtcC5hcHBseShudWxsLCByZXMuam9vX2FyZ3MpO1xuICAgIGMrKztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZV9yZXR1cm5cbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZV9yZXR1cm4oZixhcmdzKSB7XG4gIHJldHVybiB7am9vX3RyYW1wOmYsam9vX2FyZ3M6YXJnc307XG59XG5cbi8vUHJvdmlkZXM6IGpzX3ByaW50X3N0ZG91dCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZG91dChzKSB7XG4gIHZhciBzID0gY2FtbF91dGYxNl9vZl91dGY4KHMpO1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZG91dC53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAgJiYgdi5sb2cgJiYgdi5sb2cocyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGpzX3ByaW50X3N0ZGVyciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZGVycihzKSB7XG4gIHZhciBzID0gY2FtbF91dGYxNl9vZl91dGY4KHMpO1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZGVyci53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAmJiB2LmVycm9yICYmIHYuZXJyb3Iocyk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19qc1xuZnVuY3Rpb24gY2FtbF9pc19qcygpIHtcbiAgcmV0dXJuIDE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd3JhcF9leGNlcHRpb24gY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyxjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfd3JhcF9leGNlcHRpb24oZSkge1xuICBpZihlIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlO1xuICAvL1N0YWNrX292ZXJmbG93OiBjaHJvbWUsIHNhZmFyaVxuICBpZihnbG9iYWxUaGlzLlJhbmdlRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuUmFuZ2VFcnJvclxuICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC9tYXhpbXVtIGNhbGwgc3RhY2svaSkpXG4gICAgcmV0dXJuIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93KTtcbiAgLy9TdGFja19vdmVyZmxvdzogZmlyZWZveFxuICBpZihnbG9iYWxUaGlzLkludGVybmFsRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuSW50ZXJuYWxFcnJvclxuICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC90b28gbXVjaCByZWN1cnNpb24vaSkpXG4gICAgcmV0dXJuIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93KTtcbiAgLy9XcmFwIEVycm9yIGluIEpzLkVycm9yIGV4Y2VwdGlvblxuICBpZihlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5FcnJvciAmJiBjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSlcbiAgICByZXR1cm4gWzAsY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIiksZV07XG4gIC8vZmFsbGJhY2s6IHdyYXBwZWQgaW4gRmFpbHVyZVxuICByZXR1cm4gWzAsY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChTdHJpbmcoZSkpXTtcbn1cblxuLy8gRXhwZXJpbWVudGFsXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UoZXhuLCBmb3JjZSkge1xuICAvL25ldmVyIHJlcmFpc2UgZm9yIGNvbnN0YW50IGV4blxuICBpZighZXhuLmpzX2Vycm9yIHx8IGZvcmNlIHx8IGV4blswXSA9PSAyNDgpIGV4bi5qc19lcnJvciA9IG5ldyBnbG9iYWxUaGlzLkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIFswLCBleG4uanNfZXJyb3JdOyB9XG4gIHJldHVybiAwO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Jvb2woeCkgeyByZXR1cm4gISF4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19ib29sKHgpIHsgcmV0dXJuICt4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19mbG9hdCh4KSB7IHJldHVybiB4OyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2FycmF5KGEpIHtcbiAgcmV0dXJuIGEuc2xpY2UoMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGJbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGxlbjtpKyspIGJbaSsxXSA9IGFbaV07XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X29mX2pzX2FycmF5KGEpe1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgaT1hLmxlbmd0aCAtIDE7IGk+PTA7IGktLSl7XG4gICAgdmFyIGUgPSBhW2ldO1xuICAgIGwgPSBbMCxlLGxdO1xuICB9XG4gIHJldHVybiBsXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF90b19qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3RfdG9fanNfYXJyYXkobCl7XG4gIHZhciBhID0gW107XG4gIGZvcig7IGwgIT09IDA7IGwgPSBsWzJdKSB7XG4gICAgYS5wdXNoKGxbMV0pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3ZhciBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdmFyKHgpIHtcbiAgdmFyIHggPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh4KTtcbiAgLy9DaGVja3MgdGhhdCB4IGhhcyB0aGUgZm9ybSBpZGVudFsuaWRlbnRdKlxuICBpZigheC5tYXRjaCgvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKihcXC5bYS16QS1aXyRdW2EtekEtWl8kMC05XSopKiQvKSl7XG4gICAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc192YXI6IFxcXCJcIiArIHggKyBcIlxcXCIgaXMgbm90IGEgdmFsaWQgSmF2YVNjcmlwdCB2YXJpYWJsZS4gY29udGludWluZyAuLlwiKTtcbiAgICAvL2dsb2JhbFRoaXMuY29uc29sZS5lcnJvcihcIkpzLlVuc2FmZS5ldmFsX3N0cmluZ1wiKVxuICB9XG4gIHJldHVybiBldmFsKHgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19jYWxsIChjb25zdCwgbXV0YWJsZSwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19jYWxsKGYsIG8sIGFyZ3MpIHsgcmV0dXJuIGYuYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5fY2FsbCAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfZnVuX2NhbGwoZiwgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIGYoKTtcbiAgY2FzZSAyOiByZXR1cm4gZiAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIGYgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgY2FtbF9qc19mcm9tX2FycmF5KGEpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbWV0aF9jYWxsIChtdXRhYmxlLCBjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoZildLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX25ldyAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbmV3KGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBuZXcgYztcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9vanNfbmV3X2FyciAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb2pzX25ld19hcnIoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMDogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDE6IHJldHVybiBuZXcgYyAoYVswXSk7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgYSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobGVuID4gMCl7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbdW5kZWZpbmVkXSk7XG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFthcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobiA9PSBhcml0eSAmJiBmLmxlbmd0aCA9PSBhcml0eSkgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsYXJncyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLFt0aGlzLGFyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSArIDEpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7IH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZXF1YWxzICh4LCB5KSB7IHJldHVybiArKHggPT0geSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19ldmFsX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19ldmFsX3N0cmluZyAocykge3JldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwciAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V4cHIocykge1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9wdXJlX2pzX2V4cHIgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9wdXJlX2pzX2V4cHIgKHMpe1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX3B1cmVfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29iamVjdCAob2JqZWN0X2xpdGVyYWwpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19vYmplY3QgKGEpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBhW2ldO1xuICAgIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocFsxXSldID0gcFsyXTtcbiAgfVxuICByZXR1cm4gbztcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSGFzaHRibFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfdW5pdl9wYXJhbSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19jb250ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaGFzaF91bml2X3BhcmFtIChjb3VudCwgbGltaXQsIG9iaikge1xuICB2YXIgaGFzaF9hY2N1ID0gMDtcbiAgZnVuY3Rpb24gaGFzaF9hdXggKG9iaikge1xuICAgIGxpbWl0IC0tO1xuICAgIGlmIChjb3VudCA8IDAgfHwgbGltaXQgPCAwKSByZXR1cm47XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5ICYmIG9ialswXSA9PT0gKG9ialswXXwwKSkge1xuICAgICAgc3dpdGNoIChvYmpbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9ialsyXSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIGxpbWl0Kys7IGhhc2hfYXV4KG9iaik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIG9ialswXSkgfCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gb2JqLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIGhhc2hfYXV4IChvYmpbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyhvYmopKSB7XG4gICAgICBjb3VudCAtLTtcbiAgICAgIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KG9iaik7XG4gICAgICBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuXHRmb3IgKHZhciBiID0gY29udGVudCwgbCA9IGIubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgIH0gZWxzZSB7IC8qIEFSUkFZICovXG4gICAgICAgIGZvciAodmFyIGEgPSBjb250ZW50LCBsID0gYS5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGFbaV0pIHwgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKG9iaikpIHtcbiAgICAgIHZhciBqc2J5dGVzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhvYmopO1xuICAgICAgZm9yICh2YXIgYiA9IGpzYnl0ZXMsIGwgPSBqc2J5dGVzLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZm9yICh2YXIgYiA9IG9iaiwgbCA9IG9iai5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gKG9ianwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgY291bnQgLS07XG4gICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmopIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gK29iaikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGNvdW50LS07XG4gICAgICB2YXIgcCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAob2JqKSk7XG4gICAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIHBbaV0pIHwgMDtcbiAgICB9IGVsc2UgaWYob2JqICYmIG9iai5jYW1sX2N1c3RvbSkge1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaCA9IGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gob2JqKSB8IDA7XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIGgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzaF9hdXggKG9iaik7XG4gIHJldHVybiBoYXNoX2FjY3UgJiAweDNGRkZGRkZGO1xufVxuXG4vL2Z1bmN0aW9uIFJPVEwzMih4LG4pIHsgcmV0dXJuICgoeCA8PCBuKSB8ICh4ID4+PiAoMzItbikpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludChoLGQpIHtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4Y2M5ZTJkNTF8MCk7XG4gIGQgPSAoKGQgPDwgMTUpIHwgKGQgPj4+ICgzMi0xNSkpKTsgLy8gUk9UTDMyKGQsIDE1KTtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4MWI4NzM1OTMpO1xuICBoIF49IGQ7XG4gIGggPSAoKGggPDwgMTMpIHwgKGggPj4+ICgzMi0xMykpKTsgICAvL1JPVEwzMihoLCAxMyk7XG4gIHJldHVybiAoKChoICsgKGggPDwgMikpfDApICsgKDB4ZTY1NDZiNjR8MCkpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpIHtcbiAgaCBePSBoID4+PiAxNjtcbiAgaCA9IGNhbWxfbXVsIChoLCAweDg1ZWJjYTZifDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwgKGgsIDB4YzJiMmFlMzV8MCk7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaGFzaF9taXhfaW50NjRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmxvYXQgKGgsIHYwKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2ludDY0KGgsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAodjApKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2xvMzIsIGNhbWxfaW50NjRfaGkzMlxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQ2NCAoaCwgdikge1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9sbzMyKHYpKTtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfaGkzMih2KSk7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHMuY2hhckNvZGVBdChpKVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgOClcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzIpIDw8IDE2KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMykgPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHMuY2hhckNvZGVBdChpKzEpIDw8IDg7XG4gIGNhc2UgMTpcbiAgICB3IHw9IHMuY2hhckNvZGVBdChpKTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzW2ldXG4gICAgICB8IChzW2krMV0gPDwgOClcbiAgICAgIHwgKHNbaSsyXSA8PCAxNilcbiAgICAgIHwgKHNbaSszXSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHNbaSsyXSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHNbaSsxXSA8PCA4O1xuICBjYXNlIDE6IHcgfD0gc1tpXTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXMoaCwgdikge1xuICB2YXIgY29udGVudCA9IGNhbWxfbWxfYnl0ZXNfY29udGVudCh2KTtcbiAgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBjb250ZW50KVxuICBlbHNlIC8qIEFSUkFZICovXG4gICAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIGNvbnRlbnQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLCB2KSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZyh2KSk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9mbG9hdCwgY2FtbF9oYXNoX21peF9zdHJpbmcsIGNhbWxfaGFzaF9taXhfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2hhc2ggKGNvdW50LCBsaW1pdCwgc2VlZCwgb2JqKSB7XG4gIHZhciBxdWV1ZSwgcmQsIHdyLCBzeiwgbnVtLCBoLCB2LCBpLCBsZW47XG4gIHN6ID0gbGltaXQ7XG4gIGlmIChzeiA8IDAgfHwgc3ogPiAyNTYpIHN6ID0gMjU2O1xuICBudW0gPSBjb3VudDtcbiAgaCA9IHNlZWQ7XG4gIHF1ZXVlID0gW29ial07IHJkID0gMDsgd3IgPSAxO1xuICB3aGlsZSAocmQgPCB3ciAmJiBudW0gPiAwKSB7XG4gICAgdiA9IHF1ZXVlW3JkKytdO1xuICAgIGlmICh2ICYmIHYuY2FtbF9jdXN0b20pe1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoaCA9IGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKHYpO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQgKGgsIGhoKTtcbiAgICAgICAgbnVtIC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAodlswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdlsyXSk7XG4gICAgICAgIG51bS0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIHF1ZXVlWy0tcmRdID0gdlsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgdGFnID0gKCh2Lmxlbmd0aCAtIDEpIDw8IDEwKSB8IHZbMF07XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB0YWcpO1xuICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSB2Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHdyID49IHN6KSBicmVhaztcbiAgICAgICAgICBxdWV1ZVt3cisrXSA9IHZbaV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9ieXRlcyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmcoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfanNieXRlcyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHYgPT09ICh2fDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdit2KzEpO1xuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSArdikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsdik7XG4gICAgICBudW0tLTtcbiAgICB9XG4gIH1cbiAgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoaCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cbiIsIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZnVsbF9tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19mdWxsX21ham9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb21wYWN0aW9uXG5mdW5jdGlvbiBjYW1sX2djX2NvbXBhY3Rpb24oKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvdW50ZXJzXG5mdW5jdGlvbiBjYW1sX2djX2NvdW50ZXJzKCkgeyByZXR1cm4gWzI1NCwwLDAsMF0gfVxuLy9Qcm92aWRlczogY2FtbF9nY19xdWlja19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3F1aWNrX3N0YXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc3RhdCgpIHtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc2V0XG5mdW5jdGlvbiBjYW1sX2djX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19nZXRcbmZ1bmN0aW9uIGNhbWxfZ2NfZ2V0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zZXRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXIgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlbGVhc2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVsZWFzZSAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdGFydFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0YXJ0KHJhdGUsc3RhY2tfc2l6ZSx0cmFja2VyKXtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdG9wXG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RvcCh1bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V2ZW50bG9nX3Jlc3VtZVxuZnVuY3Rpb24gY2FtbF9ldmVudGxvZ19yZXN1bWUodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V2ZW50bG9nX3BhdXNlXG5mdW5jdGlvbiBjYW1sX2V2ZW50bG9nX3BhdXNlKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50XG5mdW5jdGlvbiBjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnQodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yX3NsaWNlXG5mdW5jdGlvbiBjYW1sX2djX21ham9yX3NsaWNlKHdvcmspIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vcl93b3Jkc1xuZnVuY3Rpb24gY2FtbF9nY19taW5vcl93b3Jkcyh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21pbm9yX2ZyZWVcbmZ1bmN0aW9uIGNhbWxfZ2V0X21pbm9yX2ZyZWUodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9tYWpvcl9idWNrZXRcbmZ1bmN0aW9uIGNhbWxfZ2V0X21ham9yX2J1Y2tldChuKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21ham9yX2NyZWRpdFxuZnVuY3Rpb24gY2FtbF9nZXRfbWFqb3JfY3JlZGl0KG4pIHsgcmV0dXJuIDA7IH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRm9ybWF0XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZm9ybWF0IChmbXQpIHtcbiAgZm10ID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpO1xuICB2YXIgbGVuID0gZm10Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IDMxKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJmb3JtYXRfaW50OiBmb3JtYXQgdG9vIGxvbmdcIik7XG4gIHZhciBmID1cbiAgICAgIHsganVzdGlmeTonKycsIHNpZ25zdHlsZTonLScsIGZpbGxlcjonICcsIGFsdGVybmF0ZTpmYWxzZSxcbiAgICAgICAgYmFzZTowLCBzaWduZWRjb252OmZhbHNlLCB3aWR0aDowLCB1cHBlcmNhc2U6ZmFsc2UsXG4gICAgICAgIHNpZ246MSwgcHJlYzotMSwgY29udjonZicgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gZm10LmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlICctJzpcbiAgICAgIGYuanVzdGlmeSA9ICctJzsgYnJlYWs7XG4gICAgY2FzZSAnKyc6IGNhc2UgJyAnOlxuICAgICAgZi5zaWduc3R5bGUgPSBjOyBicmVhaztcbiAgICBjYXNlICcwJzpcbiAgICAgIGYuZmlsbGVyID0gJzAnOyBicmVhaztcbiAgICBjYXNlICcjJzpcbiAgICAgIGYuYWx0ZXJuYXRlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6IGNhc2UgJzUnOlxuICAgIGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgZi53aWR0aCA9IDA7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYud2lkdGggPSBmLndpZHRoICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJy4nOlxuICAgICAgZi5wcmVjID0gMDtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi5wcmVjID0gZi5wcmVjICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICBjYXNlICdkJzogY2FzZSAnaSc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3UnOlxuICAgICAgZi5iYXNlID0gMTA7IGJyZWFrO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgZi5iYXNlID0gMTY7IGJyZWFrO1xuICAgIGNhc2UgJ1gnOlxuICAgICAgZi5iYXNlID0gMTY7IGYudXBwZXJjYXNlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnbyc6XG4gICAgICBmLmJhc2UgPSA4OyBicmVhaztcbiAgICBjYXNlICdlJzogY2FzZSAnZic6IGNhc2UgJ2cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi5jb252ID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnRSc6IGNhc2UgJ0YnOiBjYXNlICdHJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYudXBwZXJjYXNlID0gdHJ1ZTtcbiAgICAgIGYuY29udiA9IGMudG9Mb3dlckNhc2UgKCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCByYXdidWZmZXIpIHtcbiAgaWYgKGYudXBwZXJjYXNlKSByYXdidWZmZXIgPSByYXdidWZmZXIudG9VcHBlckNhc2UoKTtcbiAgdmFyIGxlbiA9IHJhd2J1ZmZlci5sZW5ndGg7XG4gIC8qIEFkanVzdCBsZW4gdG8gcmVmbGVjdCBhZGRpdGlvbmFsIGNoYXJzIChzaWduLCBldGMpICovXG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgKGYuc2lnbiA8IDAgfHwgZi5zaWduc3R5bGUgIT0gJy0nKSkgbGVuKys7XG4gIGlmIChmLmFsdGVybmF0ZSkge1xuICAgIGlmIChmLmJhc2UgPT0gOCkgbGVuICs9IDE7XG4gICAgaWYgKGYuYmFzZSA9PSAxNikgbGVuICs9IDI7XG4gIH1cbiAgLyogRG8gdGhlIGZvcm1hdHRpbmcgKi9cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcgJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICBpZiAoZi5zaWduZWRjb252KSB7XG4gICAgaWYgKGYuc2lnbiA8IDApIGJ1ZmZlciArPSAnLSc7XG4gICAgZWxzZSBpZiAoZi5zaWduc3R5bGUgIT0gJy0nKSBidWZmZXIgKz0gZi5zaWduc3R5bGU7XG4gIH1cbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSA4KSBidWZmZXIgKz0gJzAnO1xuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDE2KSBidWZmZXIgKz0gXCIweFwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnMCcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcwJztcbiAgYnVmZmVyICs9IHJhd2J1ZmZlcjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnLScpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoYnVmZmVyKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBIdWdvIEhldXphcmRcblxuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVcbnZhciBjYW1sX2dyX3N0YXRlO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9nZXQoKSB7XG4gIGlmKGNhbWxfZ3Jfc3RhdGUpIHtcbiAgICByZXR1cm4gY2FtbF9ncl9zdGF0ZTtcbiAgfVxuICB0aHJvdyBbMCxjYW1sX25hbWVkX3ZhbHVlKFwiR3JhcGhpY3MuR3JhcGhpY19mYWlsdXJlXCIpLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiTm90IGluaXRpYWxpemVkXCIpXVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGUsY2FtbF9ncl9zdGF0ZV9pbml0XG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX3NldChjdHgpIHtcbiAgY2FtbF9ncl9zdGF0ZT1jdHg7XG4gIGNhbWxfZ3Jfc3RhdGVfaW5pdCgpXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX29wZW5fZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9ncmFwaChpbmZvKXtcbiAgdmFyIGcgPSBnbG9iYWxUaGlzO1xuICB2YXIgaW5mbyA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGluZm8pO1xuICBmdW5jdGlvbiBnZXQobmFtZSl7XG4gICAgdmFyIHJlcyA9IGluZm8ubWF0Y2goXCIoXnwsKSAqXCIrbmFtZStcIiAqPSAqKFthLXpBLVowLTlfXSspICooLHwkKVwiKTtcbiAgICBpZihyZXMpIHJldHVybiByZXNbMl07XG4gIH1cbiAgdmFyIHNwZWNzID0gW107XG4gIGlmKCEoaW5mbz09XCJcIikpIHNwZWNzLnB1c2goaW5mbyk7XG4gIHZhciB0YXJnZXQgPSBnZXQoXCJ0YXJnZXRcIik7XG4gIGlmKCF0YXJnZXQpIHRhcmdldD1cIlwiO1xuICB2YXIgc3RhdHVzID0gZ2V0KFwic3RhdHVzXCIpO1xuICBpZighc3RhdHVzKSBzcGVjcy5wdXNoKFwic3RhdHVzPTFcIilcblxuICB2YXIgdyA9IGdldChcIndpZHRoXCIpO1xuICB3ID0gdz9wYXJzZUludCh3KToyMDA7XG4gIHNwZWNzLnB1c2goXCJ3aWR0aD1cIit3KTtcblxuICB2YXIgaCA9IGdldChcImhlaWdodFwiKTtcbiAgaCA9IGg/cGFyc2VJbnQoaCk6MjAwO1xuICBzcGVjcy5wdXNoKFwiaGVpZ2h0PVwiK2gpO1xuXG4gIHZhciB3aW4gPSBnLm9wZW4oXCJhYm91dDpibGFua1wiLHRhcmdldCxzcGVjcy5qb2luKFwiLFwiKSk7XG4gIGlmKCF3aW4pIHtjYW1sX2ZhaWx3aXRoKFwiR3JhcGhpY3Mub3Blbl9ncmFwaDogY2Fubm90IG9wZW4gdGhlIHdpbmRvd1wiKX1cbiAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgdmFyIGNhbnZhcyA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjYW52YXMud2lkdGggPSB3O1xuICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgdmFyIGN0eCA9IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpO1xuICBjdHguc2V0X3RpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgZG9jLnRpdGxlID0gdGl0bGU7XG4gIH07XG4gIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCk7XG4gIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gIGJvZHkuc3R5bGUubWFyZ2luID0gXCIwcHhcIjtcbiAgYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9jb2xvcixjYW1sX2dyX21vdmV0byxjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgsY2FtbF9ncl9zZXRfdGV4dF9zaXplLGNhbWxfZ3Jfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9pbml0KCl7XG4gIGNhbWxfZ3JfbW92ZXRvKGNhbWxfZ3Jfc3RhdGUueCxjYW1sX2dyX3N0YXRlLnkpO1xuICBjYW1sX2dyX3Jlc2l6ZV93aW5kb3coY2FtbF9ncl9zdGF0ZS53aWR0aCxjYW1sX2dyX3N0YXRlLmhlaWdodCk7XG4gIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgoY2FtbF9ncl9zdGF0ZS5saW5lX3dpZHRoKTtcbiAgY2FtbF9ncl9zZXRfdGV4dF9zaXplKGNhbWxfZ3Jfc3RhdGUudGV4dF9zaXplKTtcbiAgY2FtbF9ncl9zZXRfZm9udChjYW1sX2dyX3N0YXRlLmZvbnQpO1xuICBjYW1sX2dyX3NldF9jb2xvcihjYW1sX2dyX3N0YXRlLmNvbG9yKTtcbiAgY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKGNhbWxfZ3Jfc3RhdGUudGl0bGUpO1xuICAvL2NhbWxfZ3JfcmVzaXplX3dpbmRvdyBtaWdodCByZXNldCBzb21lIGNhbnZhcycgcHJvcGVydGllc1xuICBjYW1sX2dyX3N0YXRlLmNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsdyxoKXtcbiAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgY2FudmFzIDogY2FudmFzLFxuICAgIHggOiAwLFxuICAgIHkgOiAwLFxuICAgIHdpZHRoIDogdyxcbiAgICBoZWlnaHQgOiBoLFxuICAgIGxpbmVfd2lkdGggOiAxLFxuICAgIGZvbnQgOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiZml4ZWRcIiksXG4gICAgdGV4dF9zaXplIDogMjYsXG4gICAgY29sb3IgOiAweDAwMDAwMCxcbiAgICB0aXRsZSA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIilcbiAgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kb2Nfb2Zfc3RhdGVcbmZ1bmN0aW9uIGNhbWxfZ3JfZG9jX29mX3N0YXRlKHN0YXRlKSB7XG4gIGlmKHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50KVxuICAgIHJldHVybiBzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2VfZ3JhcGgoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IDA7XG4gIHMuY2FudmFzLmhlaWdodCA9IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKG5hbWUpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGl0bGUgPSBuYW1lO1xuICB2YXIganNuYW1lID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKHMuc2V0X3RpdGxlKSBzLnNldF90aXRsZShqc25hbWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9yZXNpemVfd2luZG93KHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKVxuICBzLndpZHRoID0gdztcbiAgcy5oZWlnaHQgPSBoO1xuICBzLmNhbnZhcy53aWR0aCA9IHc7XG4gIHMuY2FudmFzLmhlaWdodCA9IGg7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NsZWFyX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbGVhcl9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gIC8vICBzLmNvbnRleHQuc3Ryb2tlUmVjdCAoMC4sIDAuLCBzLndpZHRoLCBzLmhlaWdodCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV94KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMud2lkdGg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuaGVpZ2h0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfY29sb3IoY29sb3Ipe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGZ1bmN0aW9uIGNvbnZlcnQobnVtYmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnICsgbnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IDIpIHN0ciA9ICcwJyArIHN0cjtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHZhclxuICByID0gKGNvbG9yID4+IDE2KSAmIDB4ZmYsXG4gIGcgPSAoY29sb3IgPj4gOCkgICYgMHhmZixcbiAgYiA9IChjb2xvciA+PiAwKSAgJiAweGZmO1xuICBzLmNvbG9yPWNvbG9yO1xuICB2YXIgY19zdHIgPSAnIycgKyBjb252ZXJ0KHIpICsgY29udmVydChnKSArIGNvbnZlcnQoYik7XG4gIHMuY29udGV4dC5maWxsU3R5bGUgPSAgIGNfc3RyO1xuICBzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjX3N0cjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Bsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Bsb3QoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSgxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHZhciBjb2xvciA9IHMuY29sb3I7XG4gIGRbMF0gPSAoY29sb3IgPj4gMTYpICYgMHhmZjsgLy9yXG4gIGRbMV0gPSAoY29sb3IgPj4gOCkgICYgMHhmZiwgLy9nXG4gIGRbMl0gPSAoY29sb3IgPj4gMCkgICYgMHhmZjsgLy9iXG4gIGRbM10gPSAweEZGOyAvL2FcbiAgcy54PXg7XG4gIHMueT15O1xuICBzLmNvbnRleHQucHV0SW1hZ2VEYXRhKGltLHgscy5oZWlnaHQgLSB5KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcG9pbnRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3BvaW50X2NvbG9yKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltPXMuY29udGV4dC5nZXRJbWFnZURhdGEoeCxzLmhlaWdodCAtIHksMSwxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICByZXR1cm4gKGRbMF0gPDwgMTYpICsgKGRbMV0gPDwgOCkgKyBkWzJdO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9tb3ZldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21vdmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy54XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2N1cnJlbnRfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3VycmVudF95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9saW5ldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2xpbmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhzLngscy5oZWlnaHQgLSBzLnkpO1xuICBzLmNvbnRleHQubGluZVRvKHgscy5oZWlnaHQgLSB5KTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICBzLng9eDtcbiAgcy55PXk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuc3Ryb2tlUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9hcmNfYXV4KGN0eCxjeCxjeSxyeSxyeCxhMSxhMil7XG4gIHdoaWxlKGExPmEyKSBhMis9MzYwO1xuICBhMSAvPSAxODA7XG4gIGEyIC89IDE4MDtcbiAgdmFyIHJvdCA9IDAseFBvcyx5UG9zLHhQb3NfcHJldix5UG9zX3ByZXY7XG4gIHZhciBzcGFjZSA9IDI7XG4gIHZhciBudW0gPSAoKChhMiAtIGExKSAqIE1hdGguUEkgKiAoKHJ4K3J5KS8yKSkgLyBzcGFjZSkgfCAwO1xuICB2YXIgZGVsdGEgPSAoYTIgLSBhMSkgKiBNYXRoLlBJIC8gbnVtO1xuICB2YXIgaSA9IGExICogTWF0aC5QSTtcbiAgZm9yICh2YXIgaj0wO2o8PW51bTtqKyspe1xuICAgIHhQb3MgPSBjeCAtIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ5ICogTWF0aC5jb3MoaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeFBvcyA9IHhQb3MudG9GaXhlZCgyKTtcbiAgICB5UG9zID0gY3kgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHlQb3MgPSB5UG9zLnRvRml4ZWQoMik7XG4gICAgaWYgKGo9PTApIHtcbiAgICAgIGN0eC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgfSBlbHNlIGlmICh4UG9zX3ByZXYhPXhQb3MgfHwgeVBvc19wcmV2IT15UG9zKXtcbiAgICAgIGN0eC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgfVxuICAgIHhQb3NfcHJldj14UG9zO1xuICAgIHlQb3NfcHJldj15UG9zO1xuICAgIGktPSBkZWx0YTsvL2Njd1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfbGluZV93aWR0aCh3KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmxpbmVfd2lkdGggPSB3O1xuICBzLmNvbnRleHQubGluZVdpZHRoID0gd1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuZmlsbFJlY3QoeCxzLmhlaWdodCAtIHksdywtaCk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3BvbHlcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcG9seShhcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgYXIubGVuZ3RoOyBpKyspXG4gICAgcy5jb250ZXh0LmxpbmVUbyhhcltpXVsxXSxzLmhlaWdodCAtIGFyW2ldWzJdKTtcbiAgcy5jb250ZXh0LmxpbmVUbyhhclsxXVsxXSxzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHIoc3RyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgbSA9IHMuY29udGV4dC5tZWFzdXJlVGV4dChzdHIpO1xuICB2YXIgZHggPSBtLndpZHRoO1xuICBzLmNvbnRleHQuZmlsbFRleHQoc3RyLHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMueCArPSBkeCB8IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfY2hhclxuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2NoYXIoYyl7XG4gIGNhbWxfZ3JfZHJhd19zdHIoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cmluZyhzdHIpe1xuICBjYW1sX2dyX2RyYXdfc3RyKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHN0cikpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF9mb250KGYpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuZm9udCA9IGY7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF90ZXh0X3NpemUoc2l6ZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50ZXh0X3NpemUgPSBzaXplO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3RleHRfc2l6ZSh0eHQpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciB3ID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHR4dCkpLndpZHRoO1xuICByZXR1cm4gWzAsdyxzLnRleHRfc2l6ZV07XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9tYWtlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tYWtlX2ltYWdlKGFycil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGggPSBhcnIubGVuZ3RoIC0gMSA7XG4gIHZhciB3ID0gYXJyWzFdLmxlbmd0aCAtIDE7XG4gIHZhciBpbSA9IHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEodyxoKTtcbiAgZm9yKHZhciBpPTA7aTxoO2krKyl7XG4gICAgZm9yKHZhciBqPTA7ajx3O2orKyl7XG4gICAgICB2YXIgYyA9IGFycltpKzFdW2orMV07XG4gICAgICB2YXIgbyA9IGkqKHcqNCkgKyAoaiAqIDQpO1xuICAgICAgaWYoYyA9PSAtMSkge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IGMgPj4gMTYgJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IGMgPj4gIDggJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IGMgPj4gIDAgJiAwWGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDB4ZmY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kdW1wX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kdW1wX2ltYWdlKGltKXtcbiAgdmFyIGRhdGEgPSBbMF1cbiAgZm9yKHZhciBpPTA7IGk8aW0uaGVpZ2h0O2krKyl7XG4gICAgZGF0YVtpKzFdID0gWzBdXG4gICAgZm9yKHZhciBqPTA7IGo8aW0ud2lkdGg7aisrKXtcbiAgICAgIHZhciBvID0gaSooaW0ud2lkdGgqNCkgKyAoaiAqIDQpLFxuICAgICAgICAgIHIgPSBpbS5kYXRhW28rMF0sXG4gICAgICAgICAgZyA9IGltLmRhdGFbbysxXSxcbiAgICAgICAgICBiID0gaW0uZGF0YVtvKzJdO1xuICAgICAgZGF0YVtpKzFdW2orMV0gPSAociA8PCAxNikgKyAoZyA8PCA4KSArIGJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGlmKCFpbS5pbWFnZSkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikucHV0SW1hZ2VEYXRhKGltLDAsMCk7XG4gICAgdmFyIGltYWdlID0gbmV3IGdsb2JhbFRoaXMuSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgICAgIGltLmltYWdlID0gaW1hZ2U7XG4gICAgfVxuICAgIGltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gIH0gZWxzZSB7XG4gICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbS5pbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NyZWF0ZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3JlYXRlX2ltYWdlKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoeCx5KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYmxpdF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfYmxpdF9pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbTIgPSBzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5LGltLndpZHRoLGltLmhlaWdodCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW0yLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICBpbS5kYXRhW2ldID0gaW0yLmRhdGFbaV07XG4gICAgaW0uZGF0YVtpKzFdID0gaW0yLmRhdGFbaSsxXTtcbiAgICBpbS5kYXRhW2krMl0gPSBpbTIuZGF0YVtpKzJdO1xuICAgIGltLmRhdGFbaSszXSA9IGltMi5kYXRhW2krM107XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXJcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9faGFuZGxlcigpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19zaWduYWxcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9fc2lnbmFsKCl7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3dhaXRfZXZlbnRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2FpdF9ldmVudChfZXZsKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2FpdF9ldmVudCBub3QgSW1wbGVtZW50ZWQ6IHVzZSBHcmFwaGljc19qcyBpbnN0ZWFkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N5bmNocm9uaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3N5bmNocm9uaXplICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfc3luY2hyb25pemUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9yZW1lbWJlcl9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3JlbWVtYmVyX21vZGUgKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZGlzcGxheV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Rpc3BsYXlfbW9kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfZGlzcGxheV9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl93aW5kb3dfaWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2luZG93X2lkKGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2luZG93X2lkIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX3N1YndpbmRvdyhhLGIsYyxkKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX29wZW5fc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93KGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSl7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoYSkpIHJldHVybiAyNTI7IC8vIHN0cmluZ190YWdcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoYSkpIHJldHVybiAxMjUyOyAvLyBvY2FtbCBzdHJpbmcgKGlmIGRpZmZlcmVudCBmcm9tIGJ5dGVzKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkgJiYgYVswXSA9PT0gKGFbMF0+Pj4wKSAmJiBhWzBdIDw9IDI1NSkge1xuICAgIC8vIExvb2sgbGlrZSBhbiBvY2FtbCBibG9ja1xuICAgIHZhciB0YWcgPSBhWzBdIHwgMDtcbiAgICAvLyBpZ25vcmUgZG91YmxlX2FycmF5X3RhZyBiZWNhdXNlIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IHNldFxuICAgIC8vIHRoaXMgdGFnIHdoZW4gd2UgY3JlYXRlIGFuIGFycmF5IG9mIGZsb2F0LlxuICAgIHJldHVybiAodGFnID09IDI1NCk/MDp0YWdcbiAgfVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBOdW1iZXIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChhICYmIGEuY2FtbF9jdXN0b20pIHJldHVybiAxMjU1OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAoYSAmJiBhLmNvbXBhcmUpIHJldHVybiAxMjU2OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gMTI0NzsgLy8gbGlrZSBjbG9zdXJlX3RhZyAoMjQ3KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN5bWJvbFwiKSByZXR1cm4gMTI1MTtcbiAgcmV0dXJuIDEwMDE7IC8vb3V0X29mX2hlYXBfdGFnXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSl7XG4gIHJldHVybiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dLmNvbXBhcmU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20obnVtLCBjdXN0b20sIHN3YXAsIHRvdGFsKSB7XG4gIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGN1c3RvbSk7XG4gIGlmKGNvbXApIHtcbiAgICB2YXIgeCA9IChzd2FwID4gMCk/Y29tcChjdXN0b20sbnVtLHRvdGFsKTpjb21wKG51bSxjdXN0b20sdG90YWwpO1xuICAgIGlmKHRvdGFsICYmIHggIT0geCkgcmV0dXJuIHN3YXA7IC8vIHRvdGFsICYmIG5hblxuICAgIGlmKCt4ICE9ICt4KSByZXR1cm4gK3g7IC8vIG5hblxuICAgIGlmKCh4IHwgMCkgIT0gMCkgcmV0dXJuICh4IHwgMCk7IC8vICFuYW5cbiAgfVxuICByZXR1cm4gc3dhcFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsIChjb25zdCwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnRfY29tcGFyZSwgY2FtbF9zdHJpbmdfY29tcGFyZSwgY2FtbF9ieXRlc19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSwgY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19hID09IDI1MCkgeyBhID0gYVsxXTsgY29udGludWUgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19iID09IDI1MCkgeyBiID0gYlsxXTsgY29udGludWUgfVxuXG4gICAgICAvLyB0YWdzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZih0YWdfYSA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2IgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShhLCBiLCAtMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdfYiA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2EgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShiLCBhLCAxLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YWdfYSA8IHRhZ19iKT8tMToxO1xuICAgICAgfVxuICAgICAgc3dpdGNoKHRhZ19hKXtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgdmFyIHggPSBjYW1sX2ludF9jb21wYXJlKGFbMl0sIGJbMl0pO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBGb3J3YXJkX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBieXRlc1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgIHZhciB4ID0gY2FtbF9ieXRlc19jb21wYXJlKGEsIGIpO1xuICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUzOiAvLyBEb3VibGVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5X3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX2FycmF5X3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1NTogLy8gQ3VzdG9tX3RhZ1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEN1c3RvbV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKTtcbiAgICAgICAgaWYoY29tcCAhPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpe1xuICAgICAgICAgIHJldHVybiAoYS5jYW1sX2N1c3RvbTxiLmNhbWxfY3VzdG9tKT8tMToxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjb21wKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICB2YXIgeCA9IGNvbXAoYSxiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTY6IC8vIGNvbXBhcmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCkgeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgIGEgPSArYTtcbiAgICAgICAgYiA9ICtiO1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAvLyBIZXJlIHdlIGNhbiBiZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAzLiBKYXZhU2NyaXB0IG9iamVjdCB0aGFuIGNhbm5vdCBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvL1xuICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgIC8vICgyKSB3aWxsIGNvZXJjZSB0byBwcmltaXRpdmUgdHlwZXMgdXNpbmcgW3ZhbHVlT2ZdIG9yIFt0b1N0cmluZ11cbiAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIC0gaWYgYSBvciBiIGFyZSBub3Qgc3RyaW5ncywgY29udmVydCBhIGFuZCBiIHRvIG51bWJlclxuICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4Y2VwdGlvbjogYCE9YCB3aWxsIG5vdCBjb2VyY2UvY29udmVydCBpZiBib3RoIGEgYW5kIGIgYXJlIG9iamVjdHNcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MTogLy8gSmF2YVNjcmlwdCBTeW1ib2wsIG5vIG9yZGVyaW5nLlxuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjogLy8gb2NhbWwgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhiKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyMDogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gYS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDY6IC8vIExhenlfdGFnXG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5XG4gICAgICBkZWZhdWx0OiAvLyBCbG9jayB3aXRoIG90aGVyIHRhZ1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiAoYS5sZW5ndGggPCBiLmxlbmd0aCk/LTE6MTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID4gMSkgc3RhY2sucHVzaChhLCBiLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFjay5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG4gICAgdmFyIGkgPSBzdGFjay5wb3AoKTtcbiAgICBiID0gc3RhY2sucG9wKCk7XG4gICAgYSA9IHN0YWNrLnBvcCgpO1xuICAgIGlmIChpICsgMSA8IGEubGVuZ3RoKSBzdGFjay5wdXNoKGEsIGIsIGkgKyAxKTtcbiAgICBhID0gYVtpXTtcbiAgICBiID0gYltpXTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmUgKGEsIGIpIHsgcmV0dXJuIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRydWUpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9jb21wYXJlIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfaW50X2NvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gKC0xKTsgaWYgKGEgPT0gYikgcmV0dXJuIDA7IHJldHVybiAxO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA9PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX25vdGVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSAhPSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVyZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVyZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID49IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJ0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcnRoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID4gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzdGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3N0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8IDApOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWI6IGNvZGUgc3BlY2lmaWMgdG8gSnNfb2Zfb2NhbWxcblxuLy9Qcm92aWRlczogY2FtbF9qc19vbl9pZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19vbl9pZSAoKSB7XG4gIHZhciB1YSA9XG4gICAgICBnbG9iYWxUaGlzLm5hdmlnYXRvcj9nbG9iYWxUaGlzLm5hdmlnYXRvci51c2VyQWdlbnQ6XCJcIjtcbiAgcmV0dXJuIHVhLmluZGV4T2YoXCJNU0lFXCIpICE9IC0xICYmIHVhLmluZGV4T2YoXCJPcGVyYVwiKSAhPSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDovJi9nLCBsdDovPC9nLCBxdW90Oi9cXFwiL2csIGFsbDovWyY8XFxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlIChzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHMucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIGVudGl0eSA9IC9eJiM/WzAtOWEtekEtWl0rOyQvXG4gIGlmKHMubWF0Y2goZW50aXR5KSlcbiAge1xuICAgIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgdGVtcC5pbm5lckhUTUw9IHM7XG4gICAgc3RyPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXA9bnVsbDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJJbnZhbGlkIGVudGl0eSBcIiArIHMpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0X2NvbnNvbGUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0X2NvbnNvbGUgKCkge1xuICB2YXIgYyA9IGdsb2JhbFRoaXMuY29uc29sZT9nbG9iYWxUaGlzLmNvbnNvbGU6e307XG4gIHZhciBtID0gW1wibG9nXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwiYXNzZXJ0XCIsIFwiZGlyXCIsIFwiZGlyeG1sXCIsXG4gICAgICAgICAgIFwidHJhY2VcIiwgXCJncm91cFwiLCBcImdyb3VwQ29sbGFwc2VkXCIsIFwiZ3JvdXBFbmRcIiwgXCJ0aW1lXCIsIFwidGltZUVuZFwiXTtcbiAgZnVuY3Rpb24gZiAoKSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIGlmICghY1ttW2ldXSkgY1ttW2ldXT1mO1xuICByZXR1cm4gYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGUodW5pdCl7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgaWYodHlwZW9mIGcuWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLlhNTEh0dHBSZXF1ZXN0IH0gY2F0Y2ggKGUpIHsgfTtcbiAgfVxuICBpZih0eXBlb2YgZy5hY3RpdmVYT2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1zeG1sMy5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICB9XG4gIGNhbWxfZmFpbHdpdGgoXCJDYW5ub3QgY3JlYXRlIGEgWE1MSHR0cFJlcXVlc3RcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbihleG4pIHtcbiAgaWYoZXhuLmpzX2Vycm9yKSB7IHJldHVybiBleG4uanNfZXJyb3I7IH1cbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIElvXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2Nsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3N5c19jbG9zZShmZCkge1xuICBkZWxldGUgY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfc3RkX291dHB1dChjaGFuaWQscyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgc3RyID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKTtcbiAgdmFyIHNsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyKTtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4ub2Zmc2V0LCBzdHIsIDAsIHNsZW4pO1xuICBjaGFuLm9mZnNldCArPSBzbGVuO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3BlblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyciwganNfcHJpbnRfc3Rkb3V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0ZF9vdXRwdXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2ludGVybmFsKGlkeCxvdXRwdXQsZmlsZSxmbGFncykge1xuICBpZihjYW1sX2dsb2JhbF9kYXRhLmZkcyA9PT0gdW5kZWZpbmVkKSBjYW1sX2dsb2JhbF9kYXRhLmZkcyA9IG5ldyBBcnJheSgpO1xuICBmbGFncz1mbGFncz9mbGFnczp7fTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby5maWxlID0gZmlsZTtcbiAgaW5mby5vZmZzZXQgPSBmbGFncy5hcHBlbmQ/ZmlsZS5sZW5ndGgoKTowO1xuICBpbmZvLmZsYWdzID0gZmxhZ3M7XG4gIGluZm8ub3V0cHV0ID0gb3V0cHV0O1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tpZHhdID0gaW5mbztcbiAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHggfHwgaWR4ID4gY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeClcbiAgICBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4ID0gaWR4O1xuICByZXR1cm4gaWR4O1xufVxuZnVuY3Rpb24gY2FtbF9zeXNfb3BlbiAobmFtZSwgZmxhZ3MsIF9wZXJtcykge1xuICB2YXIgZiA9IHt9O1xuICB3aGlsZShmbGFncyl7XG4gICAgc3dpdGNoKGZsYWdzWzFdKXtcbiAgICBjYXNlIDA6IGYucmRvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDE6IGYud3Jvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDI6IGYuYXBwZW5kID0gMTticmVhaztcbiAgICBjYXNlIDM6IGYuY3JlYXRlID0gMTticmVhaztcbiAgICBjYXNlIDQ6IGYudHJ1bmNhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNTogZi5leGNsID0gMTsgYnJlYWs7XG4gICAgY2FzZSA2OiBmLmJpbmFyeSA9IDE7YnJlYWs7XG4gICAgY2FzZSA3OiBmLnRleHQgPSAxO2JyZWFrO1xuICAgIGNhc2UgODogZi5ub25ibG9jayA9IDE7YnJlYWs7XG4gICAgfVxuICAgIGZsYWdzPWZsYWdzWzJdO1xuICB9XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCxmKTtcbiAgdmFyIGlkeCA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg/Y2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeDowO1xuICByZXR1cm4gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCAoaWR4KzEsY2FtbF9zdGRfb3V0cHV0LGZpbGUsZik7XG59XG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDAsY2FtbF9zdGRfb3V0cHV0LCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZGluXG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDEsanNfcHJpbnRfc3Rkb3V0LCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZG91dFxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgyLGpzX3ByaW50X3N0ZGVyciwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRlcnJcblxuXG4vLyBvY2FtbCBDaGFubmVsc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX25hbWVcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSgpIHtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsc1xudmFyIGNhbWxfbWxfY2hhbm5lbHMgPSBuZXcgQXJyYXkoKTtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCAoKSB7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBjID0gMDsgYyA8IGNhbWxfbWxfY2hhbm5lbHMubGVuZ3RoOyBjKyspe1xuICAgIGlmKGNhbWxfbWxfY2hhbm5lbHNbY10gJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vcGVuZWQgJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vdXQpXG4gICAgICBsPVswLGNhbWxfbWxfY2hhbm5lbHNbY10uZmQsbF07XG4gIH1cbiAgcmV0dXJuIGw7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IChmZCkge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy5yZG9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgcmVhZG9ubHlcIik7XG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6dHJ1ZSxcbiAgICBidWZmZXI6XCJcIlxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N5c19vcGVuLGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZCwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIChmZCkgIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3Mud3Jvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHdyaXRlb25seVwiKTtcbiAgdmFyIHJlZmlsbCA9IG51bGw7XG4gIGlmKGZkID09IDAgJiYgZnNfbm9kZV9zdXBwb3J0ZWQoKSl7XG4gICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICByZWZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoZnMucmVhZEZpbGVTeW5jKDAsICd1dGY4JykpfTtcbiAgfVxuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OiBmYWxzZSxcbiAgICByZWZpbGw6cmVmaWxsXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5mZDtcbn1cblxuLy9Qcm92aWRlczogd2luX2ZpbGVkZXNjcl9vZl9jaGFubmVsXG4vL1JlcXVpcmVzOiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvclxudmFyIHdpbl9maWxlZGVzY3Jfb2ZfY2hhbm5lbCA9IGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZShjaGFuaWQsbW9kZSl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdO1xuICBkYXRhLmZsYWdzLnRleHQgPSAhbW9kZVxuICBkYXRhLmZsYWdzLmJpbmFyeSA9IG1vZGVcbiAgcmV0dXJuIDA7XG59XG5cbi8vSW5wdXQgZnJvbSBpbl9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2xvc2VfY2hhbm5lbFxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9zeXNfY2xvc2VcbmZ1bmN0aW9uIGNhbWxfbWxfY2xvc2VfY2hhbm5lbCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNoYW4ub3BlbmVkID0gZmFsc2U7XG4gIGNoYW4uZmlsZS5jbG9zZSgpO1xuICBjYW1sX3N5c19jbG9zZShjaGFuLmZkKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmlsZS5sZW5ndGgoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemVfNjQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjaGFuLmZpbGUubGVuZ3RoICgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0KGNoYW5pZCxmKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsKGNoYW5pZCxmKSB7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5yZWZpbGwgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9tbF9yZWZpbGxfaW5wdXQgKGNoYW4pIHtcbiAgdmFyIHN0ciA9IGNoYW4ucmVmaWxsKCk7XG4gIHZhciBzdHJfbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cik7XG4gIGlmIChzdHJfbGVuID09IDApIGNoYW4ucmVmaWxsID0gbnVsbDtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4uZmlsZS5sZW5ndGgoKSwgc3RyLCAwLCBzdHJfbGVuKTtcbiAgcmV0dXJuIHN0cl9sZW47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgPT0gbnVsbCkgcmV0dXJuO1xuICBpZiAoY2hhbi5maWxlLmxlbmd0aCgpICE9IGNoYW4ub2Zmc2V0KSByZXR1cm47XG4gIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXQgKGNoYW5pZCwgcywgaSwgbCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGwyID0gY2hhbi5maWxlLmxlbmd0aCgpIC0gY2hhbi5vZmZzZXQ7XG4gIGlmIChsMiA9PSAwICYmIGNoYW4ucmVmaWxsICE9IG51bGwpIGwyID0gY2FtbF9tbF9yZWZpbGxfaW5wdXQoY2hhbik7XG4gIGlmIChsMiA8IGwpIGwgPSBsMjtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsIHMsIGksIGwpO1xuICBjaGFuLm9mZnNldCArPSBsO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZSAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyg4KTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsOCk7XG5cbiAgLy8gSGVhZGVyIGlzIDIwIGJ5dGVzXG4gIHZhciBsZW4gPSBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChidWYsIDApICsgMjA7XG5cbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG5cbiAgdmFyIG9mZnNldCA9IFswXTtcbiAgdmFyIHJlcyA9IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhidWYsIG9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0ID0gY2hhbi5vZmZzZXQgKyBvZmZzZXRbMF07XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2NoYXIgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0KGNoYW5pZCk7XG4gIGlmIChjaGFuLm9mZnNldCA+PSBjaGFuLmZpbGUubGVuZ3RoKCkpXG4gICAgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB2YXIgcmVzID0gY2hhbi5maWxlLnJlYWRfb25lKGNoYW4ub2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQrKztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2ludCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgZmlsZSA9IGNoYW4uZmlsZTtcbiAgd2hpbGUgKChjaGFuLm9mZnNldCArIDMpID49IGZpbGUubGVuZ3RoKCkpIHtcbiAgICB2YXIgbCA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICAgIGlmIChsID09IDApIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgfVxuICB2YXIgbyA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgciA9KGZpbGUucmVhZF9vbmUobyAgKSA8PCAyNClcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMSkgPDwgMTYpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzIpIDw8IDgpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzMpKTtcbiAgY2hhbi5vZmZzZXQrPTQ7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW4oY2hhbmlkLHBvcyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGNoYW4ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luXzY0KGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbihjaGFuaWQpIHtyZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luXzY0KGNoYW5pZCkge3JldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQpfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X3NjYW5fbGluZVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X3NjYW5fbGluZShjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0KGNoYW5pZCk7XG4gIHZhciBwID0gY2hhbi5vZmZzZXQ7XG4gIHZhciBsZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKHAgPj0gbGVuKSB7IHJldHVybiAwO31cbiAgd2hpbGUodHJ1ZSkge1xuICAgIGlmKHAgPj0gbGVuKSByZXR1cm4gLSAocCAtIGNoYW4ub2Zmc2V0KTtcbiAgICBpZihjaGFuLmZpbGUucmVhZF9vbmUocCkgPT0gMTApIHJldHVybiBwIC0gY2hhbi5vZmZzZXQgKyAxO1xuICAgIHArKztcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2ZsdXNoXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9mbHVzaCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBmbHVzaCBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICBpZighY2hhbi5idWZmZXIgfHwgY2hhbi5idWZmZXIgPT0gXCJcIikgcmV0dXJuIDA7XG4gIGlmKGNoYW4uZmRcbiAgICAgJiYgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF1cbiAgICAgJiYgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dDtcbiAgICBzd2l0Y2gob3V0cHV0Lmxlbmd0aCl7XG4gICAgY2FzZSAyOiBvdXRwdXQoY2hhbmlkLGNoYW4uYnVmZmVyKTticmVhaztcbiAgICBkZWZhdWx0OiBvdXRwdXQoY2hhbi5idWZmZXIpXG4gICAgfTtcbiAgfVxuICBjaGFuLmJ1ZmZlciA9IFwiXCI7XG4gIHJldHVybiAwO1xufVxuXG4vL291dHB1dCB0byBvdXRfY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCxjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IG91dHB1dCB0byBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICB2YXIgYnl0ZXM7XG4gIGlmKG9mZnNldCA9PSAwICYmIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ1ZmZlcikgPT0gbGVuKVxuICAgIGJ5dGVzID0gYnVmZmVyO1xuICBlbHNlIHtcbiAgICBieXRlcyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgY2FtbF9ibGl0X2J5dGVzKGJ1ZmZlcixvZmZzZXQsYnl0ZXMsMCxsZW4pO1xuICB9XG4gIHZhciBzdHJpbmcgPSBjYW1sX3N0cmluZ19vZl9ieXRlcyhieXRlcyk7XG4gIHZhciBqc3N0cmluZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoc3RyaW5nKTtcbiAgdmFyIGlkID0ganNzdHJpbmcubGFzdEluZGV4T2YoXCJcXG5cIik7XG4gIGlmKGlkIDwgMClcbiAgICBjaGFuLmJ1ZmZlcis9anNzdHJpbmc7XG4gIGVsc2Uge1xuICAgIGNoYW4uYnVmZmVyKz1qc3N0cmluZy5zdWJzdHIoMCxpZCsxKTtcbiAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgIGNoYW4uYnVmZmVyICs9IGpzc3RyaW5nLnN1YnN0cihpZCsxKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXQoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxjYW1sX2J5dGVzX29mX3N0cmluZyhidWZmZXIpLG9mZnNldCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfY2hhciAoY2hhbmlkLGMpIHtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZywgY2FtbF9tbF9vdXRwdXQsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZSAoY2hhbmlkLHYsZmxhZ3MpIHtcbiAgdmFyIHMgPSBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcodiwgZmxhZ3MpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXQoY2hhbmlkLHBvcyl7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLHBvcyl7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0KGNoYW5pZCkge1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHJldHVybiBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0XzY0KGNoYW5pZCkge1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0IChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2ludCAoY2hhbmlkLGkpIHtcbiAgdmFyIGFyciA9IFsoaT4+MjQpICYgMHhGRiwoaT4+MTYpICYgMHhGRiwoaT4+OCkgJiAweEZGLGkgJiAweEZGIF07XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCw0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pc19idWZmZXJlZFxuZnVuY3Rpb24gY2FtbF9tbF9pc19idWZmZXJlZChjKSB7IHJldHVybiAxIH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfYnVmZmVyZWRcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2J1ZmZlcmVkKGMsdikgeyByZXR1cm4gMCB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEFycmF5XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc3ViIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc3ViIChhLCBpLCBsZW4pIHtcbiAgdmFyIGEyID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYTJbMF09MDtcbiAgZm9yKHZhciBpMiA9IDEsIGkxPSBpKzE7IGkyIDw9IGxlbjsgaTIrKyxpMSsrICl7XG4gICAgYTJbaTJdPWFbaTFdO1xuICB9XG4gIHJldHVybiBhMjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9hcHBlbmQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9hcHBlbmQoYTEsIGEyKSB7XG4gIHZhciBsMSA9IGExLmxlbmd0aCwgbDIgPSBhMi5sZW5ndGg7XG4gIHZhciBsID0gbDErbDItMVxuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IDA7XG4gIHZhciBpID0gMSxqID0gMTtcbiAgZm9yKDtpPGwxO2krKykgYVtpXT1hMVtpXTtcbiAgZm9yKDtpPGw7aSsrLGorKykgYVtpXT1hMltqXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfY29uY2F0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfY29uY2F0KGwpIHtcbiAgdmFyIGEgPSBbMF07XG4gIHdoaWxlIChsICE9PSAwKSB7XG4gICAgdmFyIGIgPSBsWzFdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYi5sZW5ndGg7IGkrKykgYS5wdXNoKGJbaV0pO1xuICAgIGwgPSBsWzJdO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIGlmIChpMiA8PSBpMSkge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGxlbjsgaisrKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBqID0gbGVuOyBqID49IDE7IGotLSkgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy8vLy8vLy8vLy8vLyBQZXJ2YXNpdmVcbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc2V0IChtdXRhYmxlLCBjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X3NldCAoYXJyYXksIGluZGV4LCBuZXd2YWwpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBhcnJheVtpbmRleCsxXT1uZXd2YWw7IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2dldCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X2dldCAoYXJyYXksIGluZGV4KSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFycmF5W2luZGV4KzFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZmlsbChhcnJheSwgb2ZzLCBsZW4sIHYpe1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIGFycmF5W29mcytpKzFdID0gdjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jaGVja19ib3VuZCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZCAoYXJyYXksIGluZGV4KSB7XG4gIGlmIChpbmRleCA+Pj4gMCA+PSBhcnJheS5sZW5ndGggLSAxKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3ZlY3QgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV92ZWN0IChsZW4sIGluaXQpIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSBpbml0O1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2Zsb2F0X3ZlY3QgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX2Zsb2F0X3ZlY3QobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9jcmVhdGUobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4iLCIvLy8vLy8vLy8gQklOX1BST1RcblxuLy9Qcm92aWRlczogY2FtbF9jaGVja19ib3VuZF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKGJpZ3N0cmluZywgaSl7XG4gIGlmIChpID4+PiAwID49IGJpZ3N0cmluZy5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2J1Zl9mbG9hdF9hcnJheV9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2NoZWNrX2JvdW5kLCBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZ1xuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9idWZfZmxvYXRfYXJyYXlfc3R1YihzcmNfcG9zLCBzcmMsIGRzdF9wb3MsIGRzdCwgbGVuKXtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICBjYW1sX2NoZWNrX2JvdW5kKGRzdCxkc3RfcG9zKTsgLy8gZmlyc3QgcG9zXG4gIGNhbWxfY2hlY2tfYm91bmQoZHN0LGRzdF9wb3MrbGVuLTEpOyAvLyBsYXN0IHBvc1xuICBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZyhzcmMsIHNyY19wb3MpOyAgLyogZmlyc3QgcG9zICovXG4gIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKHNyYywgc3JjX3BvcyArIGxlbiAqIDggLSAxKTsgLyogbGFzdCBwb3MgKi9cbiAgdmFyIHZpZXcgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQ2NEFycmF5KGxlbik7XG4gIHZhciBidWZmZXIgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSh2aWV3LmJ1ZmZlcik7XG4gIGJ1ZmZlci5zZXQoc3JjLmRhdGEuc3ViYXJyYXkoc3JjX3Bvcywgc3JjX3BvcyArIChsZW4gKiA4KSkpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIC8vIFsrIDFdIGJlY2F1c2UgdGhlIHRhZyBpcyBhdCBwb3MgMCBcbiAgICBkc3RbZHN0X3BvcytpKzFdID0gdmlld1tpXTtcbiAgfVxuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogYmluX3Byb3RfYmxpdF9idWZfYnl0ZXNfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9idWZfYnl0ZXNfc3R1YihzcmNfcG9zLCBzcmMsIGRzdF9wb3MsIGRzdCwgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoc3JjLCBzcmNfcG9zLCBkc3QsIGRzdF9wb3MsIGxlbik7XG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2Zsb2F0X2FycmF5X2J1Zl9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2NoZWNrX2JvdW5kLCBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZ1xuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9mbG9hdF9hcnJheV9idWZfc3R1YihzcmNfcG9zLHNyYywgZHN0X3BvcywgZHN0LCBsZW4pe1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDAgXG4gIGNhbWxfY2hlY2tfYm91bmQgKHNyYywgc3JjX3Bvcyk7IC8vIGZpcnN0IHBvcyBcbiAgY2FtbF9jaGVja19ib3VuZCAoc3JjLCBzcmNfcG9zICsgbGVuIC0gMSk7IC8vIGxhc3QgcG9zXG4gIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKGRzdCwgZHN0X3Bvcyk7IC8qIGZpcnN0IHBvcyAqL1xuICBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZyhkc3QsIGRzdF9wb3MgKyBsZW4gKiA4IC0gMSk7IC8qIGxhc3QgcG9zICovXG4gIC8vIFsrIDFdIGJlY2F1c2UgdGhlIHRhZyBpcyBhdCBwb3MgMFxuICBzcmNfcG9zID0gc3JjX3BvcyArIDFcbiAgdmFyIGZsb2F0NjQgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQ2NEFycmF5KHNyYy5zbGljZShzcmNfcG9zLHNyY19wb3MgKyBsZW4pKTtcbiAgdmFyIGZsb2F0NjRfdWludDggPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShmbG9hdDY0LmJ1ZmZlcik7XG4gIHZhciB2aWV3ID0gZHN0LmRhdGEuc3ViYXJyYXkoZHN0X3BvcywgZHN0X3BvcyArIChsZW4gKiA4KSk7XG4gIHZpZXcuc2V0KGZsb2F0NjRfdWludDgpO1xuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogYmluX3Byb3RfYmxpdF9zdHJpbmdfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X3N0cmluZ19idWZfc3R1YiAoc3JjX3Bvcywgc3JjLCBkc3RfcG9zLCBkc3QsIGxlbil7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzcmMsc3JjX3BvcywgZHN0LCBkc3RfcG9zLGxlbik7XG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2J5dGVzX2J1Zl9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9ieXRlc19idWZfc3R1YiAoc3JjX3Bvcywgc3JjLCBkc3RfcG9zLCBkc3QsIGxlbil7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzcmMsc3JjX3BvcywgZHN0LCBkc3RfcG9zLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEsIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheVxuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9idWZfc3R1YiAoc3JjX3Bvcywgc3JjLCBkc3RfcG9zLCBkc3QsIGxlbil7XG4gIC8vIFtiaW5fcHJvdF9ibGl0X2J1Zl9zdHViXSBpcyB1c2VkIHdpdGggbWl4ZWQgYmlnYXJyYXkga2luZHMuXG4gIC8vIENvbnZlcnRlciBldmVyeXRoaW5nIHRvIGJpZ2FycmF5IG9mIGNoYXIgYmVmb3JlIHRoZSBibGl0LlxuICBpZihzcmMua2luZCAhPSAxMikgLy8gMTIgaXMgdGhlIGNoYXIga2luZFxuICAgIHNyYyA9IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShzcmMuZGF0YSk7XG4gIGlmKGRzdC5raW5kICE9IDEyKSAvLyAxMiBpcyB0aGUgY2hhciBraW5kXG4gICAgZHN0ID0gYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5KGRzdC5kYXRhKTtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoc3JjLHNyY19wb3MsZHN0LGRzdF9wb3MsbGVuKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX3VwZGF0ZV9kdW1teSAoeCwgeSkge1xuICBpZiggdHlwZW9mIHk9PT1cImZ1bmN0aW9uXCIgKSB7IHguZnVuID0geTsgcmV0dXJuIDA7IH1cbiAgaWYoIHkuZnVuICkgeyB4LmZ1biA9IHkuZnVuOyByZXR1cm4gMDsgfVxuICB2YXIgaSA9IHkubGVuZ3RoOyB3aGlsZSAoaS0tKSB4W2ldID0geVtpXTsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2lzX2Jsb2NrIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2lzX2Jsb2NrICh4KSB7IHJldHVybiArKHggaW5zdGFuY2VvZiBBcnJheSk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX29ial90YWcgKHgpIHtcbiAgaWYgKCh4IGluc3RhbmNlb2YgQXJyYXkpICYmIHhbMF0gPT0gKHhbMF0gPj4+IDApKVxuICAgIHJldHVybiB4WzBdXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKCh4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8IHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gMjQ3XG4gIGVsc2UgaWYgKHggJiYgeC5jYW1sX2N1c3RvbSlcbiAgICByZXR1cm4gMjU1XG4gIGVsc2VcbiAgICByZXR1cm4gMTAwMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfdGFnIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF90YWcgKHgsIHRhZykgeyB4WzBdID0gdGFnOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9vYmpfYmxvY2sgY29uc3QgKGNvbnN0LGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfYmxvY2sgKHRhZywgc2l6ZSkge1xuICB2YXIgbyA9IG5ldyBBcnJheShzaXplKzEpO1xuICBvWzBdPXRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSBvW2ldID0gMDtcbiAgcmV0dXJuIG87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3dpdGhfdGFnXG5mdW5jdGlvbiBjYW1sX29ial93aXRoX3RhZyh0YWcseCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IHRhZztcbiAgZm9yKHZhciBpID0gMTsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfZHVwIG11dGFibGUgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfZHVwICh4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90cnVuY2F0ZSAobXV0YWJsZSwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfb2JqX3RydW5jYXRlICh4LCBzKSB7XG4gIGlmIChzPD0wIHx8IHMgKyAxID4geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIk9iai50cnVuY2F0ZVwiKTtcbiAgaWYgKHgubGVuZ3RoICE9IHMgKyAxKSB4Lmxlbmd0aCA9IHMgKyAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfbWFrZV9mb3J3YXJkXG5mdW5jdGlvbiBjYW1sX29ial9tYWtlX2ZvcndhcmQgKGIsdikge1xuICBiWzBdPTI1MDtcbiAgYlsxXT12O1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgKHYpIHsgcmV0dXJuIFsyNTAsIHZdOyB9XG5cbi8vLy8vLy8vLy8vLy8gQ2FtbGludGVybmFsT09cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgY29uc3RcbnZhciBjYW1sX21ldGhvZF9jYWNoZSA9IFtdO1xuZnVuY3Rpb24gY2FtbF9nZXRfcHVibGljX21ldGhvZCAob2JqLCB0YWcsIGNhY2hlaWQpIHtcbiAgdmFyIG1ldGhzID0gb2JqWzFdO1xuICB2YXIgb2ZzID0gY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF07XG4gIGlmIChvZnMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyYXkgaXMgbm90IHNwYXJzZVxuICAgIGZvciAodmFyIGkgPSBjYW1sX21ldGhvZF9jYWNoZS5sZW5ndGg7IGkgPCBjYWNoZWlkOyBpKyspXG4gICAgICBjYW1sX21ldGhvZF9jYWNoZVtpXSA9IDA7XG4gIH0gZWxzZSBpZiAobWV0aHNbb2ZzXSA9PT0gdGFnKSB7XG4gICAgcmV0dXJuIG1ldGhzW29mcyAtIDFdO1xuICB9XG4gIHZhciBsaSA9IDMsIGhpID0gbWV0aHNbMV0gKiAyICsgMSwgbWk7XG4gIHdoaWxlIChsaSA8IGhpKSB7XG4gICAgbWkgPSAoKGxpK2hpKSA+PiAxKSB8IDE7XG4gICAgaWYgKHRhZyA8IG1ldGhzW21pKzFdKSBoaSA9IG1pLTI7XG4gICAgZWxzZSBsaSA9IG1pO1xuICB9XG4gIGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdID0gbGkgKyAxO1xuICAvKiByZXR1cm4gMCBpZiB0YWcgaXMgbm90IHRoZXJlICovXG4gIHJldHVybiAodGFnID09IG1ldGhzW2xpKzFdID8gbWV0aHNbbGldIDogMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb29fbGFzdF9pZFxudmFyIGNhbWxfb29fbGFzdF9pZCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfc2V0X29vX2lkIChiKSB7XG4gIGJbMl09Y2FtbF9vb19sYXN0X2lkKys7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXNoX29vX2lkIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfZnJlc2hfb29faWQoKSB7XG4gIHJldHVybiBjYW1sX29vX2xhc3RfaWQrKztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfcmF3X2ZpZWxkXG5mdW5jdGlvbiBjYW1sX29ial9yYXdfZmllbGQobyxpKSB7IHJldHVybiBvW2krMV0gfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfcmF3X2ZpZWxkXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfcmF3X2ZpZWxkKG8saSx2KSB7IHJldHVybiBvW2krMV0gPSB2IH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzXG5mdW5jdGlvbiBjYW1sX29ial9yZWFjaGFibGVfd29yZHMobykgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9hZGRfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX29ial9hZGRfb2Zmc2V0KHYsb2Zmc2V0KSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJPYmouYWRkX29mZnNldCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xufVxuIiwiLy9JbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRlcm9sc29uL0JpZ0ludGVnZXIuanMjNGU5OWIxNWI3OTUxMzM4ZjE2NDcyODM3N2M5MDZjYWFlNWE3ODIwMlxuXG4vL1Byb3ZpZGVzOiBiaWdJbnQgY29uc3RcbnZhciBiaWdJbnQgPSAoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIEJBU0UgPSAxZTcsXG4gICAgICAgIExPR19CQVNFID0gNyxcbiAgICAgICAgTUFYX0lOVCA9IDkwMDcxOTkyNTQ3NDA5OTIsXG4gICAgICAgIE1BWF9JTlRfQVJSID0gc21hbGxUb0FycmF5KE1BWF9JTlQpLFxuICAgICAgICBERUZBVUxUX0FMUEhBQkVUID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcblxuICAgIHZhciBCaWdJbnQgPSBqb29fZ2xvYmFsX29iamVjdC5CaWdJbnQ7XG5cbiAgICB2YXIgc3VwcG9ydHNOYXRpdmVCaWdJbnQgPSB0eXBlb2YgQmlnSW50ID09PSBcImZ1bmN0aW9uXCI7XG5cbiAgICBmdW5jdGlvbiBJbnRlZ2VyKHYsIHJhZGl4LCBhbHBoYWJldCwgY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBJbnRlZ2VyWzBdO1xuICAgICAgICBpZiAodHlwZW9mIHJhZGl4ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gK3JhZGl4ID09PSAxMCAmJiAhYWxwaGFiZXQgPyBwYXJzZVZhbHVlKHYpIDogcGFyc2VCYXNlKHYsIHJhZGl4LCBhbHBoYWJldCwgY2FzZVNlbnNpdGl2ZSk7XG4gICAgICAgIHJldHVybiBwYXJzZVZhbHVlKHYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEJpZ0ludGVnZXIodmFsdWUsIHNpZ24pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNpZ24gPSBzaWduO1xuICAgICAgICB0aGlzLmlzU21hbGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW1sX2N1c3RvbSA9ICdfeic7XG4gICAgfVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbnRlZ2VyLnByb3RvdHlwZSk7XG5cbiAgICBmdW5jdGlvbiBTbWFsbEludGVnZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNpZ24gPSB2YWx1ZSA8IDA7XG4gICAgICAgIHRoaXMuaXNTbWFsbCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FtbF9jdXN0b20gPSAnX3onO1xuICAgIH1cbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbnRlZ2VyLnByb3RvdHlwZSk7XG5cbiAgICBmdW5jdGlvbiBOYXRpdmVCaWdJbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNhbWxfY3VzdG9tID0gJ196JztcbiAgICB9XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO1xuXG4gICAgZnVuY3Rpb24gaXNQcmVjaXNlKG4pIHtcbiAgICAgICAgcmV0dXJuIC1NQVhfSU5UIDwgbiAmJiBuIDwgTUFYX0lOVDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbWFsbFRvQXJyYXkobikgeyAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBkb2Vzbid0IHJlZmVyZW5jZSBCQVNFLCBuZWVkIHRvIGNoYW5nZSB0aGlzIGZ1bmN0aW9uIGlmIEJBU0UgY2hhbmdlc1xuICAgICAgICBpZiAobiA8IDFlNylcbiAgICAgICAgICAgIHJldHVybiBbbl07XG4gICAgICAgIGlmIChuIDwgMWUxNClcbiAgICAgICAgICAgIHJldHVybiBbbiAlIDFlNywgTWF0aC5mbG9vcihuIC8gMWU3KV07XG4gICAgICAgIHJldHVybiBbbiAlIDFlNywgTWF0aC5mbG9vcihuIC8gMWU3KSAlIDFlNywgTWF0aC5mbG9vcihuIC8gMWUxNCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFycmF5VG9TbWFsbChhcnIpIHsgLy8gSWYgQkFTRSBjaGFuZ2VzIHRoaXMgZnVuY3Rpb24gbWF5IG5lZWQgdG8gY2hhbmdlXG4gICAgICAgIHRyaW0oYXJyKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCA0ICYmIGNvbXBhcmVBYnMoYXJyLCBNQVhfSU5UX0FSUikgPCAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gYXJyWzBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGFyclswXSArIGFyclsxXSAqIEJBU0U7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGFyclswXSArIChhcnJbMV0gKyBhcnJbMl0gKiBCQVNFKSAqIEJBU0U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmltKHYpIHtcbiAgICAgICAgdmFyIGkgPSB2Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHZbLS1pXSA9PT0gMCk7XG4gICAgICAgIHYubGVuZ3RoID0gaSArIDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQXJyYXkobGVuZ3RoKSB7IC8vIGZ1bmN0aW9uIHNoYW1lbGVzc2x5IHN0b2xlbiBmcm9tIFlhZmZsZSdzIGxpYnJhcnkgaHR0cHM6Ly9naXRodWIuY29tL1lhZmZsZS9CaWdJbnRlZ2VyXG4gICAgICAgIHZhciB4ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHhbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRydW5jYXRlKG4pIHtcbiAgICAgICAgaWYgKG4gPiAwKSByZXR1cm4gTWF0aC5mbG9vcihuKTtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGQoYSwgYikgeyAvLyBhc3N1bWVzIGEgYW5kIGIgYXJlIGFycmF5cyB3aXRoIGEubGVuZ3RoID49IGIubGVuZ3RoXG4gICAgICAgIHZhciBsX2EgPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIGxfYiA9IGIubGVuZ3RoLFxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsX2EpLFxuICAgICAgICAgICAgY2FycnkgPSAwLFxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXG4gICAgICAgICAgICBzdW0sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsX2I7IGkrKykge1xuICAgICAgICAgICAgc3VtID0gYVtpXSArIGJbaV0gKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gc3VtID49IGJhc2UgPyAxIDogMDtcbiAgICAgICAgICAgIHJbaV0gPSBzdW0gLSBjYXJyeSAqIGJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBsX2EpIHtcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gc3VtID09PSBiYXNlID8gMSA6IDA7XG4gICAgICAgICAgICByW2krK10gPSBzdW0gLSBjYXJyeSAqIGJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcnJ5ID4gMCkgci5wdXNoKGNhcnJ5KTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQW55KGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoID49IGIubGVuZ3RoKSByZXR1cm4gYWRkKGEsIGIpO1xuICAgICAgICByZXR1cm4gYWRkKGIsIGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFNtYWxsKGEsIGNhcnJ5KSB7IC8vIGFzc3VtZXMgYSBpcyBhcnJheSwgY2FycnkgaXMgbnVtYmVyIHdpdGggMCA8PSBjYXJyeSA8IE1BWF9JTlRcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobCksXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcbiAgICAgICAgICAgIHN1bSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgc3VtID0gYVtpXSAtIGJhc2UgKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihzdW0gLyBiYXNlKTtcbiAgICAgICAgICAgIHJbaV0gPSBzdW0gLSBjYXJyeSAqIGJhc2U7XG4gICAgICAgICAgICBjYXJyeSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgICAgIHJbaSsrXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbiAhPT0gbi5zaWduKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChuLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWUsIGIgPSBuLnZhbHVlO1xuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwoYSwgTWF0aC5hYnMoYikpLCB0aGlzLnNpZ24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRBbnkoYSwgYiksIHRoaXMuc2lnbik7XG4gICAgfTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wbHVzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkO1xuXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KG4ubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gbi52YWx1ZTtcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlY2lzZShhICsgYikpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKGEgKyBiKTtcbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoTWF0aC5hYnMoYikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbChiLCBNYXRoLmFicyhhKSksIGEgPCAwKTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUucGx1cyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYWRkO1xuXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlICsgcGFyc2VWYWx1ZSh2KS52YWx1ZSk7XG4gICAgfVxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUucGx1cyA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuYWRkO1xuXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYikgeyAvLyBhc3N1bWVzIGEgYW5kIGIgYXJlIGFycmF5cyB3aXRoIGEgPj0gYlxuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXG4gICAgICAgICAgICBiX2wgPSBiLmxlbmd0aCxcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkoYV9sKSxcbiAgICAgICAgICAgIGJvcnJvdyA9IDAsXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcbiAgICAgICAgICAgIGksIGRpZmZlcmVuY2U7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBiX2w7IGkrKykge1xuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IGFbaV0gLSBib3Jyb3cgLSBiW2ldO1xuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgZGlmZmVyZW5jZSArPSBiYXNlO1xuICAgICAgICAgICAgICAgIGJvcnJvdyA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgYm9ycm93ID0gMDtcbiAgICAgICAgICAgIHJbaV0gPSBkaWZmZXJlbmNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGJfbDsgaSA8IGFfbDsgaSsrKSB7XG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gYVtpXSAtIGJvcnJvdztcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlIDwgMCkgZGlmZmVyZW5jZSArPSBiYXNlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcltpKytdID0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJbaV0gPSBkaWZmZXJlbmNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgYV9sOyBpKyspIHtcbiAgICAgICAgICAgIHJbaV0gPSBhW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRyaW0ocik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0QW55KGEsIGIsIHNpZ24pIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAoY29tcGFyZUFicyhhLCBiKSA+PSAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHN1YnRyYWN0KGEsIGIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBzdWJ0cmFjdChiLCBhKTtcbiAgICAgICAgICAgIHNpZ24gPSAhc2lnbjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGFycmF5VG9TbWFsbCh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChzaWduKSB2YWx1ZSA9IC12YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodmFsdWUsIHNpZ24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0U21hbGwoYSwgYiwgc2lnbikgeyAvLyBhc3N1bWVzIGEgaXMgYXJyYXksIGIgaXMgbnVtYmVyIHdpdGggMCA8PSBiIDwgTUFYX0lOVFxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsKSxcbiAgICAgICAgICAgIGNhcnJ5ID0gLWIsXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcbiAgICAgICAgICAgIGksIGRpZmZlcmVuY2U7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldICsgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IoZGlmZmVyZW5jZSAvIGJhc2UpO1xuICAgICAgICAgICAgZGlmZmVyZW5jZSAlPSBiYXNlO1xuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2UgPCAwID8gZGlmZmVyZW5jZSArIGJhc2UgOiBkaWZmZXJlbmNlO1xuICAgICAgICB9XG4gICAgICAgIHIgPSBhcnJheVRvU21hbGwocik7XG4gICAgICAgIGlmICh0eXBlb2YgciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHNpZ24pIHIgPSAtcjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHIpO1xuICAgICAgICB9IHJldHVybiBuZXcgQmlnSW50ZWdlcihyLCBzaWduKTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbiAhPT0gbi5zaWduKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQobi5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlLCBiID0gbi52YWx1ZTtcbiAgICAgICAgaWYgKG4uaXNTbWFsbClcbiAgICAgICAgICAgIHJldHVybiBzdWJ0cmFjdFNtYWxsKGEsIE1hdGguYWJzKGIpLCB0aGlzLnNpZ24pO1xuICAgICAgICByZXR1cm4gc3VidHJhY3RBbnkoYSwgYiwgdGhpcy5zaWduKTtcbiAgICB9O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbnVzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3Q7XG5cbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGlmIChhIDwgMCAhPT0gbi5zaWduKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQobi5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBuLnZhbHVlO1xuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhIC0gYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwoYiwgTWF0aC5hYnMoYSksIGEgPj0gMCk7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm1pbnVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdDtcblxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlIC0gcGFyc2VWYWx1ZSh2KS52YWx1ZSk7XG4gICAgfVxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubWludXMgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnN1YnRyYWN0O1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy52YWx1ZSwgIXRoaXMuc2lnbik7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNpZ24gPSB0aGlzLnNpZ247XG4gICAgICAgIHZhciBzbWFsbCA9IG5ldyBTbWFsbEludGVnZXIoLXRoaXMudmFsdWUpO1xuICAgICAgICBzbWFsbC5zaWduID0gIXNpZ247XG4gICAgICAgIHJldHVybiBzbWFsbDtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCgtdGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy52YWx1ZSwgZmFsc2UpO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKE1hdGguYWJzKHRoaXMudmFsdWUpKTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlID49IDAgPyB0aGlzLnZhbHVlIDogLXRoaXMudmFsdWUpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlMb25nKGEsIGIpIHtcbiAgICAgICAgdmFyIGFfbCA9IGEubGVuZ3RoLFxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXG4gICAgICAgICAgICBsID0gYV9sICsgYl9sLFxuICAgICAgICAgICAgciA9IGNyZWF0ZUFycmF5KGwpLFxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXG4gICAgICAgICAgICBwcm9kdWN0LCBjYXJyeSwgaSwgYV9pLCBiX2o7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhX2w7ICsraSkge1xuICAgICAgICAgICAgYV9pID0gYVtpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYl9sOyArK2opIHtcbiAgICAgICAgICAgICAgICBiX2ogPSBiW2pdO1xuICAgICAgICAgICAgICAgIHByb2R1Y3QgPSBhX2kgKiBiX2ogKyByW2kgKyBqXTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IocHJvZHVjdCAvIGJhc2UpO1xuICAgICAgICAgICAgICAgIHJbaSArIGpdID0gcHJvZHVjdCAtIGNhcnJ5ICogYmFzZTtcbiAgICAgICAgICAgICAgICByW2kgKyBqICsgMV0gKz0gY2Fycnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJpbShyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlTbWFsbChhLCBiKSB7IC8vIGFzc3VtZXMgYSBpcyBhcnJheSwgYiBpcyBudW1iZXIgd2l0aCB8YnwgPCBCQVNFXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGwpLFxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXG4gICAgICAgICAgICBjYXJyeSA9IDAsXG4gICAgICAgICAgICBwcm9kdWN0LCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9kdWN0ID0gYVtpXSAqIGIgKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihwcm9kdWN0IC8gYmFzZSk7XG4gICAgICAgICAgICByW2ldID0gcHJvZHVjdCAtIGNhcnJ5ICogYmFzZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XG4gICAgICAgICAgICByW2krK10gPSBjYXJyeSAlIGJhc2U7XG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IoY2FycnkgLyBiYXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGlmdExlZnQoeCwgbikge1xuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICB3aGlsZSAobi0tID4gMCkgci5wdXNoKDApO1xuICAgICAgICByZXR1cm4gci5jb25jYXQoeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlLYXJhdHN1YmEoeCwgeSkge1xuICAgICAgICB2YXIgbiA9IE1hdGgubWF4KHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKG4gPD0gMzApIHJldHVybiBtdWx0aXBseUxvbmcoeCwgeSk7XG4gICAgICAgIG4gPSBNYXRoLmNlaWwobiAvIDIpO1xuXG4gICAgICAgIHZhciBiID0geC5zbGljZShuKSxcbiAgICAgICAgICAgIGEgPSB4LnNsaWNlKDAsIG4pLFxuICAgICAgICAgICAgZCA9IHkuc2xpY2UobiksXG4gICAgICAgICAgICBjID0geS5zbGljZSgwLCBuKTtcblxuICAgICAgICB2YXIgYWMgPSBtdWx0aXBseUthcmF0c3ViYShhLCBjKSxcbiAgICAgICAgICAgIGJkID0gbXVsdGlwbHlLYXJhdHN1YmEoYiwgZCksXG4gICAgICAgICAgICBhYmNkID0gbXVsdGlwbHlLYXJhdHN1YmEoYWRkQW55KGEsIGIpLCBhZGRBbnkoYywgZCkpO1xuXG4gICAgICAgIHZhciBwcm9kdWN0ID0gYWRkQW55KGFkZEFueShhYywgc2hpZnRMZWZ0KHN1YnRyYWN0KHN1YnRyYWN0KGFiY2QsIGFjKSwgYmQpLCBuKSksIHNoaWZ0TGVmdChiZCwgMiAqIG4pKTtcbiAgICAgICAgdHJpbShwcm9kdWN0KTtcbiAgICAgICAgcmV0dXJuIHByb2R1Y3Q7XG4gICAgfVxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gYSBzdXJmYWNlIGZpdCBvZiBhIGdyYXBoIHBsb3R0aW5nIHRoZSBwZXJmb3JtYW5jZSBkaWZmZXJlbmNlXG4gICAgLy8gYmV0d2VlbiBsb25nIG11bHRpcGxpY2F0aW9uIGFuZCBrYXJhdHN1YmEgbXVsdGlwbGljYXRpb24gdmVyc3VzIHRoZSBsZW5ndGhzIG9mIHRoZSB0d28gYXJyYXlzLlxuICAgIGZ1bmN0aW9uIHVzZUthcmF0c3ViYShsMSwgbDIpIHtcbiAgICAgICAgcmV0dXJuIC0wLjAxMiAqIGwxIC0gMC4wMTIgKiBsMiArIDAuMDAwMDE1ICogbDEgKiBsMiA+IDA7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWUsXG4gICAgICAgICAgICBzaWduID0gdGhpcy5zaWduICE9PSBuLnNpZ24sXG4gICAgICAgICAgICBhYnM7XG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcbiAgICAgICAgICAgIGlmIChiID09PSAwKSByZXR1cm4gSW50ZWdlclswXTtcbiAgICAgICAgICAgIGlmIChiID09PSAxKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGlmIChiID09PSAtMSkgcmV0dXJuIHRoaXMubmVnYXRlKCk7XG4gICAgICAgICAgICBhYnMgPSBNYXRoLmFicyhiKTtcbiAgICAgICAgICAgIGlmIChhYnMgPCBCQVNFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5U21hbGwoYSwgYWJzKSwgc2lnbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gc21hbGxUb0FycmF5KGFicyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZUthcmF0c3ViYShhLmxlbmd0aCwgYi5sZW5ndGgpKSAvLyBLYXJhdHN1YmEgaXMgb25seSBmYXN0ZXIgZm9yIGNlcnRhaW4gYXJyYXkgc2l6ZXNcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseUthcmF0c3ViYShhLCBiKSwgc2lnbik7XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseUxvbmcoYSwgYiksIHNpZ24pO1xuICAgIH07XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50aW1lcyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5O1xuXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlTbWFsbEFuZEFycmF5KGEsIGIsIHNpZ24pIHsgLy8gYSA+PSAwXG4gICAgICAgIGlmIChhIDwgQkFTRSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5U21hbGwoYiwgYSksIHNpZ24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseUxvbmcoYiwgc21hbGxUb0FycmF5KGEpKSwgc2lnbik7XG4gICAgfVxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmIChpc1ByZWNpc2UoYS52YWx1ZSAqIHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhLnZhbHVlICogdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG11bHRpcGx5U21hbGxBbmRBcnJheShNYXRoLmFicyhhLnZhbHVlKSwgc21hbGxUb0FycmF5KE1hdGguYWJzKHRoaXMudmFsdWUpKSwgdGhpcy5zaWduICE9PSBhLnNpZ24pO1xuICAgIH07XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmIChhLnZhbHVlID09PSAwKSByZXR1cm4gSW50ZWdlclswXTtcbiAgICAgICAgaWYgKGEudmFsdWUgPT09IDEpIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoYS52YWx1ZSA9PT0gLTEpIHJldHVybiB0aGlzLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gbXVsdGlwbHlTbWFsbEFuZEFycmF5KE1hdGguYWJzKGEudmFsdWUpLCB0aGlzLnZhbHVlLCB0aGlzLnNpZ24gIT09IGEuc2lnbik7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWUodikuX211bHRpcGx5QnlTbWFsbCh0aGlzKTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudGltZXMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm11bHRpcGx5O1xuXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgKiBwYXJzZVZhbHVlKHYpLnZhbHVlKTtcbiAgICB9XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS50aW1lcyA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubXVsdGlwbHk7XG5cbiAgICBmdW5jdGlvbiBzcXVhcmUoYSkge1xuICAgICAgICAvL2NvbnNvbGUuYXNzZXJ0KDIgKiBCQVNFICogQkFTRSA8IE1BWF9JTlQpO1xuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxuICAgICAgICAgICAgciA9IGNyZWF0ZUFycmF5KGwgKyBsKSxcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxuICAgICAgICAgICAgcHJvZHVjdCwgY2FycnksIGksIGFfaSwgYV9qO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBhX2kgPSBhW2ldO1xuICAgICAgICAgICAgY2FycnkgPSAwIC0gYV9pICogYV9pO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgICAgICBhX2ogPSBhW2pdO1xuICAgICAgICAgICAgICAgIHByb2R1Y3QgPSAyICogKGFfaSAqIGFfaikgKyByW2kgKyBqXSArIGNhcnJ5O1xuICAgICAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihwcm9kdWN0IC8gYmFzZSk7XG4gICAgICAgICAgICAgICAgcltpICsgal0gPSBwcm9kdWN0IC0gY2FycnkgKiBiYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcltpICsgbF0gPSBjYXJyeTtcbiAgICAgICAgfVxuICAgICAgICB0cmltKHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihzcXVhcmUodGhpcy52YWx1ZSksIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUgKiB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAoaXNQcmVjaXNlKHZhbHVlKSkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoc3F1YXJlKHNtYWxsVG9BcnJheShNYXRoLmFicyh0aGlzLnZhbHVlKSkpLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSAqIHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpdk1vZDEoYSwgYikgeyAvLyBMZWZ0IG92ZXIgZnJvbSBwcmV2aW91cyB2ZXJzaW9uLiBQZXJmb3JtcyBmYXN0ZXIgdGhhbiBkaXZNb2QyIG9uIHNtYWxsZXIgaW5wdXQgc2l6ZXMuXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXG4gICAgICAgICAgICByZXN1bHQgPSBjcmVhdGVBcnJheShiLmxlbmd0aCksXG4gICAgICAgICAgICBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQgPSBiW2JfbCAtIDFdLFxuICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvblxuICAgICAgICAgICAgbGFtYmRhID0gTWF0aC5jZWlsKGJhc2UgLyAoMiAqIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCkpLFxuICAgICAgICAgICAgcmVtYWluZGVyID0gbXVsdGlwbHlTbWFsbChhLCBsYW1iZGEpLFxuICAgICAgICAgICAgZGl2aXNvciA9IG11bHRpcGx5U21hbGwoYiwgbGFtYmRhKSxcbiAgICAgICAgICAgIHF1b3RpZW50RGlnaXQsIHNoaWZ0LCBjYXJyeSwgYm9ycm93LCBpLCBsLCBxO1xuICAgICAgICBpZiAocmVtYWluZGVyLmxlbmd0aCA8PSBhX2wpIHJlbWFpbmRlci5wdXNoKDApO1xuICAgICAgICBkaXZpc29yLnB1c2goMCk7XG4gICAgICAgIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCA9IGRpdmlzb3JbYl9sIC0gMV07XG4gICAgICAgIGZvciAoc2hpZnQgPSBhX2wgLSBiX2w7IHNoaWZ0ID49IDA7IHNoaWZ0LS0pIHtcbiAgICAgICAgICAgIHF1b3RpZW50RGlnaXQgPSBiYXNlIC0gMTtcbiAgICAgICAgICAgIGlmIChyZW1haW5kZXJbc2hpZnQgKyBiX2xdICE9PSBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQpIHtcbiAgICAgICAgICAgICAgICBxdW90aWVudERpZ2l0ID0gTWF0aC5mbG9vcigocmVtYWluZGVyW3NoaWZ0ICsgYl9sXSAqIGJhc2UgKyByZW1haW5kZXJbc2hpZnQgKyBiX2wgLSAxXSkgLyBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcXVvdGllbnREaWdpdCA8PSBiYXNlIC0gMVxuICAgICAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICAgICAgYm9ycm93ID0gMDtcbiAgICAgICAgICAgIGwgPSBkaXZpc29yLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYXJyeSArPSBxdW90aWVudERpZ2l0ICogZGl2aXNvcltpXTtcbiAgICAgICAgICAgICAgICBxID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xuICAgICAgICAgICAgICAgIGJvcnJvdyArPSByZW1haW5kZXJbc2hpZnQgKyBpXSAtIChjYXJyeSAtIHEgKiBiYXNlKTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IHE7XG4gICAgICAgICAgICAgICAgaWYgKGJvcnJvdyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyW3NoaWZ0ICsgaV0gPSBib3Jyb3cgKyBiYXNlO1xuICAgICAgICAgICAgICAgICAgICBib3Jyb3cgPSAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJbc2hpZnQgKyBpXSA9IGJvcnJvdztcbiAgICAgICAgICAgICAgICAgICAgYm9ycm93ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoYm9ycm93ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcXVvdGllbnREaWdpdCAtPSAxO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcnJ5ICs9IHJlbWFpbmRlcltzaGlmdCArIGldIC0gYmFzZSArIGRpdmlzb3JbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXJyeSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gY2FycnkgKyBiYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyW3NoaWZ0ICsgaV0gPSBjYXJyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib3Jyb3cgKz0gY2Fycnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbc2hpZnRdID0gcXVvdGllbnREaWdpdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZW5vcm1hbGl6YXRpb25cbiAgICAgICAgcmVtYWluZGVyID0gZGl2TW9kU21hbGwocmVtYWluZGVyLCBsYW1iZGEpWzBdO1xuICAgICAgICByZXR1cm4gW2FycmF5VG9TbWFsbChyZXN1bHQpLCBhcnJheVRvU21hbGwocmVtYWluZGVyKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGl2TW9kMihhLCBiKSB7IC8vIEltcGxlbWVudGF0aW9uIGlkZWEgc2hhbWVsZXNzbHkgc3RvbGVuIGZyb20gU2lsZW50IE1hdHQncyBsaWJyYXJ5IGh0dHA6Ly9zaWxlbnRtYXR0LmNvbS9iaWdpbnRlZ2VyL1xuICAgICAgICAvLyBQZXJmb3JtcyBmYXN0ZXIgdGhhbiBkaXZNb2QxIG9uIGxhcmdlciBpbnB1dCBzaXplcy5cbiAgICAgICAgdmFyIGFfbCA9IGEubGVuZ3RoLFxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIHBhcnQgPSBbXSxcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxuICAgICAgICAgICAgZ3Vlc3MsIHhsZW4sIGhpZ2h4LCBoaWdoeSwgY2hlY2s7XG4gICAgICAgIHdoaWxlIChhX2wpIHtcbiAgICAgICAgICAgIHBhcnQudW5zaGlmdChhWy0tYV9sXSk7XG4gICAgICAgICAgICB0cmltKHBhcnQpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVBYnMocGFydCwgYikgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4bGVuID0gcGFydC5sZW5ndGg7XG4gICAgICAgICAgICBoaWdoeCA9IHBhcnRbeGxlbiAtIDFdICogYmFzZSArIHBhcnRbeGxlbiAtIDJdO1xuICAgICAgICAgICAgaGlnaHkgPSBiW2JfbCAtIDFdICogYmFzZSArIGJbYl9sIC0gMl07XG4gICAgICAgICAgICBpZiAoeGxlbiA+IGJfbCkge1xuICAgICAgICAgICAgICAgIGhpZ2h4ID0gKGhpZ2h4ICsgMSkgKiBiYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3Vlc3MgPSBNYXRoLmNlaWwoaGlnaHggLyBoaWdoeSk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBtdWx0aXBseVNtYWxsKGIsIGd1ZXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZUFicyhjaGVjaywgcGFydCkgPD0gMCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgZ3Vlc3MtLTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGd1ZXNzKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGd1ZXNzKTtcbiAgICAgICAgICAgIHBhcnQgPSBzdWJ0cmFjdChwYXJ0LCBjaGVjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIFthcnJheVRvU21hbGwocmVzdWx0KSwgYXJyYXlUb1NtYWxsKHBhcnQpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXZNb2RTbWFsbCh2YWx1ZSwgbGFtYmRhKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICBxdW90aWVudCA9IGNyZWF0ZUFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcbiAgICAgICAgICAgIGksIHEsIHJlbWFpbmRlciwgZGl2aXNvcjtcbiAgICAgICAgcmVtYWluZGVyID0gMDtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGRpdmlzb3IgPSByZW1haW5kZXIgKiBiYXNlICsgdmFsdWVbaV07XG4gICAgICAgICAgICBxID0gdHJ1bmNhdGUoZGl2aXNvciAvIGxhbWJkYSk7XG4gICAgICAgICAgICByZW1haW5kZXIgPSBkaXZpc29yIC0gcSAqIGxhbWJkYTtcbiAgICAgICAgICAgIHF1b3RpZW50W2ldID0gcSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtxdW90aWVudCwgcmVtYWluZGVyIHwgMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGl2TW9kQW55KHNlbGYsIHYpIHtcbiAgICAgICAgdmFyIHZhbHVlLCBuID0gcGFyc2VWYWx1ZSh2KTtcbiAgICAgICAgaWYgKHN1cHBvcnRzTmF0aXZlQmlnSW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBOYXRpdmVCaWdJbnQoc2VsZi52YWx1ZSAvIG4udmFsdWUpLCBuZXcgTmF0aXZlQmlnSW50KHNlbGYudmFsdWUgJSBuLnZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSBzZWxmLnZhbHVlLCBiID0gbi52YWx1ZTtcbiAgICAgICAgdmFyIHF1b3RpZW50O1xuICAgICAgICBpZiAoYiA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRpdmlkZSBieSB6ZXJvXCIpO1xuICAgICAgICBpZiAoc2VsZi5pc1NtYWxsKSB7XG4gICAgICAgICAgICBpZiAobi5pc1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgU21hbGxJbnRlZ2VyKHRydW5jYXRlKGEgLyBiKSksIG5ldyBTbWFsbEludGVnZXIoYSAlIGIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbSW50ZWdlclswXSwgc2VsZl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xuICAgICAgICAgICAgaWYgKGIgPT09IDEpIHJldHVybiBbc2VsZiwgSW50ZWdlclswXV07XG4gICAgICAgICAgICBpZiAoYiA9PSAtMSkgcmV0dXJuIFtzZWxmLm5lZ2F0ZSgpLCBJbnRlZ2VyWzBdXTtcbiAgICAgICAgICAgIHZhciBhYnMgPSBNYXRoLmFicyhiKTtcbiAgICAgICAgICAgIGlmIChhYnMgPCBCQVNFKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkaXZNb2RTbWFsbChhLCBhYnMpO1xuICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gYXJyYXlUb1NtYWxsKHZhbHVlWzBdKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluZGVyID0gdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2lnbikgcmVtYWluZGVyID0gLXJlbWFpbmRlcjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHF1b3RpZW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnNpZ24gIT09IG4uc2lnbikgcXVvdGllbnQgPSAtcXVvdGllbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFNtYWxsSW50ZWdlcihxdW90aWVudCksIG5ldyBTbWFsbEludGVnZXIocmVtYWluZGVyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IEJpZ0ludGVnZXIocXVvdGllbnQsIHNlbGYuc2lnbiAhPT0gbi5zaWduKSwgbmV3IFNtYWxsSW50ZWdlcihyZW1haW5kZXIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoYWJzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGFyaXNvbiA9IGNvbXBhcmVBYnMoYSwgYik7XG4gICAgICAgIGlmIChjb21wYXJpc29uID09PSAtMSkgcmV0dXJuIFtJbnRlZ2VyWzBdLCBzZWxmXTtcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gPT09IDApIHJldHVybiBbSW50ZWdlcltzZWxmLnNpZ24gPT09IG4uc2lnbiA/IDEgOiAtMV0sIEludGVnZXJbMF1dO1xuXG4gICAgICAgIC8vIGRpdk1vZDEgaXMgZmFzdGVyIG9uIHNtYWxsZXIgaW5wdXQgc2l6ZXNcbiAgICAgICAgaWYgKGEubGVuZ3RoICsgYi5sZW5ndGggPD0gMjAwKVxuICAgICAgICAgICAgdmFsdWUgPSBkaXZNb2QxKGEsIGIpO1xuICAgICAgICBlbHNlIHZhbHVlID0gZGl2TW9kMihhLCBiKTtcblxuICAgICAgICBxdW90aWVudCA9IHZhbHVlWzBdO1xuICAgICAgICB2YXIgcVNpZ24gPSBzZWxmLnNpZ24gIT09IG4uc2lnbixcbiAgICAgICAgICAgIG1vZCA9IHZhbHVlWzFdLFxuICAgICAgICAgICAgbVNpZ24gPSBzZWxmLnNpZ247XG4gICAgICAgIGlmICh0eXBlb2YgcXVvdGllbnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChxU2lnbikgcXVvdGllbnQgPSAtcXVvdGllbnQ7XG4gICAgICAgICAgICBxdW90aWVudCA9IG5ldyBTbWFsbEludGVnZXIocXVvdGllbnQpO1xuICAgICAgICB9IGVsc2UgcXVvdGllbnQgPSBuZXcgQmlnSW50ZWdlcihxdW90aWVudCwgcVNpZ24pO1xuICAgICAgICBpZiAodHlwZW9mIG1vZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKG1TaWduKSBtb2QgPSAtbW9kO1xuICAgICAgICAgICAgbW9kID0gbmV3IFNtYWxsSW50ZWdlcihtb2QpO1xuICAgICAgICB9IGVsc2UgbW9kID0gbmV3IEJpZ0ludGVnZXIobW9kLCBtU2lnbik7XG4gICAgICAgIHJldHVybiBbcXVvdGllbnQsIG1vZF07XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRpdk1vZEFueSh0aGlzLCB2KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHF1b3RpZW50OiByZXN1bHRbMF0sXG4gICAgICAgICAgICByZW1haW5kZXI6IHJlc3VsdFsxXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5kaXZtb2QgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmRpdm1vZCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdm1vZDtcblxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIGRpdk1vZEFueSh0aGlzLCB2KVswXTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUub3ZlciA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSAvIHBhcnNlVmFsdWUodikudmFsdWUpO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5vdmVyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vdmVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIGRpdk1vZEFueSh0aGlzLCB2KVsxXTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubW9kID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5yZW1haW5kZXIgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlICUgcGFyc2VWYWx1ZSh2KS52YWx1ZSk7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kID0gQmlnSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBiID0gbi52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlLCB4LCB5O1xuICAgICAgICBpZiAoYiA9PT0gMCkgcmV0dXJuIEludGVnZXJbMV07XG4gICAgICAgIGlmIChhID09PSAwKSByZXR1cm4gSW50ZWdlclswXTtcbiAgICAgICAgaWYgKGEgPT09IDEpIHJldHVybiBJbnRlZ2VyWzFdO1xuICAgICAgICBpZiAoYSA9PT0gLTEpIHJldHVybiBuLmlzRXZlbigpID8gSW50ZWdlclsxXSA6IEludGVnZXJbLTFdO1xuICAgICAgICBpZiAobi5zaWduKSB7XG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlclswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW4uaXNTbWFsbCkgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGV4cG9uZW50IFwiICsgbi50b1N0cmluZygpICsgXCIgaXMgdG9vIGxhcmdlLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTbWFsbCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlY2lzZSh2YWx1ZSA9IE1hdGgucG93KGEsIGIpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih0cnVuY2F0ZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHggPSB0aGlzO1xuICAgICAgICB5ID0gSW50ZWdlclsxXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChiICYgMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xuICAgICAgICAgICAgICAgIC0tYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiID09PSAwKSBicmVhaztcbiAgICAgICAgICAgIGIgLz0gMjtcbiAgICAgICAgICAgIHggPSB4LnNxdWFyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3c7XG5cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlLCBiID0gbi52YWx1ZTtcbiAgICAgICAgdmFyIF8wID0gQmlnSW50KDApLCBfMSA9IEJpZ0ludCgxKSwgXzIgPSBCaWdJbnQoMik7XG4gICAgICAgIGlmIChiID09PSBfMCkgcmV0dXJuIEludGVnZXJbMV07XG4gICAgICAgIGlmIChhID09PSBfMCkgcmV0dXJuIEludGVnZXJbMF07XG4gICAgICAgIGlmIChhID09PSBfMSkgcmV0dXJuIEludGVnZXJbMV07XG4gICAgICAgIGlmIChhID09PSBCaWdJbnQoLTEpKSByZXR1cm4gbi5pc0V2ZW4oKSA/IEludGVnZXJbMV0gOiBJbnRlZ2VyWy0xXTtcbiAgICAgICAgaWYgKG4uaXNOZWdhdGl2ZSgpKSByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludChfMCk7XG4gICAgICAgIHZhciB4ID0gdGhpcztcbiAgICAgICAgdmFyIHkgPSBJbnRlZ2VyWzFdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKChiICYgXzEpID09PSBfMSkge1xuICAgICAgICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xuICAgICAgICAgICAgICAgIC0tYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiID09PSBfMCkgYnJlYWs7XG4gICAgICAgICAgICBiIC89IF8yO1xuICAgICAgICAgICAgeCA9IHguc3F1YXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93ID0gZnVuY3Rpb24gKGV4cCwgbW9kKSB7XG4gICAgICAgIGV4cCA9IHBhcnNlVmFsdWUoZXhwKTtcbiAgICAgICAgbW9kID0gcGFyc2VWYWx1ZShtb2QpO1xuICAgICAgICBpZiAobW9kLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdGFrZSBtb2RQb3cgd2l0aCBtb2R1bHVzIDBcIik7XG4gICAgICAgIHZhciByID0gSW50ZWdlclsxXSxcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLm1vZChtb2QpO1xuICAgICAgICBpZiAoZXhwLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgZXhwID0gZXhwLm11bHRpcGx5KEludGVnZXJbLTFdKTtcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLm1vZEludihtb2QpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChleHAuaXNQb3NpdGl2ZSgpKSB7XG4gICAgICAgICAgICBpZiAoYmFzZS5pc1plcm8oKSkgcmV0dXJuIEludGVnZXJbMF07XG4gICAgICAgICAgICBpZiAoZXhwLmlzT2RkKCkpIHIgPSByLm11bHRpcGx5KGJhc2UpLm1vZChtb2QpO1xuICAgICAgICAgICAgZXhwID0gZXhwLmRpdmlkZSgyKTtcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLnNxdWFyZSgpLm1vZChtb2QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5tb2RQb3cgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdztcblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVBYnMoYSwgYikge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBhW2ldID4gYltpXSA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlQWJzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBiID0gbi52YWx1ZTtcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiBjb21wYXJlQWJzKGEsIGIpO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlQWJzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxuICAgICAgICAgICAgYSA9IE1hdGguYWJzKHRoaXMudmFsdWUpLFxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcbiAgICAgICAgICAgIGIgPSBNYXRoLmFicyhiKTtcbiAgICAgICAgICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuY29tcGFyZUFicyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdmFyIGIgPSBwYXJzZVZhbHVlKHYpLnZhbHVlO1xuICAgICAgICBhID0gYSA+PSAwID8gYSA6IC1hO1xuICAgICAgICBiID0gYiA+PSAwID8gYiA6IC1iO1xuICAgICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gYWJvdXQgY29tcGFyaXNvbiB3aXRoIEluZmluaXR5OlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGV0ZXJvbHNvbi9CaWdJbnRlZ2VyLmpzL2lzc3Vlcy82MVxuICAgICAgICBpZiAodiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnNpZ24gIT09IG4uc2lnbikge1xuICAgICAgICAgICAgcmV0dXJuIG4uc2lnbiA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wYXJlQWJzKGEsIGIpICogKHRoaXMuc2lnbiA/IC0xIDogMSk7XG4gICAgfTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlO1xuXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHYgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYSA9PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhIDwgMCAhPT0gbi5zaWduKSB7XG4gICAgICAgICAgICByZXR1cm4gYSA8IDAgPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEgPCAwID8gMSA6IC0xO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmU7XG5cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHZhciBiID0gcGFyc2VWYWx1ZSh2KS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG4gICAgfVxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuY29tcGFyZVRvID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5jb21wYXJlO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA9PT0gMDtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZXEgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmVxdWFscyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZXEgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmVxID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSAhPT0gMDtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubmVxID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5ub3RFcXVhbHMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm5lcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUubmVxID0gQmlnSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPiAwO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5ndCA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZ3JlYXRlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3QgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmdyZWF0ZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ndCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXI7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXIgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpIDwgMDtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubHQgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmxlc3NlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubHQgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmxlc3NlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmx0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA+PSAwO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5nZXEgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ2VxID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHM7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXJPckVxdWFscyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPD0gMDtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubGVxID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5sZXNzZXJPckVxdWFscyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVxID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXJPckVxdWFscyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmxlcSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWVbMF0gJiAxKSA9PT0gMDtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiAxKSA9PT0gMDtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiBCaWdJbnQoMSkpID09PSBCaWdJbnQoMCk7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZVswXSAmIDEpID09PSAxO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgMSkgPT09IDE7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiBCaWdJbnQoMSkpID09PSBCaWdJbnQoMSk7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnNpZ247XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID4gMDtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNQb3NpdGl2ZSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQb3NpdGl2ZTtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ247XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlIDwgMDtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZTtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzVW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1VuaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnZhbHVlKSA9PT0gMTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNVbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hYnMoKS52YWx1ZSA9PT0gQmlnSW50KDEpO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSAwO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBCaWdJbnQoMCk7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcbiAgICAgICAgaWYgKG4uaXNaZXJvKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG4uaXNVbml0KCkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAobi5jb21wYXJlQWJzKDIpID09PSAwKSByZXR1cm4gdGhpcy5pc0V2ZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kKG4pLmlzWmVybygpO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeTtcblxuICAgIGZ1bmN0aW9uIGlzQmFzaWNQcmltZSh2KSB7XG4gICAgICAgIHZhciBuID0gdi5hYnMoKTtcbiAgICAgICAgaWYgKG4uaXNVbml0KCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG4uZXF1YWxzKDIpIHx8IG4uZXF1YWxzKDMpIHx8IG4uZXF1YWxzKDUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG4uaXNFdmVuKCkgfHwgbi5pc0RpdmlzaWJsZUJ5KDMpIHx8IG4uaXNEaXZpc2libGVCeSg1KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobi5sZXNzZXIoNDkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyBpZiBpdCdzIHByaW1lOiBsZXQgdGhlIG90aGVyIGZ1bmN0aW9ucyBmaWd1cmUgaXQgb3V0XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWlsbGVyUmFiaW5UZXN0KG4sIGEpIHtcbiAgICAgICAgdmFyIG5QcmV2ID0gbi5wcmV2KCksXG4gICAgICAgICAgICBiID0gblByZXYsXG4gICAgICAgICAgICByID0gMCxcbiAgICAgICAgICAgIGQsIHQsIGksIHg7XG4gICAgICAgIHdoaWxlIChiLmlzRXZlbigpKSBiID0gYi5kaXZpZGUoMiksIHIrKztcbiAgICAgICAgbmV4dDogZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuLmxlc3NlcihhW2ldKSkgY29udGludWU7XG4gICAgICAgICAgICB4ID0gYmlnSW50KGFbaV0pLm1vZFBvdyhiLCBuKTtcbiAgICAgICAgICAgIGlmICh4LmlzVW5pdCgpIHx8IHguZXF1YWxzKG5QcmV2KSkgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGQgPSByIC0gMTsgZCAhPSAwOyBkLS0pIHtcbiAgICAgICAgICAgICAgICB4ID0geC5zcXVhcmUoKS5tb2Qobik7XG4gICAgICAgICAgICAgICAgaWYgKHguaXNVbml0KCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoeC5lcXVhbHMoblByZXYpKSBjb250aW51ZSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFNldCBcInN0cmljdFwiIHRvIHRydWUgdG8gZm9yY2UgR1JILXN1cHBvcnRlZCBsb3dlciBib3VuZCBvZiAyKmxvZyhOKV4yXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcmltZSA9IGZ1bmN0aW9uIChzdHJpY3QpIHtcbiAgICAgICAgdmFyIGlzUHJpbWUgPSBpc0Jhc2ljUHJpbWUodGhpcyk7XG4gICAgICAgIGlmIChpc1ByaW1lICE9PSB1bmRlZmluZWQpIHJldHVybiBpc1ByaW1lO1xuICAgICAgICB2YXIgbiA9IHRoaXMuYWJzKCk7XG4gICAgICAgIHZhciBiaXRzID0gbi5iaXRMZW5ndGgoKTtcbiAgICAgICAgaWYgKGJpdHMgPD0gNjQpXG4gICAgICAgICAgICByZXR1cm4gbWlsbGVyUmFiaW5UZXN0KG4sIFsyLCAzLCA1LCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5LCAzMSwgMzddKTtcbiAgICAgICAgdmFyIGxvZ04gPSBNYXRoLmxvZygyKSAqIGJpdHMudG9KU051bWJlcigpO1xuICAgICAgICB2YXIgdCA9IE1hdGguY2VpbCgoc3RyaWN0ID09PSB0cnVlKSA/ICgyICogTWF0aC5wb3cobG9nTiwgMikpIDogbG9nTik7XG4gICAgICAgIGZvciAodmFyIGEgPSBbXSwgaSA9IDA7IGkgPCB0OyBpKyspIHtcbiAgICAgICAgICAgIGEucHVzaChiaWdJbnQoaSArIDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlsbGVyUmFiaW5UZXN0KG4sIGEpO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1ByaW1lID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lID0gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcmltZTtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IGZ1bmN0aW9uIChpdGVyYXRpb25zKSB7XG4gICAgICAgIHZhciBpc1ByaW1lID0gaXNCYXNpY1ByaW1lKHRoaXMpO1xuICAgICAgICBpZiAoaXNQcmltZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gaXNQcmltZTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmFicygpO1xuICAgICAgICB2YXIgdCA9IGl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCA/IDUgOiBpdGVyYXRpb25zO1xuICAgICAgICBmb3IgKHZhciBhID0gW10sIGkgPSAwOyBpIDwgdDsgaSsrKSB7XG4gICAgICAgICAgICBhLnB1c2goYmlnSW50LnJhbmRCZXR3ZWVuKDIsIG4ubWludXMoMikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlsbGVyUmFiaW5UZXN0KG4sIGEpO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZTtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludiA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciB0ID0gYmlnSW50Lnplcm8sIG5ld1QgPSBiaWdJbnQub25lLCByID0gcGFyc2VWYWx1ZShuKSwgbmV3UiA9IHRoaXMuYWJzKCksIHEsIGxhc3RULCBsYXN0UjtcbiAgICAgICAgd2hpbGUgKCFuZXdSLmlzWmVybygpKSB7XG4gICAgICAgICAgICBxID0gci5kaXZpZGUobmV3Uik7XG4gICAgICAgICAgICBsYXN0VCA9IHQ7XG4gICAgICAgICAgICBsYXN0UiA9IHI7XG4gICAgICAgICAgICB0ID0gbmV3VDtcbiAgICAgICAgICAgIHIgPSBuZXdSO1xuICAgICAgICAgICAgbmV3VCA9IGxhc3RULnN1YnRyYWN0KHEubXVsdGlwbHkobmV3VCkpO1xuICAgICAgICAgICAgbmV3UiA9IGxhc3RSLnN1YnRyYWN0KHEubXVsdGlwbHkobmV3UikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghci5pc1VuaXQoKSkgdGhyb3cgbmV3IEVycm9yKHRoaXMudG9TdHJpbmcoKSArIFwiIGFuZCBcIiArIG4udG9TdHJpbmcoKSArIFwiIGFyZSBub3QgY28tcHJpbWVcIik7XG4gICAgICAgIGlmICh0LmNvbXBhcmUoMCkgPT09IC0xKSB7XG4gICAgICAgICAgICB0ID0gdC5hZGQobik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdC5uZWdhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5tb2RJbnYgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm1vZEludiA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludjtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnNpZ24pIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJ0cmFjdFNtYWxsKHZhbHVlLCAxLCB0aGlzLnNpZ24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbCh2YWx1ZSwgMSksIHRoaXMuc2lnbik7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSArIDEgPCBNQVhfSU5UKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSArIDEpO1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoTUFYX0lOVF9BUlIsIGZhbHNlKTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSArIEJpZ0ludCgxKSk7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKHZhbHVlLCAxKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwodmFsdWUsIDEsIHRoaXMuc2lnbik7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAtIDEgPiAtTUFYX0lOVCkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUgLSAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKE1BWF9JTlRfQVJSLCB0cnVlKTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSAtIEJpZ0ludCgxKSk7XG4gICAgfVxuXG4gICAgdmFyIHBvd2Vyc09mVHdvID0gWzFdO1xuICAgIHdoaWxlICgyICogcG93ZXJzT2ZUd29bcG93ZXJzT2ZUd28ubGVuZ3RoIC0gMV0gPD0gQkFTRSkgcG93ZXJzT2ZUd28ucHVzaCgyICogcG93ZXJzT2ZUd29bcG93ZXJzT2ZUd28ubGVuZ3RoIC0gMV0pO1xuICAgIHZhciBwb3dlcnMyTGVuZ3RoID0gcG93ZXJzT2ZUd28ubGVuZ3RoLCBoaWdoZXN0UG93ZXIyID0gcG93ZXJzT2ZUd29bcG93ZXJzMkxlbmd0aCAtIDFdO1xuXG4gICAgZnVuY3Rpb24gc2hpZnRfaXNTbWFsbChuKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhuKSA8PSBCQVNFO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KS50b0pTTnVtYmVyKCk7XG4gICAgICAgIGlmICghc2hpZnRfaXNTbWFsbChuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFN0cmluZyhuKSArIFwiIGlzIHRvbyBsYXJnZSBmb3Igc2hpZnRpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDwgMCkgcmV0dXJuIHRoaXMuc2hpZnRSaWdodCgtbik7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgICAgICBpZiAocmVzdWx0LmlzWmVybygpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICB3aGlsZSAobiA+PSBwb3dlcnMyTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsdGlwbHkoaGlnaGVzdFBvd2VyMik7XG4gICAgICAgICAgICBuIC09IHBvd2VyczJMZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQubXVsdGlwbHkocG93ZXJzT2ZUd29bbl0pO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5zaGlmdExlZnQgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdDtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgcmVtUXVvO1xuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodikudG9KU051bWJlcigpO1xuICAgICAgICBpZiAoIXNoaWZ0X2lzU21hbGwobikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihTdHJpbmcobikgKyBcIiBpcyB0b28gbGFyZ2UgZm9yIHNoaWZ0aW5nLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8IDApIHJldHVybiB0aGlzLnNoaWZ0TGVmdCgtbik7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAobiA+PSBwb3dlcnMyTGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmlzWmVybygpIHx8IChyZXN1bHQuaXNOZWdhdGl2ZSgpICYmIHJlc3VsdC5pc1VuaXQoKSkpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICByZW1RdW8gPSBkaXZNb2RBbnkocmVzdWx0LCBoaWdoZXN0UG93ZXIyKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlbVF1b1sxXS5pc05lZ2F0aXZlKCkgPyByZW1RdW9bMF0ucHJldigpIDogcmVtUXVvWzBdO1xuICAgICAgICAgICAgbiAtPSBwb3dlcnMyTGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZW1RdW8gPSBkaXZNb2RBbnkocmVzdWx0LCBwb3dlcnNPZlR3b1tuXSk7XG4gICAgICAgIHJldHVybiByZW1RdW9bMV0uaXNOZWdhdGl2ZSgpID8gcmVtUXVvWzBdLnByZXYoKSA6IHJlbVF1b1swXTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc2hpZnRSaWdodCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQ7XG5cbiAgICBmdW5jdGlvbiBiaXR3aXNlKHgsIHksIGZuKSB7XG4gICAgICAgIHkgPSBwYXJzZVZhbHVlKHkpO1xuICAgICAgICB2YXIgeFNpZ24gPSB4LmlzTmVnYXRpdmUoKSwgeVNpZ24gPSB5LmlzTmVnYXRpdmUoKTtcbiAgICAgICAgdmFyIHhSZW0gPSB4U2lnbiA/IHgubm90KCkgOiB4LFxuICAgICAgICAgICAgeVJlbSA9IHlTaWduID8geS5ub3QoKSA6IHk7XG4gICAgICAgIHZhciB4RGlnaXQgPSAwLCB5RGlnaXQgPSAwO1xuICAgICAgICB2YXIgeERpdk1vZCA9IG51bGwsIHlEaXZNb2QgPSBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICgheFJlbS5pc1plcm8oKSB8fCAheVJlbS5pc1plcm8oKSkge1xuICAgICAgICAgICAgeERpdk1vZCA9IGRpdk1vZEFueSh4UmVtLCBoaWdoZXN0UG93ZXIyKTtcbiAgICAgICAgICAgIHhEaWdpdCA9IHhEaXZNb2RbMV0udG9KU051bWJlcigpO1xuICAgICAgICAgICAgaWYgKHhTaWduKSB7XG4gICAgICAgICAgICAgICAgeERpZ2l0ID0gaGlnaGVzdFBvd2VyMiAtIDEgLSB4RGlnaXQ7IC8vIHR3bydzIGNvbXBsZW1lbnQgZm9yIG5lZ2F0aXZlIG51bWJlcnNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeURpdk1vZCA9IGRpdk1vZEFueSh5UmVtLCBoaWdoZXN0UG93ZXIyKTtcbiAgICAgICAgICAgIHlEaWdpdCA9IHlEaXZNb2RbMV0udG9KU051bWJlcigpO1xuICAgICAgICAgICAgaWYgKHlTaWduKSB7XG4gICAgICAgICAgICAgICAgeURpZ2l0ID0gaGlnaGVzdFBvd2VyMiAtIDEgLSB5RGlnaXQ7IC8vIHR3bydzIGNvbXBsZW1lbnQgZm9yIG5lZ2F0aXZlIG51bWJlcnNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeFJlbSA9IHhEaXZNb2RbMF07XG4gICAgICAgICAgICB5UmVtID0geURpdk1vZFswXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZuKHhEaWdpdCwgeURpZ2l0KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1bSA9IGZuKHhTaWduID8gMSA6IDAsIHlTaWduID8gMSA6IDApICE9PSAwID8gYmlnSW50KC0xKSA6IGJpZ0ludCgwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgc3VtID0gc3VtLm11bHRpcGx5KGhpZ2hlc3RQb3dlcjIpLmFkZChiaWdJbnQocmVzdWx0W2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLnByZXYoKTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubm90ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3Q7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gYml0d2lzZSh0aGlzLCBuLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAmIGI7IH0pO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5hbmQgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmFuZCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZDtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIGJpdHdpc2UodGhpcywgbiwgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgfCBiOyB9KTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUub3IgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm9yID0gQmlnSW50ZWdlci5wcm90b3R5cGUub3I7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gYml0d2lzZSh0aGlzLCBuLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSBeIGI7IH0pO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS54b3IgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnhvciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnhvcjtcblxuICAgIHZhciBMT0JNQVNLX0kgPSAxIDw8IDMwLCBMT0JNQVNLX0JJID0gKEJBU0UgJiAtQkFTRSkgKiAoQkFTRSAmIC1CQVNFKSB8IExPQk1BU0tfSTtcbiAgICBmdW5jdGlvbiByb3VnaExPQihuKSB7IC8vIGdldCBsb3dlc3RPbmVCaXQgKHJvdWdoKVxuICAgICAgICAvLyBTbWFsbEludGVnZXI6IHJldHVybiBNaW4obG93ZXN0T25lQml0KG4pLCAxIDw8IDMwKVxuICAgICAgICAvLyBCaWdJbnRlZ2VyOiByZXR1cm4gTWluKGxvd2VzdE9uZUJpdChuKSwgMSA8PCAxNCkgW0JBU0U9MWU3XVxuICAgICAgICB2YXIgdiA9IG4udmFsdWUsXG4gICAgICAgICAgICB4ID0gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgPyB2IHwgTE9CTUFTS19JIDpcbiAgICAgICAgICAgICAgICB0eXBlb2YgdiA9PT0gXCJiaWdpbnRcIiA/IHYgfCBCaWdJbnQoTE9CTUFTS19JKSA6XG4gICAgICAgICAgICAgICAgICAgIHZbMF0gKyB2WzFdICogQkFTRSB8IExPQk1BU0tfQkk7XG4gICAgICAgIHJldHVybiB4ICYgLXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW50ZWdlckxvZ2FyaXRobSh2YWx1ZSwgYmFzZSkge1xuICAgICAgICBpZiAoYmFzZS5jb21wYXJlVG8odmFsdWUpIDw9IDApIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBpbnRlZ2VyTG9nYXJpdGhtKHZhbHVlLCBiYXNlLnNxdWFyZShiYXNlKSk7XG4gICAgICAgICAgICB2YXIgcCA9IHRtcC5wO1xuICAgICAgICAgICAgdmFyIGUgPSB0bXAuZTtcbiAgICAgICAgICAgIHZhciB0ID0gcC5tdWx0aXBseShiYXNlKTtcbiAgICAgICAgICAgIHJldHVybiB0LmNvbXBhcmVUbyh2YWx1ZSkgPD0gMCA/IHsgcDogdCwgZTogZSAqIDIgKyAxIH0gOiB7IHA6IHAsIGU6IGUgKiAyIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcDogYmlnSW50KDEpLCBlOiAwIH07XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXM7XG4gICAgICAgIGlmIChuLmNvbXBhcmVUbyhiaWdJbnQoMCkpIDwgMCkge1xuICAgICAgICAgICAgbiA9IG4ubmVnYXRlKCkuc3VidHJhY3QoYmlnSW50KDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobi5jb21wYXJlVG8oYmlnSW50KDApKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpZ0ludCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmlnSW50KGludGVnZXJMb2dhcml0aG0obiwgYmlnSW50KDIpKS5lKS5hZGQoYmlnSW50KDEpKTtcbiAgICB9XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5iaXRMZW5ndGggPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aDtcblxuICAgIGZ1bmN0aW9uIG1heChhLCBiKSB7XG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpO1xuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcbiAgICAgICAgcmV0dXJuIGEuZ3JlYXRlcihiKSA/IGEgOiBiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtaW4oYSwgYikge1xuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYik7XG4gICAgICAgIHJldHVybiBhLmxlc3NlcihiKSA/IGEgOiBiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnY2QoYSwgYikge1xuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKS5hYnMoKTtcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYikuYWJzKCk7XG4gICAgICAgIGlmIChhLmVxdWFscyhiKSkgcmV0dXJuIGE7XG4gICAgICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYjtcbiAgICAgICAgaWYgKGIuaXNaZXJvKCkpIHJldHVybiBhO1xuICAgICAgICB2YXIgYyA9IEludGVnZXJbMV0sIGQsIHQ7XG4gICAgICAgIHdoaWxlIChhLmlzRXZlbigpICYmIGIuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgIGQgPSBtaW4ocm91Z2hMT0IoYSksIHJvdWdoTE9CKGIpKTtcbiAgICAgICAgICAgIGEgPSBhLmRpdmlkZShkKTtcbiAgICAgICAgICAgIGIgPSBiLmRpdmlkZShkKTtcbiAgICAgICAgICAgIGMgPSBjLm11bHRpcGx5KGQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgICAgICBhID0gYS5kaXZpZGUocm91Z2hMT0IoYSkpO1xuICAgICAgICB9XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgYiA9IGIuZGl2aWRlKHJvdWdoTE9CKGIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhLmdyZWF0ZXIoYikpIHtcbiAgICAgICAgICAgICAgICB0ID0gYjsgYiA9IGE7IGEgPSB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IGIuc3VidHJhY3QoYSk7XG4gICAgICAgIH0gd2hpbGUgKCFiLmlzWmVybygpKTtcbiAgICAgICAgcmV0dXJuIGMuaXNVbml0KCkgPyBhIDogYS5tdWx0aXBseShjKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGNtKGEsIGIpIHtcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSkuYWJzKCk7XG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpLmFicygpO1xuICAgICAgICByZXR1cm4gYS5kaXZpZGUoZ2NkKGEsIGIpKS5tdWx0aXBseShiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZEJldHdlZW4oYSwgYikge1xuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYik7XG4gICAgICAgIHZhciBsb3cgPSBtaW4oYSwgYiksIGhpZ2ggPSBtYXgoYSwgYik7XG4gICAgICAgIHZhciByYW5nZSA9IGhpZ2guc3VidHJhY3QobG93KS5hZGQoMSk7XG4gICAgICAgIGlmIChyYW5nZS5pc1NtYWxsKSByZXR1cm4gbG93LmFkZChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByYW5nZSkpO1xuICAgICAgICB2YXIgZGlnaXRzID0gdG9CYXNlKHJhbmdlLCBCQVNFKS52YWx1ZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCByZXN0cmljdGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWdpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSByZXN0cmljdGVkID8gZGlnaXRzW2ldIDogQkFTRTtcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IHRydW5jYXRlKE1hdGgucmFuZG9tKCkgKiB0b3ApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGlnaXQpO1xuICAgICAgICAgICAgaWYgKGRpZ2l0IDwgdG9wKSByZXN0cmljdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvdy5hZGQoSW50ZWdlci5mcm9tQXJyYXkocmVzdWx0LCBCQVNFLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIHZhciBwYXJzZUJhc2UgPSBmdW5jdGlvbiAodGV4dCwgYmFzZSwgYWxwaGFiZXQsIGNhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgYWxwaGFiZXQgPSBhbHBoYWJldCB8fCBERUZBVUxUX0FMUEhBQkVUO1xuICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQpO1xuICAgICAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBhbHBoYWJldCA9IGFscGhhYmV0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGFic0Jhc2UgPSBNYXRoLmFicyhiYXNlKTtcbiAgICAgICAgdmFyIGFscGhhYmV0VmFsdWVzID0ge307XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWxwaGFiZXRWYWx1ZXNbYWxwaGFiZXRbaV1dID0gaTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gdGV4dFtpXTtcbiAgICAgICAgICAgIGlmIChjID09PSBcIi1cIikgY29udGludWU7XG4gICAgICAgICAgICBpZiAoYyBpbiBhbHBoYWJldFZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChhbHBoYWJldFZhbHVlc1tjXSA+PSBhYnNCYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIjFcIiAmJiBhYnNCYXNlID09PSAxKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMgKyBcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbiBiYXNlIFwiICsgYmFzZSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmFzZSA9IHBhcnNlVmFsdWUoYmFzZSk7XG4gICAgICAgIHZhciBkaWdpdHMgPSBbXTtcbiAgICAgICAgdmFyIGlzTmVnYXRpdmUgPSB0ZXh0WzBdID09PSBcIi1cIjtcbiAgICAgICAgZm9yIChpID0gaXNOZWdhdGl2ZSA/IDEgOiAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSB0ZXh0W2ldO1xuICAgICAgICAgICAgaWYgKGMgaW4gYWxwaGFiZXRWYWx1ZXMpIGRpZ2l0cy5wdXNoKHBhcnNlVmFsdWUoYWxwaGFiZXRWYWx1ZXNbY10pKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICBkbyB7IGkrKzsgfSB3aGlsZSAodGV4dFtpXSAhPT0gXCI+XCIgJiYgaSA8IHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBkaWdpdHMucHVzaChwYXJzZVZhbHVlKHRleHQuc2xpY2Uoc3RhcnQgKyAxLCBpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYyArIFwiIGlzIG5vdCBhIHZhbGlkIGNoYXJhY3RlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VCYXNlRnJvbUFycmF5KGRpZ2l0cywgYmFzZSwgaXNOZWdhdGl2ZSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlQmFzZUZyb21BcnJheShkaWdpdHMsIGJhc2UsIGlzTmVnYXRpdmUpIHtcbiAgICAgICAgdmFyIHZhbCA9IEludGVnZXJbMF0sIHBvdyA9IEludGVnZXJbMV0sIGk7XG4gICAgICAgIGZvciAoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFsID0gdmFsLmFkZChkaWdpdHNbaV0udGltZXMocG93KSk7XG4gICAgICAgICAgICBwb3cgPSBwb3cudGltZXMoYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmVnYXRpdmUgPyB2YWwubmVnYXRlKCkgOiB2YWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KGRpZ2l0LCBhbHBoYWJldCkge1xuICAgICAgICBhbHBoYWJldCA9IGFscGhhYmV0IHx8IERFRkFVTFRfQUxQSEFCRVQ7XG4gICAgICAgIGlmIChkaWdpdCA8IGFscGhhYmV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGFscGhhYmV0W2RpZ2l0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCI8XCIgKyBkaWdpdCArIFwiPlwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQmFzZShuLCBiYXNlKSB7XG4gICAgICAgIGJhc2UgPSBiaWdJbnQoYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzWmVybygpKSB7XG4gICAgICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIHsgdmFsdWU6IFswXSwgaXNOZWdhdGl2ZTogZmFsc2UgfTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5vbnplcm8gbnVtYmVycyB0byBiYXNlIDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlLmVxdWFscygtMSkpIHtcbiAgICAgICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4geyB2YWx1ZTogWzBdLCBpc05lZ2F0aXZlOiBmYWxzZSB9O1xuICAgICAgICAgICAgaWYgKG4uaXNOZWdhdGl2ZSgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbXS5jb25jYXQuYXBwbHkoW10sIEFycmF5LmFwcGx5KG51bGwsIEFycmF5KC1uLnRvSlNOdW1iZXIoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKEFycmF5LnByb3RvdHlwZS52YWx1ZU9mLCBbMSwgMF0pXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGlzTmVnYXRpdmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGFyciA9IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KG4udG9KU051bWJlcigpIC0gMSkpXG4gICAgICAgICAgICAgICAgLm1hcChBcnJheS5wcm90b3R5cGUudmFsdWVPZiwgWzAsIDFdKTtcbiAgICAgICAgICAgIGFyci51bnNoaWZ0KFsxXSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbXS5jb25jYXQuYXBwbHkoW10sIGFyciksXG4gICAgICAgICAgICAgICAgaXNOZWdhdGl2ZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmVnID0gZmFsc2U7XG4gICAgICAgIGlmIChuLmlzTmVnYXRpdmUoKSAmJiBiYXNlLmlzUG9zaXRpdmUoKSkge1xuICAgICAgICAgICAgbmVnID0gdHJ1ZTtcbiAgICAgICAgICAgIG4gPSBuLmFicygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlLmlzVW5pdCgpKSB7XG4gICAgICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIHsgdmFsdWU6IFswXSwgaXNOZWdhdGl2ZTogZmFsc2UgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkobi50b0pTTnVtYmVyKCkpKVxuICAgICAgICAgICAgICAgICAgICAubWFwKE51bWJlci5wcm90b3R5cGUudmFsdWVPZiwgMSksXG4gICAgICAgICAgICAgICAgaXNOZWdhdGl2ZTogbmVnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgdmFyIGxlZnQgPSBuLCBkaXZtb2Q7XG4gICAgICAgIHdoaWxlIChsZWZ0LmlzTmVnYXRpdmUoKSB8fCBsZWZ0LmNvbXBhcmVBYnMoYmFzZSkgPj0gMCkge1xuICAgICAgICAgICAgZGl2bW9kID0gbGVmdC5kaXZtb2QoYmFzZSk7XG4gICAgICAgICAgICBsZWZ0ID0gZGl2bW9kLnF1b3RpZW50O1xuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gZGl2bW9kLnJlbWFpbmRlcjtcbiAgICAgICAgICAgIGlmIChkaWdpdC5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICBkaWdpdCA9IGJhc2UubWludXMoZGlnaXQpLmFicygpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0Lm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5wdXNoKGRpZ2l0LnRvSlNOdW1iZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2gobGVmdC50b0pTTnVtYmVyKCkpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogb3V0LnJldmVyc2UoKSwgaXNOZWdhdGl2ZTogbmVnIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9CYXNlU3RyaW5nKG4sIGJhc2UsIGFscGhhYmV0KSB7XG4gICAgICAgIHZhciBhcnIgPSB0b0Jhc2UobiwgYmFzZSk7XG4gICAgICAgIHJldHVybiAoYXJyLmlzTmVnYXRpdmUgPyBcIi1cIiA6IFwiXCIpICsgYXJyLnZhbHVlLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh4LCBhbHBoYWJldCk7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAocmFkaXgpIHtcbiAgICAgICAgcmV0dXJuIHRvQmFzZSh0aGlzLCByYWRpeCk7XG4gICAgfTtcblxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChyYWRpeCkge1xuICAgICAgICByZXR1cm4gdG9CYXNlKHRoaXMsIHJhZGl4KTtcbiAgICB9O1xuXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKHJhZGl4KSB7XG4gICAgICAgIHJldHVybiB0b0Jhc2UodGhpcywgcmFkaXgpO1xuICAgIH07XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChyYWRpeCwgYWxwaGFiZXQpIHtcbiAgICAgICAgaWYgKHJhZGl4ID09PSB1bmRlZmluZWQpIHJhZGl4ID0gMTA7XG4gICAgICAgIGlmIChyYWRpeCAhPT0gMTApIHJldHVybiB0b0Jhc2VTdHJpbmcodGhpcywgcmFkaXgsIGFscGhhYmV0KTtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZhbHVlLCBsID0gdi5sZW5ndGgsIHN0ciA9IFN0cmluZyh2Wy0tbF0pLCB6ZXJvcyA9IFwiMDAwMDAwMFwiLCBkaWdpdDtcbiAgICAgICAgd2hpbGUgKC0tbCA+PSAwKSB7XG4gICAgICAgICAgICBkaWdpdCA9IFN0cmluZyh2W2xdKTtcbiAgICAgICAgICAgIHN0ciArPSB6ZXJvcy5zbGljZShkaWdpdC5sZW5ndGgpICsgZGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpZ24gPSB0aGlzLnNpZ24gPyBcIi1cIiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBzaWduICsgc3RyO1xuICAgIH07XG5cbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHJhZGl4LCBhbHBoYWJldCkge1xuICAgICAgICBpZiAocmFkaXggPT09IHVuZGVmaW5lZCkgcmFkaXggPSAxMDtcbiAgICAgICAgaWYgKHJhZGl4ICE9IDEwKSByZXR1cm4gdG9CYXNlU3RyaW5nKHRoaXMsIHJhZGl4LCBhbHBoYWJldCk7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgfTtcblxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS50b0pTT04gPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0pTT04gPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTsgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMudG9TdHJpbmcoKSwgMTApO1xuICAgIH07XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9KU051bWJlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnZhbHVlT2Y7XG5cbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0pTTnVtYmVyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mO1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUudmFsdWVPZiA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUudG9KU051bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMudG9TdHJpbmcoKSwgMTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RyaW5nVmFsdWUodikge1xuICAgICAgICBpZiAoaXNQcmVjaXNlKCt2KSkge1xuICAgICAgICAgICAgdmFyIHggPSArdjtcbiAgICAgICAgICAgIGlmICh4ID09PSB0cnVuY2F0ZSh4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydHNOYXRpdmVCaWdJbnQgPyBuZXcgTmF0aXZlQmlnSW50KEJpZ0ludCh4KSkgOiBuZXcgU21hbGxJbnRlZ2VyKHgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIiArIHYpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaWduID0gdlswXSA9PT0gXCItXCI7XG4gICAgICAgIGlmIChzaWduKSB2ID0gdi5zbGljZSgxKTtcbiAgICAgICAgdmFyIHNwbGl0ID0gdi5zcGxpdCgvZS9pKTtcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDIpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlcjogXCIgKyBzcGxpdC5qb2luKFwiZVwiKSk7XG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHZhciBleHAgPSBzcGxpdFsxXTtcbiAgICAgICAgICAgIGlmIChleHBbMF0gPT09IFwiK1wiKSBleHAgPSBleHAuc2xpY2UoMSk7XG4gICAgICAgICAgICBleHAgPSArZXhwO1xuICAgICAgICAgICAgaWYgKGV4cCAhPT0gdHJ1bmNhdGUoZXhwKSB8fCAhaXNQcmVjaXNlKGV4cCkpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlcjogXCIgKyBleHAgKyBcIiBpcyBub3QgYSB2YWxpZCBleHBvbmVudC5cIik7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHNwbGl0WzBdO1xuICAgICAgICAgICAgdmFyIGRlY2ltYWxQbGFjZSA9IHRleHQuaW5kZXhPZihcIi5cIik7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBsYWNlID49IDApIHtcbiAgICAgICAgICAgICAgICBleHAgLT0gdGV4dC5sZW5ndGggLSBkZWNpbWFsUGxhY2UgLSAxO1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIGRlY2ltYWxQbGFjZSkgKyB0ZXh0LnNsaWNlKGRlY2ltYWxQbGFjZSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cCA8IDApIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbmNsdWRlIG5lZ2F0aXZlIGV4cG9uZW50IHBhcnQgZm9yIGludGVnZXJzXCIpO1xuICAgICAgICAgICAgdGV4dCArPSAobmV3IEFycmF5KGV4cCArIDEpKS5qb2luKFwiMFwiKTtcbiAgICAgICAgICAgIHYgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc1ZhbGlkID0gL14oWzAtOV1bMC05XSopJC8udGVzdCh2KTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgdik7XG4gICAgICAgIGlmIChzdXBwb3J0c05hdGl2ZUJpZ0ludCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQoQmlnSW50KHNpZ24gPyBcIi1cIiArIHYgOiB2KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSBbXSwgbWF4ID0gdi5sZW5ndGgsIGwgPSBMT0dfQkFTRSwgbWluID0gbWF4IC0gbDtcbiAgICAgICAgd2hpbGUgKG1heCA+IDApIHtcbiAgICAgICAgICAgIHIucHVzaCgrdi5zbGljZShtaW4sIG1heCkpO1xuICAgICAgICAgICAgbWluIC09IGw7XG4gICAgICAgICAgICBpZiAobWluIDwgMCkgbWluID0gMDtcbiAgICAgICAgICAgIG1heCAtPSBsO1xuICAgICAgICB9XG4gICAgICAgIHRyaW0ocik7XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihyLCBzaWduKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU51bWJlclZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzTmF0aXZlQmlnSW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludChCaWdJbnQodikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByZWNpc2UodikpIHtcbiAgICAgICAgICAgIGlmICh2ICE9PSB0cnVuY2F0ZSh2KSkgdGhyb3cgbmV3IEVycm9yKHYgKyBcIiBpcyBub3QgYW4gaW50ZWdlci5cIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmdWYWx1ZSh2LnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWJlclZhbHVlKHYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nVmFsdWUodik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgLy8gUHJlLWRlZmluZSBudW1iZXJzIGluIHJhbmdlIFstOTk5LDk5OV1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xuICAgICAgICBJbnRlZ2VyW2ldID0gcGFyc2VWYWx1ZShpKTtcbiAgICAgICAgaWYgKGkgPiAwKSBJbnRlZ2VyWy1pXSA9IHBhcnNlVmFsdWUoLWkpO1xuICAgIH1cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIEludGVnZXIub25lID0gSW50ZWdlclsxXTtcbiAgICBJbnRlZ2VyLnplcm8gPSBJbnRlZ2VyWzBdO1xuICAgIEludGVnZXIubWludXNPbmUgPSBJbnRlZ2VyWy0xXTtcbiAgICBJbnRlZ2VyLm1heCA9IG1heDtcbiAgICBJbnRlZ2VyLm1pbiA9IG1pbjtcbiAgICBJbnRlZ2VyLmdjZCA9IGdjZDtcbiAgICBJbnRlZ2VyLmxjbSA9IGxjbTtcbiAgICBJbnRlZ2VyLmlzSW5zdGFuY2UgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIEJpZ0ludGVnZXIgfHwgeCBpbnN0YW5jZW9mIFNtYWxsSW50ZWdlciB8fCB4IGluc3RhbmNlb2YgTmF0aXZlQmlnSW50OyB9O1xuICAgIEludGVnZXIucmFuZEJldHdlZW4gPSByYW5kQmV0d2VlbjtcblxuICAgIEludGVnZXIuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGRpZ2l0cywgYmFzZSwgaXNOZWdhdGl2ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VCYXNlRnJvbUFycmF5KGRpZ2l0cy5tYXAocGFyc2VWYWx1ZSksIHBhcnNlVmFsdWUoYmFzZSB8fCAxMCksIGlzTmVnYXRpdmUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSW50ZWdlcjtcbn0pKCk7XG4iLCIvKiBnbG9iYWwgYmlnSW50ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vLyBXZSByZXByZXNlbnQgYSBbWi50XSBhcyBhIGphdmFzY3JpcHQgMzJiaXQgaW50ZWdlcnMgaWYgaXQgZml0cyBvciBhcyBhIGJpZ0ludC5cblxuLy9Qcm92aWRlczogbWxfel9ub3JtYWxpemVcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel9ub3JtYWxpemUoeCl7XG4gIHZhciB5ID0geC50b0pTTnVtYmVyICgpIHwgMDtcbiAgaWYoeC5lcXVhbHMoYmlnSW50KHkpKSkgcmV0dXJuIHk7XG4gIHJldHVybiB4O1xufVxuXG4vL1Byb3ZpZGVzOiBtbF96X211bF9vdmVyZmxvd3NcbmZ1bmN0aW9uIG1sX3pfbXVsX292ZXJmbG93cyh4LHkpe1xuICB2YXIgeiA9IHgqeTtcbiAgcmV0dXJuIHogIT0gKHp8MCk7XG59XG5cbi8vZXh0ZXJuYWwgaW5pdDogdW5pdCAtPiB1bml0XG4vL1Byb3ZpZGVzOiBtbF96X2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfemFyaXRoX21hcnNoYWwsIGNhbWxfemFyaXRoX3VubWFyc2hhbCwgY2FtbF9jdXN0b21fb3BzLCBtbF96X2hhc2gsIG1sX3pfY29tcGFyZVxuZnVuY3Rpb24gbWxfel9pbml0KHVuaXQpIHtcbiAgY2FtbF9jdXN0b21fb3BzWydfeiddID1cbiAgICB7IHNlcmlhbGl6ZSA6IGNhbWxfemFyaXRoX21hcnNoYWwsXG4gICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfemFyaXRoX3VubWFyc2hhbCxcbiAgICAgIGhhc2ggOiBtbF96X2hhc2gsXG4gICAgICBjb21wYXJlIDogbWxfel9jb21wYXJlLFxuICAgIH07XG4gIHJldHVybiAwIH1cblxuLy9leHRlcm5hbCBtbF96X2luc3RhbGxfZnJhbWV0YWJsZTogdW5pdCAtPiB1bml0XG4vL1Byb3ZpZGVzOiBtbF96X2luc3RhbGxfZnJhbWV0YWJsZSBjb25zdFxuZnVuY3Rpb24gbWxfel9pbnN0YWxsX2ZyYW1ldGFibGUodW5pdCkgeyByZXR1cm4gMCB9XG5cbi8vZXh0ZXJuYWwgbmVnOiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfbmVnIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X25lZyh6MSkge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5uZWdhdGUoKSk7XG59XG5cbi8vZXh0ZXJuYWwgYWRkOiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9hZGQgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfYWRkKHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5hZGQoYmlnSW50KHoyKSkpO1xufVxuXG4vL2V4dGVybmFsIHN1YjogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfc3ViIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X3N1Yih6MSwgejIpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkuc3VidHJhY3QoYmlnSW50KHoyKSkpO1xufVxuXG4vL2V4dGVybmFsIG11bDogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfbXVsIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X211bCh6MSwgejIpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkubXVsdGlwbHkoYmlnSW50KHoyKSkpO1xufVxuXG4vL2V4dGVybmFsIGRpdjogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfZGl2XG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGUsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2Rpdih6MSwgejIpIHtcbiAgejIgPSBiaWdJbnQoejIpXG4gIGlmKHoyLmVxdWFscyhiaWdJbnQoMCkpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLmRpdmlkZShiaWdJbnQoejIpKSlcbn1cblxuLy9leHRlcm5hbCBjZGl2OiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9jZGl2XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfZGl2LCBtbF96X3NpZ24sIG1sX3pfYWRkXG5mdW5jdGlvbiBtbF96X2NkaXYoejEsIHoyKSB7XG4gIHZhciB6MV9wb3MgPSBtbF96X3NpZ24oejEpO1xuICB2YXIgejJfcG9zID0gbWxfel9zaWduKHoyKTtcbiAgaWYgKHoxX3BvcyAqIHoyX3BvcyA+IDApIC8qIE11bHRpcGxpY2F0aW9uIGlzIGxpa2UgYSBzaWdud2lzZSB4b3IgKi8ge1xuICAgIGlmICghYmlnSW50KHoxKS5tb2QoYmlnSW50KHoyKSkuZXF1YWxzKGJpZ0ludCgwKSkpIHtcbiAgICAgIHJldHVybiBtbF96X2FkZChtbF96X2Rpdih6MSwgejIpLCBiaWdJbnQoMSkpIDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1sX3pfZGl2KHoxLCB6Mik7XG59XG5cbi8vZXh0ZXJuYWwgZmRpdjogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfZmRpdlxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X2RpdiwgbWxfel9zaWduLCBtbF96X3N1YlxuZnVuY3Rpb24gbWxfel9mZGl2KHoxLCB6Mikge1xuICB2YXIgejFfcG9zID0gbWxfel9zaWduKHoxKTtcbiAgdmFyIHoyX3BvcyA9IG1sX3pfc2lnbih6Mik7XG4gIGlmICh6MV9wb3MgKiB6Ml9wb3MgPCAwKSAvKiBNdWx0aXBsaWNhdGlvbiBpcyBsaWtlIGEgc2lnbndpc2UgeG9yICovIHtcbiAgICBpZiAoIWJpZ0ludCh6MSkubW9kKGJpZ0ludCh6MikpLmVxdWFscyhiaWdJbnQoMCkpKSB7XG4gICAgICByZXR1cm4gbWxfel9zdWIobWxfel9kaXYoejEsIHoyKSwgYmlnSW50KDEpKSA7XG4gICAgfVxuICB9XG4gIHJldHVybiBtbF96X2Rpdih6MSwgejIpO1xufVxuXG4vL2V4dGVybmFsIHJlbTogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfcmVtXG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGUsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X3JlbSh6MSwgejIpIHtcbiAgejIgPSBiaWdJbnQoejIpO1xuICBpZiAoejIuZXF1YWxzKGJpZ0ludCgwKSkpIHtcbiAgICBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gIH1cbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkubW9kKHoyKSk7XG59XG5cbi8vZXh0ZXJuYWwgZGl2X3JlbTogdCAtPiB0IC0+ICh0ICogdClcbi8vUHJvdmlkZXM6IG1sX3pfZGl2X3JlbVxuLy9SZXF1aXJlczogbWxfel9kaXYsIG1sX3pfcmVtXG5mdW5jdGlvbiBtbF96X2Rpdl9yZW0oejEsIHoyKSB7XG4gIHJldHVybiBbMCwgbWxfel9kaXYoejEsejIpLCBtbF96X3JlbSh6MSwgejIpXVxufVxuLy9leHRlcm5hbCBzdWNjOiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfc3VjYyBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9zdWNjKHoxKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLm5leHQoKSk7XG59XG5cbi8vZXh0ZXJuYWwgcHJlZDogdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3ByZWQgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfcHJlZCh6MSkge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5wcmV2KCkpO1xufVxuXG4vL2V4dGVybmFsIGFiczogdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2FicyBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9hYnMoejEpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkuYWJzKCkpO1xufVxuXG4vL2V4dGVybmFsIGxvZ2FuZDogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfbG9nYW5kIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2xvZ2FuZCh6MSwgejIpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkuYW5kKGJpZ0ludCh6MikpKTtcbn1cblxuLy9leHRlcm5hbCBsb2dvcjogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfbG9nb3IgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfbG9nb3IoejEsIHoyKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLm9yKGJpZ0ludCh6MikpKTtcbn1cblxuLy9leHRlcm5hbCBsb2d4b3I6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2xvZ3hvciBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9sb2d4b3IoejEsIHoyKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLnhvcihiaWdJbnQoejIpKSk7XG59XG5cbi8vZXh0ZXJuYWwgbG9nbm90OiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfbG9nbm90IGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfbG9nbm90KHoxKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLm5vdCgpKTtcbn1cblxuLy9leHRlcm5hbCBzaGlmdF9sZWZ0OiB0IC0+IGludCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3NoaWZ0X2xlZnQgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfc2hpZnRfbGVmdCh6MSwgYW10KSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLnNoaWZ0TGVmdChhbXQpKTtcbn1cblxuLy9leHRlcm5hbCBzaGlmdF9yaWdodDogdCAtPiBpbnQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9zaGlmdF9yaWdodCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9zaGlmdF9yaWdodCh6MSwgYW10KSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLnNoaWZ0UmlnaHQoYW10KSk7XG59XG5cbi8vZXh0ZXJuYWwgc2hpZnRfcmlnaHRfdHJ1bmM6IHQgLT4gaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfc2hpZnRfcmlnaHRfdHJ1bmMgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9kaXZcbmZ1bmN0aW9uIG1sX3pfc2hpZnRfcmlnaHRfdHJ1bmMoejEsIHoyKSB7XG4gIHJldHVybiBtbF96X2RpdihiaWdJbnQoejEpLCBiaWdJbnQoMikucG93KHoyKSlcbn1cblxuLy9leHRlcm5hbCBvZl9pbnQ6IGludCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X29mX2ludCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBtbF96X29mX2ludChpKSB7XG4gIHJldHVybiBpIHwgMDtcbn1cblxuLy9leHRlcm5hbCBvZl9pbnQzMjogaW50MzIgLT4gdFxuLy9Qcm92aWRlczogbWxfel9vZl9pbnQzMiBjb25zdFxuLy9SZXF1aXJlczogbWxfel9vZl9pbnRcbmZ1bmN0aW9uIG1sX3pfb2ZfaW50MzIoaTMyKSB7XG4gIHJldHVybiBtbF96X29mX2ludChpMzIpO1xufVxuXG4vL2V4dGVybmFsIG9mX25hdGl2ZWludDogbmF0aXZlaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfb2ZfbmF0aXZlaW50IGNvbnN0XG4vL1JlcXVpcmVzOiBtbF96X29mX2ludFxuZnVuY3Rpb24gbWxfel9vZl9uYXRpdmVpbnQoeikge1xuICByZXR1cm4gbWxfel9vZl9pbnQoeilcbn1cblxuLy9leHRlcm5hbCBvZl9pbnQ2NDogaW50NjQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9vZl9pbnQ2NCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50NjRfbmVnLCBtbF96X25vcm1hbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGksY2FtbF9pbnQ2NF9oaTMyLGNhbWxfaW50NjRfbG8zMlxuZnVuY3Rpb24gbWxfel9vZl9pbnQ2NChpNjQpIHtcbiAgdmFyIG5lZyA9IGZhbHNlO1xuICBpZihjYW1sX2ludDY0X2NvbXBhcmUoaTY0LCBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSgwLDApKSA8IDApIHtcbiAgICBuZWcgPSB0cnVlO1xuICAgIGk2NCA9IGNhbWxfaW50NjRfbmVnKGk2NClcbiAgfVxuICB2YXIgbG8gPSBjYW1sX2ludDY0X2xvMzIoaTY0KSA+Pj4gMDtcbiAgdmFyIGhpID0gY2FtbF9pbnQ2NF9oaTMyKGk2NCkgPj4+IDA7XG4gIHZhciB4ID0gYmlnSW50KGxvKS5hZGQoYmlnSW50KGhpKS5zaGlmdExlZnQoMzIpKTtcbiAgaWYobmVnKSB7IHggPSB4Lm5lZ2F0ZSgpIH07XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZSh4KVxufVxuXG4vL2V4dGVybmFsIG9mX2Zsb2F0OiBmbG9hdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X29mX2Zsb2F0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfbmFtZWRfdmFsdWUsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X29mX2Zsb2F0KGYxKSB7XG4gIGlmKGYxID09IEluZmluaXR5IHx8IGYxID09IC1JbmZpbml0eSB8fCBmMSAhPSBmMSlcbiAgICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfbmFtZWRfdmFsdWUoXCJtbF96X292ZXJmbG93XCIpKTtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludChmMTwwP01hdGguY2VpbChmMSk6TWF0aC5mbG9vcihmMSkpKTtcbn1cblxuLy9leHRlcm5hbCB0b19pbnQ6IHQgLT4gaW50XG4vL1Byb3ZpZGVzOiBtbF96X3RvX2ludFxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX25hbWVkX3ZhbHVlXG5mdW5jdGlvbiBtbF96X3RvX2ludCh6MSkge1xuICBpZiAoejEgPT0gKHoxIHwgMCkpIHJldHVybiB6MSB8IDA7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xufVxuXG4vL2V4dGVybmFsIHRvX2ludDMyOiB0IC0+IGludDMyXG4vL1Byb3ZpZGVzOiBtbF96X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBtbF96X3RvX2ludFxuZnVuY3Rpb24gbWxfel90b19pbnQzMih6MSkgeyByZXR1cm4gbWxfel90b19pbnQoejEpIH1cblxuLy9leHRlcm5hbCB0b19pbnQ2NDogdCAtPiBpbnQ2NFxuLy9Qcm92aWRlczogbWxfel90b19pbnQ2NFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X2ZpdHNfaW50NjQsIGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpXG5mdW5jdGlvbiBtbF96X3RvX2ludDY0KHoxKSB7XG4gIHoxID0gYmlnSW50KHoxKVxuICBpZighbWxfel9maXRzX2ludDY0KHoxKSkge1xuICAgIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xuICB9XG4gIHZhciBtYXNrID0gYmlnSW50KDB4ZmZmZmZmZmYpXG4gIHZhciBsbyA9IHoxLmFuZChtYXNrKS50b0pTTnVtYmVyKCk7XG4gIHZhciBoaSA9IHoxLnNoaWZ0UmlnaHQoMzIpLmFuZChtYXNrKS50b0pTTnVtYmVyKCk7XG4gIHZhciB4ID0gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobG8sIGhpKTtcbiAgcmV0dXJuIHg7XG59XG5cbi8vZXh0ZXJuYWwgdGVzdGJpdDogdCAtPiBib29sXG4vL1Byb3ZpZGVzOiBtbF96X3Rlc3RiaXRcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel90ZXN0Yml0KHoscG9zKXtcbiAgeiA9IGJpZ0ludCh6KTtcbiAgcmV0dXJuICh6LnNoaWZ0UmlnaHQocG9zKS5hbmQoYmlnSW50KDEpKS50b0pTTnVtYmVyKCkpfDA7XG59XG5cbi8vZXh0ZXJuYWwgdG9fbmF0aXZlaW50OiB0IC0+IG5hdGl2ZWludFxuLy9Qcm92aWRlczogbWxfel90b19uYXRpdmVpbnRcbi8vUmVxdWlyZXM6IG1sX3pfdG9faW50XG5mdW5jdGlvbiBtbF96X3RvX25hdGl2ZWludCh6MSkgeyByZXR1cm4gbWxfel90b19pbnQoejEpIH1cblxuLy9leHRlcm5hbCBmb3JtYXQ6IHN0cmluZyAtPiB0IC0+IHN0cmluZ1xuLy9Qcm92aWRlczogbWxfel9mb3JtYXQgXG4vL1JlcXVpcmVzOiBiaWdJbnRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfZmFpbHdpdGgsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2Zvcm1hdChmbXQsIHoxKSB7XG4gIHoxID0gYmlnSW50KHoxKTtcbiAgdmFyIGZtdCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL1phcml0aC9ibG9iL2QwNTU1ZDQ1MWNlMjk1YzQ0OTdmMjRhOGQ5OTkzZjhkZDIzMDk3ZGYvei5tbGlwI0wyOTdcbiAgdmFyIGJhc2UgPSAxMDtcbiAgdmFyIGNhcyA9IDA7XG4gIHZhciB3aWR0aCA9IDA7XG4gIHZhciBhbHQgPSAwO1xuICB2YXIgZGlyID0gMDtcbiAgdmFyIHNpZ24gPSAnJztcbiAgdmFyIHBhZCA9ICcgJztcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBwcmVmaXg9XCJcIjtcbiAgd2hpbGUoZm10W2lkeF0gPT0gJyUnKSBpZHgrKztcbiAgZm9yKDs7IGlkeCsrKSB7XG4gICAgaWYoZm10W2lkeF0gPT0gJyMnKSBhbHQgPSAxO1xuICAgIGVsc2UgaWYgKGZtdFtpZHhdID09ICcwJykgcGFkID0gJzAnO1xuICAgIGVsc2UgaWYgKGZtdFtpZHhdID09ICctJykgZGlyID0gMTtcbiAgICBlbHNlIGlmIChmbXRbaWR4XSA9PSAnICcgfHwgZm10W2lkeF0gPT0gJysnKSBzaWduID0gZm10W2lkeF07XG4gICAgZWxzZSBicmVhaztcbiAgfVxuICBpZih6MS5sdChiaWdJbnQoMCkpKXtzaWduID0gJy0nO3oxID0gejEubmVnYXRlKCl9O1xuICBmb3IoO2ZtdFtpZHhdPj0nMCcgJiYgZm10W2lkeF0gPD0nOSc7aWR4KyspXG4gICAgd2lkdGg9MTAqd2lkdGggKyAoK2ZtdFtpZHhdKTtcbiAgc3dpdGNoKGZtdFtpZHhdKXtcbiAgY2FzZSAnaSc6IGNhc2UgJ2QnOiBjYXNlICd1JzogYnJlYWs7XG4gIGNhc2UgJ2InOiBiYXNlID0gMjsgaWYoYWx0KSBwcmVmaXggPSBcIjBiXCI7IGJyZWFrO1xuICBjYXNlICdvJzogYmFzZSA9IDg7IGlmKGFsdCkgcHJlZml4ID0gXCIwb1wiOyBicmVhaztcbiAgY2FzZSAneCc6IGJhc2UgPSAxNjsgaWYoYWx0KSBwcmVmaXggPSBcIjB4XCI7IGJyZWFrO1xuICBjYXNlICdYJzogYmFzZSA9IDE2OyBpZihhbHQpIHByZWZpeCA9IFwiMFhcIjsgY2FzID0gMTsgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9mYWlsd2l0aChcIlVuc3VwcG9ydGVkIGZvcm1hdCAnXCIgKyBmbXQgKyBcIidcIik7XG4gIH1cbiAgaWYgKGRpcikgcGFkID0gJyAnO1xuICB2YXIgcmVzID0gejEudG9TdHJpbmcoYmFzZSk7XG4gIGlmIChjYXMgPT09IDEpIHtcbiAgICByZXMgPSByZXMudG9VcHBlckNhc2UoKTtcbiAgfVxuICB2YXIgc2l6ZSA9IHJlcy5sZW5ndGg7XG4gIGlmIChwYWQgPT0gJyAnKSB7XG4gICAgaWYoZGlyKSB7XG4gICAgICByZXMgPSBzaWduICsgcHJlZml4ICsgcmVzO1xuICAgICAgZm9yKDtyZXMubGVuZ3RoPHdpZHRoOykgcmVzID0gcmVzICsgcGFkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBzaWduICsgcHJlZml4ICsgcmVzO1xuICAgICAgZm9yKDtyZXMubGVuZ3RoPHdpZHRoOykgcmVzID0gcGFkICsgcmVzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcHJlID0gc2lnbiArIHByZWZpeDtcbiAgICBmb3IoO3Jlcy5sZW5ndGgrcHJlLmxlbmd0aDx3aWR0aDspIHJlcyA9IHBhZCArIHJlcztcbiAgICByZXMgPSBwcmUgKyByZXM7XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocmVzKTtcbn1cblxuLy9Qcm92aWRlczoganNvb196X29mX2pzX3N0cmluZ19iYXNlXG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIGpzb29fel9vZl9qc19zdHJpbmdfYmFzZShiYXNlLCBzKSB7XG4gIGlmIChiYXNlID09IDApIHsgLy8gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL1phcml0aC9ibG9iL2I4ZGJhZjQ4YTc5MjcwNjFkZjY5OWFkN2NlNjQyYmI0ZjFmZTUzMDgvY2FtbF96LmMjTDU5OFxuICAgIGJhc2UgPSAxMDtcbiAgICB2YXIgcCA9IDA7XG4gICAgdmFyIHNpZ24gPSAxO1xuICAgIGlmKHNbcF0gPT0gJy0nKSB7IHNpZ24gPSAtMTsgcCsrIH1cbiAgICBlbHNlIGlmIChzW3BdID09ICcrJykgeyBwKysgfVxuICAgIGlmIChzW3BdID09ICcwJykge1xuICAgICAgcCArKztcbiAgICAgIGlmIChzLmxlbmd0aCA9PSBwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJjID0gc1twXTtcbiAgICAgICAgaWYgKGJjID09ICdvJyB8fCBiYyA9PSAnTycpIHtcbiAgICAgICAgICBiYXNlID0gODtcbiAgICAgICAgfSBlbHNlIGlmIChiYyA9PSAneCcgfHwgYmMgPT0gJ1gnKSB7XG4gICAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICB9IGVsc2UgaWYgKGJjID09ICdiJyB8fCBiYyA9PSAnQicpIHtcbiAgICAgICAgICBiYXNlID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZihiYXNlICE9IDEwKSB7XG4gICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKHArMSk7XG4gICAgICAgICAgaWYoc2lnbiA9PSAtMSkgcyA9IFwiLVwiICsgcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL3JlbW92ZSBsZWFkaW5nICcrJ1xuICBpZiAoc1swXSA9PSAnKycpIHMgPSBzLnN1YnN0cmluZygxKTtcbiAgLy9yZW1vdmUgbGVhZGluZyAnMCdzXG4gIHMgPSBzLnJlcGxhY2UoL14wKy8sICcnKTtcbiAgLy9ub3JtYWxpemUgXCJlbXB0eVwiIG51bWJlcnNcbiAgaWYocyA9PSAnLScgfHwgcyA9PSAnJykgcyA9ICcwJztcblxuICBmdW5jdGlvbiBkaWdpdChjb2RlKXtcbiAgICBpZihjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHJldHVybiBjb2RlIC0gNDg7XG4gICAgaWYoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEwMikgcmV0dXJuIGNvZGUgLSA5NyArIDEwO1xuICAgIGlmKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA3MCkgcmV0dXJuIGNvZGUgLSA2NSArIDEwO1xuICB9XG4gIHZhciBpID0gMDtcbiAgaWYoc1tpXSA9PSAnLScpIGkrKztcbiAgZm9yKCA7IGkgPCBzLmxlbmd0aCA7IGkrKyl7XG4gICAgdmFyIGMgPSBkaWdpdChzLmNoYXJDb2RlQXQoaSkpO1xuICAgIGlmKGMgPT0gdW5kZWZpbmVkIHx8IGMgPj0gYmFzZSlcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloub2Zfc3Vic3RyaW5nX2Jhc2U6IGludmFsaWQgZGlnaXRcIik7XG4gIH1cbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludChzLCBiYXNlKSk7XG4gIFxufVxuXG4vL2V4dGVybmFsIG9mX3N1YnN0cmluZ19iYXNlOiBpbnQgLT4gc3RyaW5nIC0+IHBvczppbnQgLT4gbGVuOmludCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X29mX3N1YnN0cmluZ19iYXNlXG4vL1JlcXVpcmVzOiBqc29vX3pfb2ZfanNfc3RyaW5nX2Jhc2UsIGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBtbF96X29mX3N1YnN0cmluZ19iYXNlKGJhc2UsIHMsIHBvcywgbGVuKSB7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpO1xuICBpZihwb3MgIT0gMCB8fCBsZW4gIT0gcy5sZW5ndGgpIHtcbiAgICBpZiAocy5sZW5ndGggLSBwb3MgPCBsZW4pIHtcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloub2Zfc3Vic3RyaW5nX2Jhc2U6IGludmFsaWQgb2Zmc2V0IG9yIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgcyA9IHMuc2xpY2UocG9zLHBvcytsZW4pO1xuICB9XG4gIHJldHVybiBqc29vX3pfb2ZfanNfc3RyaW5nX2Jhc2UoYmFzZSwgcyk7XG59XG5cbi8vZXh0ZXJuYWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9jb21wYXJlIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnRcbmZ1bmN0aW9uIG1sX3pfY29tcGFyZSh6MSwgejIpIHtcbiAgcmV0dXJuIGJpZ0ludCh6MSkuY29tcGFyZShiaWdJbnQoejIpKTtcbn1cblxuLy9leHRlcm5hbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfZXF1YWwgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel9lcXVhbCh6MSwgejIpIHtcbiAgcmV0dXJuIGJpZ0ludCh6MSkuZXF1YWxzKGJpZ0ludCh6MikpO1xufVxuXG4vL2V4dGVybmFsIHNpZ246IHQgLT4gaW50XG4vL1Byb3ZpZGVzOiBtbF96X3NpZ24gY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel9zaWduKHoxKSB7XG4gIHJldHVybiBiaWdJbnQoejEpLmNvbXBhcmUoYmlnSW50Lnplcm8pO1xufVxuXG4vL2V4dGVybmFsIGdjZDogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfZ2NkXG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2djZCh6MSwgejIpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludC5nY2QoYmlnSW50KHoxKSwgYmlnSW50KHoyKSkuYWJzKCkpO1xufVxuXG4vL2V4dGVybmFsIG51bWJpdHM6IHQgLT4gaW50XG4vL1Byb3ZpZGVzOiBtbF96X251bWJpdHMgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel9udW1iaXRzKHoxKSB7XG4gIHoxID0gYmlnSW50KHoxKS5hYnMoKTtcbiAgdmFyIG4gPSAwO1xuICB2YXIgdXBwZXJCb3VuZCA9IGJpZ0ludC5vbmU7XG4gIHdoaWxlICh1cHBlckJvdW5kLmxlcSh6MSkpIHtcbiAgICBuICs9IDE7XG4gICAgdXBwZXJCb3VuZCA9IHVwcGVyQm91bmQubXVsdGlwbHkoMik7XG4gIH1cbiAgcmV0dXJuIG47IC8vIDJee24tMX0gPD0gfHh8IDwgMl5uXG59XG5cbi8vZXh0ZXJuYWwgZml0c19pbnQ6IHQgLT4gYm9vbFxuLy9Qcm92aWRlczogbWxfel9maXRzX2ludCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBtbF96X2ZpdHNfaW50KHoxKSB7XG4gIGlmKHoxID09ICh6MSB8IDApKSByZXR1cm4gMTtcbiAgZWxzZSByZXR1cm4gMDtcbn1cblxuLy9leHRlcm5hbCBmaXRzX2ludDMyOiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfZml0c19pbnQzMlxuLy9SZXF1aXJlczogbWxfel9maXRzX2ludFxuZnVuY3Rpb24gbWxfel9maXRzX2ludDMyKHoxKSB7XG4gIHJldHVybiBtbF96X2ZpdHNfaW50KHoxKTtcbn1cblxuLy9leHRlcm5hbCBmaXRzX2ludDY0OiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfZml0c19pbnQ2NFxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBtbF96X2ZpdHNfaW50NjQoejEpIHtcbiAgejEgPSBiaWdJbnQoejEpXG4gIGlmICh6MS5jb21wYXJlKGJpZ0ludChcIjkyMjMzNzIwMzY4NTQ3NzU4MDdcIikpIDw9IDAgJiYgejEuY29tcGFyZShiaWdJbnQoXCItOTIyMzM3MjAzNjg1NDc3NTgwOFwiKSkgPj0gMClcbiAgICByZXR1cm4gMVxuICBlbHNlXG4gICAgcmV0dXJuIDBcbn1cblxuLy9leHRlcm5hbCBmaXRzX25hdGl2ZWludDogdCAtPiBib29sXG4vL1Byb3ZpZGVzOiBtbF96X2ZpdHNfbmF0aXZlaW50XG4vL1JlcXVpcmVzOiBtbF96X2ZpdHNfaW50XG5mdW5jdGlvbiBtbF96X2ZpdHNfbmF0aXZlaW50KHoxKSB7XG4gIHJldHVybiBtbF96X2ZpdHNfaW50KHoxKTtcbn1cblxuLy9leHRlcm5hbCBwb3dtOiB0IC0+IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3Bvd21cbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemUsIG1sX3pfaW52ZXJ0LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBtbF96X3Bvd20oejEsIHoyLCB6Mykge1xuICB2YXIgemVybyA9IGJpZ0ludCgwKTtcbiAgdmFyIG9uZSA9IGJpZ0ludCgxKTtcbiAgejEgPSBiaWdJbnQoejEpO1xuICB6MiA9IGJpZ0ludCh6Mik7XG4gIHozID0gYmlnSW50KHozKTtcbiAgaWYoejMuZXF1YWxzKHplcm8pKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gIGlmKHozLmFicygpLmVxdWFscyhvbmUpKSByZXR1cm4gMDtcbiAgaWYoejIuZXF1YWxzKHplcm8pKSByZXR1cm4gMTtcbiAgaWYoejIubHQoMCkpIHtcbiAgICB2YXIgaW52ID0gYmlnSW50KG1sX3pfaW52ZXJ0KHoxLCB6MykpO1xuICAgIHZhciByID0gaW52Lm1vZFBvdyh6Mi5uZWdhdGUoKSwgejMpO1xuICAgIGlmKHIubHQoemVybykpIHIgPSByLmFkZCh6My5hYnMoKSk7XG4gICAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHIpO1xuICB9IGVsc2Uge1xuICAgIHZhciByID0gYmlnSW50KHoxKS5tb2RQb3coejIsIHozKTtcbiAgICBpZihyLmx0KHplcm8pKSByID0gci5hZGQoejMuYWJzKCkpO1xuICAgIHJldHVybiBtbF96X25vcm1hbGl6ZShyKTtcbiAgfVxufVxuXG4vL2V4dGVybmFsIHBvd246IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3Bvd1xuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX2ZhaWx3aXRoLCBtbF96X25vcm1hbGl6ZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF96X3Bvdyh6MSwgaTEpIHtcbiAgaTEgPSBiaWdJbnQoaTEpO1xuICBpZiAoaTEubHQoYmlnSW50KDApKSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloucG93OiBleHBvbmVudCBtdXN0IGJlIG5vbm5lZ2F0aXZlXCIpO1xuICB9XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLnBvdyhpMSkpO1xufVxuXG4vL2V4dGVybmFsIGhhc2g6IHQgLT4gaW50XG4vL1Byb3ZpZGVzOiBtbF96X2hhc2ggY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIG1sX3pfaGFzaCh6MSkge1xuICB2YXIgYSA9IGJpZ0ludCh6MSkudG9BcnJheShNYXRoLnBvdygyLCAzMikpO1xuICB2YXIgYWNjID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgYWNjID0gY2FtbF9oYXNoX21peF9pbnQoYWNjLCBhLnZhbHVlW2ldKTtcbiAgfVxuICBpZihhLnZhbHVlLmxlbmd0aCAlIDIgIT0gMCkge1xuICAgIGFjYyA9IGNhbWxfaGFzaF9taXhfaW50KGFjYywgMCk7XG4gIH1cbiAgaWYoYS5pc05lZ2F0aXZlKXtcbiAgICBhY2MgPSBhY2MgKyAxXG4gIH1cbiAgcmV0dXJuIGFjYyB8IDBcbn1cblxuLy9leHRlcm5hbCB0b19iaXRzOiB0IC0+IHN0cmluZ1xuLy9Qcm92aWRlczogbWxfel90b19iaXRzIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX3N0cl9yZXBlYXQsIGJpZ0ludFxuZnVuY3Rpb24gbWxfel90b19iaXRzKHoxKSB7XG4gIHoxID0gYmlnSW50KHoxKS5hYnMoKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHdoaWxlKCF6MS5lcXVhbHMoYmlnSW50KDApKSl7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoejEubW9kKGJpZ0ludCgyNTYpKSk7XG4gICAgejEgPSB6MS5kaXZpZGUoYmlnSW50KDI1NikpO1xuICB9XG4gIHdoaWxlKHJlcy5sZW5ndGggJSA0ICE9IDApe1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDApO1xuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHJlcyk7XG59XG5cbi8vZXh0ZXJuYWwgb2ZfYml0czogc3RyaW5nIC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfb2ZfYml0cyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X29mX2JpdHMoejEpIHtcbiAgdmFyIHIgPSBiaWdJbnQuemVyb1xuICB2YXIgYmFzZTEgPSBiaWdJbnQoMjU2KTtcbiAgdmFyIGJhc2UgPSBiaWdJbnQub25lO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHoxKTsgaSsrKXtcbiAgICB2YXIgZCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQoejEsaSk7XG4gICAgciA9IGJpZ0ludChiYXNlKS5tdWx0aXBseShkKS5hZGQocik7XG4gICAgYmFzZSA9IGJpZ0ludChiYXNlKS5tdWx0aXBseShiYXNlMSk7XG4gIH1cbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHIpO1xufVxuXG4vL2V4dGVybmFsIHBvd21fc2VjOiB0IC0+IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3Bvd21fc2VjXG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfZmFpbHdpdGgsIG1sX3pfcG93bSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF96X3Bvd21fc2VjKHoxLCB6MiwgejMpIHtcbiAgejMgPSBiaWdJbnQoejMpLmFicygpO1xuICAvLyBwb3dtX3NlYyByZXF1aXJlcyB0aGF0IHRoZSBleHBvbmVudCBiZSBwb3NpdGl2ZVxuICB2YXIgb25lID0gYmlnSW50KDEpO1xuICBpZiAoYmlnSW50KHoyKS5sdChvbmUpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5wb3dtX3NlYzogZXhwb25lbnQgbXVzdCBiZSBwb3NpdGl2ZVwiKTtcbiAgfVxuICBpZiAoIWJpZ0ludCh6MykuYW5kKG9uZSkuZXF1YWxzKG9uZSkpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJaLnBvd21fc2VjOiBtb2R1bHVzIG11c3QgYmUgb2RkXCIpO1xuICB9XG4gIHJldHVybiBtbF96X3Bvd20oejEsIHoyLCB6Mylcbn1cblxuLy9leHRlcm5hbCByb290OiB0IC0+IGludCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3Jvb3Rcbi8vUmVxdWlyZXM6IG1sX3pfcG93LCAgYmlnSW50LCBtbF96X25vcm1hbGl6ZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF96X3Jvb3QoeiwgaSkge1xuICB2YXIgemVybyA9IGJpZ0ludCgwKTtcbiAgdmFyIG9uZSA9IGJpZ0ludCgxKTtcbiAgeiA9IGJpZ0ludCh6KTtcblxuICBpZiAoaSAlIDIgPT09IDAgJiYgei5sdCh6ZXJvKSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloucm9vdDogZXZlbiByb290IG9mIGEgbmVnYXRpdmUgbnVtYmVyXCIpO1xuICB9XG5cbiAgaWYgKHouZXF1YWxzKHplcm8pIHx8IHouZXF1YWxzKG9uZSkpIHtcbiAgICByZXR1cm4gbWxfel9ub3JtYWxpemUoeik7XG4gIH1cblxuICB2YXIgc3RhcnQgPSB6ZXJvO1xuICB2YXIgZW5kID0gejtcbiAgdmFyIGFucyA9IG51bGw7XG5cbiAgdmFyIHR3byA9IGJpZ0ludCgyKTtcblxuICB3aGlsZSAoc3RhcnQubGVxKGVuZCkpXG4gIHtcbiAgICB2YXIgbWlkID0gc3RhcnQuYWRkKGVuZCkuZGl2aWRlKHR3byk7XG4gICAgdmFyIHBvID0gbWlkLnBvdyhpKTtcbiAgICBpZiAocG8uZXF1YWxzKHopKSB7XG4gICAgICByZXR1cm4gbWxfel9ub3JtYWxpemUobWlkKTtcbiAgICB9IGVsc2UgaWYgKHBvLmx0KHopKSB7XG4gICAgICBzdGFydCA9IG1pZC5uZXh0KCk7XG4gICAgICBhbnMgPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IG1pZC5wcmV2KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShhbnMpO1xufVxuXG4vL2V4dGVybmFsIGludmVydDogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfaW52ZXJ0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGUsIG1sX3pfZ2NkZXh0X2ludGVybiwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfaW52ZXJ0KGEsIG4pIHtcbiAgLy8gQmVjYXVzZSBbYS5tb2RJbnYobildIHByb2R1Y2VzIGRpZmZlcmVudCByZXN1bHRzIGZvciBlZGdlIGNhc2VzLFxuICAvLyB3ZSB3cm90ZSBvdXIgb3duIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGdjZGV4dF9pbnRlcm4uXG4gIGEgPSBiaWdJbnQoYSk7XG4gIG4gPSBiaWdJbnQobik7XG4gIHZhciB6ZXJvID0gYmlnSW50KDApO1xuICB2YXIgb25lID0gYmlnSW50KDEpO1xuICBpZihuLmFicygpLmVxdWFscyhvbmUpKVxuICAgIHJldHVybiAwO1xuICBpZiAobi5lcXVhbHMoemVybykgJiYgYS5hYnMoKS5lcXVhbHMob25lKSkge1xuICAgIHJldHVybiBhO1xuICB9XG4gIGlmIChuLmVxdWFscyh6ZXJvKSB8fCBhLmVxdWFscyh6ZXJvKSkge1xuICAgIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgfVxuICB2YXIgeCA9IG1sX3pfZ2NkZXh0X2ludGVybihhLCBuKTtcbiAgdmFyIHIgPSBiaWdJbnQoeFsyXSk7XG4gIHZhciB0bXAgPSBiaWdJbnQoYSkubXVsdGlwbHkocikubW9kKG4pO1xuICBpZih0bXAubHQoemVybykpIHRtcCA9IHRtcC5hZGQobi5hYnMoKSk7XG4gIGlmKHIubHQoemVybykpIHIgPSByLmFkZChuLmFicygpKTtcbiAgaWYodG1wLmVxdWFscyhvbmUpKSB7XG4gICAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHIpO1xuICB9XG4gIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbn1cblxuLy9leHRlcm5hbCBwZXJmZWN0X3Bvd2VyOiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfcGVyZmVjdF9wb3dlclxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX2ZhaWx3aXRoLCBtbF96X251bWJpdHMsIG1sX3pfcm9vdCwgbWxfel9wb3dcbmZ1bmN0aW9uIG1sX3pfcGVyZmVjdF9wb3dlcih6KSB7XG4gIC8vIFJldHVybiB0cnVlIGlmIG9wIGlzIGEgcGVyZmVjdCBwb3dlciwgaS5lLiwgaWYgdGhlcmUgZXhpc3QgaW50ZWdlcnMgYSBhbmRcbiAgLy8gYiwgd2l0aCBiID4gMSwgc3VjaCB0aGF0IG9wID0gYV5iLlxuICAvLyBPdGhlcndpc2UgZmFsc2UuXG4gIHogPSBiaWdJbnQoeik7XG4gIHZhciB6ZXJvID0gYmlnSW50KDApO1xuICB2YXIgb25lID0gYmlnSW50KDEpO1xuXG4gIGlmICh6LmVxdWFscyh6ZXJvKSB8fCB6LmVxdWFscyhvbmUpIHx8IHouZXF1YWxzKG9uZS5uZWdhdGUoKSkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICB2YXIgbG9nMnogPSBtbF96X251bWJpdHMoei5hYnMoKSk7XG4gIGZvciAodmFyIGIgPSAyOyBiIDw9IGxvZzJ6OyBiKyspIHtcbiAgICBpZih6Lmx0KHplcm8pICYmIGIgJSAyID09IDApIGNvbnRpbnVlO1xuICAgIHZhciB6cCA9IHouYWJzKCk7XG4gICAgdmFyIHAgPSBiaWdJbnQobWxfel9yb290KHpwLCBiKSk7XG4gICAgaWYoei5sdCh6ZXJvKSkgcCA9IHAubmVnYXRlKCk7XG4gICAgdmFyIHIgPSBiaWdJbnQobWxfel9wb3cocCwgYikpO1xuICAgIGlmICh6LmVxdWFscyhyKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL2V4dGVybmFsIHBlcmZlY3Rfc3F1YXJlOiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfcGVyZmVjdF9zcXVhcmVcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9yb290XG5mdW5jdGlvbiBtbF96X3BlcmZlY3Rfc3F1YXJlKHopIHtcbiAgeiA9IGJpZ0ludCh6KTtcbiAgaWYgKHoubHQoYmlnSW50KDApKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciByb290ID0gYmlnSW50KG1sX3pfcm9vdCh6LCAyKSk7XG4gIGlmIChyb290Lm11bHRpcGx5KHJvb3QpLmVxKHopKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIDBcbiAgfTtcbn1cblxuLy9leHRlcm5hbCBwcm9iYWJfcHJpbWU6IHQgLT4gaW50IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9wcm9iYWJfcHJpbWUgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel9wcm9iYWJfcHJpbWUoeiwgaSkge1xuICBpZiAoYmlnSW50KHopLmlzUHJvYmFibGVQcmltZShpKSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8vZXh0ZXJuYWwgbmV4dHByaW1lOiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfbmV4dHByaW1lIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X25leHRwcmltZSh6MSkge1xuICAvLyBJbnRlcmVzdGluZ2x5LCB0aGUgemFyaXRoIG5leHRfcHJpbWUgb25seSByZXR1cm5zIFxuICAvLyBwcm9iYWJhbGlzdGljIHByaW1lcy4gIFdlIGRvIHRoZSBzYW1lLCB3aXRoIHRoZSBcbiAgLy8gc2FtZSBwcm9iYWJsaXN0aWMgcGFyYW1ldGVyIG9mIDI1LlxuICAvLyBodHRwczovL2Zvc3NpZXMub3JnL2RveC9nbXAtNi4xLjIvbXB6XzJuZXh0cHJpbWVfOGNfc291cmNlLmh0bWxcbiAgXG4gIHoxID0gYmlnSW50KHoxKVxuICB2YXIgb25lID0gYmlnSW50KDEpO1xuICB2YXIgdHdvID0gYmlnSW50KDIpO1xuXG4gIGlmICh6MS5sdChvbmUpIHx8IHoxLmVxdWFscyhvbmUpKSB7XG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICBpZiAoejEuYW5kKG9uZSkuZXF1YWxzKG9uZSkpIHtcbiAgICB6MSA9IHoxLmFkZCh0d28pO1xuICB9IGVsc2Uge1xuICAgIHoxID0gejEuYWRkKG9uZSk7XG4gIH1cblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICh6MS5pc1Byb2JhYmxlUHJpbWUoMjUpKSB7XG4gICAgICByZXR1cm4gbWxfel9ub3JtYWxpemUoejEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB6MSA9IHoxLmFkZCh0d28pXG4gICAgfVxuICB9XG59XG5cbi8vZXh0ZXJuYWwgZXh0cmFjdDogdCAtPiBpbnQgLT4gaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfZXh0cmFjdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9leHRyYWN0KHoxLCBwb3MsIGxlbikge1xuICB6MSA9IGJpZ0ludCh6MSk7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZSh6MS5zaGlmdFJpZ2h0KHBvcykuYW5kKGJpZ0ludCgyKS5wb3cobGVuKS5zdWJ0cmFjdCgxKSkpO1xufVxuXG4vL2V4dGVybmFsIGdjZGV4dF9pbnRlcm46IHQgLT4gdCAtPiAodCAqIHQgKiBib29sKVxuLy9Qcm92aWRlczogbWxfel9nY2RleHRfaW50ZXJuXG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGUsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2djZGV4dF9pbnRlcm4oejEsIHoyKSB7XG4gIHoxID0gYmlnSW50KHoxKTtcbiAgejIgPSBiaWdJbnQoejIpO1xuICB2YXIgZ2NkID0gYmlnSW50LmdjZCh6MSx6Mik7XG4gIHZhciBhID0gejE7XG4gIHZhciBiID0gejI7XG4gIHZhciB4ID0gYmlnSW50KDApO1xuICB2YXIgbGFzdHggPSBiaWdJbnQoMSk7XG4gIHZhciB5ID0gYmlnSW50KDEpO1xuICB2YXIgbGFzdHkgPSBiaWdJbnQoMSk7XG4gIHZhciBxLCB0LCByO1xuICBpZih6MS5lcXVhbHMoYmlnSW50KDApKSkge1xuICAgIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgfVxuICB3aGlsZSghYi5lcXVhbHMoYmlnSW50KDApKSkge1xuICAgIHEgPSBhLmRpdmlkZShiKTtcbiAgICByID0gYS5zdWJ0cmFjdChxLm11bHRpcGx5KGIpKTtcbiAgICB0ID0geDtcbiAgICB4ID0gbGFzdHguc3VidHJhY3QocS5tdWx0aXBseSh4KSk7XG4gICAgbGFzdHggPSB0O1xuICAgIHQgPSB5O1xuICAgIHkgPSBsYXN0eS5zdWJ0cmFjdChxLm11bHRpcGx5KHkpKTtcbiAgICBsYXN0eSA9IHQ7XG4gICAgYSA9IGI7XG4gICAgYiA9IHI7XG4gIH1cbiAgaWYoYS5sdChiaWdJbnQoMCkpKVxuICAgIHJldHVybiBbMCxtbF96X25vcm1hbGl6ZShhLm5lZ2F0ZSgpKSxtbF96X25vcm1hbGl6ZShsYXN0eC5uZWdhdGUoKSksMV1cbiAgZWxzZVxuICAgIHJldHVybiBbMCxtbF96X25vcm1hbGl6ZShhKSxtbF96X25vcm1hbGl6ZShsYXN0eCksMV1cbn1cblxuLy9leHRlcm5hbCBzcXJ0OiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfc3FydFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X3Jvb3QsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfel9zcXJ0KHoxKSB7XG4gIHZhciB6ID0gYmlnSW50KHoxKTtcbiAgdmFyIHplcm8gPSBiaWdJbnQoMCk7XG4gIGlmICh6Lmx0KHplcm8pKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5zcXJ0OiBzcXVhcmUgcm9vdCBvZiBhIG5lZ2F0aXZlIG51bWJlclwiKTtcbiAgfVxuICByZXR1cm4gbWxfel9yb290KHosIDIpO1xufVxuXG4vL2V4dGVybmFsIHNxcnRfcmVtOiB0IC0+ICh0ICogdClcbi8vUHJvdmlkZXM6IG1sX3pfc3FydF9yZW1cbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9yb290LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X3NxcnRfcmVtKHopIHtcbiAgeiA9IGJpZ0ludCh6KTtcbiAgdmFyIHplcm8gPSBiaWdJbnQoMCk7XG4gIGlmICh6Lmx0KHplcm8pKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5zcXJ0X3JlbTogc3F1YXJlIHJvb3Qgb2YgYSBuZWdhdGl2ZSBudW1iZXJcIik7XG4gIH1cbiAgdmFyIHJvb3QgPSBiaWdJbnQobWxfel9yb290KHosIDIpKTtcbiAgdmFyIG11bCA9IHJvb3QubXVsdGlwbHkocm9vdCk7XG4gIHZhciBkaWZmID0gei5zdWJ0cmFjdChtdWwpO1xuICByZXR1cm4gWzAsIG1sX3pfbm9ybWFsaXplKHJvb3QpLCBtbF96X25vcm1hbGl6ZShkaWZmKV1cbn1cblxuLy9leHRlcm5hbCB0cmFpbGluZ196ZXJvczogdCAtPiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfdHJhaWxpbmdfemVyb3MgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel90cmFpbGluZ196ZXJvcyh6KSB7XG4gIHogPSBiaWdJbnQoeikuYWJzKCk7XG4gIHZhciB6ZXJvID0gYmlnSW50KDApO1xuICB2YXIgb25lID0gYmlnSW50KDEpO1xuICBpZiAoei5lcXVhbHMoemVybykpIHtcbiAgICAvLyBtYXhfaW50IGluIDMyYml0XG4gICAgcmV0dXJuIDB4N2ZmZmZmZmY7XG4gIH1cbiAgdmFyIGkgPSAwXG4gIHogPSB6Lnhvcih6LnByZXYoKSkuc2hpZnRSaWdodCgxKTtcbiAgZm9yIChpID0gMDsgIXouZXF1YWxzKGJpZ0ludC56ZXJvKTsgaSsrKSB7XG4gICAgeiA9IHouc2hpZnRSaWdodCgxKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuLy9leHRlcm5hbCBwb3Bjb3VudDogdCAtPiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfcG9wY291bnRcbi8vUmVxdWlyZXM6IGJpZ0ludCwgY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gbWxfel9wb3Bjb3VudCh6KSB7XG4gIHogPSBiaWdJbnQoeik7XG4gIHZhciB6ZXJvID0gYmlnSW50KDApO1xuICB2YXIgb25lID0gYmlnSW50KDEpO1xuICBpZiAoei5sdCh6ZXJvKSkge1xuICAgIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyAhei5lcXVhbHMoemVybyk7IGkrKykge1xuICAgIHogPSB6LmFuZCh6LnByZXYoKSk7XG4gIH1cbiAgaWYoaSAhPSAoaXwwKSkgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX25hbWVkX3ZhbHVlKFwibWxfel9vdmVyZmxvd1wiKSk7XG4gIHJldHVybiBpfDA7XG59XG5cbi8vZXh0ZXJuYWwgaGFtZGlzdDogdCAtPiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9oYW1kaXN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfcG9wY291bnQsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gbWxfel9oYW1kaXN0KHoxLCB6Mikge1xuICBpZihiaWdJbnQoejEpLmlzTmVnYXRpdmUoKSAhPSBiaWdJbnQoejIpLmlzTmVnYXRpdmUgKCkpe1xuICAgIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xuICB9XG4gIGlmKCh6MSAhPSAoejEgfCAwKSB8fCB6MiAhPSAoejIgfCAwKSkgJiYgKGJpZ0ludCh6MSkuaXNOZWdhdGl2ZSgpIHx8IGJpZ0ludCh6MikuaXNOZWdhdGl2ZSAoKSkpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlouaGFtZGlzdDogbmVnYXRpdmUgYXJndW1lbnRzXCIpO1xuICB9XG4gIHJldHVybiBtbF96X3BvcGNvdW50KGJpZ0ludCh6MSkueG9yKGJpZ0ludCh6MikpKTtcbn1cblxuLy9leHRlcm5hbCBzaXplOiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9zaXplIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnRcbmZ1bmN0aW9uIG1sX3pfc2l6ZSh6MSkge1xuICAvLyBDbGFpbSB0byBiZSBhIDMyLWJpdCBhcmNoaXRlY3R1cmUuXG4gIHJldHVybiBiaWdJbnQoejEpLnRvQXJyYXkoTWF0aC5wb3coMiwgMzIpKS52YWx1ZS5sZW5ndGg7XG59XG5cbi8vZXh0ZXJuYWwgZGl2ZXhhY3Q6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2RpdmV4YWN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfZGl2XG5mdW5jdGlvbiBtbF96X2RpdmV4YWN0KHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9kaXYoejEsIHoyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF96YXJpdGhfbWFyc2hhbFxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBjYW1sX3phcml0aF9tYXJzaGFsKHdyaXRlciwgdiwgc3opIHtcbiAgdiA9IGJpZ0ludCh2KTtcbiAgdmFyIGJpdHMgPSB2LnRvQXJyYXkoTWF0aC5wb3coMiwgMzIpKTtcbiAgd3JpdGVyLndyaXRlKDgsIGJpdHMuaXNOZWdhdGl2ZSA/MSA6IDApO1xuICB2YXIgYmxvY2sgPSBiaXRzLnZhbHVlLmxlbmd0aDtcbiAgdmFyIGxlbiA9IGJsb2NrICogNDtcbiAgd3JpdGVyLndyaXRlKDMyLCBsZW4pO1xuICBmb3IodmFyIGkgPSBibG9jayAtIDE7IGkgPj0gMDsgaSAtLSl7XG4gICAgd3JpdGVyLndyaXRlKDgsIChiaXRzLnZhbHVlW2ldID4+PiAwICkgJiAweGZmKTtcbiAgICB3cml0ZXIud3JpdGUoOCwgKGJpdHMudmFsdWVbaV0gPj4+IDggKSAmIDB4ZmYpO1xuICAgIHdyaXRlci53cml0ZSg4LCAoYml0cy52YWx1ZVtpXSA+Pj4gMTYpICYgMHhmZik7XG4gICAgd3JpdGVyLndyaXRlKDgsIChiaXRzLnZhbHVlW2ldID4+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBzelswXSA9IDQgKiAoMSArICgoKGxlbiArIDMpIC8gNCkgfCAwKSk7XG4gIHN6WzFdID0gOCAqICgxICsgKCgobGVuICsgNykgLyA4KSB8IDApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF96YXJpdGhfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfZmFpbHdpdGgsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBjYW1sX3phcml0aF91bm1hcnNoYWwocmVhZGVyLCBzeikge1xuICB2YXIgbmVnYXRlO1xuICBzd2l0Y2gocmVhZGVyLnJlYWQ4dSAoKSkge1xuICBjYXNlIDE6IG5lZ2F0ZSA9IHRydWU7IGJyZWFrO1xuICBjYXNlIDA6IG5lZ2F0ZSA9IGZhbHNlOyBicmVhaztcbiAgZGVmYXVsdDogY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB6IChtYWxmb3JtZWQgaW5wdXQpXCIpO1xuICB9XG4gIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICB2YXIgeCA9IGJpZ0ludCgwKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbiAvIDQ7IGkrKyl7XG4gICAgdmFyIHkgPSBiaWdJbnQocmVhZGVyLnJlYWQ4dSgpKTtcbiAgICB5ID0geS5hZGQoKHJlYWRlci5yZWFkOHUoKSkgPDwgOCk7XG4gICAgeSA9IHkuYWRkKChyZWFkZXIucmVhZDh1KCkpIDw8IDE2KTtcbiAgICB5ID0geS5hZGQoKChyZWFkZXIucmVhZDh1KCkpIDw8IDI0KSA+Pj4gMCk7XG4gICAgeCA9IHkuc2hpZnRMZWZ0KGkgKiAzMikuYWRkKHgpO1xuICB9XG4gIGlmKG5lZ2F0ZSkgeCA9IHgubmVnYXRlKCk7XG4gIHN6WzBdID0gbGVuICsgNDtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHgpXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYmFja3RyYWNlX3N0YXR1cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYWNrdHJhY2Vfc3RhdHVzICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3JlY29yZF9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90ICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdDogaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZShleG4sIGJ0KSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayAoKSB7IHJldHVybiBbMF07IH1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiKTtcbn1cbiIsIi8vLy8vLy8vLyBDT1JFX0tFUk5FTFxuXG4vL1Byb3ZpZGVzOiBjb3JlX2FycmF5X3Vuc2FmZV9pbnRfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ibGl0XG52YXIgY29yZV9hcnJheV91bnNhZmVfaW50X2JsaXQgPSBjYW1sX2FycmF5X2JsaXRcbi8vUHJvdmlkZXM6IGNvcmVfYXJyYXlfdW5zYWZlX2Zsb2F0X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxudmFyIGNvcmVfYXJyYXlfdW5zYWZlX2Zsb2F0X2JsaXQgPSBjYW1sX2FycmF5X2JsaXRcblxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfdGltZV9uc19mb3JtYXRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX3RpbWVfbnNfZm9ybWF0KHRpbWUsZm9ybWF0KXtcbiAgdmFyIGQgPSBuZXcgRGF0ZSh0aW1lICogMTAwMCk7XG4gIHZhciBmb3JtYXRqcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm9ybWF0KTtcbiAgdmFyIGpzdHJpbmcgPSBqb29fZ2xvYmFsX29iamVjdC5zdHJmdGltZShmb3JtYXRqcywgZCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGpzdHJpbmcpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb3JlX2tlcm5lbF9nY19jb21wYWN0aW9uc1xuZnVuY3Rpb24gY29yZV9rZXJuZWxfZ2NfY29tcGFjdGlvbnMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2tlcm5lbF9nY19oZWFwX2NodW5rc1xuZnVuY3Rpb24gY29yZV9rZXJuZWxfZ2NfaGVhcF9jaHVua3MgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2tlcm5lbF9nY19oZWFwX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19oZWFwX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfbWFqb3JfY29sbGVjdGlvbnNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX21ham9yX2NvbGxlY3Rpb25zICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfbWFqb3JfcGx1c19taW5vcl93b3Jkc1xuZnVuY3Rpb24gY29yZV9rZXJuZWxfZ2NfbWFqb3JfcGx1c19taW5vcl93b3JkcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX21ham9yX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19tYWpvcl93b3JkcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX21pbm9yX2NvbGxlY3Rpb25zXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19taW5vcl9jb2xsZWN0aW9ucyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19taW5vcl93b3JkcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX3Byb21vdGVkX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19wcm9tb3RlZF93b3JkcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX3RvcF9oZWFwX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY190b3BfaGVhcF93b3JkcyAoKSB7IHJldHVybiAwIH1cblxuLy9Qcm92aWRlczogQ29yZV9rZXJuZWxfaGVhcF9ibG9ja19pc19oZWFwX2Jsb2NrXG5mdW5jdGlvbiBDb3JlX2tlcm5lbF9oZWFwX2Jsb2NrX2lzX2hlYXBfYmxvY2soeCl7XG4gIHJldHVybiArKHggaW5zdGFuY2VvZiBBcnJheSk7XG59XG5cbi8vUHJvdmlkZXM6IGNvcmVfbWQ1X2ZkXG4vL1JlcXVpcmVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiwgY2FtbF9tZDVfY2hhbiwgY2FtbF9tbF9jbG9zZV9jaGFubmVsXG5mdW5jdGlvbiBjb3JlX21kNV9mZChmZCl7XG4gICAgdmFyIGljID0gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4oZmQpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYW1sX21kNV9jaGFuKGljLCAtMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY2FtbF9tbF9jbG9zZV9jaGFubmVsKGljKTtcbiAgICB9XG59XG5cbi8vUHJvdmlkZXM6IGNvcmVfbWQ1X2RpZ2VzdF9zdWJiaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbWQ1X3N0cmluZywgY2FtbF9ibGl0X3N0cmluZywgY2FtbF9jcmVhdGVfYnl0ZXNcbi8vUmVxdWlyZXM6IGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY29yZV9tZDVfZGlnZXN0X3N1YmJpZ3N0cmluZyhidWYsIG9mcywgbGVuLCByZXMpe1xuICAgIHZhciBieXRlcyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWIoYnVmLCBvZnMsIGJ5dGVzLCAwLCBsZW4pO1xuICAgIHZhciByZXMyID0gY2FtbF9tZDVfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ5dGVzKSwgMCwgbGVuKTtcbiAgICBjYW1sX2JsaXRfc3RyaW5nKHJlczIsIDAsIHJlcywgMCwgMTYpO1xuICAgIHJldHVybiAwO1xufVxuXG4vL0JpZ3N0cmluZ1xuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfZGVzdHJveV9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGJpZ3N0cmluZ19kZXN0cm95X3N0dWIodl9ic3RyKSB7XG4gIGlmICh2X2JzdHIuaGFzT3duUHJvcGVydHkoJ19faXNfZGVhbGxvY2F0ZWQnKSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ3N0cmluZ19kZXN0cm95OiBiaWdzdHJpbmcgaXMgYWxyZWFkeSBkZWFsbG9jYXRlZFwiKTtcbiAgfVxuICAvLyBNdXRhdGUgdGhlIG9yaWdpbmFsIGJpZ3N0cmluZyBpbi1wbGFjZSwgdG8gc2ltdWxhdGUgd2hhdCB0aGUgQyB2ZXJzaW9uIGRvZXNcbiAgdl9ic3RyLl9faXNfZGVhbGxvY2F0ZWQgPSB0cnVlO1xuICB2X2JzdHIuZGF0YSA9IG5ldyB2X2JzdHIuZGF0YS5fX3Byb3RvX18uY29uc3RydWN0b3IoMCk7XG4gIHZfYnN0ci5kaW1zID0gWyAwIF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfcmVhbGxvY1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGJpZ3N0cmluZ19kZXN0cm95X3N0dWJcbmZ1bmN0aW9uIGJpZ3N0cmluZ19yZWFsbG9jKGJpZ3N0cmluZywgc2l6ZSkge1xuICAgIGlmIChiaWdzdHJpbmcuaGFzT3duUHJvcGVydHkoJ19faXNfZGVhbGxvY2F0ZWQnKSkge1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdzdHJpbmdfcmVhbGxvYzogYmlnc3RyaW5nIGlzIGFscmVhZHkgZGVhbGxvY2F0ZWRcIik7XG4gICAgfVxuXG4gICAgdmFyIG5ld19kYXRhID0gbmV3IGJpZ3N0cmluZy5kYXRhLl9fcHJvdG9fXy5jb25zdHJ1Y3RvcihzaXplKTtcbiAgICBuZXdfZGF0YS5zZXQoYmlnc3RyaW5nLmRhdGEuc2xpY2UoMCwgc2l6ZSkpO1xuICAgIHZhciBuZXdfYmlnc3RyaW5nID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJpZ3N0cmluZy5raW5kLCBiaWdzdHJpbmcubGF5b3V0LCBbc2l6ZV0sIG5ld19kYXRhKTtcbiAgICBiaWdzdHJpbmdfZGVzdHJveV9zdHViKGJpZ3N0cmluZyk7XG5cbiAgICByZXR1cm4gbmV3X2JpZ3N0cmluZztcbn1cbiIsIi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50X3BvcGNvdW50IGNvbnN0XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudCh2KSB7XG4gIHYgPSB2IC0gKCh2ID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICB2ID0gKHYgJiAweDMzMzMzMzMzKSArICgodiA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgcmV0dXJuICgodiArICh2ID4+PiA0KSAmIDB4RjBGMEYwRikgKiAweDEwMTAxMDEpID4+PiAyNDtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9jbGVhcl9jYW1sX2JhY2t0cmFjZV9wb3MgY29uc3RcbmZ1bmN0aW9uIEJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zKHgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY2x6IGNvbnN0XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludDMyX2Nseih4KSB7XG4gIHZhciBuID0gMzI7XG4gIHZhciB5O1xuICB5ID0geCA+PjE2OyBpZiAoeSAhPSAwKSB7IG4gPSBuIC0xNjsgeCA9IHk7IH1cbiAgeSA9IHggPj4gODsgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDg7IHggPSB5OyB9XG4gIHkgPSB4ID4+IDQ7IGlmICh5ICE9IDApIHsgbiA9IG4gLSA0OyB4ID0geTsgfVxuICB5ID0geCA+PiAyOyBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gMjsgeCA9IHk7IH1cbiAgeSA9IHggPj4gMTsgaWYgKHkgIT0gMCkgcmV0dXJuIG4gLSAyO1xuICByZXR1cm4gbiAtIHg7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50X2NseiBjb25zdFxuLy9SZXF1aXJlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHpcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50X2Nseih4KSB7IHJldHVybiBCYXNlX2ludF9tYXRoX2ludDMyX2Nseih4KTsgfVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHogY29uc3Rcbi8vUmVxdWlyZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY2x6XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHooeCkgeyByZXR1cm4gQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHooeCk7IH1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHogY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQsIGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9pbnQ2NF90b19pbnQzMlxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHooeCkge1xuICB2YXIgbiA9IDY0O1xuICB2YXIgeTtcbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMzIpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtMzI7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDE2KTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLTE2OyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCA4KTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLSA4OyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCA0KTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLSA0OyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAyKTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLSAyOyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAxKTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHJldHVybiBuIC0gMjtcbiAgcmV0dXJuIG4gLSBjYW1sX2ludDY0X3RvX2ludDMyKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2N0eiBjb25zdFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHooeCkge1xuICBpZiAoeCA9PT0gMCkgeyByZXR1cm4gMzI7IH1cbiAgdmFyIG4gPSAxO1xuICBpZiAoICh4ICYgMHgwMDAwRkZGRikgPT09IDApIHsgbiA9IG4gKyAxNjsgeCA9IHggPj4gMTY7IH1cbiAgaWYgKCAoeCAmIDB4MDAwMDAwRkYpID09PSAwKSB7IG4gPSBuICsgIDg7IHggPSB4ID4+ICA4OyB9XG4gIGlmICggKHggJiAweDAwMDAwMDBGKSA9PT0gMCkgeyBuID0gbiArICA0OyB4ID0geCA+PiAgNDsgfVxuICBpZiAoICh4ICYgMHgwMDAwMDAwMykgPT09IDApIHsgbiA9IG4gKyAgMjsgeCA9IHggPj4gIDI7IH1cbiAgcmV0dXJuIG4gLSAoeCAmIDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludF9jdHogY29uc3Rcbi8vUmVxdWlyZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY3R6XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludF9jdHooeCkgeyByZXR1cm4gQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHooeCk7IH1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY3R6IGNvbnN0XG4vL1JlcXVpcmVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2N0elxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY3R6KHgpIHsgcmV0dXJuIEJhc2VfaW50X21hdGhfaW50MzJfY3R6KHgpOyB9XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50NjRfY3R6IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkLCBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfaW50NjRfdG9faW50MzJcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYW5kLCBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaVxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHooeCkge1xuICBpZiAoY2FtbF9pbnQ2NF9pc196ZXJvKHgpKSB7IHJldHVybiA2NDsgfVxuICB2YXIgbiA9IDE7XG4gIGZ1bmN0aW9uIGlzX3plcm8gKHgpICAgIHsgcmV0dXJuIGNhbWxfaW50NjRfaXNfemVybyh4KTsgfVxuICBmdW5jdGlvbiBsYW5kICh4LHkpICAgICB7IHJldHVybiBjYW1sX2ludDY0X2FuZCh4LCB5KTsgfVxuICBmdW5jdGlvbiBzbWFsbF9pbnQ2NCh4KSB7IHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSh4LDAsMCk7IH1cbiAgaWYgKGlzX3plcm8obGFuZCh4LCBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgweEZGRkZGRiwgMHgwMDAwRkYsIDB4MDAwMCkpKSkge1xuICAgIG4gPSBuICsgMzI7IHggPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDMyKTtcbiAgfVxuICBpZiAoaXNfemVybyhsYW5kKHgsIHNtYWxsX2ludDY0KDB4MDBGRkZGKSkpKSB7XG4gICAgbiA9IG4gKyAxNjsgeCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMTYpO1xuICB9XG4gIGlmIChpc196ZXJvKGxhbmQoeCwgc21hbGxfaW50NjQoMHgwMDAwRkYpKSkpIHtcbiAgICBuID0gbiArICA4OyB4ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCA4KTtcbiAgfVxuICBpZiAoaXNfemVybyhsYW5kKHgsIHNtYWxsX2ludDY0KDB4MDAwMDBGKSkpKSB7XG4gICAgbiA9IG4gKyAgNDsgeCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgNCk7XG4gIH1cbiAgaWYgKGlzX3plcm8obGFuZCh4LCBzbWFsbF9pbnQ2NCgweDAwMDAwMykpKSkge1xuICAgIG4gPSBuICsgIDI7IHggPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDIpO1xuICB9XG4gIHJldHVybiBuIC0gKGNhbWxfaW50NjRfdG9faW50MzIoY2FtbF9pbnQ2NF9hbmQoeCwgc21hbGxfaW50NjQoMHgwMDAwMDEpKSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludF9wb3dfc3R1YiBjb25zdFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnRfcG93X3N0dWIoYmFzZSwgZXhwb25lbnQpIHtcbiAgdmFyIG9uZSA9IDE7XG4gIHZhciBtdWwgPSBbb25lLCBiYXNlLCBvbmUsIG9uZV07XG4gIHZhciByZXMgPSBvbmU7XG4gIHdoaWxlICghZXhwb25lbnQ9PTApIHtcbiAgICBtdWxbMV0gPSAobXVsWzFdICogbXVsWzNdKSB8IDA7XG4gICAgbXVsWzJdID0gKG11bFsxXSAqIG11bFsxXSkgfCAwO1xuICAgIG11bFszXSA9IChtdWxbMl0gKiBtdWxbMV0pIHwgMDtcbiAgICByZXMgPSAocmVzICogbXVsW2V4cG9uZW50ICYgM10pIHwgMDtcbiAgICBleHBvbmVudCA9IGV4cG9uZW50ID4+IDI7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQ2NF9wb3dfc3R1YiBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGksIGNhbWxfaW50NjRfbG8zMlxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnQ2NF9wb3dfc3R1YihiYXNlLCBleHBvbmVudCkge1xuICB2YXIgb25lID0gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkoMSwwKTtcbiAgdmFyIG11bCA9IFtvbmUsIGJhc2UsIG9uZSwgb25lXTtcbiAgdmFyIHJlcyA9IG9uZTtcbiAgd2hpbGUgKCFjYW1sX2ludDY0X2lzX3plcm8oZXhwb25lbnQpKSB7XG4gICAgbXVsWzFdID0gY2FtbF9pbnQ2NF9tdWwobXVsWzFdLCBtdWxbM10pO1xuICAgIG11bFsyXSA9IGNhbWxfaW50NjRfbXVsKG11bFsxXSwgbXVsWzFdKTtcbiAgICBtdWxbM10gPSBjYW1sX2ludDY0X211bChtdWxbMl0sIG11bFsxXSk7XG4gICAgcmVzID0gY2FtbF9pbnQ2NF9tdWwocmVzLCBtdWxbY2FtbF9pbnQ2NF9sbzMyKGV4cG9uZW50KSAmIDNdKTtcbiAgICBleHBvbmVudCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoZXhwb25lbnQsIDIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaGFzaF9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9oYXNoXG5mdW5jdGlvbiBCYXNlX2hhc2hfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaCgxLDEsMCxzKVxufVxuLy9Qcm92aWRlczogQmFzZV9oYXNoX2RvdWJsZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoXG5mdW5jdGlvbiBCYXNlX2hhc2hfZG91YmxlKGQpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaCgxLDEsMCxkKTtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9hbV90ZXN0aW5nIGNvbnN0XG4vL1dlYWtkZWZcbmZ1bmN0aW9uIEJhc2VfYW1fdGVzdGluZyh4KSB7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfY2hhblxuLy9SZXF1aXJlczogY2FtbF9tZDVfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9hcnJheSxjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X2NoYW4oY2hhbmlkLGxlbil7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgY2hhbl9sZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKGxlbjwwKSBsZW4gPSBjaGFuX2xlbiAtIGNoYW4ub2Zmc2V0O1xuICBpZihjaGFuLm9mZnNldCArIGxlbiA+IGNoYW5fbGVuKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuICByZXR1cm4gY2FtbF9tZDVfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZiksMCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX21kNV9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfc3RyaW5nKHMsIG9mcywgbGVuKSB7XG4gIHJldHVybiBjYW1sX21kNV9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhzKSxvZnMsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbnZhciBjYW1sX21kNV9ieXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkICh4LCB5KSB7IHJldHVybiAoeCArIHkpIHwgMDsgfVxuICBmdW5jdGlvbiB4eChxLGEsYix4LHMsdCkge1xuICAgIGEgPSBhZGQoYWRkKGEsIHEpLCBhZGQoeCwgdCkpO1xuICAgIHJldHVybiBhZGQoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBmZihhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBnZyhhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBoaChhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpOyB9XG4gIGZ1bmN0aW9uIGlpKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTsgfVxuXG4gIGZ1bmN0aW9uIG1kNShidWZmZXIsIGxlbmd0aCkge1xuICAgIHZhciBpID0gbGVuZ3RoO1xuICAgIGJ1ZmZlcltpID4+IDJdIHw9IDB4ODAgPDwgKDggKiAoaSAmIDMpKTtcbiAgICBmb3IgKGkgPSAoaSAmIH4weDMpICsgODsoaSAmIDB4M0YpIDwgNjAgO2kgKz0gNClcbiAgICAgIGJ1ZmZlclsoaSA+PiAyKSAtIDFdID0gMDtcbiAgICBidWZmZXJbKGkgPj4gMikgLTFdID0gbGVuZ3RoIDw8IDM7XG4gICAgYnVmZmVyW2kgPj4gMl0gPSAobGVuZ3RoID4+IDI5KSAmIDB4MUZGRkZGRkY7XG5cbiAgICB2YXIgdyA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XTtcblxuICAgIGZvcihpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgIHZhciBhID0gd1swXSwgYiA9IHdbMV0sIGMgPSB3WzJdLCBkID0gd1szXTtcblxuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDFdLCAxMiwgMHhFOEM3Qjc1Nik7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNywgMHgyNDIwNzBEQik7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA3LCAweEY1N0MwRkFGKTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgNV0sIDEyLCAweDQ3ODdDNjJBKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsgN10sIDIyLCAweEZENDY5NTAxKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDcsIDB4Njk4MDk4RDgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTcsIDB4RkZGRjVCQjEpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzExXSwgMjIsIDB4ODk1Q0Q3QkUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krMTNdLCAxMiwgMHhGRDk4NzE5Myk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNywgMHhBNjc5NDM4RSk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDUsIDB4RjYxRTI1NjIpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA2XSwgOSwgMHhDMDQwQjM0MCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDBdLCAyMCwgMHhFOUI2QzdBQSk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA1LCAweEQ2MkYxMDVEKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTQsIDB4RDhBMUU2ODEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA0XSwgMjAsIDB4RTdEM0ZCQzgpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTRdLCA5LCAweEMzMzcwN0Q2KTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE0LCAweEY0RDUwRDg3KTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsxM10sIDUsIDB4QTlFM0U5MDUpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAyXSwgOSwgMHhGQ0VGQTNGOCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krMTJdLCAyMCwgMHg4RDJBNEM4QSk7XG5cbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgNV0sIDQsIDB4RkZGQTM5NDIpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTYsIDB4NkQ5RDYxMjIpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE0XSwgMjMsIDB4RkRFNTM4MEMpO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDRdLCAxMSwgMHg0QkRFQ0ZBOSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNiwgMHhGNkJCNEI2MCk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA0LCAweDI4OUI3RUM2KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgMF0sIDExLCAweEVBQTEyN0ZBKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgNl0sIDIzLCAweDA0ODgxRDA1KTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDQsIDB4RDlENEQwMzkpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTYsIDB4MUZBMjdDRjgpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAyXSwgMjMsIDB4QzRBQzU2NjUpO1xuXG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgN10sIDEwLCAweDQzMkFGRjk3KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxNF0sIDE1LCAweEFCOTQyM0E3KTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDYsIDB4NjU1QjU5QzMpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAzXSwgMTAsIDB4OEYwQ0NDOTIpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAxXSwgMjEsIDB4ODU4NDVERDEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA4XSwgNiwgMHg2RkE4N0U0Rik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNSwgMHhBMzAxNDMxNCk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krMTNdLCAyMSwgMHg0RTA4MTFBMSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsxMV0sIDEwLCAweEJEM0FGMjM1KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsgMl0sIDE1LCAweDJBRDdEMkJCKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICAgIHdbMV0gPSBhZGQoYiwgd1sxXSk7XG4gICAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IG5ldyBBcnJheSgxNik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgdFtpICogNCArIGpdID0gKHdbaV0gPj4gKDggKiBqKSkgJiAweEZGO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzLCBvZnMsIGxlbikge1xuICAgIC8vIEZJWDogbWF5YmUgd2Ugc2hvdWxkIHBlcmZvcm0gdGhlIGNvbXB1dGF0aW9uIGJ5IGNodW5rIG9mIDY0IGJ5dGVzXG4gICAgLy8gYXMgaW4gaHR0cDovL3d3dy5teWVyc2RhaWx5Lm9yZy9qb3NlcGgvamF2YXNjcmlwdC9tZDUuanNcbiAgICB2YXIgYnVmID0gW107XG4gICAgdmFyIGNvbnRlbnQgPSBjYW1sX21sX2J5dGVzX2NvbnRlbnQocyk7XG4gICAgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpe1xuICAgICAgdmFyIGIgPSBjb250ZW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPVxuICAgICAgICAgIGIuY2hhckNvZGVBdChqKSB8IChiLmNoYXJDb2RlQXQoaisxKSA8PCA4KSB8XG4gICAgICAgICAgKGIuY2hhckNvZGVBdChqKzIpIDw8IDE2KSB8IChiLmNoYXJDb2RlQXQoaiszKSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYi5jaGFyQ29kZUF0KGkgKyBvZnMpIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgfSBlbHNlIHsgLyogQVJSQVkgKi9cbiAgICAgIHZhciBhID0gY29udGVudDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIHZhciBqID0gaSArIG9mcztcbiAgICAgICAgYnVmW2k+PjJdID0gYVtqXSB8IChhW2orMV0gPDwgOCkgfCAoYVtqKzJdIDw8IDE2KSB8IChhW2orM10gPDwgMjQpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYnVmW2k+PjJdIHw9IGFbaSArIG9mc10gPDwgKDggKiAoaSAmIDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KG1kNShidWYsIGxlbikpO1xuICB9XG59ICgpO1xuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJLCBidXQgd2l0aG91dCB0aGUgd2VhayBzZW1hbnRpY3NcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDNcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG52YXIgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfY3JlYXRlIChuKSB7XG4gIGlmIChuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuY3JlYXRlXCIpO1xuICB2YXIgeCA9IFsyNTEsXCJjYW1sX2VwaGVfbGlzdF9oZWFkXCJdO1xuICB4Lmxlbmd0aCA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgbjtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19zZXQoeCwgaSwgdikge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXQoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2tleVwiKTtcbiAgcmV0dXJuICh4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSBdPT09dW5kZWZpbmVkKT8wOnhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRfY29weVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldCxjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXRfY29weSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfY29weVwiKTtcbiAgdmFyIHkgPSBjYW1sX3dlYWtfZ2V0KHgsIGkpO1xuICBpZiAoeSA9PT0gMCkgcmV0dXJuIHk7XG4gIHZhciB6ID0geVsxXTtcbiAgaWYgKHogaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeildO1xuICByZXR1cm4geTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NoZWNrIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfY2hlY2soeCwgaSkge1xuICBpZih4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0hPT11bmRlZmluZWQgJiYgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldICE9PTApXG4gICAgcmV0dXJuIDE7XG4gIGVsc2VcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChhMSwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMSAtIDEsXG4gICAgICAgICAgICAgICAgICBhMiwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMiAtIDEsXG4gICAgICAgICAgICAgICAgICBsZW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZVxudmFyIGNhbWxfZXBoZV9jcmVhdGUgPSBjYW1sX3dlYWtfY3JlYXRlXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2JsaXRcbnZhciBjYW1sX2VwaGVfYmxpdF9rZXkgPSBjYW1sX3dlYWtfYmxpdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldFxudmFyIGNhbWxfZXBoZV9nZXRfa2V5ID0gY2FtbF93ZWFrX2dldFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbnZhciBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5ID0gY2FtbF93ZWFrX2dldF9jb3B5XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jaGVja1xudmFyIGNhbWxfZXBoZV9jaGVja19rZXkgPSBjYW1sX3dlYWtfY2hlY2tcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgWzAsIHZdKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgMClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9kYXRhKHNyYywgZHN0KXtcbiAgZHN0W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBzcmNbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF1dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXBcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5KHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBkYXRhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiAxO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IGxleGluZy5jIDYwNDUgMjAwNC0wMS0wMSAxNjo0Mjo0M1ogZG9saWdleiAkICovXG5cbi8qIFRoZSB0YWJsZS1kcml2ZW4gYXV0b21hdG9uIGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXguICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9hcnJheShzKSB7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpO1xuICB2YXIgbCA9IHMubGVuZ3RoIC8gMjtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgIGFbaV0gPSAocy5jaGFyQ29kZUF0KDIgKiBpKSB8IChzLmNoYXJDb2RlQXQoMiAqIGkgKyAxKSA8PCA4KSkgPDwgMTYgPj4gMTY7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5LCBjYW1sX2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHJldHVybiAtYmFzZS0xO1xuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogTmV3IGxleGVyIGVuZ2luZSwgd2l0aCBtZW1vcnkgb2YgcG9zaXRpb25zICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX21lbShzLCBpLCBtZW0sIGN1cnJfcG9zKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm47XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBjdXJyX3BvcztcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fdGFnKHMsIGksIG1lbSkge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuIDtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IC0xO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbmV3X2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9tZW0gPSAxMDtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuICB2YXIgbGV4X2Jhc2VfY29kZSA9IDY7XG4gIHZhciBsZXhfYmFja3Rya19jb2RlID0gNztcbiAgdmFyIGxleF9kZWZhdWx0X2NvZGUgPSA4O1xuICB2YXIgbGV4X3RyYW5zX2NvZGUgPSA5O1xuICB2YXIgbGV4X2NoZWNrX2NvZGUgPSAxMDtcbiAgdmFyIGxleF9jb2RlID0gMTE7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHRfY29kZSkge1xuICAgIHRibC5sZXhfYmFzZV9jb2RlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV9jb2RlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrX2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrX2NvZGVdKTtcbiAgICB0YmwubGV4X2NoZWNrX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrX2NvZGVdKTtcbiAgICB0YmwubGV4X3RyYW5zX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zX2NvZGVdKTtcbiAgICB0YmwubGV4X2RlZmF1bHRfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRfY29kZV0pO1xuICB9XG4gIGlmICh0YmwubGV4X2NvZGUgPT0gbnVsbCkgdGJsLmxleF9jb2RlID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0YmxbbGV4X2NvZGVdKTtcblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFzZV9jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICByZXR1cm4gLWJhc2UtMTtcbiAgICB9XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFja3Rya19jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIHZhciBwc3RhdGUgPSBzdGF0ZSA7XG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBJZiBzb21lIHRyYW5zaXRpb24sIGdldCBhbmQgcGVyZm9ybSBtZW1vcnkgbW92ZXMgKi9cbiAgICAgIHZhciBiYXNlX2NvZGUgPSB0YmwubGV4X2Jhc2VfY29kZVtwc3RhdGVdLCBwY19vZmY7XG4gICAgICBpZiAodGJsLmxleF9jaGVja19jb2RlW2Jhc2VfY29kZSArIGNdID09IHBzdGF0ZSlcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF90cmFuc19jb2RlW2Jhc2VfY29kZSArIGNdO1xuICAgICAgZWxzZVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X2RlZmF1bHRfY29kZVtwc3RhdGVdO1xuICAgICAgaWYgKHBjX29mZiA+IDApXG4gICAgICAgIGNhbWxfbGV4X3J1bl9tZW1cbiAgICAgICh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dLCBsZXhidWZbbGV4X2N1cnJfcG9zXSk7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cbiIsIi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50NjRcbnZhciBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludDY0ID0gY2FtbF9oYXNoX21peF9pbnQ2NDtcbi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxudmFyIEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50ID0gY2FtbF9oYXNoX21peF9pbnQ7XG4vL1Byb3ZpZGVzOiBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0XG52YXIgQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdCA9IGNhbWxfaGFzaF9taXhfZmxvYXQ7XG4vL1Byb3ZpZGVzOiBCYXNlX2ludGVybmFsaGFzaF9mb2xkX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9zdHJpbmdcbnZhciBCYXNlX2ludGVybmFsaGFzaF9mb2xkX3N0cmluZyA9IGNhbWxfaGFzaF9taXhfc3RyaW5nO1xuLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZ2V0X2hhc2hfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmluYWxcbmZ1bmN0aW9uIEJhc2VfaW50ZXJuYWxoYXNoX2dldF9oYXNoX3ZhbHVlKHNlZWQpIHtcbiAgdmFyIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKHNlZWQpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG4iLCIvLyBQcm92aWRlczogZGVmZXJyZWRfcnVuXG5mdW5jdGlvbiBkZWZlcnJlZF9ydW4oZnVuYykge1xuICB2YXIgZGVmZXJyZWQgPSB7XG4gICAgcHJvbWlzZTogUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIC50aGVuKGZ1bmMpIC8vIHRoZSBvY2FtbCB0eXBlcyBkb24ndCBrbm93IHRoaXMsIGJ1dCBmdW5jIGNhbiBhY3R1YWxseSBiZSBhc3luYyBvciBzeW5jXG4gICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZGVmZXJyZWQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZGVmZXJyZWQuaXNEZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGRlZmVycmVkLmVycm9yID0gZXJyO1xuICAgICAgICBkZWZlcnJlZC5pc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgZGVmZXJyZWQuaXNEZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSksXG4gICAgaXNFcnJvcjogZmFsc2UsXG4gICAgaXNEZXRlcm1pbmVkOiBmYWxzZSxcbiAgfTtcbiAgcmV0dXJuIGRlZmVycmVkO1xufVxuXG4vLyBQcm92aWRlczogZGVmZXJyZWRfbWFwXG5mdW5jdGlvbiBkZWZlcnJlZF9tYXAoZGVmZXJyZWQsIGZ1bmMpIHtcbiAgdmFyIG5ld0RlZmVycmVkID0ge1xuICAgIHByb21pc2U6IGRlZmVycmVkLnByb21pc2VcbiAgICAgIC50aGVuKGZ1bmMpIC8vIHRoZSBvY2FtbCB0eXBlcyBkb24ndCBrbm93IHRoaXMsIGJ1dCBmdW5jIGNhbiBhY3R1YWxseSBiZSBhc3luYyBvciBzeW5jXG4gICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgbmV3RGVmZXJyZWQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgbmV3RGVmZXJyZWQuaXNEZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIG5ld0RlZmVycmVkLmVycm9yID0gZXJyO1xuICAgICAgICBuZXdEZWZlcnJlZC5pc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgbmV3RGVmZXJyZWQuaXNEZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSksXG4gICAgaXNFcnJvcjogZmFsc2UsXG4gICAgaXNEZXRlcm1pbmVkOiBmYWxzZSxcbiAgfTtcbiAgcmV0dXJuIG5ld0RlZmVycmVkO1xufVxuXG4vLyBQcm92aWRlczogZGVmZXJyZWRfYmluZFxuZnVuY3Rpb24gZGVmZXJyZWRfYmluZChkZWZlcnJlZCwgZnVuYykge1xuICB2YXIgbmV3RGVmZXJyZWQgPSB7XG4gICAgcHJvbWlzZTogZGVmZXJyZWQucHJvbWlzZVxuICAgICAgLnRoZW4oZnVuYylcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChhbm90aGVyRGVmZXJyZWQpIHtcbiAgICAgICAgcmV0dXJuIGFub3RoZXJEZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBuZXdEZWZlcnJlZC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBuZXdEZWZlcnJlZC5pc0RldGVybWluZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgbmV3RGVmZXJyZWQuZXJyb3IgPSBlcnI7XG4gICAgICAgIG5ld0RlZmVycmVkLmlzRXJyb3IgPSB0cnVlO1xuICAgICAgICBuZXdEZWZlcnJlZC5pc0RldGVybWluZWQgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KSxcbiAgICBpc0Vycm9yOiBmYWxzZSxcbiAgICBpc0RldGVybWluZWQ6IGZhbHNlLFxuICB9O1xuICByZXR1cm4gbmV3RGVmZXJyZWQ7XG59XG5cbi8vIFByb3ZpZGVzOiBkZWZlcnJlZF91cG9uXG5mdW5jdGlvbiBkZWZlcnJlZF91cG9uKGRlZmVycmVkLCBmdW5jKSB7XG4gIGRlZmVycmVkLnByb21pc2VcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jKGRlZmVycmVkLnZhbHVlKTtcbiAgICB9KVxuICAgIC5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG59XG5cbi8vIFByb3ZpZGVzOiBkZWZlcnJlZF91cG9uX2V4blxuZnVuY3Rpb24gZGVmZXJyZWRfdXBvbl9leG4oZGVmZXJyZWQsIGZ1bmMpIHtcbiAgZGVmZXJyZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jKGRlZmVycmVkLnZhbHVlKTtcbiAgfSk7XG59XG5cbi8vIFByb3ZpZGVzOiBkZWZlcnJlZF9pc19kZXRlcm1pbmVkXG5mdW5jdGlvbiBkZWZlcnJlZF9pc19kZXRlcm1pbmVkKGRlZmVycmVkKSB7XG4gIHJldHVybiBkZWZlcnJlZC5pc0RldGVybWluZWQ7XG59XG5cbi8vIFByb3ZpZGVzOiBkZWZlcnJlZF9wZWVrXG5mdW5jdGlvbiBkZWZlcnJlZF9wZWVrKGRlZmVycmVkKSB7XG4gIGlmICghZGVmZXJyZWQuaXNEZXRlcm1pbmVkIHx8IGRlZmVycmVkLmlzRXJyb3IpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gWzAsIGRlZmVycmVkLnZhbHVlXTtcbn1cblxuLy8gUHJvdmlkZXM6IGRlZmVycmVkX3ZhbHVlX2V4blxuZnVuY3Rpb24gZGVmZXJyZWRfdmFsdWVfZXhuKGRlZmVycmVkKSB7XG4gIGlmICghZGVmZXJyZWQuaXNEZXRlcm1pbmVkKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJEZWZlcnJlZCBoYXMgbm90IHJldHVybmVkIHlldC5cIik7XG4gIH1cbiAgaWYgKGRlZmVycmVkLmlzRXJyb3IpIHtcbiAgICB0aHJvdyBkZWZlcnJlZC5lcnJvcjtcbiAgfVxuICByZXR1cm4gZGVmZXJyZWQudmFsdWU7XG59XG5cbi8vIFByb3ZpZGVzOiBkZWZlcnJlZF9yZXR1cm5cbmZ1bmN0aW9uIGRlZmVycmVkX3JldHVybih2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHByb21pc2U6IFByb21pc2UucmVzb2x2ZSh2YWx1ZSksXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGlzRXJyb3I6IGZhbHNlLFxuICAgIGlzRGV0ZXJtaW5lZDogdHJ1ZSxcbiAgfTtcbn1cblxuLy8gUHJvdmlkZXM6IGRlZmVycmVkX2NyZWF0ZVxuZnVuY3Rpb24gZGVmZXJyZWRfY3JlYXRlKHByb21pc2VfY3JlYXRvcikge1xuICB2YXIgZGVmZXJyZWQgPSB7XG4gICAgcHJvbWlzZTogbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHByb21pc2VfY3JlYXRvcihyZXNvbHZlKTtcbiAgICB9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGRlZmVycmVkLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGRlZmVycmVkLmlzRGV0ZXJtaW5lZCA9IHRydWU7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgZGVmZXJyZWQuZXJyb3IgPSBlcnI7XG4gICAgICAgIGRlZmVycmVkLmlzRXJyb3IgPSB0cnVlO1xuICAgICAgICBkZWZlcnJlZC5pc0RldGVybWluZWQgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KSxcbiAgICBpc0Vycm9yOiBmYWxzZSxcbiAgICBpc0RldGVybWluZWQ6IGZhbHNlLFxuICB9O1xuICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8vIFByb3ZpZGVzOiBkZWZlcnJlZF90b19wcm9taXNlXG5mdW5jdGlvbiBkZWZlcnJlZF90b19wcm9taXNlKGRlZmVycmVkKSB7XG4gIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG4vLyBQcm92aWRlczogZGVmZXJyZWRfb2ZfcHJvbWlzZVxuZnVuY3Rpb24gZGVmZXJyZWRfb2ZfcHJvbWlzZShwcm9taXNlKSB7XG4gIHZhciBkZWZlcnJlZCA9IHtcbiAgICBwcm9taXNlOiBwcm9taXNlXG4gICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZGVmZXJyZWQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZGVmZXJyZWQuaXNEZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGRlZmVycmVkLmVycm9yID0gZXJyO1xuICAgICAgICBkZWZlcnJlZC5pc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgZGVmZXJyZWQuaXNEZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSksXG4gICAgaXNFcnJvcjogZmFsc2UsXG4gICAgaXNEZXRlcm1pbmVkOiBmYWxzZSxcbiAgfTtcbiAgcmV0dXJuIGRlZmVycmVkO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gSHVnbyBIZXV6YXJkXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBTaGFjaGFyIEl0emhha3lcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9vY2FtbC9ibG9iLzQuMDcvb3RoZXJsaWJzL3N0ci9zdHJzdHVicy5jXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanNjb3EvanNjb3EvYmxvYi92OC4xMS9jb3EtanMvanNfc3R1Yi9zdHIuanNcblxuLy9Qcm92aWRlczogcmVfbWF0Y2hcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2dldFxuXG52YXIgcmVfbWF0Y2ggPSBmdW5jdGlvbigpe1xuICB2YXIgcmVfd29yZF9sZXR0ZXJzID0gW1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4MDAtMHgxRjogbm9uZSAqL1xuICAgIDB4MDAsIDB4MDAsIDB4RkYsIDB4MDMsICAgICAgIC8qIDB4MjAtMHgzRjogZGlnaXRzIDAtOSAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4ODcsICAgICAgIC8qIDB4NDAtMHg1RjogQSB0byBaLCBfICovXG4gICAgMHhGRSwgMHhGRiwgMHhGRiwgMHgwNywgICAgICAgLyogMHg2MC0weDdGOiBhIHRvIHogKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDgwLTB4OUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweEEwLTB4QkY6IG5vbmUgKi9cbiAgICAweEZGLCAweEZGLCAweDdGLCAweEZGLCAgICAgICAvKiAweEMwLTB4REY6IExhdGluLTEgYWNjZW50ZWQgdXBwZXJjYXNlICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiAgICAgICAgLyogMHhFMC0weEZGOiBMYXRpbi0xIGFjY2VudGVkIGxvd2VyY2FzZSAqL1xuICBdO1xuXG4gIHZhciBvcGNvZGVzID0ge1xuICAgIENIQVI6IDAsIENIQVJOT1JNOiAxLCBTVFJJTkc6IDIsIFNUUklOR05PUk06IDMsIENIQVJDTEFTUzogNCxcbiAgICBCT0w6IDUsIEVPTDogNiwgV09SREJPVU5EQVJZOiA3LFxuICAgIEJFR0dST1VQOiA4LCBFTkRHUk9VUDogOSwgUkVGR1JPVVA6IDEwLFxuICAgIEFDQ0VQVDogMTEsXG4gICAgU0lNUExFT1BUOiAxMiwgU0lNUExFU1RBUjogMTMsIFNJTVBMRVBMVVM6IDE0LFxuICAgIEdPVE86IDE1LCBQVVNIQkFDSzogMTYsIFNFVE1BUks6IDE3LFxuICAgIENIRUNLUFJPR1JFU1M6IDE4XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfd29yZF9sZXR0ZXIoYykge1xuICAgIHJldHVybiAocmVfd29yZF9sZXR0ZXJzWyAgKGMgPj4gMyldID4+IChjICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX2JpdHNldChzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfc3RyaW5nX2dldChzLChpID4+IDMpKSA+PiAoaSAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiByZV9tYXRjaF9pbXBsKHJlLCBzLCBwb3MsIHBhcnRpYWwpIHtcblxuICAgIHZhciBwcm9nICAgICAgICAgID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzFdKSxcbiAgICAgICAgY3Bvb2wgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsyXSksXG4gICAgICAgIG5vcm10YWJsZSAgICAgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHJlWzNdKSxcbiAgICAgICAgbnVtZ3JvdXBzICAgICA9IHJlWzRdIHwgMCxcbiAgICAgICAgbnVtcmVnaXN0ZXJzICA9IHJlWzVdIHwgMCxcbiAgICAgICAgc3RhcnRjaGFycyAgICA9IHJlWzZdIHwgMDtcblxuICAgIHZhciBzID0gY2FtbF9hcnJheV9vZl9zdHJpbmcocyk7XG5cbiAgICB2YXIgcGMgPSAwLFxuICAgICAgICBxdWl0ID0gZmFsc2UsXG4gICAgICAgIHN0YWNrID0gW10sXG4gICAgICAgIGdyb3VwcyA9IG5ldyBBcnJheShudW1ncm91cHMpLFxuICAgICAgICByZV9yZWdpc3RlciA9IG5ldyBBcnJheShudW1yZWdpc3RlcnMpO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyl7XG4gICAgICBncm91cHNbaV0gPSB7c3RhcnQ6IC0xLCBlbmQ6LTF9XG4gICAgfVxuICAgIGdyb3Vwc1swXS5zdGFydCA9IHBvcztcblxuICAgIHZhciBiYWNrdHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHZhciBpdGVtID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmIChpdGVtLnVuZG8pIHtcbiAgICAgICAgICBpdGVtLnVuZG8ub2JqW2l0ZW0udW5kby5wcm9wXSA9IGl0ZW0udW5kby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGl0ZW0ucG9zKSB7XG4gICAgICAgICAgcGMgPSBpdGVtLnBvcy5wYztcbiAgICAgICAgICBwb3MgPSBpdGVtLnBvcy50eHQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWl0ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHB1c2ggPSBmdW5jdGlvbihpdGVtKSB7IHN0YWNrLnB1c2goaXRlbSk7IH07XG5cbiAgICB2YXIgYWNjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZ3JvdXBzWzBdLmVuZCA9IHBvcztcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoMSArIGdyb3Vwcy5sZW5ndGgqMik7XG4gICAgICByZXN1bHRbMF0gPSAwOyAvLyB0YWdcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZyA9IGdyb3Vwc1tpXTtcbiAgICAgICAgaWYoZy5zdGFydCA8IDAgfHwgZy5lbmQgPCAwKSB7XG4gICAgICAgICAgZy5zdGFydCA9IGcuZW5kID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0WzIqaSArIDEgXSA9IGcuc3RhcnQ7XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxICsgMSBdID0gZy5lbmQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICB2YXIgcHJlZml4X21hdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYocGFydGlhbCkgcmV0dXJuIGFjY2VwdCAoKTtcbiAgICAgIGVsc2UgYmFja3RyYWNrICgpO1xuICAgIH1cblxuICAgIC8qIE1haW4gREZBIGludGVycHJldGVyIGxvb3AgKi9cbiAgICB3aGlsZSAoIXF1aXQpIHtcbiAgICAgIHZhciBvcCA9IHByb2dbcGNdICYgMHhmZixcbiAgICAgICAgICBzYXJnID0gcHJvZ1twY10gPj4gOCxcbiAgICAgICAgICB1YXJnID0gc2FyZyAmIDB4ZmYsXG4gICAgICAgICAgYyA9IHNbcG9zXSxcbiAgICAgICAgICBncm91cDtcblxuICAgICAgcGMrKztcblxuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVI6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGMgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSTk9STTpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkc6XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAoYyA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgZWxzZSB7IGJhY2t0cmFjaygpOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNUUklOR05PUk06XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSQ0xBU1M6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CT0w6XG4gICAgICAgIGlmKHBvcyA+IDAgJiYgc1twb3MgLSAxXSAhPSAxMCAvKiBcXG4gKi8pIHtiYWNrdHJhY2soKX1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU9MOlxuICAgICAgICBpZihwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLldPUkRCT1VOREFSWTpcbiAgICAgICAgaWYocG9zID09IDApIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1swXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrICgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pICE9IGlzX3dvcmRfbGV0dGVyKHNbcG9zXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CRUdHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6Z3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOidzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuc3RhcnR9fSk7XG4gICAgICAgIGdyb3VwLnN0YXJ0ID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5FTkRHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC5lbmR9fSk7XG4gICAgICAgIGdyb3VwLmVuZCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuUkVGR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBpZihncm91cC5zdGFydCA8IDAgfHwgZ3JvdXAuZW5kIDwgMCkge2JhY2t0cmFjayAoKTsgYnJlYWt9XG4gICAgICAgIGZvciAodmFyIGkgPSBncm91cC5zdGFydDsgaSA8IGdyb3VwLmVuZDsgaSsrKXtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoc1tpXSAhPSBzW3Bvc10pIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRU9QVDpcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVTVEFSOlxuICAgICAgICB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSlcbiAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVBMVVM6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgfSB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQUNDRVBUOlxuICAgICAgICByZXR1cm4gYWNjZXB0KCk7XG4gICAgICBjYXNlIG9wY29kZXMuR09UTzpcbiAgICAgICAgcGMgPSBwYyArIHNhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlBVU0hCQUNLOlxuICAgICAgICBwdXNoKHtwb3M6IHtwYzogcGMgKyBzYXJnLCB0eHQ6IHBvc319KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0VUTUFSSzpcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajpyZV9yZWdpc3RlcixcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6IHVhcmcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVfcmVnaXN0ZXJbdWFyZ119fSk7XG4gICAgICAgIHJlX3JlZ2lzdGVyW3VhcmddID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEVDS1BST0dSRVNTOlxuICAgICAgICBpZiAocmVfcmVnaXN0ZXJbdWFyZ10gPT09IHBvcykgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlY29kZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gcmVfbWF0Y2hfaW1wbDtcbn0oKTtcblxuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfZm9yd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfZm9yd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfZm9yd2FyZFwiKVxuICB3aGlsZSAocG9zIDw9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2JhY2t3YXJkXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9iYWNrd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfYmFja3dhcmRcIilcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zLS07XG4gIH1cblxuICByZXR1cm4gWzBdOyAgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG5cbi8vUHJvdmlkZXM6IHJlX3N0cmluZ19tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zdHJpbmdfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc3RyaW5nX21hdGNoXCIpXG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9wYXJ0aWFsX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3BhcnRpYWxfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIucGFydGlhbF9tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMSk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcmVwbGFjZW1lbnRfdGV4dFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9hcnJheV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIGV4dGVybmFsIHJlX3JlcGxhY2VtZW50X3RleHQ6IHN0cmluZyAtPiBpbnQgYXJyYXkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuZnVuY3Rpb24gcmVfcmVwbGFjZW1lbnRfdGV4dChyZXBsLGdyb3VwcyxvcmlnKSB7XG4gIHZhciByZXBsID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZXBsKTtcbiAgdmFyIGxlbiA9IHJlcGwubGVuZ3RoO1xuICB2YXIgb3JpZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob3JpZyk7XG4gIHZhciByZXMgPSBcIlwiOyAvL3Jlc3VsdFxuICB2YXIgbiA9IDA7IC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgdmFyIGN1cjsgLy9jdXJyZW50IGNoYXJcbiAgdmFyIHN0YXJ0LCBlbmQsIGM7XG4gIHdoaWxlKG4gPCBsZW4pe1xuICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgaWYoY3VyICE9ICdcXFxcJyl7XG4gICAgICByZXMgKz0gY3VyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKG4gPT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCIpO1xuICAgICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICAgIHN3aXRjaChjdXIpe1xuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIHJlcyArPSBjdXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMCc6IGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6IGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgICBjID0gK2N1cjtcbiAgICAgICAgaWYgKGMqMiA+PSBncm91cHMubGVuZ3RoIC0gMSApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIgKTtcbiAgICAgICAgc3RhcnQgPSBjYW1sX2FycmF5X2dldChncm91cHMsYyoyKTtcbiAgICAgICAgZW5kID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLCBjKjIgKzEpO1xuICAgICAgICBpZiAoc3RhcnQgPT0gLTEpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIpO1xuICAgICAgICByZXMrPW9yaWcuc2xpY2Uoc3RhcnQsZW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgKz0gKCdcXFxcJyAgKyBjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhyZXMpOyB9XG4iLCIvL1Byb3ZpZGVzOiBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3Rkb3V0XG52YXIgZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZG91dCBcbi8vUHJvdmlkZXM6IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRlcnJcbnZhciBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3RkZXJyXG5cbi8vUHJvdmlkZXM6IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9iZWZvcmVfdGVzdFxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVyciwgZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZG91dFxuZnVuY3Rpb24gZXhwZWN0X3Rlc3RfY29sbGVjdG9yX2JlZm9yZV90ZXN0ICh2b3V0cHV0LCB2c3Rkb3V0LCB2c3RkZXJyKXtcbiAgZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVyciA9IGNhbWxfbWxfY2hhbm5lbHNbdnN0ZGVycl07XG4gIGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXQgPSBjYW1sX21sX2NoYW5uZWxzW3ZzdGRvdXRdO1xuICB2YXIgb3V0cHV0ID0gY2FtbF9tbF9jaGFubmVsc1t2b3V0cHV0XTtcbiAgY2FtbF9tbF9jaGFubmVsc1t2c3Rkb3V0XSA9IG91dHB1dDtcbiAgY2FtbF9tbF9jaGFubmVsc1t2c3RkZXJyXSA9IG91dHB1dDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9hZnRlcl90ZXN0XG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3RkZXJyLCBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3Rkb3V0XG5mdW5jdGlvbiBleHBlY3RfdGVzdF9jb2xsZWN0b3JfYWZ0ZXJfdGVzdCAodnN0ZG91dCwgdnN0ZGVycil7XG4gIGNhbWxfbWxfY2hhbm5lbHNbdnN0ZG91dF0gPSBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3Rkb3V0O1xuICBjYW1sX21sX2NoYW5uZWxzW3ZzdGRlcnJdID0gZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVycjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF9vdXRfY2hhbm5lbF9wb3NfZmRcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfb3V0X2NoYW5uZWxfcG9zX2ZkKGNoYW4pe1xuICB2YXIgaW5mbyA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbl07XG4gIHJldHVybiBpbmZvLm9mZnNldFxufVxuIiwiLy9UaGUgZm9sbG93aW5nIGFyZSBkZWZpbmVkIGluIENzdHJ1Y3Rcbi8vVGhlcmUgYXJlIGp1c3QgcHJvdmlkZWQgaGVyZSBmb3IgY29tcGF0aWJpbGl0eSByZWFzb25zXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9XZWFrZGVmXG52YXIgY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmcgPSBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ29weXJpZ2h0IChjKSAyMDE3IEluaGFiaXRlZCBUeXBlIExMQy5cblxuICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgYXV0aG9yIG5vciB0aGUgbmFtZXMgb2YgaGlzIGNvbnRyaWJ1dG9yc1xuICAgICAgIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICAgICAgIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09OVFJJQlVUT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NcbiAgICBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICAgIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAgICBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbiAgICBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG4gICAgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAgICBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTilcbiAgICBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXG4gICAgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOXG4gICAgQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gICAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdhZl9ibGl0X3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9ibGl0X3RvX2J5dGVzKHNyYywgc3JjX29mZiwgZHN0LCBkc3Rfb2ZmLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQoZHN0LCBkc3Rfb2ZmICsgaSwgY2FtbF9iYV9nZXRfMShzcmMsIHNyY19vZmYgKyBpKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nYWZfYmxpdF90b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmFfc2V0XzEsIGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ2FmX2JsaXRfdG9fYmlnc3RyaW5nKHNyYywgc3JjX29mZiwgZHN0LCBkc3Rfb2ZmLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNhbWxfYmFfc2V0XzEoZHN0LCBkc3Rfb2ZmICsgaSwgY2FtbF9iYV9nZXRfMShzcmMsIHNyY19vZmYgKyBpKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nYWZfYmxpdF9mcm9tX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NldF8xLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9ibGl0X2Zyb21fYnl0ZXMoc3JjLCBzcmNfb2ZmLCBkc3QsIGRzdF9vZmYsIGxlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2FtbF9iYV9zZXRfMShkc3QsIGRzdF9vZmYgKyBpLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHNyYywgc3JjX29mZiArIGkpKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdhZl9tZW1jbXBfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xLCBjYW1sX2ludF9jb21wYXJlXG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9tZW1jbXBfYmlnc3RyaW5nKGJhMSwgYmExX29mZiwgYmEyLCBiYTJfb2ZmLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gY2FtbF9pbnRfY29tcGFyZShjYW1sX2JhX2dldF8xKGJhMSwgYmExX29mZiArIGkpLCBjYW1sX2JhX2dldF8xKGJhMiwgYmEyX29mZiArIGkpKTtcbiAgICBpZiAoYyAhPSAwKSByZXR1cm4gY1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdhZl9tZW1jbXBfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xLCBjYW1sX2ludF9jb21wYXJlLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9tZW1jbXBfc3RyaW5nKGJhLCBiYV9vZmYsIHN0ciwgc3RyX29mZiwgbGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGNhbWxfaW50X2NvbXBhcmUoY2FtbF9iYV9nZXRfMShiYSwgYmFfb2ZmICsgaSksIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQoc3RyLCBzdHJfb2ZmICsgaSkpO1xuICAgIGlmIChjICE9IDApIHJldHVybiBjXG4gIH1cbiAgcmV0dXJuIDA7XG59XG4iLCIvLy8vLy8vLy8gVElNRV9OT1dcblxuLy9Qcm92aWRlczogdGltZV9ub3dfbmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaF9vcl96ZXJvXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9pbnQ2NF9vZl9pbnQzMlxudmFyIG1zX3RvX25hbm8gPSBjYW1sX2ludDY0X29mX2ludDMyKDEwMDAqMTAwMCk7XG5mdW5jdGlvbiB0aW1lX25vd19uYW5vc2Vjb25kc19zaW5jZV91bml4X2Vwb2NoX29yX3plcm8oKXtcbiAgICB2YXIgbXMgPSBEYXRlLm5vdygpO1xuICAgIC8vIG11bHRpcGxlIGJ5IHR3byAtIGludDYzIGludGVnZXJzIGFyZSBzaGlmdGVkIHRvIHRoZSBsZWZ0XG4gICAgdmFyIG1zX2k2MyA9IGNhbWxfaW50NjRfb2ZfZmxvYXQobXMqMik7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfbXVsKG1zX2k2Myxtc190b19uYW5vKTtcbn1cbiJdfQ==
