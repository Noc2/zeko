"use strict";(self.webpackChunkzeko_documentation=self.webpackChunkzeko_documentation||[]).push([[414],{5747:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>h});var o=n(5893),i=n(1151);const a={sidebar_position:2},s="Design of zkApp for rollup MVP",c={id:"design",title:"Design of zkApp for rollup MVP",description:"Basic functionality",source:"@site/docs/design.md",sourceDirName:".",slug:"/design",permalink:"/zeko/design",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/zeko/"},next:{title:"Zeko data availability contracts",permalink:"/zeko/da-layer"}},r={},h=[{value:"Basic functionality",id:"basic-functionality",level:2},{value:"Implementation",id:"implementation",level:2}];function l(e){const t={em:"em",h1:"h1",h2:"h2",hr:"hr",p:"p",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"design-of-zkapp-for-rollup-mvp",children:"Design of zkApp for rollup MVP"}),"\n",(0,o.jsx)(t.h2,{id:"basic-functionality",children:"Basic functionality"}),"\n",(0,o.jsx)(t.p,{children:"Field 0 of the app state is the hash of the current state of the ledger.\nThe ledger can be updated by providing a transaction statement\nand its proof."}),"\n",(0,o.jsx)(t.p,{children:"We need to support transfers to and from the rollup,\nwith and without cooperation from the sequencers."}),"\n",(0,o.jsx)(t.p,{children:"One fundamental constraint is that zkApp commands have a complexity limit,\ni.e. you can not have an infinite amount of account updates in a single command\n(for obvious reasons)."}),"\n",(0,o.jsx)(t.p,{children:"We also disregard non-Mina tokens for now."}),"\n",(0,o.jsx)(t.p,{children:"The L1 and L2 are connected by a special account on the L2,\ndenoted by having the account index 0."}),"\n",(0,o.jsx)(t.p,{children:"The special account has minimal special treatment.\nThe transaction snark is modified such that this account\nmust have a specific vk set,\nand the permissions must be all Proof."}),"\n",(0,o.jsx)(t.p,{children:"The complete state of the account is exposed through requests and responses."}),"\n",(0,o.jsx)(t.p,{children:"The account must start with the maximum amount of Mina possible when the rollup is made.\nWhen a transfer happens from L1 to L2, an action is added to the L1 account, along with MINA.\nThe sequencer will also sequence these actions and keep track of a merkle list of\norders and merkle list of processed orders.\nThese fields will be stored on the L2 account.\nOn the other end, the L2 account will allow withdrawing MINA if there is such\nan unprocessed order, and the processed list field must be updated accordingly.\nThe L1 account contract will need to check that these match."}),"\n",(0,o.jsx)(t.p,{children:"In the other direction, MINA can be added to the L2 account along with an action\nto go the other way.\nOn the L1 side this will allow you to withdraw from the account, and update the field\nof processed withdrawals at the same time."}),"\n",(0,o.jsx)(t.p,{children:"Field 0 of the app state of the L2 account is reserved to be the protocol state hash of\nthe entire L1."}),"\n",(0,o.jsx)(t.p,{children:"This is implemented by in the zkapp command logic checking whether the account in question\nis of the public key in question. The public key in question is fetched through a request.\nIf it is the specified account then check that the call data of the account update\nis equivalent to the call data also fetched via a request."}),"\n",(0,o.jsx)(t.p,{children:"In essence, we do a cross-layer contract call."}),"\n",(0,o.jsx)(t.p,{children:"What if we have multiple such account updates in a single L1 rollup update?\nThe above (almost) inherently limits it to only one, since there is only\none possible call data.\nIf they both use the same call data, it could happen, but the contract would\nbe such that is impossible, e.g. by using a counter."}),"\n",(0,o.jsxs)(t.p,{children:['What about if we have none? We run into the problem that "all account updates\nfor the account" having that call data is ',(0,o.jsx)(t.em,{children:"vacuously"})," true.\nWe avoid this by checking that the nonce has been incremented by exactly once,\nalso avoiding the above problem."]}),"\n",(0,o.jsx)(t.p,{children:'This perhaps isn\'t optimal, since we might run into situations where we want multiple\nL2 account updates per "commit" to the L1.'}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsx)(t.p,{children:"Do note that since the L2 has fewer/no limits, it is fast to go from L1 to L2,\nbut slow to go from L2 to L1, inherently.\nThe sequencer is also the one expected to do many of the operations on the L2 account,\nand will thus also pay those fees, but we will ignore that for now since the fees should\nbe low enough that it should not deter profit, but we have to think about the incentives\nof this."}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["What about all the other conditions on the L2 account? E.g. permissions set to proof and such.\nThat is part of the ",(0,o.jsx)(t.em,{children:"initialisation"}),". Currently, initialisation isn't\nguarded by anything, but before using a rollup, you can check the state of the rollup,\nor otherwise check its history, to verify for yourself that it is legitimate.\nIf it's been made illegitimately, you can choose not to use it.\nAlthough we could still enforce proper initialisation in the future if we wanted to."]}),"\n",(0,o.jsx)(t.h2,{id:"implementation",children:"Implementation"}),"\n",(0,o.jsx)(t.p,{children:"There are three circuits, one for the nested account, one for the L1 account, and one for merging transaction snarks.\nWhy another circuit for merging transaction snarks? We ignore first/second-pass logic, since it is not relevant for our\npurposes."}),"\n",(0,o.jsx)(t.p,{children:'The logic for transfers is almost equivalent for the two accounts.\nThe action state for one account is synchronised to state field 0 of the other account.\nState field 1 is the hash of the merkle list of actions processed.\nA transfer from L1 to L2 is done by appending an action, adding the necessary amount to the outer account,\nthen when "sequencing", we synchronise the fields.\nFor each such sequencing, there can be exactly one "synchronisation" account update for the nested account,\nsince the account nonce must be incremented (enforced by the circuit), and that is checked in the outer account\'s\ncircuit.'}),"\n",(0,o.jsx)(t.p,{children:"At the same time as doing the synchronisation, some amount of payments is done.\nFor the nested account update, this is likely to be as many as there are to process,\nbut for the outer one, this is likely to be less, meaning a queue forms."})]})}function u(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>c,a:()=>s});var o=n(7294);const i={},a=o.createContext(i);function s(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);